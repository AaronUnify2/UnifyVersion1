<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Trench Fighter Prototype</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #health-container {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
        }
        .heart {
            width: 30px;
            height: 30px;
            margin-right: 10px;
            background-color: #ff0000;
            clip-path: path('M15,2.5 C15,2.5 13,0 8.5,0 C4,0 0,4 0,8.5 C0,13 2.5,16.5 6,19.5 C9.5,22.5 15,27.5 15,27.5 C15,27.5 20.5,22.5 24,19.5 C27.5,16.5 30,13 30,8.5 C30,4 26,0 21.5,0 C17,0 15,2.5 15,2.5 Z');
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: "";
            position: absolute;
            background-color: white;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #stats-container {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 18px;
            text-align: right;
        }
        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        .inventory-slot {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffffff;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            pointer-events: auto;
            cursor: pointer;
        }
        .inventory-slot.selected {
            border-color: #ffcc00;
            background-color: rgba(255, 204, 0, 0.3);
        }
        #controls {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            pointer-events: auto;
        }
        #loading-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #loading-bar {
            width: 50%;
            height: 20px;
            background-color: #333;
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        #loading-progress {
            height: 100%;
            background-color: #ff0000;
            width: 0%;
            transition: width 0.3s;
        }
        #shoot-button {
            position: absolute;
            bottom: 100px;
            right: 20px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 0, 0, 0.3);
            border: 2px solid #ff0000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
            pointer-events: auto;
        }
        #hit-indicator {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1>TRENCH FIGHTER</h1>
        <p>Loading game assets...</p>
        <div id="loading-bar">
            <div id="loading-progress"></div>
        </div>
    </div>

    <div id="ui-container">
        <div id="health-container">
            <div class="heart"></div>
            <div class="heart"></div>
            <div class="heart"></div>
        </div>
        <div id="crosshair"></div>
        <div id="stats-container">
            <div>Kills: <span id="kill-count">0</span></div>
            <div>Turrets: <span id="turret-count">0</span></div>
        </div>
        <div id="inventory">
            <div class="inventory-slot selected" data-weapon="pistol">Pistol</div>
            <div class="inventory-slot" data-weapon="shotgun">Shotgun<br>0</div>
            <div class="inventory-slot" data-weapon="rifle">Rifle<br>0</div>
            <div class="inventory-slot" data-weapon="grenade">Grenade<br>0</div>
        </div>
        <div id="controls"></div>
        <div id="shoot-button">SHOOT</div>
        <div id="hit-indicator"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Main game class
        class TrenchFighter {
            constructor() {
                this.initThree();
                this.initGame();
                this.initControls();
                this.loadAssets();
            }

            initThree() {
                // Create scene, camera, and renderer
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // Sky blue
                this.scene.fog = new THREE.Fog(0x87CEEB, 0, 500);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.y = 1.6; // Player height

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);

                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);

                // Add directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                this.scene.add(directionalLight);

                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            initGame() {
                // Game state
                this.player = {
                    health: 3,
                    position: new THREE.Vector3(0, 1.6, 0),
                    velocity: new THREE.Vector3(),
                    onGround: false,
                    canJump: false,
                    moveForward: false,
                    moveBackward: false,
                    moveLeft: false,
                    moveRight: false,
                    running: false,
                    speed: 5,
                    kills: 0,
                    turrets: 0,
                    weapons: {
                        pistol: { level: 1, ammo: Infinity },
                        shotgun: { ammo: 0 },
                        rifle: { ammo: 0 },
                        grenade: { ammo: 0 }
                    },
                    currentWeapon: 'pistol',
                    shootCooldown: 0
                };

                // Clock for timing
                this.clock = new THREE.Clock();
                this.deltaTime = 0;

                // Raycaster for shooting
                this.raycaster = new THREE.Raycaster();
                this.mouseVector = new THREE.Vector2();

                // Game world objects
                this.enemies = [];
                this.turrets = [];
                this.projectiles = [];
                this.pickups = [];
            }

            initControls() {
                // First-person controls
                this.controls = new PointerLockControls(this.camera, document.body);
                
                // For desktop controls
                document.addEventListener('click', () => {
                    if (!this.controls.isLocked) {
                        this.controls.lock();
                    }
                });

                // Keyboard controls for desktop
                document.addEventListener('keydown', (event) => {
                    switch (event.code) {
                        case 'KeyW': this.player.moveForward = true; break;
                        case 'KeyS': this.player.moveBackward = true; break;
                        case 'KeyA': this.player.moveLeft = true; break;
                        case 'KeyD': this.player.moveRight = true; break;
                        case 'Space': if (this.player.canJump) this.jump(); break;
                        case 'ShiftLeft': this.player.running = true; break;
                        case 'Digit1': this.selectWeapon('pistol'); break;
                        case 'Digit2': this.selectWeapon('shotgun'); break;
                        case 'Digit3': this.selectWeapon('rifle'); break;
                        case 'Digit4': this.selectWeapon('grenade'); break;
                    }
                });

                document.addEventListener('keyup', (event) => {
                    switch (event.code) {
                        case 'KeyW': this.player.moveForward = false; break;
                        case 'KeyS': this.player.moveBackward = false; break;
                        case 'KeyA': this.player.moveLeft = false; break;
                        case 'KeyD': this.player.moveRight = false; break;
                        case 'ShiftLeft': this.player.running = false; break;
                    }
                });

                // Mouse click for shooting on desktop
                document.addEventListener('mousedown', (event) => {
                    if (event.button === 0 && this.controls.isLocked) {
                        this.shoot();
                    }
                });

                // Mobile controls setup
                const joystick = document.getElementById('controls');
                let joystickActive = false;
                let joystickOrigin = { x: 0, y: 0 };

                joystick.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    joystickActive = true;
                    joystickOrigin.x = event.touches[0].clientX;
                    joystickOrigin.y = event.touches[0].clientY;
                });

                joystick.addEventListener('touchmove', (event) => {
                    event.preventDefault();
                    if (joystickActive) {
                        const dx = event.touches[0].clientX - joystickOrigin.x;
                        const dy = event.touches[0].clientY - joystickOrigin.y;
                        
                        this.player.moveForward = dy < -20;
                        this.player.moveBackward = dy > 20;
                        this.player.moveLeft = dx < -20;
                        this.player.moveRight = dx > 20;
                    }
                });

                joystick.addEventListener('touchend', (event) => {
                    event.preventDefault();
                    joystickActive = false;
                    this.player.moveForward = false;
                    this.player.moveBackward = false;
                    this.player.moveLeft = false;
                    this.player.moveRight = false;
                });

                // Shoot button for mobile
                const shootButton = document.getElementById('shoot-button');
                shootButton.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    this.shoot();
                });

                // Touchscreen camera control for mobile
                let touchStartX = 0;
                let touchStartY = 0;
                
                document.addEventListener('touchstart', (event) => {
                    // Only handle camera control if not touching controls or shoot button
                    if (event.target === this.renderer.domElement) {
                        touchStartX = event.touches[0].clientX;
                        touchStartY = event.touches[0].clientY;
                    }
                });

                document.addEventListener('touchmove', (event) => {
                    if (event.target === this.renderer.domElement) {
                        const touchX = event.touches[0].clientX;
                        const touchY = event.touches[0].clientY;
                        
                        const movementX = touchX - touchStartX;
                        const movementY = touchY - touchStartY;
                        
                        // Apply camera rotation based on touch movement
                        this.camera.rotation.y -= movementX * 0.01;
                        
                        // Limit vertical rotation to avoid flipping
                        const verticalRotation = this.camera.rotation.x - movementY * 0.01;
                        this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, verticalRotation));
                        
                        touchStartX = touchX;
                        touchStartY = touchY;
                    }
                });

                // Inventory selection
                const inventorySlots = document.querySelectorAll('.inventory-slot');
                inventorySlots.forEach(slot => {
                    slot.addEventListener('click', (event) => {
                        const weapon = slot.getAttribute('data-weapon');
                        this.selectWeapon(weapon);
                    });
                    
                    // For mobile
                    slot.addEventListener('touchstart', (event) => {
                        event.preventDefault();
                        const weapon = slot.getAttribute('data-weapon');
                        this.selectWeapon(weapon);
                    });
                });
            }

            selectWeapon(weapon) {
                // Only switch to weapons with ammo
                if (weapon !== 'pistol' && this.player.weapons[weapon].ammo <= 0) {
                    return;
                }
                
                this.player.currentWeapon = weapon;
                
                // Update UI
                const slots = document.querySelectorAll('.inventory-slot');
                slots.forEach(slot => {
                    if (slot.getAttribute('data-weapon') === weapon) {
                        slot.classList.add('selected');
                    } else {
                        slot.classList.remove('selected');
                    }
                });
            }

            loadAssets() {
                // Create a simple loading manager
                const loadingManager = new THREE.LoadingManager();
                loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
                    const progress = (itemsLoaded / itemsTotal) * 100;
                    document.getElementById('loading-progress').style.width = `${progress}%`;
                };
                
                loadingManager.onLoad = () => {
                    setTimeout(() => {
                        document.getElementById('loading-screen').style.display = 'none';
                        this.startGame();
                    }, 1000);
                };

                // Simulate loading assets
                let loadedItems = 0;
                const totalItems = 10;
                
                const simulateLoading = () => {
                    loadedItems++;
                    loadingManager.onProgress('', loadedItems, totalItems);
                    
                    if (loadedItems < totalItems) {
                        setTimeout(simulateLoading, 300);
                    } else {
                        loadingManager.onLoad();
                    }
                };
                
                simulateLoading();
                
                // Create game world while "loading"
                this.createWorld();
            }

            createWorld() {
                // Create ground
                const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4CAF50, // Grass green
                    roughness: 0.8 
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Create hill in the center
                const hillGeometry = new THREE.ConeGeometry(100, 30, 32);
                const hillMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513, // Brown
                    roughness: 0.9 
                });
                this.hill = new THREE.Mesh(hillGeometry, hillMaterial);
                this.hill.position.set(0, 15, 0);
                this.hill.receiveShadow = true;
                this.hill.castShadow = true;
                this.scene.add(this.hill);
                
                // Create trenches
                this.createTrenches();
                
                // Add some trees
                this.createTrees();
                
                // Add colliders for collision detection
                this.colliders = [ground, this.hill];
            }
            
            createTrenches() {
                const trenchMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x6D4C41, // Darker brown for trenches
                    roughness: 1.0 
                });
                
                // Create a simple trench system
                this.createTrenchSegment(-20, -2, 0, 40, 4, 5, trenchMaterial); // East-West trench
                this.createTrenchSegment(-2, -2, -20, 4, 4, 40, trenchMaterial); // North-South trench
                
                // Create a circular trench around the hill
                const segments = 16;
                const radius = 50;
                const width = 5;
                const depth = 5;
                
                for (let i = 0; i < segments; i++) {
                    const angle1 = (i / segments) * Math.PI * 2;
                    const angle2 = ((i + 1) / segments) * Math.PI * 2;
                    
                    const x1 = Math.sin(angle1) * radius;
                    const z1 = Math.cos(angle1) * radius;
                    
                    const x2 = Math.sin(angle2) * radius;
                    const z2 = Math.cos(angle2) * radius;
                    
                    const dx = x2 - x1;
                    const dz = z2 - z1;
                    const length = Math.sqrt(dx * dx + dz * dz);
                    
                    const centerX = (x1 + x2) / 2;
                    const centerZ = (z1 + z2) / 2;
                    
                    // Calculate rotation angle
                    const rotation = Math.atan2(dz, dx);
                    
                    this.createTrenchSegment(
                        centerX, -2, centerZ, 
                        length, depth, width, 
                        trenchMaterial,
                        rotation
                    );
                }
                
                // Add small connector trenches towards the hill
                const connectorCount = 4;
                for (let i = 0; i < connectorCount; i++) {
                    const angle = (i / connectorCount) * Math.PI * 2;
                    const x1 = Math.sin(angle) * radius;
                    const z1 = Math.cos(angle) * radius;
                    const x2 = Math.sin(angle) * 20;
                    const z2 = Math.cos(angle) * 20;
                    
                    const length = Math.sqrt((x2-x1)*(x2-x1) + (z2-z1)*(z2-z1));
                    const centerX = (x1 + x2) / 2;
                    const centerZ = (z1 + z2) / 2;
                    const rotation = Math.atan2(z2-z1, x2-x1);
                    
                    this.createTrenchSegment(
                        centerX, -2, centerZ, 
                        length, depth, width, 
                        trenchMaterial,
                        rotation
                    );
                }
            }
            
            createTrenchSegment(x, y, z, width, height, depth, material, rotation = 0) {
                // Create the main trench
                const trenchGeometry = new THREE.BoxGeometry(width, height, depth);
                const trench = new THREE.Mesh(trenchGeometry, material);
                trench.position.set(x, y, z);
                trench.rotation.y = rotation;
                trench.receiveShadow = true;
                trench.castShadow = true;
                this.scene.add(trench);
                
                // Add to collision objects
                if (!this.colliders) this.colliders = [];
                this.colliders.push(trench);
                
                // Return the trench object for potential further use
                return trench;
            }
            
            createTrees() {
                // Create some simple trees around the map
                const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x33691E });
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
                
                for (let i = 0; i < 50; i++) {
                    // Random position outside the central hill area
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 60 + Math.random() * 100;
                    const x = Math.sin(angle) * distance;
                    const z = Math.cos(angle) * distance;
                    
                    // Create trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(x, 2.5, z);
                    trunk.castShadow = true;
                    trunk.receiveShadow = true;
                    this.scene.add(trunk);
                    
                    // Create foliage
                    const foliageGeometry = new THREE.ConeGeometry(3, 6, 8);
                    const foliage = new THREE.Mesh(foliageGeometry, treeMaterial);
                    foliage.position.set(x, 8, z);
                    foliage.castShadow = true;
                    foliage.receiveShadow = true;
                    this.scene.add(foliage);
                    
                    // Add to colliders
                    this.colliders.push(trunk);
                }
            }

            startGame() {
                // Initialize player at a starting position
                this.camera.position.set(20, 1.6, 20);
                
                // Start the main game loop
                this.animate();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Calculate delta time
                this.deltaTime = Math.min(0.1, this.clock.getDelta());
                
                // Update game state
                this.update();
                
                // Render the scene
                this.renderer.render(this.scene, this.camera);
            }

            update() {
                // Skip updates if controls are not locked
                if (!this.controls.isLocked && !this.isMobile()) {
                    return;
                }
                
                // Update player movement
                this.updateMovement();
                
                // Update shooting cooldown
                if (this.player.shootCooldown > 0) {
                    this.player.shootCooldown -= this.deltaTime;
                }
                
                // Update projectiles
                this.updateProjectiles();
                
                // Update enemies
                this.updateEnemies();
                
                // Update turrets
                this.updateTurrets();
                
                // Update pickups
                this.updatePickups();
                
                // Update UI
                this.updateUI();
            }
            
            updateMovement() {
                // Calculate velocity based on input
                const speed = this.player.running ? this.player.speed * 1.5 : this.player.speed;
                
                this.player.velocity.x = 0;
                this.player.velocity.z = 0;
                
                let direction = new THREE.Vector3();
                
                if (this.player.moveForward) {
                    direction.z = -1;
                }
                if (this.player.moveBackward) {
                    direction.z = 1;
                }
                if (this.player.moveLeft) {
                    direction.x = -1;
                }
                if (this.player.moveRight) {
                    direction.x = 1;
                }
                
                // Normalize direction vector
                if (direction.length() > 0) {
                    direction.normalize();
                }
                
                // Apply movement in the camera's local space
                direction.applyQuaternion(this.camera.quaternion);
                direction.y = 0; // Keep movement on xz plane
                
                this.player.velocity.x = direction.x * speed;
                this.player.velocity.z = direction.z * speed;
                
                // Apply gravity
                this.player.velocity.y -= 9.8 * this.deltaTime;
                
                // Move the player
                this.camera.position.x += this.player.velocity.x * this.deltaTime;
                this.camera.position.z += this.player.velocity.z * this.deltaTime;
                this.camera.position.y += this.player.velocity.y * this.deltaTime;
                
                // Prevent falling through the ground
                if (this.camera.position.y < 1.6) {
                    this.camera.position.y = 1.6;
                    this.player.velocity.y = 0;
                    this.player.onGround = true;
                    this.player.canJump = true;
                } else {
                    this.player.onGround = false;
                }
                
                // Simple collision detection with obstacles
                this.handleCollisions();
            }
            
            handleCollisions() {
                // Player collision sphere
                const playerRadius = 0.5;
                const playerPosition = new THREE.Vector3(
                    this.camera.position.x,
                    this.camera.position.y - 0.8, // Adjust for camera height
                    this.camera.position.z
                );
                
                // Check collision with each object
                this.colliders.forEach(object => {
                    if (object.geometry.type === 'PlaneGeometry') {
                        // Ground collision is already handled
                        return;
                    }
                    
                    // Get object's world position
                    const objectPosition = new THREE.Vector3();
                    object.getWorldPosition(objectPosition);
                    
                    // Calculate distance
                    const dx = playerPosition.x - objectPosition.x;
                    const dz = playerPosition.z - objectPosition.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // Simple collision based on object type
                    let collisionRadius = 0;
                    
                    if (object.geometry.type === 'BoxGeometry') {
                        // For trenches, use half the width/depth
                        const size = new THREE.Vector3();
                        object.geometry.computeBoundingBox();
                        object.geometry.boundingBox.getSize(size);
                        collisionRadius = Math.max(size.x, size.z) / 2;
                    } else if (object.geometry.type === 'CylinderGeometry') {
                        // For tree trunks
                        collisionRadius = 0.7; // Based on trunk top radius
                    } else if (object.geometry.type === 'ConeGeometry' && object === this.hill) {
                        // Special case for the hill
                        const baseDistance = Math.sqrt(dx * dx + dz * dz);
                        const heightRatio = 1 - (this.camera.position.y / 30);
                        collisionRadius = 100 * heightRatio;
                        
                        // If we're inside the hill, push outward
                        if (baseDistance < collisionRadius) {
                            const pushDirection = new THREE.Vector2(dx, dz).normalize();
                            this.camera.position.x = objectPosition.x + pushDirection.x * collisionRadius;
                            this.camera.position.z = objectPosition.z + pushDirection.y * collisionRadius;
                        }
                        return;
                    }
                    
                    // If collision detected, push player away
                    if (distance < playerRadius + collisionRadius) {
                        // Direction to push
                        const pushX = dx / distance;
                        const pushZ = dz / distance;
                        
                        // Move player out of collision
                        this.camera.position.x = objectPosition.x + pushX * (playerRadius + collisionRadius);
                        this.camera.position.z = objectPosition.z + pushZ * (playerRadius + collisionRadius);
                    }
                });
            }
            
            jump() {
                if (this.player.canJump) {
                    this.player.velocity.y = 5;
                    this.player.canJump = false;
                    this.player.onGround = false;
                }
            }
            
            shoot() {
                // Check if weapon is on cooldown
                if (this.player.shootCooldown > 0) {
                    return;
                }
                
                // Check if we have ammo for non-pistol weapons
                if (this.player.currentWeapon !== 'pistol' && this.player.weapons[this.player.currentWeapon].ammo <= 0) {
                    // Switch back to pistol if out of ammo
                    this.selectWeapon('pistol');
                    return;
                }
                
                // Set cooldown based on weapon type and pistol level
                switch (this.player.currentWeapon) {
                    case 'pistol':
                        // Faster rate of fire with higher levels
                        this.player.shootCooldown = 0.5 / this.player.weapons.pistol.level;
                        break;
                    case 'shotgun':
                        this.player.shootCooldown = 0.8;
                        this.player.weapons.shotgun.ammo--;
                        break;
                    case 'rifle':
                        this.player.shootCooldown = 0.3;
                        this.player.weapons.rifle.ammo--;
                        break;
                    case 'grenade':
                        this.player.shootCooldown = 1.0;
                        this.player.weapons.grenade.ammo--;
                        this.throwGrenade();
                        // Update UI
                        document.querySelector('.inventory-slot[data-weapon="grenade"]').innerHTML = `Grenade<br>${this.player.weapons.grenade.ammo}`;
                        return; // Grenade throwing is handled separately
                }
                
                // Set up raycaster from camera
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                
                // Create projectile based on weapon type
                const projectile = {
                    position: this.camera.position.clone(),
                    direction: this.raycaster.ray.direction.clone(),
                    speed: 50,
                    weapon: this.player.currentWeapon,
                    owner: 'player',
                    timeAlive: 0,
                    maxLife: 2 // seconds before despawning
                };
                
                // For shotgun, create multiple projectiles with slight spread
                if (this.player.currentWeapon === 'shotgun') {
                    const spread = 0.1;
                    for (let i = 0; i < 5; i++) {
                        const spreadProjectile = {
                            ...projectile,
                            direction: new THREE.Vector3(
                                projectile.direction.x + (Math.random() - 0.5) * spread,
                                projectile.direction.y + (Math.random() - 0.5) * spread,
                                projectile.direction.z + (Math.random() - 0.5) * spread
                            ).normalize()
                        };
                        this.projectiles.push(spreadProjectile);
                    }
                } else if (this.player.currentWeapon === 'pistol') {
                    // For pistol, projectile count depends on level
                    const bulletCount = Math.min(this.player.weapons.pistol.level, 3);
                    const spread = 0.05;
                    
                    for (let i = 0; i < bulletCount; i++) {
                        const spreadFactor = bulletCount > 1 ? spread : 0;
                        const spreadProjectile = {
                            ...projectile,
                            direction: new THREE.Vector3(
                                projectile.direction.x + (Math.random() - 0.5) * spreadFactor,
                                projectile.direction.y + (Math.random() - 0.5) * spreadFactor,
                                projectile.direction.z + (Math.random() - 0.5) * spreadFactor
                            ).normalize()
                        };
                        this.projectiles.push(spreadProjectile);
                    }
                } else {
                    // Regular single projectile for rifle
                    this.projectiles.push(projectile);
                }
                
                // Update ammo display for non-pistol weapons
                if (this.player.currentWeapon !== 'pistol') {
                    document.querySelector(`.inventory-slot[data-weapon="${this.player.currentWeapon}"]`).innerHTML = 
                        `${this.player.currentWeapon.charAt(0).toUpperCase() + this.player.currentWeapon.slice(1)}<br>${this.player.weapons[this.player.currentWeapon].ammo}`;
                }
                
                // Add muzzle flash effect (simple color change on crosshair)
                const crosshair = document.getElementById('crosshair');
                crosshair.style.backgroundColor = 'rgba(255, 255, 0, 0.5)';
                setTimeout(() => {
                    crosshair.style.backgroundColor = 'transparent';
                }, 50);
                
                // Play sound (would add actual sound effects in a full implementation)
                console.log(`Firing ${this.player.currentWeapon}`);
            }
            
            throwGrenade() {
                // Create a grenade object
                const grenadeDirection = this.raycaster.ray.direction.clone();
                const grenade = {
                    position: this.camera.position.clone(),
                    direction: new THREE.Vector3(
                        grenadeDirection.x,
                        grenadeDirection.y + 0.2, // Throw slightly upward
                        grenadeDirection.z
                    ).normalize(),
                    speed: 15,
                    timeAlive: 0,
                    maxLife: 3, // Seconds before exploding
                    owner: 'player'
                };
                
                // Add grenade to projectiles array with special type
                grenade.type = 'grenade';
                this.projectiles.push(grenade);
                
                console.log('Throwing grenade');
            }
            
            updateProjectiles() {
                // Update positions of all projectiles
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const projectile = this.projectiles[i];
                    
                    // Update position based on direction and speed
                    projectile.position.x += projectile.direction.x * projectile.speed * this.deltaTime;
                    projectile.position.y += projectile.direction.y * projectile.speed * this.deltaTime;
                    projectile.position.z += projectile.direction.z * projectile.speed * this.deltaTime;
                    
                    // Increment time alive
                    projectile.timeAlive += this.deltaTime;
                    
                    // Check if grenade should explode
                    if (projectile.type === 'grenade' && projectile.timeAlive >= projectile.maxLife) {
                        this.explodeGrenade(projectile);
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Check for collisions with environment
                    const ray = new THREE.Raycaster(
                        new THREE.Vector3(
                            projectile.position.x - projectile.direction.x * 0.5,
                            projectile.position.y - projectile.direction.y * 0.5,
                            projectile.position.z - projectile.direction.z * 0.5
                        ),
                        projectile.direction,
                        0,
                        0.5
                    );
                    
                    const intersects = ray.intersectObjects(this.colliders);
                    
                    if (intersects.length > 0 || projectile.timeAlive >= projectile.maxLife) {
                        // Handle grenade bounce instead of removal
                        if (projectile.type === 'grenade') {
                            // Simple bounce
                            const normal = intersects[0]?.face?.normal || new THREE.Vector3(0, 1, 0);
                            projectile.direction.reflect(normal);
                            projectile.speed *= 0.7; // Reduce speed after bounce
                            
                            // Apply gravity to grenade
                            projectile.direction.y -= 0.1;
                            projectile.direction.normalize();
                        } else {
                            // Regular projectile hit something
                            // Could add impact effect here
                            this.projectiles.splice(i, 1);
                        }
                        continue;
                    }
                    
                    // Check for enemy hits (in a full game, this would be more sophisticated)
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        const distance = projectile.position.distanceTo(enemy.position);
                        
                        if (distance < 1 && projectile.owner === 'player') {
                            // Enemy hit!
                            enemy.health--;
                            
                            if (enemy.health <= 0) {
                                // Enemy defeated
                                this.enemies.splice(j, 1);
                                this.player.kills++;
                                
                                // Drop turret grenade
                                this.dropTurretGrenade(enemy.position);
                            }
                            
                            // Remove projectile
                            this.projectiles.splice(i, 1);
                            break;
                        }
                    }
                    
                    // Check for player hits
                    if (projectile.owner !== 'player') {
                        const distance = projectile.position.distanceTo(this.camera.position);
                        
                        if (distance < 1) {
                            // Player hit!
                            this.playerTakeDamage();
                            
                            // Remove projectile
                            this.projectiles.splice(i, 1);
                        }
                    }
                }
            }
            
            explodeGrenade(grenade) {
                console.log('Grenade exploded at', grenade.position);
                
                // In a full implementation, would create explosion effects, sounds, etc.
                
                // Place a random turret at the explosion location
                this.placeTurret(grenade.position);
            }
            
            placeTurret(position) {
                // Determine the turret type randomly
                const turretTypes = ['machineGun', 'tank', 'mortar'];
                const type = turretTypes[Math.floor(Math.random() * turretTypes.length)];
                
                // Find appropriate y position on ground
                const ray = new THREE.Raycaster(
                    new THREE.Vector3(position.x, 100, position.z),
                    new THREE.Vector3(0, -1, 0)
                );
                const intersects = ray.intersectObjects(this.colliders);
                
                let yPosition = 0;
                if (intersects.length > 0) {
                    yPosition = intersects[0].point.y;
                }
                
                // Create a simple turret object
                const turret = {
                    type: type,
                    position: new THREE.Vector3(position.x, yPosition, position.z),
                    rotation: Math.random() * Math.PI * 2,
                    health: 5,
                    shootCooldown: 0,
                    lastTargetPosition: null,
                    owner: 'player'
                };
                
                // Create visual representation based on type
                switch (type) {
                    case 'machineGun':
                        turret.visual = this.createMachineGunNest(position.x, yPosition, position.z);
                        turret.shootCooldown = 0.1; // Fast firing
                        break;
                    case 'tank':
                        turret.visual = this.createTank(position.x, yPosition, position.z);
                        turret.shootCooldown = 1.0; // Slow, powerful shots
                        turret.moveSpeed = 2; // Units per second
                        turret.moveCooldown = 3; // Seconds between movement
                        turret.moveTimer = 0;
                        turret.moveDirection = new THREE.Vector2(Math.random() - 0.5, Math.random() - 0.5).normalize();
                        break;
                    case 'mortar':
                        turret.visual = this.createMortar(position.x, yPosition, position.z);
                        turret.shootCooldown = 3.0; // Very slow, area damage
                        break;
                }
                
                // Add to turrets array
                this.turrets.push(turret);
                this.player.turrets++;
                
                console.log(`Placed ${type} turret at`, position);
            }
            
            createMachineGunNest(x, y, z) {
                // Create a simple machine gun nest
                const baseGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 8);
                const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(x, y + 0.25, z);
                base.castShadow = true;
                base.receiveShadow = true;
                this.scene.add(base);
                
                const gunGeometry = new THREE.BoxGeometry(0.3, 0.3, 1.5);
                const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const gun = new THREE.Mesh(gunGeometry, gunMaterial);
                gun.position.set(x, y + 0.65, z);
                gun.castShadow = true;
                gun.receiveShadow = true;
                this.scene.add(gun);
                
                // Return a group containing all parts
                return { base, gun };
            }
            
            createTank(x, y, z) {
                // Create a simple tank
                const bodyGeometry = new THREE.BoxGeometry(3, 1.5, 4);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4B5320 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(x, y + 1.25, z);
                body.castShadow = true;
                body.receiveShadow = true;
                this.scene.add(body);
                
                const turretGeometry = new THREE.CylinderGeometry(1, 1, 1, 8);
                const turretMaterial = new THREE.MeshStandardMaterial({ color: 0x3B4210 });
                const turret = new THREE.Mesh(turretGeometry, turretMaterial);
                turret.position.set(x, y + 2.5, z);
                turret.rotation.x = Math.PI / 2;
                turret.castShadow = true;
                turret.receiveShadow = true;
                this.scene.add(turret);
                
                const barrelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
                const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                barrel.position.set(x, y + 2.5, z + 1.5);
                barrel.rotation.x = Math.PI / 2;
                barrel.castShadow = true;
                barrel.receiveShadow = true;
                this.scene.add(barrel);
                
                return { body, turret, barrel };
            }
            
            createMortar(x, y, z) {
                // Create a simple mortar
                const baseGeometry = new THREE.CylinderGeometry(1, 1.5, 0.5, 8);
                const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(x, y + 0.25, z);
                base.castShadow = true;
                base.receiveShadow = true;
                this.scene.add(base);
                
                const barrelGeometry = new THREE.CylinderGeometry(0.5, 0.7, 1.5, 8);
                const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                barrel.position.set(x, y + 1.0, z);
                barrel.rotation.x = Math.PI / 6; // Angle upward
                barrel.castShadow = true;
                barrel.receiveShadow = true;
                this.scene.add(barrel);
                
                return { base, barrel };
            }
            
            updateTurrets() {
                for (let i = this.turrets.length - 1; i >= 0; i--) {
                    const turret = this.turrets[i];
                    
                    // Handle shooting based on turret type
                    switch (turret.type) {
                        case 'machineGun':
                            this.updateMachineGunTurret(turret);
                            break;
                        case 'tank':
                            this.updateTankTurret(turret);
                            break;
                        case 'mortar':
                            this.updateMortarTurret(turret);
                            break;
                    }
                }
            }
            
            updateMachineGunTurret(turret) {
                // Machine gun has 140° field of view
                // Get direction to player
                const directionToPlayer = new THREE.Vector3(
                    this.camera.position.x - turret.position.x,
                    0, // Ignore Y difference
                    this.camera.position.z - turret.position.z
                ).normalize();
                
                // Calculate forward direction of turret
                const turretForward = new THREE.Vector3(Math.sin(turret.rotation), 0, Math.cos(turret.rotation));
                
                // Calculate angle between turret forward and direction to player
                const angle = turretForward.angleTo(directionToPlayer);
                
                // Check if player is within field of view (140° = 2.44 radians)
                const fieldOfView = 2.44;
                const distanceToPlayer = this.camera.position.distanceTo(turret.position);
                
                if (angle < fieldOfView / 2 && distanceToPlayer < 50) {
                    // Player is in view and in range
                    
                    // Gradually rotate turret towards player
                    const rotationSpeed = 2.0; // Radians per second
                    const targetRotation = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                    
                    // Calculate shortest rotation direction
                    let rotationDifference = targetRotation - turret.rotation;
                    
                    // Normalize to [-PI, PI]
                    while (rotationDifference > Math.PI) rotationDifference -= Math.PI * 2;
                    while (rotationDifference < -Math.PI) rotationDifference += Math.PI * 2;
                    
                    // Apply rotation with max speed
                    if (Math.abs(rotationDifference) < rotationSpeed * this.deltaTime) {
                        turret.rotation = targetRotation;
                    } else {
                        turret.rotation += Math.sign(rotationDifference) * rotationSpeed * this.deltaTime;
                    }
                    
                    // Update visual representation
                    turret.visual.gun.rotation.y = turret.rotation;
                    
                    // Shoot at player if cooldown allows
                    if (turret.shootCooldown <= 0) {
                        this.turretShoot(turret);
                        turret.shootCooldown = 0.1; // Reset cooldown
                    } else {
                        turret.shootCooldown -= this.deltaTime;
                    }
                }
            }
            
            updateTankTurret(turret) {
                // Update movement
                turret.moveTimer += this.deltaTime;
                
                if (turret.moveTimer >= turret.moveCooldown) {
                    // Change direction randomly
                    turret.moveDirection = new THREE.Vector2(Math.random() - 0.5, Math.random() - 0.5).normalize();
                    turret.moveTimer = 0;
                }
                
                // Move tank
                const moveX = turret.moveDirection.x * turret.moveSpeed * this.deltaTime;
                const moveZ = turret.moveDirection.y * turret.moveSpeed * this.deltaTime;
                
                turret.position.x += moveX;
                turret.position.z += moveZ;
                
                // Update visual position
                turret.visual.body.position.x = turret.position.x;
                turret.visual.body.position.z = turret.position.z;
                turret.visual.turret.position.x = turret.position.x;
                turret.visual.turret.position.z = turret.position.z;
                turret.visual.barrel.position.x = turret.position.x;
                turret.visual.barrel.position.z = turret.position.z + 1.5; // Offset for barrel
                
                // Rotate tank body in movement direction
                const bodyRotation = Math.atan2(moveX, moveZ);
                turret.visual.body.rotation.y = bodyRotation;
                
                // Check for player in range for targeting
                const distanceToPlayer = this.camera.position.distanceTo(turret.position);
                
                if (distanceToPlayer < 40) {
                    // Target player
                    const directionToPlayer = new THREE.Vector3(
                        this.camera.position.x - turret.position.x,
                        0,
                        this.camera.position.z - turret.position.z
                    ).normalize();
                    
                    // Calculate turret rotation
                    const targetRotation = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                    turret.rotation = targetRotation;
                    
                    // Update turret and barrel rotation
                    turret.visual.turret.rotation.y = targetRotation - bodyRotation + Math.PI/2;
                    turret.visual.barrel.rotation.y = targetRotation - bodyRotation + Math.PI/2;
                    
                    // Shoot at player if cooldown allows
                    if (turret.shootCooldown <= 0) {
                        this.turretShoot(turret);
                        turret.shootCooldown = 2.0; // Reset cooldown (longer for tank)
                    }
                }
                
                // Decrease cooldown
                turret.shootCooldown -= this.deltaTime;
            }
            
            updateMortarTurret(turret) {
                // Mortar fires randomly into trenches
                if (turret.shootCooldown <= 0) {
                    // Random location within range
                    const range = 40;
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * range;
                    
                    const targetX = turret.position.x + Math.sin(angle) * distance;
                    const targetZ = turret.position.z + Math.cos(angle) * distance;
                    
                    // Store target position for visualization
                    turret.lastTargetPosition = new THREE.Vector3(targetX, 0, targetZ);
                    
                    // Create mortar projectile
                    const projectile = {
                        position: new THREE.Vector3(turret.position.x, turret.position.y + 1.5, turret.position.z),
                        targetPosition: new THREE.Vector3(targetX, 0, targetZ),
                        timeAlive: 0,
                        maxLife: 3,
                        type: 'mortar',
                        owner: turret.owner
                    };
                    
                    this.projectiles.push(projectile);
                    
                    // Reset cooldown
                    turret.shootCooldown = 5.0;
                } else {
                    turret.shootCooldown -= this.deltaTime;
                }
            }
            
            turretShoot(turret) {
                // Create projectile based on turret type
                let projectile;
                
                switch (turret.type) {
                    case 'machineGun':
                        // Direction based on turret rotation
                        const direction = new THREE.Vector3(
                            Math.sin(turret.rotation),
                            0,
                            Math.cos(turret.rotation)
                        );
                        
                        projectile = {
                            position: new THREE.Vector3(
                                turret.position.x + direction.x * 1.5,
                                turret.position.y + 0.5,
                                turret.position.z + direction.z * 1.5
                            ),
                            direction: direction,
                            speed: 40,
                            weapon: 'machineGun',
                            owner: turret.owner,
                            timeAlive: 0,
                            maxLife: 2
                        };
                        break;
                        
                    case 'tank':
                        // Direction based on turret rotation
                        const tankDirection = new THREE.Vector3(
                            Math.sin(turret.rotation),
                            0,
                            Math.cos(turret.rotation)
                        );
                        
                        projectile = {
                            position: new THREE.Vector3(
                                turret.position.x + tankDirection.x * 3,
                                turret.position.y + 1.5,
                                turret.position.z + tankDirection.z * 3
                            ),
                            direction: tankDirection,
                            speed: 30,
                            weapon: 'tank',
                            owner: turret.owner,
                            timeAlive: 0,
                            maxLife: 3,
                            explosive: true
                        };
                        break;
                }
                
                if (projectile) {
                    this.projectiles.push(projectile);
                }
            }
            
            dropTurretGrenade(position) {
                // Create a pickup for turret grenade
                const pickup = {
                    type: 'grenade',
                    position: new THREE.Vector3(position.x, position.y, position.z),
                    rotation: 0
                };
                
                // Create visual representation
                const geometry = new THREE.SphereGeometry(0.3, 8, 8);
                const material = new THREE.MeshStandardMaterial({ color: 0x00FF00 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(pickup.position);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                
                pickup.visual = mesh;
                this.pickups.push(pickup);
                
                console.log('Dropped turret grenade at', position);
            }
            
            updatePickups() {
                // Rotate pickups for visual effect
                for (let i = 0; i < this.pickups.length; i++) {
                    const pickup = this.pickups[i];
                    pickup.rotation += 2 * this.deltaTime;
                    pickup.visual.rotation.y = pickup.rotation;
                    
                    // Make it hover slightly
                    pickup.visual.position.y = pickup.position.y + Math.sin(this.clock.elapsedTime * 2) * 0.1 + 0.5;
                    
                    // Check for player pickup
                    const distance = this.camera.position.distanceTo(pickup.position);
                    
                    if (distance < 1.5) {
                        // Player picked up the item
                        this.collectPickup(pickup);
                        this.pickups.splice(i, 1);
                        this.scene.remove(pickup.visual);
                        i--;
                    }
                }
            }
            
            collectPickup(pickup) {
                // Handle pickup based on type
                if (pickup.type === 'grenade') {
                    this.player.weapons.grenade.ammo++;
                    console.log('Collected turret grenade');
                    
                    // Update UI
                    document.querySelector('.inventory-slot[data-weapon="grenade"]').innerHTML = `Grenade<br>${this.player.weapons.grenade.ammo}`;
                }
                
                // Could add more pickup types here
            }
            
            playerTakeDamage() {
                // Reduce player health
                this.player.health--;
                
                // Update health display
                const hearts = document.querySelectorAll('.heart');
                for (let i = 0; i < hearts.length; i++) {
                    if (i >= this.player.health) {
                        hearts[i].style.opacity = '0.3';
                    }
                }
                
                // Show hit indicator
                const hitIndicator = document.getElementById('hit-indicator');
                hitIndicator.style.opacity = '1';
                setTimeout(() => {
                    hitIndicator.style.opacity = '0';
                }, 200);
                
                // Check for death
                if (this.player.health <= 0) {
                    this.playerDeath();
                }
            }
            
            playerDeath() {
                console.log('Player died');
                
                // Reset health
                this.player.health = 3;
                
                // Downgrade pistol level
                this.player.weapons.pistol.level = Math.max(1, this.player.weapons.pistol.level - 1);
                
                // Reset health display
                const hearts = document.querySelectorAll('.heart');
                for (let i = 0; i < hearts.length; i++) {
                    hearts[i].style.opacity = '1';
                }
                
                // Respawn at a random position
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 20;
                this.camera.position.x = Math.sin(angle) * distance;
                this.camera.position.z = Math.cos(angle) * distance;
                this.camera.position.y = 1.6;
            }
            
            updateUI() {
                // Update kill counter
                document.getElementById('kill-count').textContent = this.player.kills;
                
                // Update turret counter
                document.getElementById('turret-count').textContent = this.player.turrets;
                
                // In a full implementation, would update ammo counts, etc.
            }
            
            updateEnemies() {
                // In the prototype, we'll periodically spawn enemies
                if (Math.random() < 0.01 && this.enemies.length < 5) {
                    this.spawnEnemy();
                }
                
                // Update existing enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    
                    // Move enemy towards player if in range
                    const distanceToPlayer = this.camera.position.distanceTo(enemy.position);
                    
                    if (distanceToPlayer < 30) {
                        // Enemy sees player and moves towards them
                        const directionToPlayer = new THREE.Vector3(
                            this.camera.position.x - enemy.position.x,
                            0,
                            this.camera.position.z - enemy.position.z
                        ).normalize();
                        
                        // Move enemy
                        enemy.position.x += directionToPlayer.x * enemy.speed * this.deltaTime;
                        enemy.position.z += directionToPlayer.z * enemy.speed * this.deltaTime;
                        
                        // Update visual position
                        enemy.visual.position.copy(enemy.position);
                        
                        // Rotate enemy towards player
                        const angle = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                        enemy.visual.rotation.y = angle;
                        
                        // Shoot at player if close enough and cooldown allows
                        if (distanceToPlayer < 20 && enemy.shootCooldown <= 0) {
                            this.enemyShoot(enemy);
                            enemy.shootCooldown = 1.0; // Reset cooldown
                        }
                    } else {
                        // Random movement
                        enemy.moveTimer += this.deltaTime;
                        
                        if (enemy.moveTimer >= enemy.moveInterval) {
                            // Change direction
                            const angle = Math.random() * Math.PI * 2;
                            enemy.moveDirection.x = Math.sin(angle);
                            enemy.moveDirection.z = Math.cos(angle);
                            
                            enemy.moveTimer = 0;
                            enemy.moveInterval = 2 + Math.random() * 3; // 2-5 seconds
                        }
                        
                        // Move enemy
                        enemy.position.x += enemy.moveDirection.x * enemy.speed * 0.5 * this.deltaTime;
                        enemy.position.z += enemy.moveDirection.z * enemy.speed * 0.5 * this.deltaTime;
                        
                        // Update visual position
                        enemy.visual.position.copy(enemy.position);
                        
                        // Rotate in movement direction
                        const angle = Math.atan2(enemy.moveDirection.x, enemy.moveDirection.z);
                        enemy.visual.rotation.y = angle;
                    }
                    
                    // Update cooldown
                    if (enemy.shootCooldown > 0) {
                        enemy.shootCooldown -= this.deltaTime;
                    }
                }
            }
            
            spawnEnemy() {
                // Spawn enemy at random position away from player
                let x, z;
                do {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 40 + Math.random() * 30;
                    x = Math.sin(angle) * distance;
                    z = Math.cos(angle) * distance;
                } while (Math.sqrt(x*x + z*z) < 30); // Ensure minimum distance from origin
                
                // Create enemy object
                const enemy = {
                    position: new THREE.Vector3(x, 1.6, z),
                    health: 3,
                    speed: 3,
                    moveDirection: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
                    moveTimer: 0,
                    moveInterval: 2 + Math.random() * 3,
                    shootCooldown: 1.0,
                    weapon: 'pistol'
                };
                
                // Create visual representation
                const geometry = new THREE.BoxGeometry(1, 1.8, 1);
                const material = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(enemy.position);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                
                enemy.visual = mesh;
                this.enemies.push(enemy);
                
                console.log('Spawned enemy at', enemy.position);
            }
            
            enemyShoot(enemy) {
                // Get direction to player
                const directionToPlayer = new THREE.Vector3(
                    this.camera.position.x - enemy.position.x,
                    this.camera.position.y - enemy.position.y,
                    this.camera.position.z - enemy.position.z
                ).normalize();
                
                // Add slight inaccuracy
                directionToPlayer.x += (Math.random() - 0.5) * 0.1;
                directionToPlayer.y += (Math.random() - 0.5) * 0.1;
                directionToPlayer.z += (Math.random() - 0.5) * 0.1;
                directionToPlayer.normalize();
                
                // Create projectile
                const projectile = {
                    position: new THREE.Vector3(
                        enemy.position.x + directionToPlayer.x * 0.6,
                        enemy.position.y + 0.5,
                        enemy.position.z + directionToPlayer.z * 0.6
                    ),
                    direction: directionToPlayer,
                    speed: 30,
                    weapon: enemy.weapon,
                    owner: 'enemy',
                    timeAlive: 0,
                    maxLife: 2
                };
                
                this.projectiles.push(projectile);
            }
            
            isMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
        }

        // Initialize the game when the page is loaded
        window.addEventListener('load', () => {
            const game = new TrenchFighter();
        });
    </script>

<!-- Firebase SDK --> <script src="https://www.gstatic.com/firebasejs/9.x.x/firebase-app.js"></script> <script src="https://www.gstatic.com/firebasejs/9.x.x/firebase-database.js"></script> 

<!-- Game systems --> 

<script src="turret-system.js">

// Turret AI System for Trench Fighter
// This extends the basic turret functionality with more advanced behaviors

class TurretSystem {
  constructor(game) {
    this.game = game;
    this.turretTypes = [
      {
        id: 'machineGun',
        name: 'Machine Gun Nest',
        description: 'Rapid-fire, auto-targeting with 140° field of view, vulnerable from behind',
        health: 5,
        damage: 1,
        fireRate: 0.1, // Seconds between shots
        range: 50,
        fieldOfView: Math.PI * (140/180), // 140 degrees in radians
        moveSpeed: 0 // Stationary
      },
      {
        id: 'tank',
        name: 'Tank',
        description: 'Mobile unit that randomly patrols and fires explosive rounds',
        health: 10,
        damage: 2,
        fireRate: 2.0, // Seconds between shots
        range: 40,
        fieldOfView: Math.PI * (180/180), // 180 degrees in radians
        moveSpeed: 2 // Units per second
      },
      {
        id: 'mortar',
        name: 'Mortar',
        description: 'Stationary unit firing explosive rounds into trenches at random intervals',
        health: 3,
        damage: 3,
        fireRate: 5.0, // Seconds between shots
        range: 60,
        fieldOfView: Math.PI * 2, // 360 degrees
        moveSpeed: 0 // Stationary
      }
    ];
  }
  
  // Create a turret of the specified type at the given position
  createTurret(type, position, owner) {
    // Get turret type configuration
    const turretConfig = this.turretTypes.find(t => t.id === type);
    
    if (!turretConfig) {
      console.error(`Unknown turret type: ${type}`);
      return null;
    }
    
    // Find appropriate y position on ground
    const ray = new THREE.Raycaster(
      new THREE.Vector3(position.x, 100, position.z),
      new THREE.Vector3(0, -1, 0)
    );
    const intersects = ray.intersectObjects(this.game.colliders);
    
    let yPosition = 0;
    if (intersects.length > 0) {
      yPosition = intersects[0].point.y;
    }
    
    // Create turret object
    const turret = {
      id: 'turret_' + Math.random().toString(36).substring(2, 15),
      type: type,
      config: turretConfig,
      position: new THREE.Vector3(position.x, yPosition, position.z),
      rotation: Math.random() * Math.PI * 2,
      health: turretConfig.health,
      shootCooldown: 0,
      lastShootTime: 0,
      targets: [],
      currentTarget: null,
      state: 'idle', // idle, targeting, shooting
      owner: owner || 'player',
      kills: 0,
      created: Date.now(),
      lastUpdated: Date.now()
    };
    
    // Add movement properties for mobile turrets
    if (turretConfig.moveSpeed > 0) {
      turret.moveDirection = new THREE.Vector2(Math.random() - 0.5, Math.random() - 0.5).normalize();
      turret.moveTimer = 0;
      turret.moveCooldown = 3 + Math.random() * 2; // 3-5 seconds between direction changes
      turret.currentPath = null;
    }
    
    // Create visual representation based on type
    turret.visual = this.createTurretVisual(turret);
    
    // Add to game's turrets array
    this.game.turrets.push(turret);
    
    // Return the created turret
    return turret;
  }
  
  // Create visual representation for a turret
  createTurretVisual(turret) {
    switch (turret.type) {
      case 'machineGun':
        return this.createMachineGunVisual(turret);
      case 'tank':
        return this.createTankVisual(turret);
      case 'mortar':
        return this.createMortarVisual(turret);
      default:
        console.error(`Unknown turret type: ${turret.type}`);
        return null;
    }
  }
  
  createMachineGunVisual(turret) {
    const position = turret.position;
    
    // Base
    const baseGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 8);
    const baseMaterial = new THREE.MeshStandardMaterial({ 
      color: turret.owner === 'player' ? 0x8B4513 : 0x5D4037 
    });
    const base = new THREE.Mesh(baseGeometry, baseMaterial);
    base.position.set(position.x, position.y + 0.25, position.z);
    base.castShadow = true;
    base.receiveShadow = true;
    this.game.scene.add(base);
    
    // Gun
    const gunGeometry = new THREE.BoxGeometry(0.3, 0.3, 1.5);
    const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const gun = new THREE.Mesh(gunGeometry, gunMaterial);
    gun.position.set(position.x, position.y + 0.65, position.z);
    gun.rotation.y = turret.rotation;
    gun.castShadow = true;
    gun.receiveShadow = true;
    this.game.scene.add(gun);
    
    // Create shield (front facing protection)
    const shieldGeometry = new THREE.BoxGeometry(1.8, 0.8, 0.2);
    const shieldMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
    const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
    shield.position.set(
      position.x + Math.sin(turret.rotation) * 0.8,
      position.y + 0.7,
      position.z + Math.cos(turret.rotation) * 0.8
    );
    shield.rotation.y = turret.rotation;
    shield.castShadow = true;
    shield.receiveShadow = true;
    this.game.scene.add(shield);
    
    return { base, gun, shield };
  }
  
  createTankVisual(turret) {
    const position = turret.position;
    
    // Body
    const bodyGeometry = new THREE.BoxGeometry(3, 1.5, 4);
    const bodyMaterial = new THREE.MeshStandardMaterial({ 
      color: turret.owner === 'player' ? 0x4B5320 : 0x3E4817
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.set(position.x, position.y + 1.25, position.z);
    body.rotation.y = turret.rotation;
    body.castShadow = true;
    body.receiveShadow = true;
    this.game.scene.add(body);
    
    // Turret base
    const turretGeometry = new THREE.CylinderGeometry(1, 1, 1, 8);
    const turretMaterial = new THREE.MeshStandardMaterial({ 
      color: turret.owner === 'player' ? 0x3B4210 : 0x2E3410
    });
    const turretMesh = new THREE.Mesh(turretGeometry, turretMaterial);
    turretMesh.position.set(position.x, position.y + 2.5, position.z);
    turretMesh.rotation.x = Math.PI / 2;
    turretMesh.castShadow = true;
    turretMesh.receiveShadow = true;
    this.game.scene.add(turretMesh);
    
    // Barrel
    const barrelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
    const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
    barrel.position.set(
      position.x + Math.sin(turret.rotation) * 1.5,
      position.y + 2.5,
      position.z + Math.cos(turret.rotation) * 1.5
    );
    barrel.rotation.x = Math.PI / 2;
    barrel.rotation.z = turret.rotation;
    barrel.castShadow = true;
    barrel.receiveShadow = true;
    this.game.scene.add(barrel);
    
    // Tracks (left)
    const trackLGeometry = new THREE.BoxGeometry(0.5, 0.8, 4.5);
    const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x1A1A1A });
    const trackL = new THREE.Mesh(trackLGeometry, trackMaterial);
    trackL.position.set(
      position.x + Math.sin(turret.rotation + Math.PI/2) * 1.5,
      position.y + 0.4,
      position.z + Math.cos(turret.rotation + Math.PI/2) * 1.5
    );
    trackL.rotation.y = turret.rotation;
    trackL.castShadow = true;
    trackL.receiveShadow = true;
    this.game.scene.add(trackL);
    
    // Tracks (right)
    const trackRGeometry = new THREE.BoxGeometry(0.5, 0.8, 4.5);
    const trackR = new THREE.Mesh(trackRGeometry, trackMaterial);
    trackR.position.set(
      position.x + Math.sin(turret.rotation - Math.PI/2) * 1.5,
      position.y + 0.4,
      position.z + Math.cos(turret.rotation - Math.PI/2) * 1.5
    );
    trackR.rotation.y = turret.rotation;
    trackR.castShadow = true;
    trackR.receiveShadow = true;
    this.game.scene.add(trackR);
    
    return { body, turretMesh, barrel, trackL, trackR };
  }
  
  createMortarVisual(turret) {
    const position = turret.position;
    
    // Base
    const baseGeometry = new THREE.CylinderGeometry(1, 1.5, 0.5, 8);
    const baseMaterial = new THREE.MeshStandardMaterial({ 
      color: turret.owner === 'player' ? 0x8B4513 : 0x5D4037 
    });
    const base = new THREE.Mesh(baseGeometry, baseMaterial);
    base.position.set(position.x, position.y + 0.25, position.z);
    base.castShadow = true;
    base.receiveShadow = true;
    this.game.scene.add(base);
    
    // Barrel
    const barrelGeometry = new THREE.CylinderGeometry(0.5, 0.7, 1.5, 8);
    const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
    barrel.position.set(position.x, position.y + 1.0, position.z);
    barrel.rotation.x = Math.PI / 4; // Angled up
    barrel.rotation.z = turret.rotation;
    barrel.castShadow = true;
    barrel.receiveShadow = true;
    this.game.scene.add(barrel);
    
    // Ammo box
    const ammoBoxGeometry = new THREE.BoxGeometry(1, 0.7, 1);
    const ammoBoxMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
    const ammoBox = new THREE.Mesh(ammoBoxGeometry, ammoBoxMaterial);
    ammoBox.position.set(
      position.x + Math.sin(turret.rotation + Math.PI/2) * 1.0,
      position.y + 0.6,
      position.z + Math.cos(turret.rotation + Math.PI/2) * 1.0
    );
    ammoBox.rotation.y = turret.rotation;
    ammoBox.castShadow = true;
    ammoBox.receiveShadow = true;
    this.game.scene.add(ammoBox);
    
    return { base, barrel, ammoBox };
  }
  
  // Update all turrets
  updateTurrets(deltaTime) {
    for (let i = this.game.turrets.length - 1; i >= 0; i--) {
      const turret = this.game.turrets[i];
      
      // Skip if turret is handled by another system
      if (turret.managed) continue;
      
      // Handle different turret types
      switch (turret.type) {
        case 'machineGun':
          this.updateMachineGunTurret(turret, deltaTime);
          break;
        case 'tank':
          this.updateTankTurret(turret, deltaTime);
          break;
        case 'mortar':
          this.updateMortarTurret(turret, deltaTime);
          break;
      }
      
      // Reduce cooldown
      if (turret.shootCooldown > 0) {
        turret.shootCooldown -= deltaTime;
      }
      
      // Update lastUpdated timestamp
      turret.lastUpdated = Date.now();
    }
  }
  
  updateMachineGunTurret(turret, deltaTime) {
    // Find targets within range and field of view
    const targets = this.findTargetsInFieldOfView(turret);
    
    if (targets.length > 0) {
      // Get closest target
      const target = targets[0];
      turret.currentTarget = target;
      turret.state = 'targeting';
      
      // Calculate direction to target
      const directionToTarget = new THREE.Vector3(
        target.position.x - turret.position.x,
        0, // Ignore Y axis for rotation
        target.position.z - turret.position.z
      ).normalize();
      
      // Calculate target rotation
      const targetRotation = Math.atan2(directionToTarget.x, directionToTarget.z);
      
      // Smoothly rotate turret towards target
      const rotationSpeed = 3.0; // Radians per second
      
      // Calculate shortest rotation direction
      let rotationDifference = targetRotation - turret.rotation;
      
      // Normalize to [-PI, PI]
      while (rotationDifference > Math.PI) rotationDifference -= Math.PI * 2;
      while (rotationDifference < -Math.PI) rotationDifference += Math.PI * 2;
      
      // Apply rotation with max speed
      if (Math.abs(rotationDifference) < rotationSpeed * deltaTime) {
        turret.rotation = targetRotation;
      } else {
        turret.rotation += Math.sign(rotationDifference) * rotationSpeed * deltaTime;
      }
      
      // Update visual rotation
      if (turret.visual) {
        turret.visual.gun.rotation.y = turret.rotation;
        
        // Update shield position and rotation
        turret.visual.shield.position.set(
          turret.position.x + Math.sin(turret.rotation) * 0.8,
          turret.position.y + 0.7,
          turret.position.z + Math.cos(turret.rotation) * 0.8
        );
        turret.visual.shield.rotation.y = turret.rotation;
      }
      
      // Shoot if cooldown allows and turret is facing target
      if (turret.shootCooldown <= 0 && Math.abs(rotationDifference) < 0.1) {
        this.turretShoot(turret, target);
        turret.shootCooldown = turret.config.fireRate;
        turret.lastShootTime = Date.now();
        turret.state = 'shooting';
      }
    } else {
      turret.currentTarget = null;
      turret.state = 'idle';
      
      // Rotate slowly when idle
      turret.rotation += deltaTime * 0.2;
      
      // Update visual rotation
      if (turret.visual) {
        turret.visual.gun.rotation.y = turret.rotation;
        
        // Update shield position and rotation
        turret.visual.shield.position.set(
          turret.position.x + Math.sin(turret.rotation) * 0.8,
          turret.position.y + 0.7,
          turret.position.z + Math.cos(turret.rotation) * 0.8
        );
        turret.visual.shield.rotation.y = turret.rotation;
      }
    }
  }
  
  updateTankTurret(turret, deltaTime) {
    // Handle movement
    if (turret.config.moveSpeed > 0) {
      turret.moveTimer += deltaTime;
      
      if (turret.moveTimer >= turret.moveCooldown) {
        // Change direction randomly
        turret.moveDirection = new THREE.Vector2(Math.random() - 0.5, Math.random() - 0.5).normalize();
        turret.moveTimer = 0;
        turret.moveCooldown = 3 + Math.random() * 2; // 3-5 seconds
      }
      
      // Calculate movement
      const moveX = turret.moveDirection.x * turret.config.moveSpeed * deltaTime;
      const moveZ = turret.moveDirection.y * turret.config.moveSpeed * deltaTime;
      
      // Check if movement would collide with anything
      const nextPosition = new THREE.Vector3(
        turret.position.x + moveX,
        turret.position.y,
        turret.position.z + moveZ
      );
      
      // Simple collision detection with other turrets
      let canMove = true;
      for (const otherTurret of this.game.turrets) {
        if (otherTurret === turret) continue;
        
        const distance = nextPosition.distanceTo(otherTurret.position);
        if (distance < 5) { // Minimum distance between turrets
          canMove = false;
          break;
        }
      }
      
      // Apply movement if no collision
      if (canMove) {
        turret.position.x += moveX;
        turret.position.z += moveZ;
        
        // Calculate body rotation based on movement direction
        const bodyRotation = Math.atan2(moveX, moveZ);
        
        // Update visual position and rotation
        if (turret.visual) {
          // Update body
          turret.visual.body.position.set(
            turret.position.x,
            turret.position.y + 1.25,
            turret.position.z
          );
          turret.visual.body.rotation.y = bodyRotation;
          
          // Update turret base
          turret.visual.turretMesh.position.set(
            turret.position.x,
            turret.position.y + 2.5,
            turret.position.z
          );
          
          // Update tracks
          turret.visual.trackL.position.set(
            turret.position.x + Math.sin(bodyRotation + Math.PI/2) * 1.5,
            turret.position.y + 0.4,
            turret.position.z + Math.cos(bodyRotation + Math.PI/2) * 1.5
          );
          turret.visual.trackL.rotation.y = bodyRotation;
          
          turret.visual.trackR.position.set(
            turret.position.x + Math.sin(bodyRotation - Math.PI/2) * 1.5,
            turret.position.y + 0.4,
            turret.position.z + Math.cos(bodyRotation - Math.PI/2) * 1.5
          );
          turret.visual.trackR.rotation.y = bodyRotation;
        }
      } else {
        // If collision detected, change direction
        turret.moveDirection.negate();
        turret.moveTimer = 0;
      }
    }
    
    // Find targets within range and field of view
    const targets = this.findTargetsInFieldOfView(turret);
    
    if (targets.length > 0) {
      // Get closest target
      const target = targets[0];
      turret.currentTarget = target;
      turret.state = 'targeting';
      
      // Calculate direction to target
      const directionToTarget = new THREE.Vector3(
        target.position.x - turret.position.x,
        0, // Ignore Y axis for rotation
        target.position.z - turret.position.z
      ).normalize();
      
      // Calculate target rotation
      const targetRotation = Math.atan2(directionToTarget.x, directionToTarget.z);
      
      // Store current rotation
      turret.rotation = targetRotation;
      
      // Update barrel position and rotation
      if (turret.visual) {
        // Body rotation from movement
        const bodyRotation = turret.visual.body.rotation.y;
        
        // Calculate relative turret rotation
        const relativeRotation = targetRotation - bodyRotation;
        
        // Update turret parts
        turret.visual.barrel.position.set(
          turret.position.x + Math.sin(targetRotation) * 1.5,
          turret.position.y + 2.5,
          turret.position.z + Math.cos(targetRotation) * 1.5
        );
        turret.visual.barrel.rotation.z = targetRotation;
      }
      
      // Shoot if cooldown allows
      if (turret.shootCooldown <= 0) {
        this.turretShoot(turret, target);
        turret.shootCooldown = turret.config.fireRate;
        turret.lastShootTime = Date.now();
        turret.state = 'shooting';
      }
    } else {
      turret.currentTarget = null;
      turret.state = 'idle';
    }
  }
  
  updateMortarTurret(turret, deltaTime) {
    // Mortar fires at random locations within range
    if (turret.shootCooldown <= 0) {
      turret.state = 'shooting';
      
      // Select a random target area within range
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * turret.config.range;
      
      const targetPosition = new THREE.Vector3(
        turret.position.x + Math.sin(angle) * distance,
        0,
        turret.position.z + Math.cos(angle) * distance
      );
      
      // Update barrel rotation to point in firing direction
      if (turret.visual) {
        const directionToTarget = new THREE.Vector3(
          targetPosition.x - turret.position.x,
          0,
          targetPosition.z - turret.position.z
        ).normalize();
        
        const targetRotation = Math.atan2(directionToTarget.x, directionToTarget.z);
        turret.rotation = targetRotation;
        
        // Update barrel rotation
        turret.visual.barrel.rotation.z = targetRotation;
      }
      
      // Fire a mortar shell
      this.fireMortarShell(turret, targetPosition);
      
      // Reset cooldown
      turret.shootCooldown = turret.config.fireRate;
      turret.lastShootTime = Date.now();
    } else {
      turret.state = 'idle';
    }
  }
  
  // Find potential targets in field of view and range
  findTargetsInFieldOfView(turret) {
    const targets = [];
    
    // Check for players (including camera position if owned by player)
    if (turret.owner !== 'player') {
      // Check if player is in range and field of view
      const distanceToPlayer = this.game.camera.position.distanceTo(turret.position);
      
      if (distanceToPlayer <= turret.config.range) {
        // Calculate direction to player
        const directionToPlayer = new THREE.Vector3(
          this.game.camera.position.x - turret.position.x,
          0, // Ignore Y difference for rotation
          this.game.camera.position.z - turret.position.z
        ).normalize();
        
        // Calculate forward direction of turret
        const turretForward = new THREE.Vector3(
          Math.sin(turret.rotation),
          0,
          Math.cos(turret.rotation)
        );
        
        // Calculate angle between turret forward and direction to player
        const angle = turretForward.angleTo(directionToPlayer);
        
        // Check if player is within field of view
        if (angle <= turret.config.fieldOfView / 2) {
          // Check for line of sight
          if (this.hasLineOfSight(turret.position, this.game.camera.position)) {
            targets.push({
              type: 'player',
              position: this.game.camera.position,
              distance: distanceToPlayer
            });
          }
        }
      }
    }
    
    // Check for enemies (NPCs)
    for (const enemy of this.game.enemies) {
      // Skip if enemy is owned by the same player
      if (enemy.owner === turret.owner) continue;
      
      const distanceToEnemy = enemy.position.distanceTo(turret.position);
      
      if (distanceToEnemy <= turret.config.range) {
        // Calculate direction to enemy
        const directionToEnemy = new THREE.Vector3(
          enemy.position.x - turret.position.x,
          0, // Ignore Y difference for rotation
          enemy.position.z - turret.position.z
        ).normalize();
        
        // Calculate forward direction of turret
        const turretForward = new THREE.Vector3(
          Math.sin(turret.rotation),
          0,
          Math.cos(turret.rotation)
        );
        
        // Calculate angle between turret forward and direction to enemy
        const angle = turretForward.angleTo(directionToEnemy);
        
        // Check if enemy is within field of view
        if (angle <= turret.config.fieldOfView / 2) {
          // Check for line of sight
          if (this.hasLineOfSight(turret.position, enemy.position)) {
            targets.push({
              type: 'enemy',
              position: enemy.position,
              entity: enemy,
              distance: distanceToEnemy
            });
          }
        }
      }
    }
    
    // Check for other players
    if (this.game.multiplayer) {
      for (const playerId in this.game.multiplayer.players) {
        const player = this.game.multiplayer.players[playerId];
        
        // Skip if player is the owner
        if (player.owner === turret.owner) continue;
        
        const playerPosition = new THREE.Vector3(
          player.data.position.x,
          player.data.position.y,
          player.data.position.z
        );
        
        const distanceToPlayer = playerPosition.distanceTo(turret.position);
        
        if (distanceToPlayer <= turret.config.range) {
          // Calculate direction to player
          const directionToPlayer = new THREE.Vector3(
            playerPosition.x - turret.position.x,
            0, // Ignore Y difference for rotation
            playerPosition.z - turret.position.z
          ).normalize();
          
          // Calculate forward direction of turret
          const turretForward = new THREE.Vector3(
            Math.sin(turret.rotation),
            0,
            Math.cos(turret.rotation)
          );
          
          // Calculate angle between turret forward and direction to player
          const angle = turretForward.angleTo(directionToPlayer);
          
          // Check if player is within field of view
          if (angle <= turret.config.fieldOfView / 2) {
            // Check for line of sight
            if (this.hasLineOfSight(turret.position, playerPosition)) {
              targets.push({
                type: 'multiplayer_player',
                position: playerPosition,
                playerId: playerId,
                distance: distanceToPlayer
              });
            }
          }
        }
      }
    }
    
    // Sort targets by distance
    targets.sort((a, b) => a.distance - b.distance);
    
    return targets;
  }
  
  // Check if there's a clear line of sight between two points
  hasLineOfSight(from, to) {
    // Direction vector
    const direction = new THREE.Vector3(
      to.x - from.x,
      to.y - from.y,
      to.z - from.z
    ).normalize();
    
    // Distance
    const distance = from.distanceTo(to);
    
    // Create raycaster
    const raycaster = new THREE.Raycaster(from, direction, 0, distance);
    
    // Get intersections with colliders
    const intersections = raycaster.intersectObjects(this.game.colliders);
    
    // If no intersections, there's a clear line of sight
    return intersections.length === 0;
  }
  
  // Handle turret shooting
  turretShoot(turret, target) {
    switch (turret.type) {
      case 'machineGun':
        this.fireMachineGun(turret, target);
        break;
      case 'tank':
        this.fireTankCannon(turret, target);
        break;
      case 'mortar':
        // Mortar firing is handled in updateMortarTurret
        break;
    }
  }
  
  fireMachineGun(turret, target) {
    // Create muzzle flash (in a full implementation)
    
    // Create bullet projectile
    const bulletDirection = new THREE.Vector3(
      Math.sin(turret.rotation),
      0,
      Math.cos(turret.rotation)
    );
    
    // Add slight spread
    bulletDirection.x += (Math.random() - 0.5) * 0.05;
    bulletDirection.y += (Math.random() - 0.5) * 0.05;
    bulletDirection.z += (Math.random() - 0.5) * 0.05;
    bulletDirection.normalize();
    
    const bulletStartPos = new THREE.Vector3(
      turret.position.x + bulletDirection.x * 1.0,
      turret.position.y + 0.65,
      turret.position.z + bulletDirection.z * 1.0
    );
    
    const bullet = {
      position: bulletStartPos,
      direction: bulletDirection,
      speed: 50,
      weapon: 'machineGun',
      damage: turret.config.damage,
      owner: turret.owner,
      timeAlive: 0,
      maxLife: 2 // seconds
    };
    
    // Add to projectiles
    this.game.projectiles.push(bullet);
  }
  
  fireTankCannon(turret, target) {
    // Create muzzle flash (in a full implementation)
    
    // Create shell projectile
    const shellDirection = new THREE.Vector3(
      Math.sin(turret.rotation),
      0,
      Math.cos(turret.rotation)
    );
    
    const shellStartPos = new THREE.Vector3(
      turret.position.x + shellDirection.x * 3.0,
      turret.position.y + 2.5,
      turret.position.z + shellDirection.z * 3.0
    );
    
    const shell = {
      position: shellStartPos,
      direction: shellDirection,
      speed: 30,
      weapon: 'tank',
      damage: turret.config.damage,
      owner: turret.owner,
      timeAlive: 0,
      maxLife: 3, // seconds
      explosive: true,
      explosionRadius: 5
    };
    
    // Add to projectiles
    this.game.projectiles.push(shell);
  }
  
  fireMortarShell(turret, targetPosition) {
    // Create firing effect (in a full implementation)
    
    // Calculate direction vector with arc
    const horizontalDistance = new THREE.Vector2(
      targetPosition.x - turret.position.x,
      targetPosition.z - turret.position.z
    ).length();
    
    // Use arc trajectory
    const mortarDirection = new THREE.Vector3(
      targetPosition.x - turret.position.x,
      15, // High arc
      targetPosition.z - turret.position.z
    ).normalize();
    
    const mortarStartPos = new THREE.Vector3(
      turret.position.x,
      turret.position.y + 1.5,
      turret.position.z
    );
    
    const mortarShell = {
      position: mortarStartPos,
      startPosition: mortarStartPos.clone(),
      targetPosition: targetPosition.clone(),
      direction: mortarDirection,
      speed: 20,
      weapon: 'mortar',
      damage: turret.config.damage,
      owner: turret.owner,
      timeAlive: 0,
      maxLife: horizontalDistance / 20, // Time based on distance
      explosive: true,
      explosionRadius: 8,
      type: 'mortar',
      arc: true
    };
    
    // Add to projectiles
    this.game.projectiles.push(mortarShell);
  }
  
  // Handle damage to turrets
  damageRurret(turret, amount) {
    turret.health -= amount;
    
    if (turret.health <= 0) {
      this.destroyTurret(turret);
    }
  }
  
  // Handle turret destruction
  destroyTurret(turret) {
    // Create explosion effect (in a full implementation)
    
    // Remove visual representation
    if (turret.visual) {
      switch (turret.type) {
        case 'machineGun':
          this.game.scene.remove(turret.visual.base);
          this.game.scene.remove(turret.visual.gun);
          this.game.scene.remove(turret.visual.shield);
          break;
        case 'tank':
          this.game.scene.remove(turret.visual.body);
          this.game.scene.remove(turret.visual.turretMesh);
          this.game.scene.remove(turret.visual.barrel);
          this.game.scene.remove(turret.visual.trackL);
          this.game.scene.remove(turret.visual.trackR);
          break;
        case 'mortar':
          this.game.scene.remove(turret.visual.base);
          this.game.scene.remove(turret.visual.barrel);
          this.game.scene.remove(turret.visual.ammoBox);
          break;
      }
    }
    
    // Remove from game's turrets array
    const index = this.game.turrets.indexOf(turret);
    if (index !== -1) {
      this.game.turrets.splice(index, 1);
    }
    
    // Reduce player's turret count if it's their turret
    if (turret.owner === 'player') {
      this.game.player.turrets--;
    }
    
    // If multiplayer is active, remove from database
    if (this.game.multiplayer && turret.id) {
      this.game.multiplayer.db.ref(`turrets/${turret.id}`).remove();
    }
  }
}

// Extend the updateProjectiles method in the game to handle special projectile types
class ProjectileExtensions {
  static extend(TrenchFighter) {
    // Store the original method
    const originalUpdateProjectiles = TrenchFighter.prototype.updateProjectiles;
    
    TrenchFighter.prototype.updateProjectiles = function() {
      // Call original method
      originalUpdateProjectiles.call(this);
      
      // Handle special projectile types
      for (let i = this.projectiles.length - 1; i >= 0; i--) {
        const projectile = this.projectiles[i];
        
        // Handle mortar projectiles with arc trajectory
        if (projectile.type === 'mortar' && projectile.arc) {
          // Calculate progress (0 to 1)
          const totalTime = projectile.maxLife;
          const progress = projectile.timeAlive / totalTime;
          
          if (progress >= 1) {
            // Explode at target position
            this.createExplosion(projectile.targetPosition, projectile.explosionRadius, projectile.damage, projectile.owner);
            this.projectiles.splice(i, 1);
            continue;
          }
          
          // Parabolic arc
          const startPos = projectile.startPosition;
          const endPos = projectile.targetPosition;
          
          // Interpolate position along arc
          projectile.position.x = startPos.x + (endPos.x - startPos.x) * progress;
          projectile.position.z = startPos.z + (endPos.z - startPos.z) * progress;
          
          // Calculate height using parabola (maximum height at midpoint)
          const arcHeight = 30; // Maximum height of the arc
          const heightProgress = 4 * progress * (1 - progress); // Parabolic function (0 at start/end, 1 at middle)
          projectile.position.y = startPos.y + arcHeight * heightProgress;
          
          // Update direction to point along trajectory
          if (i > 0 && projectile.timeAlive > 0) {
            const prevPos = this.projectiles[i].position.clone();
            const direction = new THREE.Vector3(
              projectile.position.x - prevPos.x,
              projectile.position.y - prevPos.y,
              projectile.position.z - prevPos.z
            ).normalize();
            
            projectile.direction = direction;
          }
        }
        
        // Handle explosive projectiles
        if (projectile.explosive && projectile.timeAlive >= projectile.maxLife) {
          // Create explosion at projectile position
          this.createExplosion(projectile.position, projectile.explosionRadius || 5, projectile.damage || 1, projectile.owner);
          this.projectiles.splice(i, 1);
        }
      }
    };
  }
}

// Creates an explosion effect and damages nearby entities
TrenchFighter.prototype.createExplosion = function(position, radius, damage, owner) {
  // Visual effect (in a full implementation)
  console.log(`Explosion at ${position.x}, ${position.y}, ${position.z} with radius ${radius}`);
  
  // Check for players in blast radius
  const distanceToPlayer = position.distanceTo(this.camera.position);
  if (distanceToPlayer < radius && owner !== 'player') {
    // Calculate damage based on distance (more damage closer to center)
    const distanceFactor = 1 - (distanceToPlayer / radius);
    const damageAmount = Math.ceil(damage * distanceFactor);
    
    // Apply damage to player
    this.lastDamageBy = owner;
    for (let i = 0; i < damageAmount; i++) {
      this.playerTakeDamage();
    }
  }
  
  // Check for enemies in blast radius
  for (let i = this.enemies.length - 1; i >= 0; i--) {
    const enemy = this.enemies[i];
    const distanceToEnemy = position.distanceTo(enemy.position);
    
    if (distanceToEnemy < radius && enemy.owner !== owner) {
      // Calculate damage based on distance
      const distanceFactor = 1 - (distanceToEnemy / radius);
      const damageAmount = Math.ceil(damage * distanceFactor);
      
      // Apply damage to enemy
      enemy.health -= damageAmount;
      
      if (enemy.health <= 0) {
        // Enemy defeated
        this.enemies.splice(i, 1);
        this.scene.remove(enemy.visual);
        
        // If it was the player's kill, increase count and drop turret grenade
        if (owner === 'player') {
          this.player.kills++;
          this.dropTurretGrenade(enemy.position);
        }
      }
    }
  }
  
  // Check for turrets in blast radius
  for (let i = this.turrets.length - 1; i >= 0; i--) {
    const turret = this.turrets[i];
    const distanceToTurret = position.distanceTo(turret.position);
    
    if (distanceToTurret < radius && turret.owner !== owner) {
      // Calculate damage based on distance
      const distanceFactor = 1 - (distanceToTurret / radius);
      const damageAmount = Math.ceil(damage * distanceFactor);
      
      // Apply damage to turret
      turret.health -= damageAmount;
      
      if (turret.health <= 0) {
        // Turret destroyed
        this.turretSystem.destroyTurret(turret);
      }
    }
  }
  
  // Check for multiplayer players in blast radius (if multiplayer is active)
  if (this.multiplayer) {
    for (const playerId in this.multiplayer.players) {
      const player = this.multiplayer.players[playerId];
      const playerPosition = new THREE.Vector3(
        player.data.position.x,
        player.data.position.y,
        player.data.position.z
      );
      
      const distanceToPlayer = position.distanceTo(playerPosition);
      if (distanceToPlayer < radius && playerId !== owner) {
        // Calculate damage based on distance
        const distanceFactor = 1 - (distanceToPlayer / radius);
        const damageAmount = Math.ceil(damage * distanceFactor);
        
        // Send damage event to multiplayer system
        this.multiplayer.sendDamageEvent(playerId, damageAmount, owner);
      }
    }
  }
};

// Initialize turret system in the game
class TurretSystemIntegration {
  static extend(TrenchFighter) {
    // Extend the constructor
    const originalConstructor = TrenchFighter.prototype.constructor;
    TrenchFighter.prototype.constructor = function() {
      originalConstructor.apply(this, arguments);
      
      // Initialize turret system after game is started
      this.startGameWithTurrets = this.startGame;
      this.startGame = function() {
        this.startGameWithTurrets();
        this.turretSystem = new TurretSystem(this);
        
        // Apply projectile extensions
        ProjectileExtensions.extend(TrenchFighter);
      };
    };
    
    // Extend the update method to update turrets
    const originalUpdate = TrenchFighter.prototype.update;
    TrenchFighter.prototype.update = function() {
      originalUpdate.call(this);
      
      // Update turrets if system is initialized
      if (this.turretSystem) {
        this.turretSystem.updateTurrets(this.deltaTime);
      }
    };
    
    // Replace placeTurret method to use the turret system
    TrenchFighter.prototype.placeTurret = function(position) {
      if (!this.turretSystem) return;
      
      // Determine the turret type randomly
      const turretTypes = ['machineGun', 'tank', 'mortar'];
      const type = turretTypes[Math.floor(Math.random() * turretTypes.length)];
      
      // Create turret using the turret system
      const turret = this.turretSystem.createTurret(type, position, 'player');
      
      // Increment player's turret count
      this.player.turrets++;
      
      // Add to multiplayer database if active
      if (this.multiplayer) {
        this.multiplayer.addLocalTurretToDatabase(turret);
      }
      
      console.log(`Placed ${type} turret at`, position);
      return turret;
    };
  }
}

// Apply turret system integration when the page loads
window.addEventListener('load', () => {
  // Wait for TrenchFighter class to be available
  if (typeof TrenchFighter !== 'undefined') {
    TurretSystemIntegration.extend(TrenchFighter);
  } else {
    console.error('TrenchFighter class not found');
  }
});

</script> 

<script src="weapon-system.js">

// Weapon System for Trench Fighter
// Handles weapon behaviors, upgrades, and visual representations

class WeaponSystem {
  constructor(game) {
    this.game = game;
    
    // Define weapon types and their properties
    this.weaponTypes = {
      pistol: {
        name: 'Pistol',
        description: 'Standard sidearm that upgrades with consecutive kills',
        damage: 1,
        baseFireRate: 0.5, // Base fire rate in seconds between shots
        spread: 0.02, // Base bullet spread
        projectileCount: 1, // Base projectile count
        range: 40,
        ammoType: 'infinite',
        upgradeableLevels: 3,
        modelScale: 0.3
      },
      shotgun: {
        name: 'Shotgun',
        description: 'Short-range weapon with wide spread',
        damage: 1,
        fireRate: 0.8,
        spread: 0.1,
        projectileCount: 5,
        range: 15,
        ammoType: 'shotgun',
        modelScale: 0.4
      },
      rifle: {
        name: 'Semi-Auto Rifle',
        description: 'Long-range weapon with high accuracy',
        damage: 1,
        fireRate: 0.3,
        spread: 0.01,
        projectileCount: 1,
        range: 70,
        ammoType: 'rifle',
        modelScale: 0.5
      },
      grenade: {
        name: 'Turret Grenade',
        description: 'Deploys an automated defense turret',
        damage: 0,
        fireRate: 1.0,
        throwForce: 15,
        ammoType: 'grenade',
        modelScale: 0.2
      }
    };
    
    // Initialize weapon models
    this.initializeWeaponModels();
  }
  
  // Initialize weapon models (simplified for prototype)
  initializeWeaponModels() {
    // Create weapon meshes
    this.weaponMeshes = {};
    
    // Pistol
    this.weaponMeshes.pistol = this.createPistolMesh();
    
    // Shotgun
    this.weaponMeshes.shotgun = this.createShotgunMesh();
    
    // Rifle
    this.weaponMeshes.rifle = this.createRifleMesh();
    
    // Grenade
    this.weaponMeshes.grenade = this.createGrenadeMesh();
    
    // Hide all weapons initially
    for (const type in this.weaponMeshes) {
      this.weaponMeshes[type].visible = false;
      this.game.scene.add(this.weaponMeshes[type]);
    }
  }
  
  // Create pistol mesh
  createPistolMesh() {
    const group = new THREE.Group();
    
    // Pistol handle
    const handleGeometry = new THREE.BoxGeometry(0.08, 0.15, 0.03);
    const handleMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
    handle.position.set(0, -0.08, 0);
    group.add(handle);
    
    // Pistol barrel
    const barrelGeometry = new THREE.BoxGeometry(0.03, 0.05, 0.12);
    const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
    barrel.position.set(0, 0, 0.06);
    group.add(barrel);
    
    // Pistol slide
    const slideGeometry = new THREE.BoxGeometry(0.06, 0.03, 0.15);
    const slideMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const slide = new THREE.Mesh(slideGeometry, slideMaterial);
    slide.position.set(0, 0.02, 0.03);
    group.add(slide);
    
    // Position for first-person view
    group.position.set(0.15, -0.1, -0.2);
    group.rotation.set(0, Math.PI / 2, 0);
    
    return group;
  }
  
  // Create shotgun mesh
  createShotgunMesh() {
    const group = new THREE.Group();
    
    // Shotgun stock
    const stockGeometry = new THREE.BoxGeometry(0.05, 0.08, 0.2);
    const stockMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const stock = new THREE.Mesh(stockGeometry, stockMaterial);
    stock.position.set(0, -0.02, -0.1);
    group.add(stock);
    
    // Shotgun barrel
    const barrelGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
    const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
    barrel.rotation.set(0, 0, Math.PI / 2);
    barrel.position.set(0, 0.02, 0.1);
    group.add(barrel);
    
    // Shotgun pump
    const pumpGeometry = new THREE.BoxGeometry(0.04, 0.04, 0.1);
    const pumpMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const pump = new THREE.Mesh(pumpGeometry, pumpMaterial);
    pump.position.set(0, -0.015, 0.05);
    group.add(pump);
    
    // Position for first-person view
    group.position.set(0.15, -0.08, -0.2);
    group.rotation.set(0, Math.PI / 2, 0);
    
    return group;
  }
  
  // Create rifle mesh
  createRifleMesh() {
    const group = new THREE.Group();
    
    // Rifle stock
    const stockGeometry = new THREE.BoxGeometry(0.04, 0.08, 0.15);
    const stockMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const stock = new THREE.Mesh(stockGeometry, stockMaterial);
    stock.position.set(0, -0.02, -0.1);
    group.add(stock);
    
    // Rifle barrel
    const barrelGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.4, 8);
    const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
    barrel.rotation.set(0, 0, Math.PI / 2);
    barrel.position.set(0, 0.02, 0.15);
    group.add(barrel);
    
    // Rifle body
    const bodyGeometry = new THREE.BoxGeometry(0.05, 0.04, 0.2);
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.set(0, 0.01, 0.05);
    group.add(body);
    
    // Rifle magazine
    const magGeometry = new THREE.BoxGeometry(0.03, 0.1, 0.03);
    const magMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const mag = new THREE.Mesh(magGeometry, magMaterial);
    mag.position.set(0, -0.06, 0.03);
    group.add(mag);
    
    // Position for first-person view
    group.position.set(0.15, -0.05, -0.2);
    group.rotation.set(0, Math.PI / 2, 0);
    
    return group;
  }
  
  // Create grenade mesh
  createGrenadeMesh() {
    const group = new THREE.Group();
    
    // Grenade body
    const bodyGeometry = new THREE.SphereGeometry(0.05, 8, 8);
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x00FF00 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    group.add(body);
    
    // Grenade top
    const topGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.03, 8);
    const topMaterial = new THREE.MeshStandardMaterial({ color: 0xCCCCCC });
    const top = new THREE.Mesh(topGeometry, topMaterial);
    top.position.set(0, 0.06, 0);
    group.add(top);
    
    // Position for first-person view
    group.position.set(0.15, -0.1, -0.2);
    
    return group;
  }
  
  // Show weapon based on currently selected weapon
  showCurrentWeapon(weaponType) {
    // Hide all weapons first
    for (const type in this.weaponMeshes) {
      this.weaponMeshes[type].visible = false;
    }
    
    // Show selected weapon if it exists
    if (this.weaponMeshes[weaponType]) {
      this.weaponMeshes[weaponType].visible = true;
      
      // Apply weapon level modifications for pistol
      if (weaponType === 'pistol') {
        this.updatePistolAppearanceForLevel(this.game.player.weapons.pistol.level);
      }
    }
  }
  
  // Update pistol appearance based on level
  updatePistolAppearanceForLevel(level) {
    const pistol = this.weaponMeshes.pistol;
    
    // Reset any modifications
    pistol.scale.set(1, 1, 1);
    
    switch (level) {
      case 1:
        // Base pistol - already set
        break;
      case 2:
        // Level 2 - slightly larger barrel
        pistol.children[1].scale.set(1, 1, 1.2);
        break;
      case 3:
        // Level 3 - larger barrel and slide
        pistol.children[1].scale.set(1.1, 1.1, 1.3);
        pistol.children[2].scale.set(1.2, 1.2, 1.2);
        break;
    }
  }
  
  // Update weapon position to match camera
  updateWeaponPosition() {
    // Base position offset from camera
    const basePosition = new THREE.Vector3(0.15, -0.1, -0.2);
    
    // Get camera's direction and position
    const cameraDirection = new THREE.Vector3(0, 0, -1);
    cameraDirection.applyQuaternion(this.game.camera.quaternion);
    
    // Apply bobbing effect based on movement
    let bobbingOffset = new THREE.Vector3(0, 0, 0);
    
    if (this.game.player.moveForward || this.game.player.moveBackward || 
        this.game.player.moveLeft || this.game.player.moveRight) {
      // Simple bobbing effect when moving
      const bobbingIntensity = 0.02;
      const bobbingSpeed = 10;
      bobbingOffset.y = Math.sin(this.game.clock.elapsedTime * bobbingSpeed) * bobbingIntensity;
      bobbingOffset.x = Math.cos(this.game.clock.elapsedTime * bobbingSpeed) * bobbingIntensity * 0.5;
    }
    
    // Apply recoil effect if recent shot
    if (this.game.player.shootCooldown > 0) {
      const recoilProgress = 1 - (this.game.player.shootCooldown / this.getWeaponFireRate());
      let recoilIntensity = 0;
      
      // Apply different recoil based on weapon
      switch (this.game.player.currentWeapon) {
        case 'pistol':
          recoilIntensity = 0.03 * (1 + (this.game.player.weapons.pistol.level - 1) * 0.2);
          break;
        case 'shotgun':
          recoilIntensity = 0.06;
          break;
        case 'rifle':
          recoilIntensity = 0.04;
          break;
        case 'grenade':
          // Grenade throw animation
          if (recoilProgress < 0.5) {
            // Wind up
            recoilIntensity = -0.05 * (0.5 - recoilProgress) * 2;
          } else {
            // Throw forward
            recoilIntensity = 0.1 * (1 - recoilProgress) * 2;
          }
          break;
      }
      
      // Smooth curve for recoil
      const recoilCurve = Math.sin(recoilProgress * Math.PI);
      
      // Apply recoil to z-axis (backward) and y-axis (upward)
      bobbingOffset.z += recoilIntensity * recoilCurve;
      bobbingOffset.y += recoilIntensity * recoilCurve * 0.5;
    }
    
    // Apply position to all weapons
    for (const type in this.weaponMeshes) {
      const weapon = this.weaponMeshes[type];
      
      // Position relative to camera
      weapon.position.copy(basePosition).add(bobbingOffset);
      
      // Set weapon position in world space
      weapon.position.applyQuaternion(this.game.camera.quaternion);
      weapon.position.add(this.game.camera.position);
      
      // Set rotation to match camera
      weapon.quaternion.copy(this.game.camera.quaternion);
      
      // Apply additional rotation based on weapon type
      if (type === 'pistol') {
        weapon.rotateY(Math.PI / 2);
      } else if (type === 'shotgun' || type === 'rifle') {
        weapon.rotateY(Math.PI / 2);
      }
    }
  }
  
  // Shoot the currently selected weapon
  shootCurrentWeapon() {
    const weaponType = this.game.player.currentWeapon;
    
    // Check if weapon is on cooldown
    if (this.game.player.shootCooldown > 0) {
      return false;
    }
    
    // Check if we have ammo for non-pistol weapons
    if (weaponType !== 'pistol' && this.game.player.weapons[weaponType].ammo <= 0) {
      // Switch back to pistol if out of ammo
      this.game.selectWeapon('pistol');
      return false;
    }
    
    // Set cooldown based on weapon type
    this.game.player.shootCooldown = this.getWeaponFireRate();
    
    // Decrement ammo for non-pistol weapons
    if (weaponType !== 'pistol') {
      this.game.player.weapons[weaponType].ammo--;
      
      // Update UI
      document.querySelector(`.inventory-slot[data-weapon="${weaponType}"]`).innerHTML = 
          `${weaponType.charAt(0).toUpperCase() + weaponType.slice(1)}<br>${this.game.player.weapons[weaponType].ammo}`;
    }
    
    // Handle different weapon types
    switch (weaponType) {
      case 'pistol':
        this.firePistol();
        break;
      case 'shotgun':
        this.fireShotgun();
        break;
      case 'rifle':
        this.fireRifle();
        break;
      case 'grenade':
        this.throwGrenade();
        break;
    }
    
    return true;
  }
  
  // Get fire rate based on weapon type and level
  getWeaponFireRate() {
    const weaponType = this.game.player.currentWeapon;
    const weaponConfig = this.weaponTypes[weaponType];
    
    if (weaponType === 'pistol') {
      // Pistol fire rate improves with level
      const level = this.game.player.weapons.pistol.level;
      return weaponConfig.baseFireRate / level;
    } else {
      return weaponConfig.fireRate;
    }
  }
  
  // Fire pistol with properties based on current level
  firePistol() {
    const pistolLevel = this.game.player.weapons.pistol.level;
    const pistolConfig = this.weaponTypes.pistol;
    
    // Set up raycaster from camera
    this.game.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.game.camera);
    
    // Get base direction
    const baseDirection = this.game.raycaster.ray.direction.clone();
    
    // Determine projectile count based on level
    let projectileCount = Math.min(pistolLevel, 3);
    
    // Determine spread based on level
    let spread = pistolConfig.spread * (1 - (pistolLevel - 1) * 0.2);
    
    // Create projectiles
    for (let i = 0; i < projectileCount; i++) {
      // Apply spread for multiple projectiles
      const direction = baseDirection.clone();
      
      if (projectileCount > 1) {
        direction.x += (Math.random() - 0.5) * spread;
        direction.y += (Math.random() - 0.5) * spread;
        direction.z += (Math.random() - 0.5) * spread;
        direction.normalize();
      }
      
      const projectile = {
        position: this.game.camera.position.clone(),
        direction: direction,
        speed: 50,
        weapon: 'pistol',
        damage: pistolConfig.damage,
        owner: 'player',
        timeAlive: 0,
        maxLife: 2
      };
      
      this.game.projectiles.push(projectile);
    }
    
    // Add muzzle flash effect
    this.createMuzzleFlash(this.weaponMeshes.pistol, 0.05);
    
    // Add recoil animation (handled in updateWeaponPosition)
    
    // Play sound (would add actual sound effects in a full implementation)
    console.log(`Firing pistol (Level ${pistolLevel})`);
  }
  
  // Fire shotgun
  fireShotgun() {
    const shotgunConfig = this.weaponTypes.shotgun;
    
    // Set up raycaster from camera
    this.game.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.game.camera);
    
    // Get base direction
    const baseDirection = this.game.raycaster.ray.direction.clone();
    
    // Create multiple projectiles with spread
    for (let i = 0; i < shotgunConfig.projectileCount; i++) {
      const direction = baseDirection.clone();
      
      // Apply spread
      direction.x += (Math.random() - 0.5) * shotgunConfig.spread;
      direction.y += (Math.random() - 0.5) * shotgunConfig.spread;
      direction.z += (Math.random() - 0.5) * shotgunConfig.spread;
      direction.normalize();
      
      const projectile = {
        position: this.game.camera.position.clone(),
        direction: direction,
        speed: 50,
        weapon: 'shotgun',
        damage: shotgunConfig.damage,
        owner: 'player',
        timeAlive: 0,
        maxLife: 1 // Shorter range
      };
      
      this.game.projectiles.push(projectile);
    }
    
    // Add muzzle flash effect
    this.createMuzzleFlash(this.weaponMeshes.shotgun, 0.1);
    
    // Play sound
    console.log('Firing shotgun');
  }
  
  // Fire rifle
  fireRifle() {
    const rifleConfig = this.weaponTypes.rifle;
    
    // Set up raycaster from camera
    this.game.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.game.camera);
    
    // Get base direction with minimal spread
    const direction = this.game.raycaster.ray.direction.clone();
    direction.x += (Math.random() - 0.5) * rifleConfig.spread;
    direction.y += (Math.random() - 0.5) * rifleConfig.spread;
    direction.z += (Math.random() - 0.5) * rifleConfig.spread;
    direction.normalize();
    
    const projectile = {
      position: this.game.camera.position.clone(),
      direction: direction,
      speed: 70, // Faster bullet
      weapon: 'rifle',
      damage: rifleConfig.damage,
      owner: 'player',
      timeAlive: 0,
      maxLife: 3 // Longer range
    };
    
    this.game.projectiles.push(projectile);
    
    // Add muzzle flash effect
    this.createMuzzleFlash(this.weaponMeshes.rifle, 0.06);
    
    // Play sound
    console.log('Firing rifle');
  }
  
      // Throw grenade
  throwGrenade() {
    const grenadeConfig = this.weaponTypes.grenade;
    
    // Set up direction from camera
    this.game.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.game.camera);
    
    // Get direction with slight upward adjustment
    const grenadeDirection = this.game.raycaster.ray.direction.clone();
    grenadeDirection.y += 0.2; // Throw slightly upward
    grenadeDirection.normalize();
    
    const grenade = {
      position: this.game.camera.position.clone(),
      direction: grenadeDirection,
      speed: grenadeConfig.throwForce,
      timeAlive: 0,
      maxLife: 3, // Seconds before exploding
      owner: 'player',
      type: 'grenade'
    };
    
    // Add grenade to projectiles array
    this.game.projectiles.push(grenade);
    
    console.log('Throwing grenade');
  }
  
  // Create muzzle flash effect
  createMuzzleFlash(weaponMesh, size) {
    // In a full implementation, would create a proper muzzle flash effect
    // For the prototype, we'll just log it
    console.log('Muzzle flash');
    
    // Add a flash effect to the crosshair
    const crosshair = document.getElementById('crosshair');
    crosshair.style.backgroundColor = 'rgba(255, 255, 0, 0.5)';
    setTimeout(() => {
      crosshair.style.backgroundColor = 'transparent';
    }, 50);
  }
  
  // Collect a weapon pickup
  collectWeaponPickup(pickupType) {
    switch (pickupType) {
      case 'shotgun':
        this.game.player.weapons.shotgun.ammo += 10;
        break;
      case 'rifle':
        this.game.player.weapons.rifle.ammo += 20;
        break;
      case 'grenade':
        this.game.player.weapons.grenade.ammo += 1;
        break;
    }
    
    // Update UI
    document.querySelector(`.inventory-slot[data-weapon="${pickupType}"]`).innerHTML = 
      `${pickupType.charAt(0).toUpperCase() + pickupType.slice(1)}<br>${this.game.player.weapons[pickupType].ammo}`;
    
    // Automatically select the weapon if not already equipped
    if (this.game.player.currentWeapon === 'pistol') {
      this.game.selectWeapon(pickupType);
    }
  }
  
  // Upgrade pistol level (called after kill)
  upgradePistol() {
    // Max level is 3
    if (this.game.player.weapons.pistol.level < 3) {
      this.game.player.weapons.pistol.level++;
      
      // Update appearance if pistol is currently equipped
      if (this.game.player.currentWeapon === 'pistol') {
        this.updatePistolAppearanceForLevel(this.game.player.weapons.pistol.level);
      }
      
      console.log(`Pistol upgraded to level ${this.game.player.weapons.pistol.level}`);
    }
  }
  
  // Downgrade pistol level (called after death)
  downgradePistol() {
    // Minimum level is 1
    if (this.game.player.weapons.pistol.level > 1) {
      this.game.player.weapons.pistol.level--;
      
      // Update appearance if pistol is currently equipped
      if (this.game.player.currentWeapon === 'pistol') {
        this.updatePistolAppearanceForLevel(this.game.player.weapons.pistol.level);
      }
      
      console.log(`Pistol downgraded to level ${this.game.player.weapons.pistol.level}`);
    }
  }
}

// Extend the TrenchFighter class to integrate the weapon system
class WeaponSystemIntegration {
  static extend(TrenchFighter) {
    // Extend the constructor
    const originalConstructor = TrenchFighter.prototype.constructor;
    TrenchFighter.prototype.constructor = function() {
      originalConstructor.apply(this, arguments);
      
      // Initialize weapon system after game is started
      this.startGameWithWeapons = this.startGame;
      this.startGame = function() {
        this.startGameWithWeapons();
        this.weaponSystem = new WeaponSystem(this);
      };
    };
    
    // Extend the update method to update weapon positions
    const originalUpdate = TrenchFighter.prototype.update;
    TrenchFighter.prototype.update = function() {
      originalUpdate.call(this);
      
      // Update weapon positions if system is initialized
      if (this.weaponSystem) {
        this.weaponSystem.updateWeaponPosition();
      }
    };
    
    // Replace shoot method to use the weapon system
    TrenchFighter.prototype.shoot = function() {
      if (this.weaponSystem) {
        return this.weaponSystem.shootCurrentWeapon();
      }
      return false;
    };
    
    // Extend selectWeapon method to show the selected weapon model
    const originalSelectWeapon = TrenchFighter.prototype.selectWeapon;
    TrenchFighter.prototype.selectWeapon = function(weapon) {
      const result = originalSelectWeapon.call(this, weapon);
      
      // Show the selected weapon model
      if (this.weaponSystem) {
        this.weaponSystem.showCurrentWeapon(weapon);
      }
      
      return result;
    };
    
    // Extend collectPickup method to use the weapon system
    const originalCollectPickup = TrenchFighter.prototype.collectPickup;
    TrenchFighter.prototype.collectPickup = function(pickup) {
      originalCollectPickup.call(this, pickup);
      
      // Handle weapon-specific pickups
      if (this.weaponSystem && (pickup.type === 'shotgun' || pickup.type === 'rifle' || pickup.type === 'grenade')) {
        this.weaponSystem.collectWeaponPickup(pickup.type);
      }
    };
    
    // Extend enemy defeat to upgrade pistol
    const originalUpdateProjectiles = TrenchFighter.prototype.updateProjectiles;
    TrenchFighter.prototype.updateProjectiles = function() {
      // Store current enemy count
      const enemyCountBefore = this.enemies.length;
      
      // Call original method
      originalUpdateProjectiles.call(this);
      
      // If enemy count decreased and player fired the shot, upgrade pistol
      const enemyCountAfter = this.enemies.length;
      if (enemyCountBefore > enemyCountAfter && this.weaponSystem) {
        // Player killed an enemy
        this.weaponSystem.upgradePistol();
      }
    };
    
    // Extend playerDeath to downgrade pistol
    const originalPlayerDeath = TrenchFighter.prototype.playerDeath;
    TrenchFighter.prototype.playerDeath = function() {
      // Call original method
      originalPlayerDeath.call(this);
      
      // Downgrade pistol
      if (this.weaponSystem) {
        this.weaponSystem.downgradePistol();
      }
    };
  }
}

// Apply weapon system integration when the page loads
window.addEventListener('load', () => {
  // Wait for TrenchFighter class to be available
  if (typeof TrenchFighter !== 'undefined') {
    WeaponSystemIntegration.extend(TrenchFighter);
  } else {
    console.error('TrenchFighter class not found');
  }
});

</script> 

<script src="firebase-integration.js">

// Firebase Multiplayer Integration for Trench Fighter
// This script should be added to the main HTML file

// Firebase Configuration
const firebaseConfig = {

  apiKey: "AIzaSyCK3jK4Ld3bDL8XlhDZ-2qJnTYTPgypk1s",

  authDomain: "trenchfighter-252a1.firebaseapp.com",

  databaseURL: "https://trenchfighter-252a1-default-rtdb.asia-southeast1.firebasedatabase.app",

  projectId: "trenchfighter-252a1",

  storageBucket: "trenchfighter-252a1.firebasestorage.app",

  messagingSenderId: "246395113908",

  appId: "1:246395113908:web:e88735e52dcb87fbcaa2e1",

  measurementId: "G-5R4K27D1DT"

};

class MultiplayerManager {
  constructor(game) {
    this.game = game;
    this.playerId = null;
    this.playerRef = null;
    this.players = {}; // Other players in the game
    this.turretsRef = null;
    
    this.initFirebase();
  }
  
  async initFirebase() {
    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    this.db = firebase.database();
    
    // Generate a unique player ID
    this.playerId = this.generatePlayerId();
    
    // Set up player reference in the database
    this.playerRef = this.db.ref(`players/${this.playerId}`);
    
    // Set up turrets reference
    this.turretsRef = this.db.ref('turrets');
    
    // Remove player from database when they disconnect
    this.playerRef.onDisconnect().remove();
    
    // Update player data
    this.updatePlayerData();
    
    // Listen for other players
    this.listenForOtherPlayers();
    
    // Listen for turrets
    this.listenForTurrets();
    
    // Set up server time sync
    await this.syncTime();
    
    console.log('Firebase multiplayer initialized');
  }
  
  generatePlayerId() {
    // Generate a random ID for the player
    return 'player_' + Math.random().toString(36).substring(2, 9);
  }
  
  updatePlayerData() {
    // Update player position and rotation in the database
    if (this.playerRef && this.game.camera) {
      this.playerRef.update({
        position: {
          x: this.game.camera.position.x,
          y: this.game.camera.position.y,
          z: this.game.camera.position.z
        },
        rotation: {
          x: this.game.camera.rotation.x,
          y: this.game.camera.rotation.y,
          z: this.game.camera.rotation.z
        },
        health: this.game.player.health,
        currentWeapon: this.game.player.currentWeapon,
        lastUpdated: firebase.database.ServerValue.TIMESTAMP
      });
    }
    
    // Schedule the next update
    setTimeout(() => this.updatePlayerData(), 100); // Update 10 times per second
  }
  
  listenForOtherPlayers() {
    // Listen for other players joining or leaving
    const playersRef = this.db.ref('players');
    
    // Handle player added
    playersRef.on('child_added', (snapshot) => {
      const playerId = snapshot.key;
      
      // Skip if it's the current player
      if (playerId === this.playerId) return;
      
      // Create a new player object
      const playerData = snapshot.val();
      this.addOtherPlayer(playerId, playerData);
    });
    
    // Handle player data updated
    playersRef.on('child_changed', (snapshot) => {
      const playerId = snapshot.key;
      
      // Skip if it's the current player
      if (playerId === this.playerId) return;
      
      // Update player data
      const playerData = snapshot.val();
      this.updateOtherPlayer(playerId, playerData);
    });
    
    // Handle player removed
    playersRef.on('child_removed', (snapshot) => {
      const playerId = snapshot.key;
      
      // Skip if it's the current player
      if (playerId === this.playerId) return;
      
      // Remove player
      this.removeOtherPlayer(playerId);
    });
  }
  
  addOtherPlayer(playerId, playerData) {
    // Create a visual representation for other player
    const geometry = new THREE.BoxGeometry(1, 1.8, 1);
    const material = new THREE.MeshStandardMaterial({ color: 0x0000FF }); // Blue for other players
    const playerMesh = new THREE.Mesh(geometry, material);
    
    // Set initial position and rotation
    playerMesh.position.set(
      playerData.position.x,
      playerData.position.y,
      playerData.position.z
    );
    
    playerMesh.rotation.set(
      playerData.rotation.x,
      playerData.rotation.y,
      playerData.rotation.z
    );
    
    playerMesh.castShadow = true;
    playerMesh.receiveShadow = true;
    
    // Add to scene
    this.game.scene.add(playerMesh);
    
    // Store player data
    this.players[playerId] = {
      data: playerData,
      mesh: playerMesh
    };
    
    console.log(`Player ${playerId} joined`);
  }
  
  updateOtherPlayer(playerId, playerData) {
    if (!this.players[playerId]) return;
    
    const player = this.players[playerId];
    
    // Update position with simple interpolation
    player.mesh.position.lerp(
      new THREE.Vector3(
        playerData.position.x,
        playerData.position.y,
        playerData.position.z
      ),
      0.5
    );
    
    // Update rotation with simple interpolation
    player.mesh.rotation.set(
      playerData.rotation.x,
      playerData.rotation.y,
      playerData.rotation.z
    );
    
    // Update stored data
    player.data = playerData;
  }
  
  removeOtherPlayer(playerId) {
    if (!this.players[playerId]) return;
    
    // Remove from scene
    this.game.scene.remove(this.players[playerId].mesh);
    
    // Remove from players object
    delete this.players[playerId];
    
    console.log(`Player ${playerId} left`);
  }
  
  listenForTurrets() {
    // Listen for turrets being added, updated, or removed
    
    // Handle turret added
    this.turretsRef.on('child_added', (snapshot) => {
      const turretId = snapshot.key;
      const turretData = snapshot.val();
      
      // Skip if it's the current player's turret (already handled locally)
      if (turretData.owner === this.playerId) return;
      
      // Create the turret
      this.addRemoteTurret(turretId, turretData);
    });
    
    // Handle turret updated
    this.turretsRef.on('child_changed', (snapshot) => {
      const turretId = snapshot.key;
      const turretData = snapshot.val();
      
      // Skip if it's the current player's turret (already handled locally)
      if (turretData.owner === this.playerId) return;
      
      // Update the turret
      this.updateRemoteTurret(turretId, turretData);
    });
    
    // Handle turret removed
    this.turretsRef.on('child_removed', (snapshot) => {
      const turretId = snapshot.key;
      const turretData = snapshot.val();
      
      // Skip if it's the current player's turret (already handled locally)
      if (turretData && turretData.owner === this.playerId) return;
      
      // Remove the turret
      this.removeRemoteTurret(turretId);
    });
  }
  
  addRemoteTurret(turretId, turretData) {
    // Create a turret based on type and position
    const position = new THREE.Vector3(
      turretData.position.x,
      turretData.position.y,
      turretData.position.z
    );
    
    // This will create the turret and add it to the game
    const turret = {
      id: turretId,
      type: turretData.type,
      position: position,
      rotation: turretData.rotation,
      health: turretData.health,
      shootCooldown: 0,
      owner: turretData.owner,
      remote: true // Flag to identify remote turrets
    };
    
    // Create visual representation based on type
    switch (turretData.type) {
      case 'machineGun':
        turret.visual = this.game.createMachineGunNest(
          position.x, position.y, position.z
        );
        turret.shootCooldown = 0.1;
        break;
      case 'tank':
        turret.visual = this.game.createTank(
          position.x, position.y, position.z
        );
        turret.shootCooldown = 1.0;
        turret.moveSpeed = 2;
        turret.moveCooldown = 3;
        turret.moveTimer = 0;
        turret.moveDirection = new THREE.Vector2(
          Math.random() - 0.5, Math.random() - 0.5
        ).normalize();
        break;
      case 'mortar':
        turret.visual = this.game.createMortar(
          position.x, position.y, position.z
        );
        turret.shootCooldown = 3.0;
        break;
    }
    
    // Add to turrets array
    this.game.turrets.push(turret);
  }
  
  updateRemoteTurret(turretId, turretData) {
    // Find turret in the game's turrets array
    const turretIndex = this.game.turrets.findIndex(t => t.id === turretId);
    
    if (turretIndex === -1) return;
    
    const turret = this.game.turrets[turretIndex];
    
    // Update position and rotation
    turret.position.set(
      turretData.position.x,
      turretData.position.y,
      turretData.position.z
    );
    
    turret.rotation = turretData.rotation;
    
    // Update visual representation
    switch (turret.type) {
      case 'machineGun':
        turret.visual.base.position.set(
          turret.position.x,
          turret.position.y + 0.25,
          turret.position.z
        );
        turret.visual.gun.position.set(
          turret.position.x,
          turret.position.y + 0.65,
          turret.position.z
        );
        turret.visual.gun.rotation.y = turret.rotation;
        break;
      case 'tank':
        turret.visual.body.position.set(
          turret.position.x,
          turret.position.y + 1.25,
          turret.position.z
        );
        turret.visual.turret.position.set(
          turret.position.x,
          turret.position.y + 2.5,
          turret.position.z
        );
        turret.visual.barrel.position.set(
          turret.position.x,
          turret.position.y + 2.5,
          turret.position.z + 1.5
        );
        break;
      case 'mortar':
        turret.visual.base.position.set(
          turret.position.x,
          turret.position.y + 0.25,
          turret.position.z
        );
        turret.visual.barrel.position.set(
          turret.position.x,
          turret.position.y + 1.0,
          turret.position.z
        );
        break;
    }
    
    // Update other properties
    turret.health = turretData.health;
  }
  
  removeRemoteTurret(turretId) {
    // Find turret in the game's turrets array
    const turretIndex = this.game.turrets.findIndex(t => t.id === turretId);
    
    if (turretIndex === -1) return;
    
    const turret = this.game.turrets[turretIndex];
    
    // Remove visual representation from scene
    switch (turret.type) {
      case 'machineGun':
        this.game.scene.remove(turret.visual.base);
        this.game.scene.remove(turret.visual.gun);
        break;
      case 'tank':
        this.game.scene.remove(turret.visual.body);
        this.game.scene.remove(turret.visual.turret);
        this.game.scene.remove(turret.visual.barrel);
        break;
      case 'mortar':
        this.game.scene.remove(turret.visual.base);
        this.game.scene.remove(turret.visual.barrel);
        break;
    }
    
    // Remove from turrets array
    this.game.turrets.splice(turretIndex, 1);
  }
  
  addLocalTurretToDatabase(turret) {
    // Generate unique ID for the turret
    const turretId = 'turret_' + Math.random().toString(36).substring(2, 9);
    
    // Add to database
    this.turretsRef.child(turretId).set({
      type: turret.type,
      position: {
        x: turret.position.x,
        y: turret.position.y,
        z: turret.position.z
      },
      rotation: turret.rotation,
      health: turret.health,
      owner: this.playerId,
      createdAt: firebase.database.ServerValue.TIMESTAMP
    });
    
    // Set the ID on the local turret
    turret.id = turretId;
  }
  
  async syncTime() {
    // Synchronize local time with server time
    const timeRef = this.db.ref('.info/serverTimeOffset');
    
    return new Promise((resolve) => {
      timeRef.once('value', (snapshot) => {
        const offset = snapshot.val();
        this.serverTimeOffset = offset;
        resolve();
      });
    });
  }
  
  // Get current server time
  getServerTime() {
    return Date.now() + (this.serverTimeOffset || 0);
  }
  
  // Register a kill in the database
  registerKill(victimId) {
    if (!this.playerId) return;
    
    // Update player's kill count
    this.playerRef.child('kills').transaction((currentKills) => {
      return (currentKills || 0) + 1;
    });
    
    // Record kill event
    this.db.ref('kills').push({
      killer: this.playerId,
      victim: victimId,
      timestamp: firebase.database.ServerValue.TIMESTAMP
    });
  }
}

// Extend the TrenchFighter class to integrate multiplayer
class MultiplayerExtensions {
  static extend(TrenchFighter) {
    // Extend the constructor
    const originalConstructor = TrenchFighter.prototype.constructor;
    TrenchFighter.prototype.constructor = function() {
      originalConstructor.apply(this, arguments);
      
      // Initialize multiplayer after game is started
      this.startGameWithMultiplayer = this.startGame;
      this.startGame = function() {
        this.startGameWithMultiplayer();
        this.multiplayer = new MultiplayerManager(this);
      };
    };
    
    // Extend placeTurret to add turrets to the database
    const originalPlaceTurret = TrenchFighter.prototype.placeTurret;
    TrenchFighter.prototype.placeTurret = function(position) {
      // Call original method
      originalPlaceTurret.call(this, position);
      
      // Get the turret that was just added
      const turret = this.turrets[this.turrets.length - 1];
      
      // Add to database if multiplayer is initialized
      if (this.multiplayer) {
        this.multiplayer.addLocalTurretToDatabase(turret);
      }
    };
    
    // Extend playerDeath to register kills
    const originalPlayerDeath = TrenchFighter.prototype.playerDeath;
    TrenchFighter.prototype.playerDeath = function() {
      // Call original method
      originalPlayerDeath.call(this);
      
      // Register death in multiplayer
      if (this.multiplayer && this.lastDamageBy) {
        this.multiplayer.registerKill(this.lastDamageBy);
      }
    };
    
    // Extend updateProjectiles to handle hits from other players
    const originalUpdateProjectiles = TrenchFighter.prototype.updateProjectiles;
    TrenchFighter.prototype.updateProjectiles = function() {
      // Call original method
      originalUpdateProjectiles.call(this);
      
      // Check for hits from other players
      for (let i = this.projectiles.length - 1; i >= 0; i--) {
        const projectile = this.projectiles[i];
        
        // Only check projectiles from other players
        if (projectile.owner !== 'player' && projectile.owner !== 'enemy') {
          const distance = projectile.position.distanceTo(this.camera.position);
          
          if (distance < 1) {
            // Player hit!
            this.lastDamageBy = projectile.owner;
            this.playerTakeDamage();
            
            // Remove projectile
            this.projectiles.splice(i, 1);
          }
        }
      }
    };
  }
}

// Apply multiplayer extensions when the page loads
window.addEventListener('load', () => {
  // Wait for TrenchFighter class to be available
  if (typeof TrenchFighter !== 'undefined') {
    MultiplayerExtensions.extend(TrenchFighter);
  } else {
    console.error('TrenchFighter class not found');
  }
});

</script>
</body>
</html>