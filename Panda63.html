<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Enhanced PS2-Style Mascot Panda</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background-color: #000;
      touch-action: none;
    }
    canvas { 
      display: block; 
    }
    #controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }
    .direction-pad {
      display: grid;
      grid-template-columns: repeat(3, 60px);
      grid-template-rows: repeat(3, 60px);
      gap: 5px;
      pointer-events: none;
    }
    .camera-pad {
      display: grid;
      grid-template-columns: repeat(3, 60px);
      grid-template-rows: repeat(3, 60px);
      gap: 5px;
      pointer-events: none;
    }
    .control-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: white;
      user-select: none;
      pointer-events: auto;
      border: none;
      outline: none;
      -webkit-tap-highlight-color: transparent;
    }
    .control-btn:active, .control-btn.active {
      background-color: rgba(255, 255, 255, 0.6);
    }
    .control-btn.center {
      opacity: 0;
      pointer-events: none;
    }
    .instructions {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-family: Arial, sans-serif;
      background-color: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
    #fps-counter {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      font-family: monospace;
      background-color: rgba(0,0,0,0.6);
      padding: 5px;
      border-radius: 3px;
      font-size: 12px;
    }
    #hud {
      position: absolute;
      top: 60px;
      left: 20px;
      color: white;
      font-family: 'Arial', sans-serif;
      font-size: 16px;
      text-shadow: 2px 2px 2px rgba(0,0,0,0.8);
    }
    .gem-counter {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .gem-icon {
      width: 30px;
      height: 30px;
      background-color: #f8f;
      border-radius: 3px;
      margin-right: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 10px #f0f;
    }

/* Special styling for the jump button */
#jump-btn {
  background-color: rgba(255, 100, 100, 0.6);
  font-size: 14px;
  font-weight: bold;
  color: white;
  pointer-events: auto;
  opacity: 1;
}

#jump-btn:active, #jump-btn.active {
  background-color: rgba(255, 50, 50, 0.8);
}
  </style>
</head>
<body>
 <div class="instructions">
  Left buttons: Move Panda<br>
  Right buttons: Rotate Camera<br>
  Center button: Jump
</div>

  <div id="fps-counter">FPS: 60</div>
  
  <div id="hud">
    <div class="gem-counter">
      <div class="gem-icon">♦</div>
      <span id="gem-count">0</span>
    </div>
  </div>
  
  <div id="controls">
    <div class="control-group">
      <div class="direction-pad">
        <button id="btn-nw" class="control-btn">↖</button>
        <button id="btn-n" class="control-btn">↑</button>
        <button id="btn-ne" class="control-btn">↗</button>
        <button id="btn-w" class="control-btn">←</button>
        <button id="btn-center" class="control-btn center">·</button>
        <button id="btn-e" class="control-btn">→</button>
        <button id="btn-sw" class="control-btn">↙</button>
        <button id="btn-s" class="control-btn">↓</button>
        <button id="btn-se" class="control-btn">↘</button>
      </div>
    </div>
    
    <div class="control-group">
<div class="camera-pad">
  <button id="cam-zoom-in" class="control-btn">+</button>
  <button id="cam-up" class="control-btn">↑</button>
  <button id="cam-empty1" class="control-btn center">·</button>
  <button id="cam-left" class="control-btn">←</button>
  <button id="jump-btn" class="control-btn">JUMP</button>
  <button id="cam-right" class="control-btn">→</button>
  <button id="cam-zoom-out" class="control-btn">-</button>
  <button id="cam-down" class="control-btn">↓</button>
  <button id="cam-empty3" class="control-btn center">·</button>
</div>
    </div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Enhanced PS2-Style 3D Game Setup
    // With improved textures, normal maps, and advanced effects
    
    // Set up renderer with PS2-era capabilities (better than PS1)
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    
    // Set up scene
    const scene = new THREE.Scene();
    
    // Set up camera with PS2-era field of view
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 8);
    camera.lookAt(0, 1, 0);
    
    // PS2-era enhanced lighting system
    // Ambient light
    const ambientLight = new THREE.AmbientLight(0x666666);
    scene.add(ambientLight);
    
    // Main directional light with shadows
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 30);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 10;
    directionalLight.shadow.camera.far = 200;
    directionalLight.shadow.camera.left = -50;
    directionalLight.shadow.camera.right = 50;
    directionalLight.shadow.camera.top = 50;
    directionalLight.shadow.camera.bottom = -50;
    scene.add(directionalLight);
    
    // Secondary fill light - PS2 games often used multiple lights
    const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
    fillLight.position.set(-30, 50, -30);
    scene.add(fillLight);
    
    // ===== TEXTURE CREATION UTILITIES =====
    
    // Create a procedural normal map using a canvas
    function createProceduralNormalMap(width = 256, height = 256, scale = 10) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      
      // First, create a height map
      ctx.fillStyle = '#808080';
      ctx.fillRect(0, 0, width, height);
      
      // Add random noise
      for (let i = 0; i < 10000; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const size = Math.random() * 3 + 1;
        const gray = 100 + Math.random() * 60;
        
        ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
        ctx.fillRect(x, y, size, size);
      }
      
      // Add larger structures
      for (let i = 0; i < 20; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const radius = 10 + Math.random() * 40;
        
        const isBump = Math.random() > 0.5;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        
        if (isBump) {
          gradient.addColorStop(0, 'rgb(240, 240, 240)');
          gradient.addColorStop(1, 'rgb(128, 128, 128)');
        } else {
          gradient.addColorStop(0, 'rgb(60, 60, 60)');
          gradient.addColorStop(1, 'rgb(128, 128, 128)');
        }
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Convert to normal map
      const imgData = ctx.getImageData(0, 0, width, height);
      const data = imgData.data;
      
      const normalData = ctx.createImageData(width, height);
      const normalPixels = normalData.data;
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = (y * width + x) * 4;
          const left = data[idx - 4] / 255;
          const right = data[idx + 4] / 255;
          const up = data[(y - 1) * width * 4 + x * 4] / 255;
          const down = data[(y + 1) * width * 4 + x * 4] / 255;
          
          const dX = (right - left) * scale;
          const dY = (down - up) * scale;
          
          const length = Math.sqrt(dX * dX + dY * dY + 1);
          const nx = -dX / length;
          const ny = -dY / length;
          const nz = 1 / length;
          
          normalPixels[idx] = Math.floor((nx * 0.5 + 0.5) * 255);
          normalPixels[idx + 1] = Math.floor((ny * 0.5 + 0.5) * 255);
          normalPixels[idx + 2] = Math.floor((nz * 0.5 + 0.5) * 255);
          normalPixels[idx + 3] = 255;
        }
      }
      
      ctx.putImageData(normalData, 0, 0);
      
      return new THREE.CanvasTexture(canvas);
    }
    
    // Create a grass texture with normal map
    function createGrassWithNormalMap() {
  // Color texture
  const colorCanvas = document.createElement('canvas');
  colorCanvas.width = 512;  // Increase resolution
  colorCanvas.height = 512;
  const colorCtx = colorCanvas.getContext('2d');
  
  // Create a more varied base pattern
  // First layer - dark base
  colorCtx.fillStyle = '#335522';
  colorCtx.fillRect(0, 0, 512, 512);
  
  // Second layer - patches of different green
  for (let i = 0; i < 30; i++) {
    const x = Math.random() * 512;
    const y = Math.random() * 512;
    const radius = 20 + Math.random() * 60;
    
    const gradient = colorCtx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, 'rgba(120, 180, 65, 0.7)');
    gradient.addColorStop(1, 'rgba(51, 85, 34, 0)');
    
    colorCtx.fillStyle = gradient;
    colorCtx.beginPath();
    colorCtx.arc(x, y, radius, 0, Math.PI * 2);
    colorCtx.fill();
  }
  
  // Add grass blades
  for (let i = 0; i < 10000; i++) {
    const x = Math.random() * 512;
    const y = Math.random() * 512;
    
    // Grass blade
    const length = 3 + Math.random() * 12;
    const width = 1 + Math.random() * 2;
    
    // Vary the green color
    const r = 40 + Math.random() * 40;
    const g = 100 + Math.random() * 80;
    const b = 20 + Math.random() * 50;
    
    colorCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    
    // Rotate to create random blade orientation
    colorCtx.save();
    colorCtx.translate(x, y);
    colorCtx.rotate(Math.random() * Math.PI * 2);
    colorCtx.fillRect(-width/2, -length/2, width, length);
    colorCtx.restore();
  }
  
  // Add some soil/dirt spots
  for (let i = 0; i < 50; i++) {
    const x = Math.random() * 512;
    const y = Math.random() * 512;
    const radius = 3 + Math.random() * 10;
    
    colorCtx.fillStyle = `rgb(${90 + Math.random() * 40}, ${70 + Math.random() * 30}, ${30 + Math.random() * 30})`;
    colorCtx.beginPath();
    colorCtx.arc(x, y, radius, 0, Math.PI * 2);
    colorCtx.fill();
  }
  
  // Create matching normal map with more detail
  const normalMap = createProceduralNormalMap(512, 512, 15);
  
  // Create textures
  const colorTexture = new THREE.CanvasTexture(colorCanvas);
  
  // Set texture properties
  colorTexture.wrapS = THREE.RepeatWrapping;
  colorTexture.wrapT = THREE.RepeatWrapping;
  colorTexture.repeat.set(100, 100);
  
  normalMap.wrapS = THREE.RepeatWrapping;
  normalMap.wrapT = THREE.RepeatWrapping;
  normalMap.repeat.set(100, 100);
  
  return {
    colorMap: colorTexture,
    normalMap: normalMap
  };
}
    
    // Create fur texture with normal map
    function createFurTextureWithNormal() {
      // Create base color texture for fur
      const colorCanvas = document.createElement('canvas');
      colorCanvas.width = 256;
      colorCanvas.height = 256;
      const colorCtx = colorCanvas.getContext('2d');
      
      // Base fur color
      colorCtx.fillStyle = '#ffffff';
      colorCtx.fillRect(0, 0, 256, 256);
      
      // Add fur strands
      for (let i = 0; i < 2000; i++) {
        const x = Math.random() * 256;
        const y = Math.random() * 256;
        const length = 2 + Math.random() * 8;
        const width = 1 + Math.random() * 1.5;
        const angle = Math.random() * Math.PI * 2;
        
        // Random gray for the fur strand
        const gray = 200 + Math.random() * 55;
        colorCtx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
        
        // Draw a small line representing a fur strand
        colorCtx.save();
        colorCtx.translate(x, y);
        colorCtx.rotate(angle);
        colorCtx.fillRect(-width/2, -length/2, width, length);
        colorCtx.restore();
      }
      
      // Create a matching normal map
      const normalCanvas = document.createElement('canvas');
      normalCanvas.width = 256;
      normalCanvas.height = 256;
      const normalCtx = normalCanvas.getContext('2d');
      
      // Initialize with flat normal
      normalCtx.fillStyle = '#8080ff';
      normalCtx.fillRect(0, 0, 256, 256);
      
      // Add normal details for each fur strand
      for (let i = 0; i < 2000; i++) {
        const x = Math.random() * 256;
        const y = Math.random() * 256;
        const length = 2 + Math.random() * 8;
        const width = 1 + Math.random() * 1.5;
        const angle = Math.random() * Math.PI * 2;
        
        // Calculate normal based on angle
        const xNormal = Math.floor(128 + Math.cos(angle) * 64);
        const yNormal = Math.floor(128 + Math.sin(angle) * 64);
        
        normalCtx.fillStyle = `rgb(${xNormal}, ${yNormal}, 255)`;
        
        // Draw the strand normal
        normalCtx.save();
        normalCtx.translate(x, y);
        normalCtx.rotate(angle);
        normalCtx.fillRect(-width/2, -length/2, width, length);
        normalCtx.restore();
      }
      
      // Create textures
      const colorTexture = new THREE.CanvasTexture(colorCanvas);
      const normalTexture = new THREE.CanvasTexture(normalCanvas);
      
      // Set texture properties
      colorTexture.wrapS = THREE.RepeatWrapping;
      colorTexture.wrapT = THREE.RepeatWrapping;
      normalTexture.wrapS = THREE.RepeatWrapping;
      normalTexture.wrapT = THREE.RepeatWrapping;
      
      return {
        colorMap: colorTexture,
        normalMap: normalTexture
      };
    }
    
    // Create a bamboo texture
    function createBambooTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 512;
      const context = canvas.getContext('2d');
      
      // Base bamboo color
      context.fillStyle = '#3a6324';
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw bamboo segments/rings
      for (let y = 0; y < canvas.height; y += 60) {
        // Darker ring
        context.fillStyle = '#2d4f1e';
        context.fillRect(0, y, canvas.width, 10);
        
        // Add some texture variation
        for (let i = 0; i < 100; i++) {
          const x = Math.random() * canvas.width;
          const yPos = y + Math.random() * 60;
          const size = Math.random() * 3 + 1;
          const alpha = Math.random() * 0.2 + 0.1;
          
          context.fillStyle = `rgba(45, 79, 30, ${alpha})`;
          context.fillRect(x, yPos, size, size);
        }
      }
      
      // Create vertical stripes typical of bamboo
      for (let x = 0; x < canvas.width; x += 20) {
        context.fillStyle = 'rgba(45, 79, 30, 0.2)';
        context.fillRect(x, 0, 2, canvas.height);
      }
      
      return new THREE.CanvasTexture(canvas);
    }
    

// Create a jungle floor texture
function createJungleFloorTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 512;
  const ctx = canvas.getContext('2d');
  
  // Dark soil base
  ctx.fillStyle = '#3a2a1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Medium soil patches
  for (let i = 0; i < 40; i++) {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const radius = 20 + Math.random() * 60;
    
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, 'rgba(80, 60, 40, 0.8)');
    gradient.addColorStop(1, 'rgba(58, 42, 26, 0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Add leaf litter and small details
  for (let i = 0; i < 2000; i++) {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const size = 2 + Math.random() * 5;
    
    // Random browns and greens for leaves
    const r = 40 + Math.random() * 80;
    const g = 30 + Math.random() * 70;
    const b = 10 + Math.random() * 30;
    
    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(Math.random() * Math.PI * 2);
    ctx.fillRect(-size/2, -size/2, size, size);
    ctx.restore();
  }
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(10, 10);
  
  return texture;
}

// Create a textured sky
function createTexturedSky() {
  // Create canvas for the sky texture
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext('2d');
  
  // Create gradient sky
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#1e90ff');  // Deep blue at top
  gradient.addColorStop(0.5, '#87ceeb');  // Sky blue in middle
  gradient.addColorStop(1, '#e0f7ff');   // Lighter at horizon
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Add some clouds
  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
  
  // Draw several clouds
  for (let i = 0; i < 15; i++) {
    const x = Math.random() * canvas.width;
    const y = canvas.height * 0.2 + Math.random() * canvas.height * 0.5;
    const size = 30 + Math.random() * 60;
    
    // Draw cloud puffs
    for (let j = 0; j < 6; j++) {
      const puffX = x + (Math.random() - 0.5) * size;
      const puffY = y + (Math.random() - 0.5) * size * 0.6;
      const puffSize = (0.5 + Math.random() * 0.5) * size * 0.5;
      
      ctx.beginPath();
      ctx.arc(puffX, puffY, puffSize, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // Create texture from canvas
  const skyTexture = new THREE.CanvasTexture(canvas);
  
  // Create a large sky sphere
  const skyGeometry = new THREE.SphereGeometry(800, 32, 16);
  
  // Create material with the texture inside
  const skyMaterial = new THREE.MeshBasicMaterial({
    map: skyTexture,
    side: THREE.BackSide
  });
  
  const sky = new THREE.Mesh(skyGeometry, skyMaterial);
  
  // Add a simple update function for sky rotation
  sky.update = function(time) {
    sky.rotation.y = time * 0.02; // Slowly rotate the sky
  };
  
  return sky;
}

  
  
    
    // Create PS2-style water
    function createPS2Water(size = 40, position = { x: 0, y: -0.3, z: 0 }) {
      // Water group to hold all elements
      const waterGroup = new THREE.Group();
      waterGroup.position.set(position.x, position.y, position.z);
      
      // Create the water plane
      const waterGeometry = new THREE.PlaneGeometry(size, size, 16, 16);
      
      // Create a canvas for the water texture
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Fill with base water color
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#4585b7');
      gradient.addColorStop(0.5, '#5d9dc9');
      gradient.addColorStop(1, '#4585b7');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Add wave patterns
      for (let i = 0; i < 10; i++) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 2 + Math.random() * 2;
        
        ctx.beginPath();
        let y = Math.random() * canvas.height;
        ctx.moveTo(0, y);
        
        // Create wavy line
        for (let x = 0; x < canvas.width; x += 20) {
          y += (Math.random() - 0.5) * 20;
          ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
      
      // Create a second canvas for normal map
      const normalCanvas = document.createElement('canvas');
      normalCanvas.width = 512;
      normalCanvas.height = 512;
      const normalCtx = normalCanvas.getContext('2d');
      
      // Fill with neutral normal color
      normalCtx.fillStyle = '#8080ff';
      normalCtx.fillRect(0, 0, normalCanvas.width, normalCanvas.height);
      
      // Add normal map details
      for (let y = 0; y < normalCanvas.height; y += 4) {
        for (let x = 0; x < normalCanvas.width; x += 4) {
          const nx = Math.floor(128 + Math.sin(x * 0.1) * Math.cos(y * 0.1) * 127);
          const ny = Math.floor(128 + Math.sin(y * 0.1) * Math.cos(x * 0.1) * 127);
          normalCtx.fillStyle = `rgb(${nx}, ${ny}, 255)`;
          normalCtx.fillRect(x, y, 4, 4);
        }
      }
      
      // Create textures
      const waterTexture = new THREE.CanvasTexture(canvas);
      waterTexture.wrapS = THREE.RepeatWrapping;
      waterTexture.wrapT = THREE.RepeatWrapping;
      waterTexture.repeat.set(5, 5);
      
      const waterNormal = new THREE.CanvasTexture(normalCanvas);
      waterNormal.wrapS = THREE.RepeatWrapping;
      waterNormal.wrapT = THREE.RepeatWrapping;
      waterNormal.repeat.set(5, 5);
      
      // Create material
      const waterMaterial = new THREE.MeshStandardMaterial({
        color: 0x4499cc,
        map: waterTexture,
        normalMap: waterNormal,
        transparent: true,
        opacity: 0.8,
        roughness: 0.2,
        metalness: 0.1
      });
      
      // Create water mesh
      const water = new THREE.Mesh(waterGeometry, waterMaterial);
      water.rotation.x = -Math.PI / 2;
      water.receiveShadow = true;
      
      waterGroup.add(water);
      
      // Create an updatable ripple position
      const ripplePositions = [];
      const rippleTimes = [];
      const MAX_RIPPLES = 8;
      
      // Add animated highlights (sparkles)
      const sparkleGeometry = new THREE.BufferGeometry();
      const sparkleCount = 100;
      
      const positions = new Float32Array(sparkleCount * 3);
      const scales = new Float32Array(sparkleCount);
      
      for (let i = 0; i < sparkleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * size;
        positions[i * 3 + 1] = 0.05;
        positions[i * 3 + 2] = (Math.random() - 0.5) * size;
        scales[i] = Math.random() * 0.5 + 0.5;
      }
      
      sparkleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      sparkleGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
      
      const sparkleMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.2,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });
      
      const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
      sparkles.position.y = 0.05;
      waterGroup.add(sparkles);
      
      // Animation function
      waterGroup.update = function(time) {
        // Update water texture offsets
        water.material.map.offset.x = Math.sin(time * 0.05) * 0.05;
        water.material.map.offset.y = time * 0.03;
        water.material.normalMap.offset.x = time * 0.03;
        water.material.normalMap.offset.y = time * 0.02;
        
        // Update vertices for wave motion
        const vertices = water.geometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
          const x = vertices[i];
          const z = vertices[i + 2];
          
          vertices[i + 1] = Math.sin(x * 0.5 + time) * 0.1 + 
                           Math.cos(z * 0.5 + time * 0.8) * 0.1;
          
          // Apply ripple effects
          for (let r = 0; r < ripplePositions.length; r++) {
            const ripplePos = ripplePositions[r];
            const rippleAge = time - rippleTimes[r];
            
            const dx = x - ripplePos.x;
            const dz = z - ripplePos.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            const speed = 3.0;
            const waveWidth = 1.0;
            const amplitude = Math.max(0, 0.2 - rippleAge * 0.1);
            
            const wavePos = dist - rippleAge * speed;
            if (Math.abs(wavePos) < waveWidth) {
              vertices[i + 1] += Math.cos(wavePos / waveWidth * Math.PI) * amplitude;
            }
          }
        }
        
        water.geometry.attributes.position.needsUpdate = true;
        
// Update sparkles
        const sparklePositions = sparkles.geometry.attributes.position.array;
        const sparkleScales = sparkles.geometry.attributes.scale.array;
        
        for (let i = 0; i < sparkleCount; i++) {
          // Make sparkles "flicker"
          const x = sparklePositions[i * 3];
          const z = sparklePositions[i * 3 + 2];
          
          sparkleScales[i] = (Math.sin(time * 2 + x) * 0.25 + 0.75) * 
                             (Math.cos(time * 1.5 + z) * 0.25 + 0.75);
          
          // Slowly move sparkles
          sparklePositions[i * 3] += Math.sin(time + i) * 0.005;
          sparklePositions[i * 3 + 2] += Math.cos(time * 0.8 + i) * 0.005;
          
          // Keep within bounds
          if (sparklePositions[i * 3] > size / 2) sparklePositions[i * 3] -= size;
          if (sparklePositions[i * 3] < -size / 2) sparklePositions[i * 3] += size;
          if (sparklePositions[i * 3 + 2] > size / 2) sparklePositions[i * 3 + 2] -= size;
          if (sparklePositions[i * 3 + 2] < -size / 2) sparklePositions[i * 3 + 2] += size;
        }
        
        sparkles.geometry.attributes.position.needsUpdate = true;
        sparkles.geometry.attributes.scale.needsUpdate = true;
      };
      
      // Function to add a ripple
      waterGroup.addRipple = function(position) {
        // Convert position to water-local coordinates
        const waterPos = {
          x: position.x - this.position.x,
          z: position.z - this.position.z
        };
        
        // Limit number of ripples
        if (ripplePositions.length >= MAX_RIPPLES) {
          ripplePositions.shift();
          rippleTimes.shift();
        }
        
        ripplePositions.push(waterPos);
        rippleTimes.push(performance.now() * 0.001);
      };
      
      return waterGroup;
    }
    
    // Create enhanced particle system
    function createEnhancedParticleSystem() {
      // Main particle container
      const particleSystem = new THREE.Group();
      
      // Create dust effect (footsteps, landing)
      function createDustEffect() {
        const geometry = new THREE.BufferGeometry();
        const particleCount = 100;
        
        const positions = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const lifetimes = new Float32Array(particleCount);
        const velocities = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] = 0;
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = 0;
          sizes[i] = 0;
          lifetimes[i] = 0;
          velocities[i * 3] = 0;
          velocities[i * 3 + 1] = 0;
          velocities[i * 3 + 2] = 0;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        // Create dust texture
        const dustCanvas = document.createElement('canvas');
        dustCanvas.width = 128;
        dustCanvas.height = 128;
        const ctx = dustCanvas.getContext('2d');
        
        // Draw a soft dust particle
        const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 128, 128);
        
        const dustTexture = new THREE.CanvasTexture(dustCanvas);
        
        const material = new THREE.PointsMaterial({
          color: 0xeedddd,
          size: 0.15,
          map: dustTexture,
          transparent: true,
          opacity: 0.6,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(geometry, material);
        
        particles.userData = {
          lifetimes: lifetimes,
          velocities: velocities,
          activeParticles: 0
        };
        
        // Spawn function
        particles.spawn = function(position, count) {
          const positionArray = this.geometry.attributes.position.array;
          const sizeArray = this.geometry.attributes.size.array;
          const lifetimeArray = this.userData.lifetimes;
          const velocityArray = this.userData.velocities;
          
          let spawned = 0;
          for (let i = 0; i < particleCount && spawned < count; i++) {
            if (lifetimeArray[i] <= 0) {
              positionArray[i * 3] = position.x + (Math.random() - 0.5) * 0.5;
              positionArray[i * 3 + 1] = position.y + Math.random() * 0.1;
              positionArray[i * 3 + 2] = position.z + (Math.random() - 0.5) * 0.5;
              
              velocityArray[i * 3] = (Math.random() - 0.5) * 0.8;
              velocityArray[i * 3 + 1] = Math.random() * 1.5 + 0.5;
              velocityArray[i * 3 + 2] = (Math.random() - 0.5) * 0.8;
              
              sizeArray[i] = 0.05 + Math.random() * 0.1;
              
              lifetimeArray[i] = 0.5 + Math.random() * 0.5;
              
              spawned++;
              this.userData.activeParticles++;
            }
          }
          
          this.geometry.attributes.position.needsUpdate = true;
          this.geometry.attributes.size.needsUpdate = true;
        };
        
        // Update function
        particles.update = function(delta) {
          if (this.userData.activeParticles <= 0) return;
          
          const positionArray = this.geometry.attributes.position.array;
          const sizeArray = this.geometry.attributes.size.array;
          const lifetimeArray = this.userData.lifetimes;
          const velocityArray = this.userData.velocities;
          
          let activeCount = 0;
          
          for (let i = 0; i < particleCount; i++) {
            if (lifetimeArray[i] <= 0) continue;
            
            lifetimeArray[i] -= delta;
            
            if (lifetimeArray[i] > 0) {
              positionArray[i * 3] += velocityArray[i * 3] * delta;
              positionArray[i * 3 + 1] += velocityArray[i * 3 + 1] * delta;
              positionArray[i * 3 + 2] += velocityArray[i * 3 + 2] * delta;
              
              velocityArray[i * 3] *= 0.95;
              velocityArray[i * 3 + 1] -= 0.8 * delta;
              velocityArray[i * 3 + 2] *= 0.95;
              
              const lifeRatio = lifetimeArray[i] / (0.5 + Math.random() * 0.5);
              sizeArray[i] = 0.05 + Math.random() * 0.1 * lifeRatio;
              
              activeCount++;
            } else {
              sizeArray[i] = 0;
            }
          }
          
          this.userData.activeParticles = activeCount;
          
          this.geometry.attributes.position.needsUpdate = true;
          this.geometry.attributes.size.needsUpdate = true;
        };
        
        return particles;
      }
      
      // Create sparkle effect for collectibles
      function createSparkleEffect() {
        const geometry = new THREE.BufferGeometry();
        const particleCount = 50;
        
        const positions = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const colors = new Float32Array(particleCount * 3);
        const lifetimes = new Float32Array(particleCount);
        const velocities = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] = 0;
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = 0;
          sizes[i] = 0;
          lifetimes[i] = 0;
          colors[i * 3] = 1;
          colors[i * 3 + 1] = 1;
          colors[i * 3 + 2] = 1;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        // Create sparkle texture
        const sparkleCanvas = document.createElement('canvas');
        sparkleCanvas.width = 128;
        sparkleCanvas.height = 128;
        const ctx = sparkleCanvas.getContext('2d');
        
        // Draw a star shape
        ctx.fillStyle = 'white';
        ctx.beginPath();
        
        const centerX = 64;
        const centerY = 64;
        const outerRadius = 64;
        const innerRadius = 16;
        
        for (let i = 0; i < 8; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = i * Math.PI / 4;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.closePath();
        ctx.fill();
        
        const sparkleTexture = new THREE.CanvasTexture(sparkleCanvas);
        
        const material = new THREE.PointsMaterial({
          size: 0.2,
          map: sparkleTexture,
          transparent: true,
          opacity: 0.8,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexColors: true
        });
        
        const particles = new THREE.Points(geometry, material);
        
        particles.userData = {
          lifetimes: lifetimes,
          velocities: velocities,
          activeParticles: 0
        };
        
        // Spawn function
        particles.spawn = function(position, count) {
          const positionArray = this.geometry.attributes.position.array;
          const sizeArray = this.geometry.attributes.size.array;
          const colorArray = this.geometry.attributes.color.array;
          const lifetimeArray = this.userData.lifetimes;
          const velocityArray = this.userData.velocities;
          
          let spawned = 0;
          for (let i = 0; i < particleCount && spawned < count; i++) {
            if (lifetimeArray[i] <= 0) {
              positionArray[i * 3] = position.x + (Math.random() - 0.5) * 0.3;
              positionArray[i * 3 + 1] = position.y + (Math.random() - 0.5) * 0.3;
              positionArray[i * 3 + 2] = position.z + (Math.random() - 0.5) * 0.3;
              
              const angle = Math.random() * Math.PI * 2;
              const speed = 0.5 + Math.random() * 2;
              velocityArray[i * 3] = Math.cos(angle) * speed;
              velocityArray[i * 3 + 1] = Math.sin(angle) * speed;
              velocityArray[i * 3 + 2] = (Math.random() - 0.5) * speed;
              
              sizeArray[i] = 0.1 + Math.random() * 0.2;
              
              colorArray[i * 3] = Math.random() * 0.5 + 0.5;
              colorArray[i * 3 + 1] = Math.random() * 0.5 + 0.5;
              colorArray[i * 3 + 2] = Math.random() * 0.5 + 0.5;
              
              lifetimeArray[i] = 0.5 + Math.random() * 1.0;
              
              spawned++;
              this.userData.activeParticles++;
            }
          }
          
          this.geometry.attributes.position.needsUpdate = true;
          this.geometry.attributes.size.needsUpdate = true;
          this.geometry.attributes.color.needsUpdate = true;
        };
        
        // Update function
        particles.update = function(delta) {
          if (this.userData.activeParticles <= 0) return;
          
          const positionArray = this.geometry.attributes.position.array;
          const sizeArray = this.geometry.attributes.size.array;
          const colorArray = this.geometry.attributes.color.array;
          const lifetimeArray = this.userData.lifetimes;
          const velocityArray = this.userData.velocities;
          
          let activeCount = 0;
          
          for (let i = 0; i < particleCount; i++) {
            if (lifetimeArray[i] <= 0) continue;
            
            lifetimeArray[i] -= delta;
            
            if (lifetimeArray[i] > 0) {
              positionArray[i * 3] += velocityArray[i * 3] * delta;
              positionArray[i * 3 + 1] += velocityArray[i * 3 + 1] * delta;
              positionArray[i * 3 + 2] += velocityArray[i * 3 + 2] * delta;
              
              velocityArray[i * 3] *= 0.9;
              velocityArray[i * 3 + 1] *= 0.9;
              velocityArray[i * 3 + 2] *= 0.9;
              
              sizeArray[i] *= 0.99;
              
              colorArray[i * 3] = Math.min(1.0, colorArray[i * 3] + delta * 0.2);
              colorArray[i * 3 + 1] = Math.min(1.0, colorArray[i * 3 + 1] + delta * 0.2);
              colorArray[i * 3 + 2] = Math.min(1.0, colorArray[i * 3 + 2] + delta * 0.2);
              
              activeCount++;
            } else {
              sizeArray[i] = 0;
            }
          }
          
          this.userData.activeParticles = activeCount;
          
          this.geometry.attributes.position.needsUpdate = true;
          this.geometry.attributes.size.needsUpdate = true;
          this.geometry.attributes.color.needsUpdate = true;
        };
        
        return particles;
      }
      
      // Create different particle effect types
      const effectTypes = {
        dust: createDustEffect(),
        sparkle: createSparkleEffect()
      };
      
      // Add all effects to the particle system
      for (const [name, effect] of Object.entries(effectTypes)) {
        particleSystem.add(effect);
        particleSystem[name] = effect;
      }
      
      // Main update function
      particleSystem.update = function(delta) {
        for (const effect of Object.values(effectTypes)) {
          if (effect.update) {
            effect.update(delta);
          }
        }
      };
      
      // Spawn particles at position
      particleSystem.spawn = function(position, count, type) {
        if (effectTypes[type]) {
          effectTypes[type].spawn(position, count);
        }
      };
      
      return particleSystem;
    }
    
    // 
    // ===== Setup Scene Elements =====
    
    // Create sky
    // Create textured sky (replace the existing sky creation)
const sky = createTexturedSky();
scene.add(sky);

// Create jungle floor
const floorTexture = createJungleFloorTexture();
const floorGeometry = new THREE.PlaneGeometry(100, 100);
const floorMaterial = new THREE.MeshStandardMaterial({
  map: floorTexture,
  roughness: 0.9,
  metalness: 0.1
});
const floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = -Math.PI / 2;  // Rotate to be horizontal
floor.position.y = -0.6;  // Lower the floor
floor.receiveShadow = true;
scene.add(floor);

    
    // Create water
    const water = createPS2Water(40, { x: 20, y: -0.3, z: 20 });
    scene.add(water);
    
    // Create particle system
    const particleSystem = createEnhancedParticleSystem();
    scene.add(particleSystem);
    
    // ===== Create PS2-Style Panda Character =====
    function createPS2Panda() {
      const panda = new THREE.Group();
      
      // Get fur textures
      const furTextures = createFurTextureWithNormal();
      
      // Higher quality materials with textures
      const whiteMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        map: furTextures.colorMap,
        normalMap: furTextures.normalMap,
        normalScale: new THREE.Vector2(0.5, 0.5),
        roughness: 0.7,
        metalness: 0.1
      });
      
      const blackMaterial = new THREE.MeshStandardMaterial({
        color: 0x222222,
        map: furTextures.colorMap,
        normalMap: furTextures.normalMap,
        normalScale: new THREE.Vector2(0.5, 0.5),
        roughness: 0.7,
        metalness: 0.1
      });
      
      const blueMaterial = new THREE.MeshStandardMaterial({
        color: 0x3355ff,
        roughness: 0.6,
        metalness: 0.2
      });
      
      const redMaterial = new THREE.MeshStandardMaterial({
        color: 0xff3333,
        roughness: 0.5,
        metalness: 0.3
      });
      
      // Character components with higher polygon counts
      
      // ----- HEAD (200+ polygons with subdivisions) -----
      const headGeometry = new THREE.SphereGeometry(0.6, 12, 10);
      const head = new THREE.Mesh(headGeometry, whiteMaterial);
      head.position.y = 1.6;
      head.castShadow = true;
      panda.add(head);
      
      // ----- FACE DETAILS -----
      // Muzzle - higher poly for PS2
      const muzzleGeometry = new THREE.SphereGeometry(0.45, 10, 8);
      const muzzle = new THREE.Mesh(muzzleGeometry, whiteMaterial);
      muzzle.position.set(0, 1.45, 0.4);
      muzzle.scale.set(0.85, 0.75, 0.8);
      muzzle.castShadow = true;
      panda.add(muzzle);
      
      // Eyes with PS2-quality details
      const eyePatchGeometry = new THREE.SphereGeometry(0.32, 10, 8);
      
      const leftEyePatch = new THREE.Mesh(eyePatchGeometry, blackMaterial);
      leftEyePatch.position.set(0.29, 1.65, 0.45);
      leftEyePatch.scale.set(1, 1, 0.7);
      leftEyePatch.castShadow = true;
      panda.add(leftEyePatch);
      
      const rightEyePatch = new THREE.Mesh(eyePatchGeometry.clone(), blackMaterial);
      rightEyePatch.position.set(-0.29, 1.65, 0.45);
      rightEyePatch.scale.set(1, 1, 0.7);
      rightEyePatch.castShadow = true;
      panda.add(rightEyePatch);
      
      // Eye whites
      const eyeGeometry = new THREE.SphereGeometry(0.14, 10, 8);
      
      const leftEye = new THREE.Mesh(eyeGeometry, whiteMaterial);
      leftEye.position.set(0.31, 1.65, 0.57);
      panda.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeometry.clone(), whiteMaterial);
      rightEye.position.set(-0.31, 1.65, 0.57);
      panda.add(rightEye);
      
      // Pupils
      const pupilGeometry = new THREE.SphereGeometry(0.06, 8, 8);
      
      const leftPupil = new THREE.Mesh(pupilGeometry, blackMaterial);
      leftPupil.position.set(0.32, 1.66, 0.67);
      panda.add(leftPupil);
      
      const rightPupil = new THREE.Mesh(pupilGeometry.clone(), blackMaterial);
      rightPupil.position.set(-0.32, 1.66, 0.67);
      panda.add(rightPupil);
      
      // Nose detail
      const noseGeometry = new THREE.SphereGeometry(0.15, 8, 6);
      const nose = new THREE.Mesh(noseGeometry, blackMaterial);
      nose.position.set(0, 1.36, 0.78);
      nose.scale.set(0.7, 0.5, 0.5);
      nose.castShadow = true;
      panda.add(nose);
      
      // Mouth line
      const mouthGeometry = new THREE.TorusGeometry(0.14, 0.02, 10, 12, Math.PI);
      const mouth = new THREE.Mesh(mouthGeometry, blackMaterial);
      mouth.position.set(0, 1.25, 0.7);
      mouth.rotation.x = -Math.PI / 2;
      mouth.rotation.z = Math.PI;
      panda.add(mouth);
      
      // ----- EARS -----
      const earGeometry = new THREE.SphereGeometry(0.25, 10, 6);
      
      const leftEar = new THREE.Mesh(earGeometry, blackMaterial);
      leftEar.position.set(0.45, 2.0, 0);
      leftEar.scale.set(1, 1.2, 0.6);
      leftEar.castShadow = true;
      panda.add(leftEar);
      
      const rightEar = new THREE.Mesh(earGeometry.clone(), blackMaterial);
      rightEar.position.set(-0.45, 2.0, 0);
      rightEar.scale.set(1, 1.2, 0.6);
      rightEar.castShadow = true;
      panda.add(rightEar);
      
      // Inner ears
      const innerEarGeometry = new THREE.SphereGeometry(0.15, 8, 6);
      
      const leftInnerEar = new THREE.Mesh(innerEarGeometry, redMaterial);
      leftInnerEar.position.set(0.45, 2.0, 0.05);
      leftInnerEar.scale.set(0.7, 0.7, 0.3);
      panda.add(leftInnerEar);
      
      const rightInnerEar = new THREE.Mesh(innerEarGeometry.clone(), redMaterial);
      rightInnerEar.position.set(-0.45, 2.0, 0.05);
      rightInnerEar.scale.set(0.7, 0.7, 0.3);
      panda.add(rightInnerEar);
      
 // ----- BODY -----
// Use a more organic body shape
const torsoUpperGeometry = new THREE.SphereGeometry(0.42, 12, 10);
const torsoUpper = new THREE.Mesh(torsoUpperGeometry, whiteMaterial);
torsoUpper.position.y = 1.15;
torsoUpper.scale.set(1, 0.8, 0.9);
torsoUpper.castShadow = true;
panda.add(torsoUpper);

const torsoLowerGeometry = new THREE.SphereGeometry(0.45, 12, 10);
const torsoLower = new THREE.Mesh(torsoLowerGeometry, whiteMaterial);
torsoLower.position.y = 0.7;
torsoLower.scale.set(1, 0.9, 0.85);
torsoLower.castShadow = true;
panda.add(torsoLower);

// Add a belly
const bellyGeometry = new THREE.SphereGeometry(0.35, 10, 8);
const belly = new THREE.Mesh(bellyGeometry, whiteMaterial);
belly.position.set(0, 0.85, 0.2);
belly.scale.set(0.9, 0.8, 0.6);
belly.castShadow = true;
panda.add(belly);

// Reference to use in animations
const torso = new THREE.Group();
torso.position.y = 0.85;
panda.add(torso);
      
      // Black back patch
      const backPatchGeometry = new THREE.SphereGeometry(0.4, 10, 8);
      const backPatch = new THREE.Mesh(backPatchGeometry, blackMaterial);
      backPatch.position.set(0, 0.9, -0.15);
      backPatch.scale.set(0.8, 0.8, 0.3);
      backPatch.castShadow = true;
      panda.add(backPatch);
      
 // ----- ARMS -----
// Create more organic, less tube-like arms
// Upper arms with shoulder joints
const shoulderGeometry = new THREE.SphereGeometry(0.15, 10, 8);

const leftShoulder = new THREE.Mesh(shoulderGeometry, blackMaterial);
leftShoulder.position.set(0.42, 1.25, 0);
leftShoulder.castShadow = true;
panda.add(leftShoulder);

const rightShoulder = new THREE.Mesh(shoulderGeometry.clone(), blackMaterial);
rightShoulder.position.set(-0.42, 1.25, 0);
rightShoulder.castShadow = true;
panda.add(rightShoulder);

// More tapered upper arms
const upperArmGeometry = new THREE.SphereGeometry(0.12, 10, 8);

const leftUpperArm = new THREE.Mesh(upperArmGeometry, blackMaterial);
leftUpperArm.position.set(0.55, 1.15, 0.05);
leftUpperArm.scale.set(0.9, 1.2, 0.9);
leftUpperArm.rotation.z = -0.3;
leftUpperArm.castShadow = true;
panda.add(leftUpperArm);

const rightUpperArm = new THREE.Mesh(upperArmGeometry.clone(), blackMaterial);
rightUpperArm.position.set(-0.55, 1.15, 0.05);
rightUpperArm.scale.set(0.9, 1.2, 0.9);
rightUpperArm.rotation.z = 0.3;
rightUpperArm.castShadow = true;
panda.add(rightUpperArm);

// Elbow joints
const elbowGeometry = new THREE.SphereGeometry(0.11, 8, 6);

const leftElbow = new THREE.Mesh(elbowGeometry, blackMaterial);
leftElbow.position.set(0.65, 1.0, 0.08);
leftElbow.castShadow = true;
panda.add(leftElbow);

const rightElbow = new THREE.Mesh(elbowGeometry.clone(), blackMaterial);
rightElbow.position.set(-0.65, 1.0, 0.08);
rightElbow.castShadow = true;
panda.add(rightElbow);

// Lower arms - slightly tapered
const lowerArmGeometry = new THREE.SphereGeometry(0.1, 10, 8);

const leftLowerArm = new THREE.Mesh(lowerArmGeometry, blackMaterial);
leftLowerArm.position.set(0.75, 0.92, 0.1);
leftLowerArm.scale.set(0.85, 1.1, 0.85);
leftLowerArm.rotation.z = -0.5;
leftLowerArm.castShadow = true;
panda.add(leftLowerArm);

const rightLowerArm = new THREE.Mesh(lowerArmGeometry.clone(), blackMaterial);
rightLowerArm.position.set(-0.75, 0.92, 0.1);
rightLowerArm.scale.set(0.85, 1.1, 0.85);
rightLowerArm.rotation.z = 0.5;
rightLowerArm.castShadow = true;
panda.add(rightLowerArm);

// More detailed hands with wrist
const wristGeometry = new THREE.SphereGeometry(0.1, 8, 6);
const handGeometry = new THREE.SphereGeometry(0.13, 10, 8);

// Left wrist and hand
const leftWrist = new THREE.Mesh(wristGeometry, blackMaterial);
leftWrist.position.set(0.82, 0.85, 0.12);
leftWrist.castShadow = true;
panda.add(leftWrist);

const leftHand = new THREE.Mesh(handGeometry, blackMaterial);
leftHand.position.set(0.9, 0.82, 0.15);
leftHand.scale.set(1.1, 0.7, 0.85);
leftHand.rotation.z = -0.2;
leftHand.castShadow = true;
panda.add(leftHand);

// Right wrist and hand
const rightWrist = new THREE.Mesh(wristGeometry.clone(), blackMaterial);
rightWrist.position.set(-0.82, 0.85, 0.12);
rightWrist.castShadow = true;
panda.add(rightWrist);

const rightHand = new THREE.Mesh(handGeometry.clone(), blackMaterial);
rightHand.position.set(-0.9, 0.82, 0.15);
rightHand.scale.set(1.1, 0.7, 0.85);
rightHand.rotation.z = 0.2;
rightHand.castShadow = true;
panda.add(rightHand);
      
      // ----- LEGS -----
      // Hips
      const hipsGeometry = new THREE.BoxGeometry(0.6, 0.2, 0.5, 3, 2, 3);
      const hips = new THREE.Mesh(hipsGeometry, whiteMaterial);
      hips.position.y = 0.35;
      hips.castShadow = true;
      panda.add(hips);
      
// Upper legs
      const upperLegGeometry = new THREE.CylinderGeometry(0.15, 0.14, 0.5, 10, 3);
      
      const leftUpperLeg = new THREE.Mesh(upperLegGeometry, blackMaterial);
      leftUpperLeg.position.set(0.2, 0.1, 0);
      leftUpperLeg.castShadow = true;
      panda.add(leftUpperLeg);
      
      const rightUpperLeg = new THREE.Mesh(upperLegGeometry.clone(), blackMaterial);
      rightUpperLeg.position.set(-0.2, 0.1, 0);
      rightUpperLeg.castShadow = true;
      panda.add(rightUpperLeg);
      
      // Lower legs
      const lowerLegGeometry = new THREE.CylinderGeometry(0.13, 0.15, 0.5, 10, 3);
      
      const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, blackMaterial);
      leftLowerLeg.position.set(0.2, -0.3, 0);
      leftLowerLeg.castShadow = true;
      panda.add(leftLowerLeg);
      
      const rightLowerLeg = new THREE.Mesh(lowerLegGeometry.clone(), blackMaterial);
      rightLowerLeg.position.set(-0.2, -0.3, 0);
      rightLowerLeg.castShadow = true;
      panda.add(rightLowerLeg);
      
      // Feet
      const footGeometry = new THREE.SphereGeometry(0.15, 10, 8);
      
      const leftFoot = new THREE.Mesh(footGeometry, redMaterial);
      leftFoot.position.set(0.2, -0.6, 0.1);
      leftFoot.scale.set(1.3, 0.6, 1.6);
      leftFoot.castShadow = true;
      panda.add(leftFoot);
      
      const rightFoot = new THREE.Mesh(footGeometry.clone(), redMaterial);
      rightFoot.position.set(-0.2, -0.6, 0.1);
      rightFoot.scale.set(1.3, 0.6, 1.6);
      rightFoot.castShadow = true;
      panda.add(rightFoot);
      
      // ----- TAIL -----
      const tailBaseGeometry = new THREE.SphereGeometry(0.15, 10, 8);
      const tailBase = new THREE.Mesh(tailBaseGeometry, blackMaterial);
      tailBase.position.set(0, 0.5, -0.5);
      tailBase.castShadow = true;
      panda.add(tailBase);
      
      const tailMidGeometry = new THREE.SphereGeometry(0.12, 8, 6);
      const tailMid = new THREE.Mesh(tailMidGeometry, blackMaterial);
      tailMid.position.set(0, 0.55, -0.7);
      tailMid.castShadow = true;
      panda.add(tailMid);
      
      const tailTipGeometry = new THREE.SphereGeometry(0.08, 8, 6);
      const tailTip = new THREE.Mesh(tailTipGeometry, blackMaterial);
      tailTip.position.set(0, 0.6, -0.85);
      tailTip.castShadow = true;
      panda.add(tailTip);
      
      // ----- ACCESSORIES -----
      // Backpack
      const backpackGeometry = new THREE.BoxGeometry(0.6, 0.7, 0.3, 4, 4, 2);
      const backpack = new THREE.Mesh(backpackGeometry, blueMaterial);
      backpack.position.set(0, 0.9, -0.35);
      backpack.castShadow = true;
      panda.add(backpack);
      
      // Backpack strap
      const backpackStrapGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.8, 3, 1, 3);
      const backpackStrap = new THREE.Mesh(backpackStrapGeometry, blueMaterial);
      backpackStrap.position.set(0, 1.3, 0.05);
      backpackStrap.rotation.x = Math.PI / 8;
      backpackStrap.castShadow = true;
      panda.add(backpackStrap);
      
      // Backpack details
      const backpackDetailGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.05, 2, 2, 1);
      const backpackDetail = new THREE.Mesh(backpackDetailGeometry, redMaterial);
      backpackDetail.position.set(0, 0.95, -0.18);
      backpackDetail.castShadow = true;
      panda.add(backpackDetail);
      
      // Sunglasses on head
      const sunglassFrameGeometry = new THREE.BoxGeometry(0.6, 0.12, 0.05, 3, 2, 1);
      const sunglassFrame = new THREE.Mesh(sunglassFrameGeometry, redMaterial);
      sunglassFrame.position.set(0, 2.0, 0.4);
      sunglassFrame.rotation.x = 0.4;
      sunglassFrame.scale.set(1.1, 1.2, 1);
      sunglassFrame.castShadow = true;
      panda.add(sunglassFrame);
      
      // Sunglass lenses
      const lensGeometry = new THREE.CylinderGeometry(0.13, 0.13, 0.03, 12, 1);
      
      const leftLens = new THREE.Mesh(lensGeometry, blackMaterial);
      leftLens.position.set(0.20, 2.0, 0.42);
      leftLens.rotation.x = 0.4;
      panda.add(leftLens);
      
      const rightLens = new THREE.Mesh(lensGeometry.clone(), blackMaterial);
      rightLens.position.set(-0.20, 2.0, 0.42);
      rightLens.rotation.x = 0.4;
      panda.add(rightLens);
      
   // Store references for animations
panda.head = head;
panda.muzzle = muzzle;
panda.leftEyePatch = leftEyePatch;
panda.rightEyePatch = rightEyePatch;
panda.leftEye = leftEye;
panda.rightEye = rightEye;
panda.leftPupil = leftPupil;
panda.rightPupil = rightPupil;
panda.mouth = mouth;
panda.leftEar = leftEar;
panda.rightEar = rightEar;

// New body structure
panda.torso = torso;
panda.torsoUpper = torsoUpper;
panda.torsoLower = torsoLower;
panda.belly = belly;

// New arm structure
panda.leftShoulder = leftShoulder;
panda.rightShoulder = rightShoulder;
panda.leftUpperArm = leftUpperArm;
panda.rightUpperArm = rightUpperArm;
panda.leftElbow = leftElbow;
panda.rightElbow = rightElbow;
panda.leftLowerArm = leftLowerArm;
panda.rightLowerArm = rightLowerArm;
panda.leftWrist = leftWrist;
panda.rightWrist = rightWrist;
panda.leftHand = leftHand;
panda.rightHand = rightHand;

// Legs
panda.hips = hips;
panda.leftUpperLeg = leftUpperLeg;
panda.rightUpperLeg = rightUpperLeg;
panda.leftLowerLeg = leftLowerLeg;
panda.rightLowerLeg = rightLowerLeg;
panda.leftFoot = leftFoot;
panda.rightFoot = rightFoot;

// Tail and accessories
panda.tailBase = tailBase;
panda.tailMid = tailMid;
panda.tailTip = tailTip;
panda.backpack = backpack;
panda.sunglassFrame = sunglassFrame;

      // Initialize animation state management
      panda.animationState = {
        isWalking: false,
        isJumping: false,
        isInAir: false,
        jumpVelocity: 0,
        groundY: 0,
        blink: {
          timer: 0,
          interval: 4 + Math.random() * 3,
          duration: 0.15
        }
      };
      
      return panda;
    }
    
    // Create bamboo with textures
    function createBamboo(x, z) {
      const bambooGroup = new THREE.Group();
      
      const height = 3 + Math.random() * 4;
      const segments = Math.floor(height * 2);
      
      // Create the bamboo texture
      const bambooTexture = createBambooTexture();
      bambooTexture.wrapS = THREE.RepeatWrapping;
      bambooTexture.wrapT = THREE.RepeatWrapping;
      bambooTexture.repeat.set(1, segments/2);
      
      // Materials with texture
      const materialA = new THREE.MeshStandardMaterial({ 
        map: bambooTexture,
        color: 0x2d4f1e,
        roughness: 0.8,
        metalness: 0.1
      });
      
      const materialB = new THREE.MeshStandardMaterial({ 
        map: bambooTexture,
        color: 0x3a6324,
        roughness: 0.8,
        metalness: 0.1
      });
      
      for (let i = 0; i < segments; i++) {
        const segHeight = height / segments;
        const y = i * segHeight;
        const radius = 0.2 - (i * 0.01);
        
        const geometry = new THREE.CylinderGeometry(
          radius,
          radius - 0.01,
          segHeight,
          8,
          1
        );
        
        const material = i % 2 === 0 ? materialA : materialB;
        const segment = new THREE.Mesh(geometry, material);
        segment.position.y = y + segHeight/2;
        segment.castShadow = true;
        
        bambooGroup.add(segment);
      }
      
      // PS2 era leaf details
      for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
        const leafGeometry = new THREE.PlaneGeometry(0.7, 0.3, 3, 2);
        const leafMaterial = new THREE.MeshStandardMaterial({
          color: 0x44aa44,
          roughness: 0.8,
          metalness: 0.1,
          side: THREE.DoubleSide
        });
        
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
        
        const segment = Math.floor(segments * 0.7) + i;
        const yPos = (segment * height / segments);
        leaf.position.set(
          (Math.random() - 0.5) * 0.4,
          yPos,
          (Math.random() - 0.5) * 0.4
        );
        
        leaf.rotation.x = Math.random() * Math.PI;
        leaf.rotation.y = Math.random() * Math.PI * 2;
        leaf.rotation.z = Math.random() * Math.PI / 4;
        
        leaf.castShadow = true;
        bambooGroup.add(leaf);
      }
      
      bambooGroup.position.set(x, 0, z);
      return bambooGroup;
    }
    
    // PS2-quality gems with textures
    function createGem(x, y, z) {
      const gemGroup = new THREE.Group();
      
      const gemGeometry = new THREE.OctahedronGeometry(0.3, 2);
      const gemMaterial = new THREE.MeshStandardMaterial({
        color: 0xff44ff,
        roughness: 0.2,
        metalness: 0.7,
        emissive: 0x550055,
        emissiveIntensity: 0.5
      });
      
      const gem = new THREE.Mesh(gemGeometry, gemMaterial);
      gem.castShadow = true;
      gemGroup.add(gem);
      
      // Particle system for gem sparkle
      const sparkleGeometry = new THREE.BufferGeometry();
      const sparkleCount = 5;
      const positionArray = new Float32Array(sparkleCount * 3);
      const sizeArray = new Float32Array(sparkleCount);
      
      for (let i = 0; i < sparkleCount; i++) {
        positionArray[i * 3] = (Math.random() - 0.5) * 0.5;
        positionArray[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
        positionArray[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
        
        sizeArray[i] = 0.05 + Math.random() * 0.05;
      }
      
      sparkleGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
      sparkleGeometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));
      
      const sparkleMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.1,
        sizeAttenuation: true,
        transparent: true,
        blending: THREE.AdditiveBlending
      });
      
      const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
      gemGroup.add(sparkles);
      
      // Add animation
      gemGroup.update = function(time) {
        gem.rotation.y = time * 1.5;
        gem.rotation.z = time * 0.7;
        gem.position.y = Math.sin(time * 3) * 0.1 + 0.2;
        
        for (let i = 0; i < sparkleCount; i++) {
          const offset = i * 0.5;
          const scale = Math.sin(time * 5 + offset) * 0.5 + 0.5;
          sparkleGeometry.attributes.size.array[i] = 0.05 + 0.05 * scale;
        }
        sparkleGeometry.attributes.size.needsUpdate = true;
      };
      
      gemGroup.position.set(x, y, z);
      return gemGroup;
    }
    
    // Add bamboo to the scene
    const bamboos = [];
    for (let i = 0; i < 30; i++) {
      const distance = 5 + Math.random() * 20;
      const angle = Math.random() * Math.PI * 2;
      const x = Math.sin(angle) * distance;
      const z = Math.cos(angle) * distance;
      const bamboo = createBamboo(x, z);
      scene.add(bamboo);
      bamboos.push(bamboo);
    }
    
    // Add PS2-quality collectible gems
    const gems = [];
    for (let i = 0; i < 10; i++) {
      const distance = 3 + Math.random() * 15;
      const angle = Math.random() * Math.PI * 2;
      const x = Math.sin(angle) * distance;
      const z = Math.cos(angle) * distance;
      const gem = createGem(x, 0.8, z);
      scene.add(gem);
      gems.push(gem);
    }
    
    // Create the panda
    const panda = createPS2Panda();
    scene.add(panda);
    
    // Control state for player input
    const controls = {};
    
    function setupTouchControls() {
      const buttons = {
        'btn-n': 'moveForward',
        'btn-s': 'moveBackward',
        'btn-w': 'moveRight',
        'btn-e': 'moveLeft',
        'btn-nw': 'moveForwardRight',
        'btn-ne': 'moveForwardLeft',
        'btn-sw': 'moveBackwardRight',
        'btn-se': 'moveBackwardLeft',
        'cam-left': 'cameraTurnLeft',
        'cam-right': 'cameraTurnRight',
        'cam-up': 'cameraTiltUp',
        'cam-down': 'cameraTiltDown',
        'cam-zoom-in': 'cameraZoomIn',
        'cam-zoom-out': 'cameraZoomOut'
      };
      
      // Helper to setup touch events for a button
      function setupButtonEvents(buttonId, controlName) {
        const button = document.getElementById(buttonId);
        if (!button) return;
        
        // Start pressing button
        button.addEventListener('touchstart', (e) => {
          e.preventDefault();
          e.stopPropagation();
          controls[controlName] = true;
          button.classList.add('active');
          
          // Double-tap to jump
          if (controlName === 'moveForward' && 
              e.timeStamp - (button.lastTap || 0) < 300) {
            controls.jump = true;
            setTimeout(() => { controls.jump = false; }, 100);
          }
          button.lastTap = e.timeStamp;
        }, { passive: false });
        
        // Release button
        ['touchend', 'touchcancel'].forEach(eventType => {
          button.addEventListener(eventType, (e) => {
            e.preventDefault();
            e.stopPropagation();
            controls[controlName] = false;
            button.classList.remove('active');
          }, { passive: false });
        });
        
        // Prevent default
        button.addEventListener('touchmove', (e) => {
          e.preventDefault();
          e.stopPropagation();
        }, { passive: false });
      }
      
      // Set up all buttons
      for (const [buttonId, controlName] of Object.entries(buttons)) {
        setupButtonEvents(buttonId, controlName);
      }
    }
    
    // Initialize touch controls
    setupTouchControls();
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Prevent pinch zoom on mobile
    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 1) {
        e.preventDefault();
      }
    }, { passive: false });
    
    // Camera and physics variables
    let cameraAngle = 0;
    let cameraHeight = 3;
    let cameraDistance = 6;
    let gravity = 20;
    let score = 0;
    
    // Create FPS counter and update it
    const fpsElement = document.getElementById('fps-counter');
    const gemCountElement = document.getElementById('gem-count');
    let frameCount = 0;
    let lastTime = performance.now();
    
    function updateFPS() {
      frameCount++;
      const currentTime = performance.now();
      const elapsed = (currentTime - lastTime) / 1000;
      
      if (elapsed >= 1) {
        const fps = Math.round(frameCount / elapsed);
        fpsElement.textContent = `FPS: ${fps}`;
        frameCount = 0;
        lastTime = currentTime;
      }
    }
    
    // PS2-era character controller with physics
    function updateCharacter(delta) {
      // Process jump input
      if (controls.jump && !panda.animationState.isInAir) {
        panda.animationState.isJumping = true;
        panda.animationState.isInAir = true;
        panda.animationState.jumpVelocity = 8;
      }
      
      // Apply gravity
      if (panda.animationState.isInAir) {
        panda.animationState.jumpVelocity -= gravity * delta;
        panda.position.y += panda.animationState.jumpVelocity * delta;
        
        if (panda.position.y <= panda.animationState.groundY) {
          panda.position.y = panda.animationState.groundY;
          panda.animationState.isInAir = false;
          panda.animationState.isJumping = false;
          
          // Spawn dust particles on landing
          particleSystem.spawn(
            new THREE.Vector3(
              panda.position.x,
              panda.position.y - 0.5,
              panda.position.z
            ),
            10,
            'dust'
          );
        }
      }
      
      // Handle movement
      let moving = false;
      const moveSpeed = 5.0 * delta;
      
      // Get camera direction for relative movement
      let cameraForward = new THREE.Vector3(0, 0, -1);
      cameraForward.applyQuaternion(camera.quaternion);
      cameraForward.y = 0; // Project onto XZ plane
      cameraForward.normalize();
      
      // Get the right vector
      let cameraRight = new THREE.Vector3(cameraForward.z, 0, -cameraForward.x);
      
      // Initialize movement vector
      let moveVector = new THREE.Vector3(0, 0, 0);
      let targetRotationY = panda.rotation.y;
      
      // Calculate movement based on camera orientation
      if (controls.moveForward) {
        moveVector.add(cameraForward);
        targetRotationY = Math.atan2(cameraForward.x, cameraForward.z);
        moving = true;
      }
      if (controls.moveBackward) {
        moveVector.sub(cameraForward);
        targetRotationY = Math.atan2(-cameraForward.x, -cameraForward.z);
        moving = true;
      }
      if (controls.moveLeft) {
        moveVector.sub(cameraRight);
        targetRotationY = Math.atan2(-cameraRight.x, -cameraRight.z);
        moving = true;
      }
      if (controls.moveRight) {
        moveVector.add(cameraRight);
        targetRotationY = Math.atan2(cameraRight.x, cameraRight.z);
        moving = true;
      }
      
      // Calculate diagonal movement
      if (controls.moveForwardLeft) {
        let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight.clone().multiplyScalar(-1)).normalize();
        moveVector.add(diagonalDir);
        targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
        moving = true;
      }
      if (controls.moveForwardRight) {
        let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight).normalize();
        moveVector.add(diagonalDir);
        targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
        moving = true;
      }
      if (controls.moveBackwardLeft) {
        let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight.clone().multiplyScalar(-1)).normalize();
        moveVector.add(diagonalDir);
        targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
        moving = true;
      }
      if (controls.moveBackwardRight) {
        let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight).normalize();
        moveVector.add(diagonalDir);
        targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
        moving = true;
      }
      
      // Normalize and apply movement
      if (moving) {
        moveVector.normalize();
        
        // Apply movement speed
        panda.position.x += moveVector.x * moveSpeed;
        panda.position.z += moveVector.z * moveSpeed;
        
        // Smoothly rotate panda to face movement direction
        const rotationSpeed = 10 * delta;
        panda.rotation.y = THREE.MathUtils.lerp(
          panda.rotation.y,
          targetRotationY,
          rotationSpeed
        );
        
        // Generate footstep particles
        if (!panda.animationState.isInAir && Math.sin(performance.now() * 0.01) > 0.9) {
          particleSystem.spawn(
            new THREE.Vector3(
              panda.position.x,
              panda.position.y - 0.5,
              panda.position.z
            ),
            3,
            'dust'
          );
        }
      }
      
      // Check if panda is near water and add ripples
      const distanceToWater = new THREE.Vector2(panda.position.x - water.position.x, panda.position.z - water.position.z).length();
      if (distanceToWater < 20 && moving && Math.random() < 0.03) {
        water.addRipple({
          x: panda.position.x,
          z: panda.position.z
        });
      }
      
      // Set animation state
      panda.animationState.isWalking = moving && !panda.animationState.isInAir;
      
      // Return movement status
      return moving;
    }
    
    // Camera controller
    function updateCamera(delta) {
      // Camera controls
      if (controls.cameraTurnLeft) {
        cameraAngle += 2 * delta;
      }
      if (controls.cameraTurnRight) {
        cameraAngle -= 2 * delta;
      }
      if (controls.cameraTiltUp) {
        cameraHeight += 2 * delta;
        cameraHeight = Math.min(6, cameraHeight);
      }
      if (controls.cameraTiltDown) {
        cameraHeight -= 2 * delta;
        cameraHeight = Math.max(1.5, cameraHeight);
      }
      if (controls.cameraZoomIn) {
        cameraDistance -= 3 * delta;
        cameraDistance = Math.max(3, cameraDistance);
      }
      if (controls.cameraZoomOut) {
        cameraDistance += 3 * delta;
        cameraDistance = Math.min(10, cameraDistance);
      }
      
      // Smoothly update camera position
      const targetX = panda.position.x + Math.sin(cameraAngle) * cameraDistance;
      const targetZ = panda.position.z + Math.cos(cameraAngle) * cameraDistance;
      const targetY = panda.position.y + cameraHeight;
      
      camera.position.x += (targetX - camera.position.x) * 5 * delta;
      camera.position.z += (targetZ - camera.position.z) * 5 * delta;
      camera.position.y += (targetY - camera.position.y) * 5 * delta;
      
      // Look at character with slight offset
      camera.lookAt(
        panda.position.x,
        panda.position.y + 1,
        panda.position.z
      );
    }
    
    // Character animations
    function updateCharacterAnimations(time, delta, moving) {
      // Update blinking
      panda.animationState.blink.timer += delta;
      if (panda.animationState.blink.timer >= panda.animationState.blink.interval) {
        panda.animationState.blink.timer = 0;
        panda.animationState.blink.interval = 2 + Math.random() * 4;
      }
      
      // Perform blink
      const blinkPhase = panda.animationState.blink.timer / panda.animationState.blink.interval;
      const isBlinking = blinkPhase < panda.animationState.blink.duration / panda.animationState.blink.interval;
      
      if (isBlinking) {
        panda.leftEye.scale.y = 0.1;
        panda.rightEye.scale.y = 0.1;
      } else {
        panda.leftEye.scale.y = 1;
        panda.rightEye.scale.y = 1;
      }
      
      // Head animations
      if (!panda.animationState.isInAir) {
        // Normal head bob when on ground
        panda.head.position.y = 1.6 + Math.sin(time * 1.5) * 0.05;
        panda.head.rotation.y = Math.sin(time * 0.8) * 0.1;
      } else {
        // Look down when jumping/falling
        panda.head.rotation.x = panda.animationState.jumpVelocity > 0 ? -0.2 : 0.3;
      }
      
      // Eye movements
      panda.leftPupil.position.x = 0.32 + Math.sin(time * 0.6) * 0.04;
      panda.rightPupil.position.x = -0.32 + Math.sin(time * 0.6) * 0.04;
      
      // Mouth animation
      panda.mouth.scale.x = 1 + Math.sin(time * 2) * 0.1;
      
      // Ear animations
      panda.leftEar.rotation.z = -0.1 + Math.sin(time * 1.2) * 0.05;
      panda.rightEar.rotation.z = 0.1 - Math.sin(time * 1.2) * 0.05;
      
  // Idle animations when not moving
if (!moving && !panda.animationState.isInAir) {
  // Breathing animation
  panda.torsoUpper.scale.y = 1 + Math.sin(time * 1.2) * 0.03;
  panda.torsoUpper.scale.z = 1 - Math.sin(time * 1.2) * 0.01;
  panda.torsoLower.scale.y = 1 - Math.sin(time * 1.2) * 0.02;
  panda.belly.scale.z = 1 + Math.sin(time * 1.2) * 0.03;
  
  // Subtle arm movements
  panda.leftUpperArm.rotation.x = Math.sin(time * 0.7) * 0.1;
  panda.rightUpperArm.rotation.x = Math.sin(time * 0.7 + 0.5) * 0.1;
  panda.leftShoulder.position.y = 1.25 + Math.sin(time * 0.7) * 0.02;
  panda.rightShoulder.position.y = 1.25 + Math.sin(time * 0.7 + 0.5) * 0.02;
  
  // Reset legs
  panda.leftUpperLeg.rotation.x = 0;
  panda.rightUpperLeg.rotation.x = 0;
  panda.leftLowerLeg.rotation.x = 0;
  panda.rightLowerLeg.rotation.x = 0;
}
      
      // Walking animations
      if (panda.animationState.isWalking) {
        // Leg animations
        panda.leftUpperLeg.rotation.x = Math.sin(time * 10) * 0.7;
        panda.rightUpperLeg.rotation.x = Math.sin(time * 10 + Math.PI) * 0.7;
        
        // Lower legs follow with a delay
        panda.leftLowerLeg.rotation.x = Math.sin(time * 10 - Math.PI/3) * 0.5;
        panda.rightLowerLeg.rotation.x = Math.sin(time * 10 + Math.PI - Math.PI/3) * 0.5;
        
        // Arm swing animations
        panda.leftUpperArm.rotation.x = Math.sin(time * 10 + Math.PI) * 0.5;
        panda.rightUpperArm.rotation.x = Math.sin(time * 10) * 0.5;
        panda.leftLowerArm.rotation.x = Math.sin(time * 10 + Math.PI + Math.PI/4) * 0.3;
        panda.rightLowerArm.rotation.x = Math.sin(time * 10 + Math.PI/4) * 0.3;
        
        // Body movement
        panda.torso.rotation.y = Math.sin(time * 5) * 0.05;
        
        // Secondary animations
        panda.backpack.rotation.x = Math.sin(time * 10) * 0.1;
        panda.tailBase.rotation.y = Math.sin(time * 5) * 0.2;
      }
      
      // Jump animation
      if (panda.animationState.isInAir) {
        // Different poses for rising and falling
        if (panda.animationState.jumpVelocity > 0) {
          // Rising
          panda.leftUpperLeg.rotation.x = -0.4;
          panda.rightUpperLeg.rotation.x = -0.4;
          panda.leftLowerLeg.rotation.x = 0.6;
          panda.rightLowerLeg.rotation.x = 0.6;
          
          // Arms raised
          panda.leftUpperArm.rotation.x = -0.7;
          panda.rightUpperArm.rotation.x = -0.7;
          panda.leftLowerArm.rotation.x = -0.4;
          panda.rightLowerArm.rotation.x = -0.4;
        } else {
          // Falling
          panda.leftUpperLeg.rotation.x = 0.2;
          panda.rightUpperLeg.rotation.x = 0.2;
          panda.leftLowerLeg.rotation.x = 0.6;
          panda.rightLowerLeg.rotation.x = 0.6;
          
          // Arms out for balance
          panda.leftUpperArm.rotation.x = 0;
          panda.rightUpperArm.rotation.x = 0;
          panda.leftUpperArm.rotation.z = -0.6;
          panda.rightUpperArm.rotation.z = 0.6;
        }
      } else {
        // Reset arm rotation when not jumping
        panda.leftUpperArm.rotation.z = -0.3;
        panda.rightUpperArm.rotation.z = 0.3;
      }
      
      // Tail animations
      panda.tailBase.rotation.z = Math.sin(time * 2) * 0.2;
      panda.tailMid.rotation.z = Math.sin(time * 2 + 0.3) * 0.3;
      panda.tailTip.rotation.z = Math.sin(time * 2 + 0.6) * 0.4;
    }
   

// Create PS2-Style Foxy Character
function createPS2Foxy() {
  const foxy = new THREE.Group();
  
  // Get fur textures - we'll reuse the method from the panda but adjust colors
  const furTextures = createFurTextureWithNormal();
  
  // Enhanced materials with textures for Foxy's colors
  const orangeMaterial = new THREE.MeshStandardMaterial({
    color: 0xFF6347, // Tomato orange for main body
    map: furTextures.colorMap,
    normalMap: furTextures.normalMap,
    normalScale: new THREE.Vector2(0.5, 0.5),
    roughness: 0.7,
    metalness: 0.1
  });
  
  const whiteMaterial = new THREE.MeshStandardMaterial({
    color: 0xFFFFFF,
    map: furTextures.colorMap,
    normalMap: furTextures.normalMap,
    normalScale: new THREE.Vector2(0.5, 0.5),
    roughness: 0.7,
    metalness: 0.1
  });
  
  const peachMaterial = new THREE.MeshStandardMaterial({
    color: 0xFFDAB9, // Peach color for face
    map: furTextures.colorMap,
    normalMap: furTextures.normalMap,
    normalScale: new THREE.Vector2(0.5, 0.5),
    roughness: 0.7,
    metalness: 0.1
  });
  
  const blackMaterial = new THREE.MeshStandardMaterial({
    color: 0x222222,
    map: furTextures.colorMap,
    normalMap: furTextures.normalMap,
    normalScale: new THREE.Vector2(0.5, 0.5),
    roughness: 0.7,
    metalness: 0.1
  });
  
  const blueMaterial = new THREE.MeshStandardMaterial({
    color: 0x4169E1, // Royal blue for stripes
    roughness: 0.6,
    metalness: 0.2
  });
  
  const purpleMaterial = new THREE.MeshStandardMaterial({
    color: 0x9370DB, // Medium purple for paws
    roughness: 0.6,
    metalness: 0.2
  });
  
  const redMaterial = new THREE.MeshStandardMaterial({
    color: 0xFF0000, // Red for heart
    roughness: 0.5,
    metalness: 0.3
  });
  
  const brownMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Saddle brown for nose
    roughness: 0.7,
    metalness: 0.1
  });
  
  const greenMaterial = new THREE.MeshStandardMaterial({
    color: 0x90EE90, // Light green for ear insides
    roughness: 0.7,
    metalness: 0.1
  });
  
  // ----- HEAD -----
  const headGeometry = new THREE.SphereGeometry(0.6, 12, 10);
  const head = new THREE.Mesh(headGeometry, orangeMaterial);
  head.position.y = 1.6;
  head.castShadow = true;
  foxy.add(head);
  
  // Face - white muzzle area
  const muzzleGeometry = new THREE.SphereGeometry(0.55, 10, 8);
  const muzzle = new THREE.Mesh(muzzleGeometry, whiteMaterial);
  muzzle.position.set(0, 1.45, 0.25);
  muzzle.scale.set(0.9, 0.75, 0.7);
  muzzle.castShadow = true;
  foxy.add(muzzle);
  
  // Peach face patches
  const facePatchGeometry = new THREE.SphereGeometry(0.4, 10, 8);
  
  const leftFacePatch = new THREE.Mesh(facePatchGeometry, peachMaterial);
  leftFacePatch.position.set(0.3, 1.65, 0.35);
  leftFacePatch.scale.set(0.9, 0.8, 0.6);
  leftFacePatch.castShadow = true;
  foxy.add(leftFacePatch);
  
  const rightFacePatch = new THREE.Mesh(facePatchGeometry.clone(), peachMaterial);
  rightFacePatch.position.set(-0.3, 1.65, 0.35);
  rightFacePatch.scale.set(0.9, 0.8, 0.6);
  rightFacePatch.castShadow = true;
  foxy.add(rightFacePatch);
  
  // Eyes
  const eyeGeometry = new THREE.SphereGeometry(0.14, 10, 8);
  
  const leftEye = new THREE.Mesh(eyeGeometry, blackMaterial);
  leftEye.position.set(0.25, 1.65, 0.57);
  foxy.add(leftEye);
  
  const rightEye = new THREE.Mesh(eyeGeometry.clone(), blackMaterial);
  rightEye.position.set(-0.25, 1.65, 0.57);
  foxy.add(rightEye);
  
  // Eye highlights
  const highlightGeometry = new THREE.SphereGeometry(0.05, 8, 8);
  
  const leftHighlight = new THREE.Mesh(highlightGeometry, whiteMaterial);
  leftHighlight.position.set(0.29, 1.69, 0.65);
  foxy.add(leftHighlight);
  
  const rightHighlight = new THREE.Mesh(highlightGeometry.clone(), whiteMaterial);
  rightHighlight.position.set(-0.21, 1.69, 0.65);
  foxy.add(rightHighlight);
  
  // Nose
  const noseGeometry = new THREE.SphereGeometry(0.08, 8, 6);
  const nose = new THREE.Mesh(noseGeometry, brownMaterial);
  nose.position.set(0, 1.45, 0.75);
  nose.scale.set(1, 0.8, 0.8);
  nose.castShadow = true;
  foxy.add(nose);
  
  // Smile - stitched look
  const mouthGeometry = new THREE.TorusGeometry(0.13, 0.02, 10, 12, Math.PI);
  const mouth = new THREE.Mesh(mouthGeometry, purpleMaterial); // Purple stitching
  mouth.position.set(0, 1.35, 0.7);
  mouth.rotation.x = -Math.PI / 2;
  mouth.rotation.z = Math.PI;
  foxy.add(mouth);
  
// ----- EARS -----
  // More pointy ear geometry - taller and narrower cone with more segments
  const earGeometry = new THREE.ConeGeometry(0.15, 0.6, 8);
  
  // Add white spots on the top of the head (using small spheres)
  for (let i = 0; i < 7; i++) {
    const spotGeometry = new THREE.SphereGeometry(0.03, 6, 6);
    const spot = new THREE.Mesh(spotGeometry, whiteMaterial);
    // Position spots randomly on top of head
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * 0.3;
    spot.position.set(
      Math.sin(angle) * radius,
      1.95 + Math.random() * 0.1,
      Math.cos(angle) * radius
    );
    foxy.add(spot);
  }
  
  // Ears with green inside - more pointy
  const leftEar = new THREE.Mesh(earGeometry, orangeMaterial);
  leftEar.position.set(0.4, 2.1, 0);
  leftEar.rotation.z = Math.PI / 12;
  leftEar.rotation.x = -Math.PI / 12;
  leftEar.castShadow = true;
  foxy.add(leftEar);
  
  const rightEar = new THREE.Mesh(earGeometry.clone(), orangeMaterial);
  rightEar.position.set(-0.4, 2.1, 0);
  rightEar.rotation.z = -Math.PI / 12;
  rightEar.rotation.x = -Math.PI / 12;
  rightEar.castShadow = true;
  foxy.add(rightEar);
  
  // Inner ears - green pattern (also more pointy)
  const innerEarGeometry = new THREE.ConeGeometry(0.1, 0.5, 8);
  
  const leftInnerEar = new THREE.Mesh(innerEarGeometry, greenMaterial);
  leftInnerEar.position.set(0.4, 2.08, 0.02);
  leftInnerEar.rotation.z = Math.PI / 12;
  leftInnerEar.rotation.x = -Math.PI / 12;
  foxy.add(leftInnerEar);
  
  const rightInnerEar = new THREE.Mesh(innerEarGeometry.clone(), greenMaterial);
  rightInnerEar.position.set(-0.4, 2.08, 0.02);
  rightInnerEar.rotation.z = -Math.PI / 12;
  rightInnerEar.rotation.x = -Math.PI / 12;
  foxy.add(rightInnerEar);
  
  // ----- BODY -----
  // Main body
  const torsoUpperGeometry = new THREE.SphereGeometry(0.42, 12, 10);
  const torsoUpper = new THREE.Mesh(torsoUpperGeometry, orangeMaterial);
  torsoUpper.position.y = 1.15;
  torsoUpper.scale.set(1, 0.8, 0.9);
  torsoUpper.castShadow = true;
  foxy.add(torsoUpper);
  
  const torsoLowerGeometry = new THREE.SphereGeometry(0.45, 12, 10);
  const torsoLower = new THREE.Mesh(torsoLowerGeometry, orangeMaterial);
  torsoLower.position.y = 0.7;
  torsoLower.scale.set(1, 0.9, 0.85);
  torsoLower.castShadow = true;
  foxy.add(torsoLower);
  
  // Heart on chest
  const heartGeometry = new THREE.SphereGeometry(0.2, 10, 8);
  const heart = new THREE.Mesh(heartGeometry, whiteMaterial);
  heart.position.set(0, 1.05, 0.35);
  heart.scale.set(1.2, 1, 0.6);
  heart.castShadow = true;
  foxy.add(heart);
  
  // Heart outline
  const heartOutlineGeometry = new THREE.TorusGeometry(0.2, 0.02, 8, 16, Math.PI * 2);
  const heartOutline = new THREE.Mesh(heartOutlineGeometry, redMaterial);
  heartOutline.position.set(0, 1.05, 0.38);
  heartOutline.rotation.x = Math.PI / 2;
  heartOutline.scale.set(1.2, 1, 1);
  foxy.add(heartOutline);
  
  // Music note (simplified) on the heart
  const noteBaseGeometry = new THREE.SphereGeometry(0.04, 8, 8);
  const noteBase = new THREE.Mesh(noteBaseGeometry, blackMaterial);
  noteBase.position.set(0.03, 1.05, 0.42);
  foxy.add(noteBase);
  
  const noteStemGeometry = new THREE.BoxGeometry(0.02, 0.12, 0.02);
  const noteStem = new THREE.Mesh(noteStemGeometry, blackMaterial);
  noteStem.position.set(0.03, 1.12, 0.42);
  foxy.add(noteStem);
  
  // Reference group for torso
  const torso = new THREE.Group();
  torso.position.y = 0.85;
  foxy.add(torso);
  
  // ----- ARMS -----
  // Shoulders with blue and white stripes
  const shoulderGeometry = new THREE.SphereGeometry(0.15, 10, 8);
  
  const leftShoulder = new THREE.Mesh(shoulderGeometry, blueMaterial);
  leftShoulder.position.set(0.42, 1.25, 0);
  leftShoulder.castShadow = true;
  foxy.add(leftShoulder);
  
  const rightShoulder = new THREE.Mesh(shoulderGeometry.clone(), blueMaterial);
  rightShoulder.position.set(-0.42, 1.25, 0);
  rightShoulder.castShadow = true;
  foxy.add(rightShoulder);
  
  // Arm segments with alternating colors for stripes
  const upperArmGeometry = new THREE.SphereGeometry(0.12, 10, 8);
  
  const leftUpperArm = new THREE.Mesh(upperArmGeometry, whiteMaterial);
  leftUpperArm.position.set(0.55, 1.15, 0.05);
  leftUpperArm.scale.set(0.9, 1.2, 0.9);
  leftUpperArm.rotation.z = -0.3;
  leftUpperArm.castShadow = true;
  foxy.add(leftUpperArm);
  
  const rightUpperArm = new THREE.Mesh(upperArmGeometry.clone(), whiteMaterial);
  rightUpperArm.position.set(-0.55, 1.15, 0.05);
  rightUpperArm.scale.set(0.9, 1.2, 0.9);
  rightUpperArm.rotation.z = 0.3;
  rightUpperArm.castShadow = true;
  foxy.add(rightUpperArm);
  
  // Elbow joints - blue stripe
  const elbowGeometry = new THREE.SphereGeometry(0.11, 8, 6);
  
  const leftElbow = new THREE.Mesh(elbowGeometry, blueMaterial);
  leftElbow.position.set(0.65, 1.0, 0.08);
  leftElbow.castShadow = true;
  foxy.add(leftElbow);
  
  const rightElbow = new THREE.Mesh(elbowGeometry.clone(), blueMaterial);
  rightElbow.position.set(-0.65, 1.0, 0.08);
  rightElbow.castShadow = true;
  foxy.add(rightElbow);
  
  // Lower arms - white stripe
  const lowerArmGeometry = new THREE.SphereGeometry(0.1, 10, 8);
  
  const leftLowerArm = new THREE.Mesh(lowerArmGeometry, whiteMaterial);
  leftLowerArm.position.set(0.75, 0.92, 0.1);
  leftLowerArm.scale.set(0.85, 1.1, 0.85);
  leftLowerArm.rotation.z = -0.5;
  leftLowerArm.castShadow = true;
  foxy.add(leftLowerArm);
  
  const rightLowerArm = new THREE.Mesh(lowerArmGeometry.clone(), whiteMaterial);
  rightLowerArm.position.set(-0.75, 0.92, 0.1);
  rightLowerArm.scale.set(0.85, 1.1, 0.85);
  rightLowerArm.rotation.z = 0.5;
  rightLowerArm.castShadow = true;
  foxy.add(rightLowerArm);
  
  // Purple paws
  const wristGeometry = new THREE.SphereGeometry(0.1, 8, 6);
  const handGeometry = new THREE.SphereGeometry(0.13, 10, 8);
  
  // Left wrist and hand
  const leftWrist = new THREE.Mesh(wristGeometry, blueMaterial);
  leftWrist.position.set(0.82, 0.85, 0.12);
  leftWrist.castShadow = true;
  foxy.add(leftWrist);
  
  const leftHand = new THREE.Mesh(handGeometry, purpleMaterial);
  leftHand.position.set(0.9, 0.82, 0.15);
  leftHand.scale.set(1.1, 0.7, 0.85);
  leftHand.rotation.z = -0.2;
  leftHand.castShadow = true;
  foxy.add(leftHand);
  
  // Right wrist and hand
  const rightWrist = new THREE.Mesh(wristGeometry.clone(), blueMaterial);
  rightWrist.position.set(-0.82, 0.85, 0.12);
  rightWrist.castShadow = true;
  foxy.add(rightWrist);
  
  const rightHand = new THREE.Mesh(handGeometry.clone(), purpleMaterial);
  rightHand.position.set(-0.9, 0.82, 0.15);
  rightHand.scale.set(1.1, 0.7, 0.85);
  rightHand.rotation.z = 0.2;
  rightHand.castShadow = true;
  foxy.add(rightHand);
  
  // ----- LEGS -----
  // Upper legs with blue striped pattern
  const upperLegGeometry = new THREE.CylinderGeometry(0.15, 0.14, 0.25, 10, 3);
  
  const leftUpperLeg = new THREE.Mesh(upperLegGeometry, blueMaterial);
  leftUpperLeg.position.set(0.2, 0.25, 0);
  leftUpperLeg.castShadow = true;
  foxy.add(leftUpperLeg);
  
  const rightUpperLeg = new THREE.Mesh(upperLegGeometry.clone(), blueMaterial);
  rightUpperLeg.position.set(-0.2, 0.25, 0);
  rightUpperLeg.castShadow = true;
  foxy.add(rightUpperLeg);
  
  // Mid legs with white striped pattern
  const midLegGeometry = new THREE.CylinderGeometry(0.14, 0.13, 0.25, 10, 3);
  
  const leftMidLeg = new THREE.Mesh(midLegGeometry, whiteMaterial);
  leftMidLeg.position.set(0.2, 0, 0);
  leftMidLeg.castShadow = true;
  foxy.add(leftMidLeg);
  
  const rightMidLeg = new THREE.Mesh(midLegGeometry.clone(), whiteMaterial);
  rightMidLeg.position.set(-0.2, 0, 0);
  rightMidLeg.castShadow = true;
  foxy.add(rightMidLeg);
  
  // Lower legs with blue striped pattern
  const lowerLegGeometry = new THREE.CylinderGeometry(0.13, 0.15, 0.25, 10, 3);
  
  const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, blueMaterial);
  leftLowerLeg.position.set(0.2, -0.25, 0);
  leftLowerLeg.castShadow = true;
  foxy.add(leftLowerLeg);
  
  const rightLowerLeg = new THREE.Mesh(lowerLegGeometry.clone(), blueMaterial);
  rightLowerLeg.position.set(-0.2, -0.25, 0);
  rightLowerLeg.castShadow = true;
  foxy.add(rightLowerLeg);
  
  // Purple patterned feet
  const footGeometry = new THREE.SphereGeometry(0.15, 10, 8);
  
  const leftFoot = new THREE.Mesh(footGeometry, purpleMaterial);
  leftFoot.position.set(0.2, -0.5, 0.1);
  leftFoot.scale.set(1.3, 0.6, 1.6);
  leftFoot.castShadow = true;
  foxy.add(leftFoot);
  
  const rightFoot = new THREE.Mesh(footGeometry.clone(), purpleMaterial);
  rightFoot.position.set(-0.2, -0.5, 0.1);
  rightFoot.scale.set(1.3, 0.6, 1.6);
  rightFoot.castShadow = true;
  foxy.add(rightFoot);
  
  // ----- TAIL -----
  // Bushy fox tail with segments (base is purple, middle is orange, tip is white)
  const tailBaseGeometry = new THREE.SphereGeometry(0.18, 10, 8);
  const tailBase = new THREE.Mesh(tailBaseGeometry, purpleMaterial);
  tailBase.position.set(0, 0.5, -0.5);
  tailBase.castShadow = true;
  foxy.add(tailBase);
  
  const tailMidGeometry = new THREE.SphereGeometry(0.16, 8, 6);
  const tailMid = new THREE.Mesh(tailMidGeometry, orangeMaterial);
  tailMid.position.set(0, 0.6, -0.75);
  tailMid.castShadow = true;
  foxy.add(tailMid);
  
  const tailTipGeometry = new THREE.SphereGeometry(0.12, 8, 6);
  const tailTip = new THREE.Mesh(tailTipGeometry, whiteMaterial);
  tailTip.position.set(0, 0.65, -1.0);
  tailTip.castShadow = true;
  foxy.add(tailTip);
  
  // Store references for animations
  foxy.head = head;
  foxy.muzzle = muzzle;
  foxy.leftFacePatch = leftFacePatch;
  foxy.rightFacePatch = rightFacePatch;
  foxy.leftEye = leftEye;
  foxy.rightEye = rightEye;
  foxy.leftHighlight = leftHighlight;
  foxy.rightHighlight = rightHighlight;
  foxy.mouth = mouth;
  foxy.leftEar = leftEar;
  foxy.rightEar = rightEar;
  
  // Body structure
  foxy.torso = torso;
  foxy.torsoUpper = torsoUpper;
  foxy.torsoLower = torsoLower;
  
  // Arm structure
  foxy.leftShoulder = leftShoulder;
  foxy.rightShoulder = rightShoulder;
  foxy.leftUpperArm = leftUpperArm;
  foxy.rightUpperArm = rightUpperArm;
  foxy.leftElbow = leftElbow;
  foxy.rightElbow = rightElbow;
  foxy.leftLowerArm = leftLowerArm;
  foxy.rightLowerArm = rightLowerArm;
  foxy.leftWrist = leftWrist;
  foxy.rightWrist = rightWrist;
  foxy.leftHand = leftHand;
  foxy.rightHand = rightHand;
  
  // Legs
  foxy.leftUpperLeg = leftUpperLeg;
  foxy.rightUpperLeg = rightUpperLeg;
  foxy.leftMidLeg = leftMidLeg;
  foxy.rightMidLeg = rightMidLeg;
  foxy.leftLowerLeg = leftLowerLeg;
  foxy.rightLowerLeg = rightLowerLeg;
  foxy.leftFoot = leftFoot;
  foxy.rightFoot = rightFoot;
  
  // Tail
  foxy.tailBase = tailBase;
  foxy.tailMid = tailMid;
  foxy.tailTip = tailTip;
  
  // Initialize animation state management - same as panda
  foxy.animationState = {
    isWalking: false,
    isJumping: false,
    isInAir: false,
    jumpVelocity: 0,
    groundY: 0,
    blink: {
      timer: 0,
      interval: 4 + Math.random() * 3,
      duration: 0.15
    }
  };
  
  return foxy;
}

// Function to update character animations for Foxy
// This is similar to the panda animations but with adjustments for Foxy's unique features
function updateFoxyAnimations(foxy, time, delta, moving) {
  // Update blinking
  foxy.animationState.blink.timer += delta;
  if (foxy.animationState.blink.timer >= foxy.animationState.blink.interval) {
    foxy.animationState.blink.timer = 0;
    foxy.animationState.blink.interval = 2 + Math.random() * 4;
  }
  
  // Perform blink
  const blinkPhase = foxy.animationState.blink.timer / foxy.animationState.blink.interval;
  const isBlinking = blinkPhase < foxy.animationState.blink.duration / foxy.animationState.blink.interval;
  
  if (isBlinking) {
    foxy.leftEye.scale.y = 0.1;
    foxy.rightEye.scale.y = 0.1;
  } else {
    foxy.leftEye.scale.y = 1;
    foxy.rightEye.scale.y = 1;
  }
  
  // Head animations
  if (!foxy.animationState.isInAir) {
    // Normal head bob when on ground
    foxy.head.position.y = 1.6 + Math.sin(time * 1.5) * 0.05;
    foxy.head.rotation.y = Math.sin(time * 0.8) * 0.1;
  } else {
    // Look down when jumping/falling
    foxy.head.rotation.x = foxy.animationState.jumpVelocity > 0 ? -0.2 : 0.3;
  }
  
  // Eye movements
  foxy.leftHighlight.position.x = 0.29 + Math.sin(time * 0.6) * 0.03;
  foxy.rightHighlight.position.x = -0.21 + Math.sin(time * 0.6) * 0.03;
  
  // Mouth animation - purple stitched smile
  foxy.mouth.scale.x = 1 + Math.sin(time * 2) * 0.1;
  
  // Ear animations
  foxy.leftEar.rotation.z = Math.PI / 12 + Math.sin(time * 1.2) * 0.05;
  foxy.rightEar.rotation.z = -Math.PI / 12 - Math.sin(time * 1.2) * 0.05;
  
  // Tail animations - more active for a fox
  foxy.tailBase.rotation.z = Math.sin(time * 3) * 0.3;
  foxy.tailMid.rotation.z = Math.sin(time * 3 + 0.3) * 0.4;
  foxy.tailTip.rotation.z = Math.sin(time * 3 + 0.6) * 0.5;
  
  // Position tail tips relative to base movement
  foxy.tailMid.position.x = Math.sin(time * 3) * 0.1;
  foxy.tailTip.position.x = Math.sin(time * 3) * 0.2;
  
  // Idle animations when not moving
  if (!moving && !foxy.animationState.isInAir) {
    // Breathing animation
    foxy.torsoUpper.scale.y = 1 + Math.sin(time * 1.2) * 0.03;
    foxy.torsoUpper.scale.z = 1 - Math.sin(time * 1.2) * 0.01;
    foxy.torsoLower.scale.y = 1 - Math.sin(time * 1.2) * 0.02;
    
    // Subtle arm movements
    foxy.leftUpperArm.rotation.x = Math.sin(time * 0.7) * 0.1;
    foxy.rightUpperArm.rotation.x = Math.sin(time * 0.7 + 0.5) * 0.1;
    foxy.leftShoulder.position.y = 1.25 + Math.sin(time * 0.7) * 0.02;
    foxy.rightShoulder.position.y = 1.25 + Math.sin(time * 0.7 + 0.5) * 0.02;
    
    // Reset legs
    foxy.leftUpperLeg.rotation.x = 0;
    foxy.rightUpperLeg.rotation.x = 0;
    foxy.leftLowerLeg.rotation.x = 0;
    foxy.rightLowerLeg.rotation.x = 0;
  }
  
  // Walking animations
  if (foxy.animationState.isWalking) {
    // Leg animations
    foxy.leftUpperLeg.rotation.x = Math.sin(time * 10) * 0.7;
    foxy.rightUpperLeg.rotation.x = Math.sin(time * 10 + Math.PI) * 0.7;
    
    // Mid legs follow
    foxy.leftMidLeg.rotation.x = Math.sin(time * 10 - Math.PI/6) * 0.6;
    foxy.rightMidLeg.rotation.x = Math.sin(time * 10 + Math.PI - Math.PI/6) * 0.6;
    
 // Lower legs follow with a delay
    foxy.leftLowerLeg.rotation.x = Math.sin(time * 10 - Math.PI/3) * 0.5;
    foxy.rightLowerLeg.rotation.x = Math.sin(time * 10 + Math.PI - Math.PI/3) * 0.5;
    
    // Arm swing animations
    foxy.leftUpperArm.rotation.x = Math.sin(time * 10 + Math.PI) * 0.5;
    foxy.rightUpperArm.rotation.x = Math.sin(time * 10) * 0.5;
    foxy.leftLowerArm.rotation.x = Math.sin(time * 10 + Math.PI + Math.PI/4) * 0.3;
    foxy.rightLowerArm.rotation.x = Math.sin(time * 10 + Math.PI/4) * 0.3;
    
    // Body movement
    foxy.torso.rotation.y = Math.sin(time * 5) * 0.05;
    
    // Tail swings faster while walking
    foxy.tailBase.rotation.y = Math.sin(time * 5) * 0.3;
  }
  
  // Jump animation
  if (foxy.animationState.isInAir) {
    // Different poses for rising and falling
    if (foxy.animationState.jumpVelocity > 0) {
      // Rising
      foxy.leftUpperLeg.rotation.x = -0.4;
      foxy.rightUpperLeg.rotation.x = -0.4;
      foxy.leftMidLeg.rotation.x = 0.2;
      foxy.rightMidLeg.rotation.x = 0.2;
      foxy.leftLowerLeg.rotation.x = 0.6;
      foxy.rightLowerLeg.rotation.x = 0.6;
      
      // Arms raised
      foxy.leftUpperArm.rotation.x = -0.7;
      foxy.rightUpperArm.rotation.x = -0.7;
      foxy.leftLowerArm.rotation.x = -0.4;
      foxy.rightLowerArm.rotation.x = -0.4;
      
      // Tail up
      foxy.tailBase.rotation.x = -0.5;
    } else {
      // Falling
      foxy.leftUpperLeg.rotation.x = 0.2;
      foxy.rightUpperLeg.rotation.x = 0.2;
      foxy.leftMidLeg.rotation.x = 0.4;
      foxy.rightMidLeg.rotation.x = 0.4;
      foxy.leftLowerLeg.rotation.x = 0.6;
      foxy.rightLowerLeg.rotation.x = 0.6;
      
      // Arms out for balance
      foxy.leftUpperArm.rotation.x = 0;
      foxy.rightUpperArm.rotation.x = 0;
      foxy.leftUpperArm.rotation.z = -0.6;
      foxy.rightUpperArm.rotation.z = 0.6;
      
      // Tail down for balance
      foxy.tailBase.rotation.x = 0.3;
    }
  } else {
    // Reset arm rotation when not jumping
    foxy.leftUpperArm.rotation.z = -0.3;
    foxy.rightUpperArm.rotation.z = 0.3;
    foxy.tailBase.rotation.x = 0;
  }
}

 
    // Check for collectible gems
   function checkCollectibles() {
  // Get the current character
  let character;
  if (window.characterManager) {
    character = window.characterManager.getCurrentCharacter();
  } else {
    character = panda;
  }
  
  gems.forEach((gem, index) => {
    if (gem.visible) {
      const distance = character.position.distanceTo(gem.position);
      if (distance < 1.5) {
        // Collect the gem
        gem.visible = false;
        score++;
        gemCountElement.textContent = score;
        
        // Collection effect
        particleSystem.spawn(gem.position, 15, 'sparkle');
        
        // Respawn gem in a new location after delay (only in open world mode)
        if (!crashLevel) {
          setTimeout(() => {
            const distance = 5 + Math.random() * 15;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.sin(angle) * distance;
            const z = Math.cos(angle) * distance;
            gem.position.set(x, 0.8, z);
            gem.visible = true;
          }, 5000);
        }
      }
    }
  });
}    
    // Main rendering loop
    const clock = new THREE.Clock();
    
// Function to add character selection UI and functionality
function addCharacterSelection() {
  // Create a character selection UI
  const selectionUI = document.createElement('div');
  selectionUI.style.position = 'absolute';
  selectionUI.style.top = '20px';
  selectionUI.style.left = '50%';
  selectionUI.style.transform = 'translateX(-50%)';
  selectionUI.style.display = 'flex';
  selectionUI.style.gap = '20px';
  selectionUI.style.backgroundColor = 'rgba(0,0,0,0.6)';
  selectionUI.style.padding = '10px';
  selectionUI.style.borderRadius = '10px';
  selectionUI.style.zIndex = '1000';
  
  // Create character buttons
  const characters = [
    { id: 'panda', name: 'Panda' },
    { id: 'foxy', name: 'Foxy' }
  ];
  
  characters.forEach(char => {
    const button = document.createElement('button');
    button.textContent = char.name;
    button.id = `select-${char.id}`;
    button.style.padding = '10px 20px';
    button.style.borderRadius = '5px';
    button.style.border = 'none';
    button.style.backgroundColor = '#4CAF50';
    button.style.color = 'white';
    button.style.cursor = 'pointer';
    button.style.fontWeight = 'bold';
    button.style.fontSize = '16px';
    button.style.transition = 'background-color 0.3s';
    
    // Hover effect
    button.onmouseover = () => {
      button.style.backgroundColor = '#45a049';
    };
    button.onmouseout = () => {
      button.style.backgroundColor = '#4CAF50';
    };
    
    // Active character indicator
    if (char.id === 'panda') {
      button.style.backgroundColor = '#45a049';
      button.style.boxShadow = '0 0 10px rgba(255,255,255,0.5)';
    }
    
    selectionUI.appendChild(button);
  });
  
  document.body.appendChild(selectionUI);
  
  // Character switching functionality
  let currentCharacter = panda;
  let foxyCharacter = null;
  
  document.getElementById('select-panda').addEventListener('click', () => {
    if (currentCharacter !== panda) {
      // Store foxy position and rotation
      const position = { ...currentCharacter.position };
      const rotation = { ...currentCharacter.rotation };
      
      // Hide foxy
      currentCharacter.visible = false;
      
      // Show panda
      panda.position.copy(position);
      panda.rotation.copy(rotation);
      panda.visible = true;
      
      // Update current character
      currentCharacter = panda;
      
      // Update button styles
      document.getElementById('select-panda').style.backgroundColor = '#45a049';
      document.getElementById('select-panda').style.boxShadow = '0 0 10px rgba(255,255,255,0.5)';
      document.getElementById('select-foxy').style.backgroundColor = '#4CAF50';
      document.getElementById('select-foxy').style.boxShadow = 'none';
    }
  });
  
  document.getElementById('select-foxy').addEventListener('click', () => {
    if (currentCharacter !== foxyCharacter) {
      // Create Foxy if not already created
      if (!foxyCharacter) {
        foxyCharacter = createPS2Foxy();
        scene.add(foxyCharacter);
      }
      
      // Store panda position and rotation
      const position = { ...currentCharacter.position };
      const rotation = { ...currentCharacter.rotation };
      
      // Hide panda
      currentCharacter.visible = false;
      
      // Show foxy at panda's position
      foxyCharacter.position.copy(position);
      foxyCharacter.rotation.copy(rotation);
      foxyCharacter.visible = true;
      
      // Update current character
      currentCharacter = foxyCharacter;
      
      // Update button styles
      document.getElementById('select-foxy').style.backgroundColor = '#45a049';
      document.getElementById('select-foxy').style.boxShadow = '0 0 10px rgba(255,255,255,0.5)';
      document.getElementById('select-panda').style.backgroundColor = '#4CAF50';
      document.getElementById('select-panda').style.boxShadow = 'none';
    }
  });
  
  // Return references to update in the game loop
  return {
    getCurrentCharacter: () => currentCharacter,
    getFoxyCharacter: () => foxyCharacter
  };
}

// Update the main animate function to handle both characters
function updateMainAnimationLoop() {
  // Add character selection UI and get character references
  const characterManager = addCharacterSelection();
  
  // Immediately store character manager in window
  window.characterManager = characterManager;
  

  
  // Override the animate function
  animate = function() {
    requestAnimationFrame(animate);
    
    // Get delta time and elapsed time
    const delta = Math.min(clock.getDelta(), 0.1);
    const time = clock.getElapsedTime();
    
    // Get current character
    const currentCharacter = characterManager.getCurrentCharacter();
    const foxyCharacter = characterManager.getFoxyCharacter();
    
    // Update FPS counter
    updateFPS();
    
    // Update current character controller
    const moving = updateCharacter(delta);
    
    // Update appropriate character animations
    if (currentCharacter === panda) {
      updateCharacterAnimations(time, delta, moving);
    } else if (currentCharacter === foxyCharacter) {
      updateFoxyAnimations(foxyCharacter, time, delta, moving);
    }
    
    // Update camera position
    updateCamera(delta);
    
    // Update skybox (day/night cycle)
    sky.update(time);
    
    // Update water effects
    water.update(time);
    
    // Update particle system
    particleSystem.update(delta);
    
    // Update collectible gems
    gems.forEach(gem => {
      if (gem.update) gem.update(time);
    });
    
    // Check for collectibles
    checkCollectibles();
    
    // Render the scene
    renderer.render(scene, camera);
  };
  
  // Modify the updateCharacter function to use the current character
  const originalUpdateCharacter = updateCharacter;
  updateCharacter = function(delta) {
    // Get current character
    const currentCharacter = characterManager.getCurrentCharacter();
    
    // Process jump input
    if (controls.jump && !currentCharacter.animationState.isInAir) {
      currentCharacter.animationState.isJumping = true;
      currentCharacter.animationState.isInAir = true;
      currentCharacter.animationState.jumpVelocity = 8;
    }
    
    // Apply gravity
    if (currentCharacter.animationState.isInAir) {
      currentCharacter.animationState.jumpVelocity -= gravity * delta;
      currentCharacter.position.y += currentCharacter.animationState.jumpVelocity * delta;
      
      if (currentCharacter.position.y <= currentCharacter.animationState.groundY) {
        currentCharacter.position.y = currentCharacter.animationState.groundY;
        currentCharacter.animationState.isInAir = false;
        currentCharacter.animationState.isJumping = false;
        
        // Spawn dust particles on landing
        particleSystem.spawn(
          new THREE.Vector3(
            currentCharacter.position.x,
            currentCharacter.position.y - 0.5,
            currentCharacter.position.z
          ),
          10,
          'dust'
        );
      }
    }
    
    // Handle movement
    let moving = false;
    const moveSpeed = 5.0 * delta;
    
    // Get camera direction for relative movement
    let cameraForward = new THREE.Vector3(0, 0, -1);
    cameraForward.applyQuaternion(camera.quaternion);
    cameraForward.y = 0; // Project onto XZ plane
    cameraForward.normalize();
    
    // Get the right vector
    let cameraRight = new THREE.Vector3(cameraForward.z, 0, -cameraForward.x);
    
    // Initialize movement vector
    let moveVector = new THREE.Vector3(0, 0, 0);
    let targetRotationY = currentCharacter.rotation.y;
    
    // Calculate movement based on camera orientation
    if (controls.moveForward) {
      moveVector.add(cameraForward);
      targetRotationY = Math.atan2(cameraForward.x, cameraForward.z);
      moving = true;
    }
    if (controls.moveBackward) {
      moveVector.sub(cameraForward);
      targetRotationY = Math.atan2(-cameraForward.x, -cameraForward.z);
      moving = true;
    }
    if (controls.moveLeft) {
      moveVector.sub(cameraRight);
      targetRotationY = Math.atan2(-cameraRight.x, -cameraRight.z);
      moving = true;
    }
    if (controls.moveRight) {
      moveVector.add(cameraRight);
      targetRotationY = Math.atan2(cameraRight.x, cameraRight.z);
      moving = true;
    }
    
    // Calculate diagonal movement
    if (controls.moveForwardLeft) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight.clone().multiplyScalar(-1)).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveForwardRight) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveBackwardLeft) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight.clone().multiplyScalar(-1)).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveBackwardRight) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    
    // Normalize and apply movement
    if (moving) {
      moveVector.normalize();
      
      // Apply movement speed
      currentCharacter.position.x += moveVector.x * moveSpeed;
      currentCharacter.position.z += moveVector.z * moveSpeed;
      
      // Smoothly rotate character to face movement direction
      const rotationSpeed = 10 * delta;
      currentCharacter.rotation.y = THREE.MathUtils.lerp(
        currentCharacter.rotation.y,
        targetRotationY,
        rotationSpeed
      );
      
      // Generate footstep particles
      if (!currentCharacter.animationState.isInAir && Math.sin(performance.now() * 0.01) > 0.9) {
        particleSystem.spawn(
          new THREE.Vector3(
            currentCharacter.position.x,
            currentCharacter.position.y - 0.5,
            currentCharacter.position.z
          ),
          3,
          'dust'
        );
      }
    }
    
    // Check if character is near water and add ripples
    const distanceToWater = new THREE.Vector2(currentCharacter.position.x - water.position.x, currentCharacter.position.z - water.position.z).length();
    if (distanceToWater < 20 && moving && Math.random() < 0.03) {
      water.addRipple({
        x: currentCharacter.position.x,
        z: currentCharacter.position.z
      });
    }
    
    // Set animation state
    currentCharacter.animationState.isWalking = moving && !currentCharacter.animationState.isInAir;
    
    // Return movement status
    return moving;
  };
  
  // Modify the updateCamera function to use the current character
  const originalUpdateCamera = updateCamera;
  updateCamera = function(delta) {
    const currentCharacter = characterManager.getCurrentCharacter();
    
    // Camera controls
    if (controls.cameraTurnLeft) {
      cameraAngle += 2 * delta;
    }
    if (controls.cameraTurnRight) {
      cameraAngle -= 2 * delta;
    }
    if (controls.cameraTiltUp) {
      cameraHeight += 2 * delta;
      cameraHeight = Math.min(6, cameraHeight);
    }
    if (controls.cameraTiltDown) {
      cameraHeight -= 2 * delta;
      cameraHeight = Math.max(1.5, cameraHeight);
    }
    if (controls.cameraZoomIn) {
      cameraDistance -= 3 * delta;
      cameraDistance = Math.max(3, cameraDistance);
    }
    if (controls.cameraZoomOut) {
      cameraDistance += 3 * delta;
      cameraDistance = Math.min(10, cameraDistance);
    }
    
    // Smoothly update camera position based on current character
    const targetX = currentCharacter.position.x + Math.sin(cameraAngle) * cameraDistance;
    const targetZ = currentCharacter.position.z + Math.cos(cameraAngle) * cameraDistance;
    const targetY = currentCharacter.position.y + cameraHeight;
    
    camera.position.x += (targetX - camera.position.x) * 5 * delta;
    camera.position.z += (targetZ - camera.position.z) * 5 * delta;
    camera.position.y += (targetY - camera.position.y) * 5 * delta;
    
    // Look at current character with slight offset
    camera.lookAt(
      currentCharacter.position.x,
      currentCharacter.position.y + 1,
      currentCharacter.position.z
    );
  };
  
  // Modify the checkCollectibles function to use the current character
  const originalCheckCollectibles = checkCollectibles;
  checkCollectibles = function() {
    const currentCharacter = characterManager.getCurrentCharacter();
    
    gems.forEach((gem, index) => {
      if (gem.visible) {
        const distance = currentCharacter.position.distanceTo(gem.position);
        if (distance < 1.5) {
          // Collect the gem
          gem.visible = false;
          score++;
          gemCountElement.textContent = score;
          
          // Collection effect
          particleSystem.spawn(gem.position, 15, 'sparkle');
          
          // Respawn gem in a new location after delay
          setTimeout(() => {
            const distance = 5 + Math.random() * 15;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.sin(angle) * distance;
            const z = Math.cos(angle) * distance;
            gem.position.set(x, 0.8, z);
            gem.visible = true;
          }, 5000);
        }
      }
    });
  };
  
  // Restart animation loop
  animate();
}

    function animate() {
      requestAnimationFrame(animate);
      
      // Get delta time and elapsed time
      const delta = Math.min(clock.getDelta(), 0.1);
      const time = clock.getElapsedTime();
      
      // Update FPS counter
      updateFPS();
      
      // Update character controller
      const moving = updateCharacter(delta);
      
      // Update character animations
      updateCharacterAnimations(time, delta, moving);
      
      // Update camera position
      updateCamera(delta);
      
      // Update skybox (day/night cycle)
      sky.update(time);
      
      // Update water effects
      water.update(time);
      
      // Update particle system
      particleSystem.update(delta);
      
      // Update collectible gems
      gems.forEach(gem => {
        if (gem.update) gem.update(time);
      });
      
      // Check for collectibles
      checkCollectibles();
      
      // Render the scene
      renderer.render(scene, camera);
    }
    

    // Start the animation loop
    animate();
    // Call this function to initialize character selection and update the game loop
updateMainAnimationLoop();

    // Hide instructions after 10 seconds
    setTimeout(() => {
      const instructions = document.querySelector('.instructions');
      if (instructions) {
        instructions.style.opacity = '0';
        instructions.style.transition = 'opacity 1s';
      }
    }, 10000);
// Create the stone wall texture for the hallway
function createStoneWallTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 512;
  const ctx = canvas.getContext('2d');
  
  // Base stone color
  ctx.fillStyle = '#777777';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Add stone patterns
  for (let i = 0; i < 300; i++) {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const width = 20 + Math.random() * 40;
    const height = 10 + Math.random() * 30;
    
    // Vary the stone colors
    const grayValue = 100 + Math.random() * 80;
    ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue * 0.95})`;
    
    // Create rounded stones
    ctx.beginPath();
    ctx.ellipse(x, y, width/2, height/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Add some cracks
    if (Math.random() > 0.7) {
      ctx.strokeStyle = `rgba(60, 60, 60, 0.5)`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + (Math.random() - 0.5) * width, y + (Math.random() - 0.5) * height);
      ctx.stroke();
    }
  }
  
  // Add highlights and shadows to create texture depth
  for (let i = 0; i < 1000; i++) {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const size = 1 + Math.random() * 3;
    
    if (Math.random() > 0.5) {
      // Highlights
      ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.2})`;
    } else {
      // Shadows
      ctx.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.3})`;
    }
    
    ctx.fillRect(x, y, size, size);
  }
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(4, 4);
  
  return texture;
}

// Create the crash-style linear level
function createCrashLevel() {
  const levelGroup = new THREE.Group();
  
  // Get stone texture for walls
  const stoneTexture = createStoneWallTexture();
  
  // Create wall material with the texture
  const wallMaterial = new THREE.MeshStandardMaterial({
    map: stoneTexture,
    roughness: 0.8,
    metalness: 0.2,
    bumpMap: stoneTexture,
    bumpScale: 0.05
  });
  
  // Create floor material (path)
  const floorMaterial = new THREE.MeshStandardMaterial({
    map: createJungleFloorTexture(),
    roughness: 0.9,
    metalness: 0.1
  });
  
  // Level parameters
  const levelLength = 300; // Total length of the level
  const sectionLength = 10; // Length of each section
  const hallwayWidth = 8;   // Width of the hallway
  const wallHeight = 6;     // Height of the walls
  
  // Create the level sections
  const levelSections = [];
  const gapPositions = [];  // Store positions of gaps for collision detection
  
  // FIX 4: Track the number of gems we add to ensure we reach 100
  let gemCount = 0;
  
  for (let z = 0; z < levelLength; z += sectionLength) {
    // FIX 2: Make gaps smaller and less frequent (only 10% chance instead of 20%)
    // Also make the gap only 4 units instead of 5
    const isGap = Math.random() > 0.9 && z > 30; // No gaps in the first 30 units
    
    if (!isGap) {
      // Create floor section
      const floorGeometry = new THREE.BoxGeometry(hallwayWidth, 1, sectionLength);
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      // FIX 3: Lower the floor position
      floor.position.set(0, -1.0, z + sectionLength/2);
      floor.receiveShadow = true;
      levelGroup.add(floor);
      
      // Add section to array for collision detection
      levelSections.push({
        start: z,
        end: z + sectionLength,
        type: 'floor'
      });
      
      // FIX 3: Add decorative bamboo inside the hallway but lower its position
      const bamboosPerSection = 3;
      for (let i = 0; i < bamboosPerSection; i++) {
        // Position bamboo randomly along hallway edges (not in the center path)
        const side = Math.random() > 0.5 ? 1 : -1;
        const offsetX = side * (1.5 + Math.random() * 2); // Keep bamboo near walls
        const offsetZ = Math.random() * sectionLength;
        
        const bamboo = createBamboo(offsetX, z + offsetZ);
        // FIX 3: Lower bamboo position by adjusting its y position
        bamboo.position.y -= 0.4; // Lower bamboo by 0.4 units
        // Adjust bamboo scale to fit in hallway
        bamboo.scale.set(0.7, 0.7, 0.7);
        levelGroup.add(bamboo);
      }
      
      // FIX 4: Add more gems along the path
      // Ensure we add exactly 100 gems by the end of the level
      // Calculate how many gems we should add to this section
      // to distribute 100 gems evenly across the level
      const sectionsLeft = Math.ceil((levelLength - z) / sectionLength);
      const gemsRemaining = 100 - gemCount;
      const gemsPerSection = Math.ceil(gemsRemaining / sectionsLeft);
      
      // Add gems to this section
      for (let i = 0; i < gemsPerSection && gemCount < 100; i++) {
        const gemX = (Math.random() - 0.5) * 4; // Keep gems within path
        const gemZ = z + Math.random() * sectionLength;
        // FIX 3: Lower gem position as well
        const gem = createGem(gemX, 0.6, gemZ); // Lower from 0.8 to 0.6
        levelGroup.add(gem);
        gems.push(gem); // Add to the global gems array
        gemCount++;
      }
    } else {
      // FIX 2: This is a gap section - make it smaller (only 4 units wide)
      const gapLength = 4; // Reduced from 5 (half section) to 4 units
      const gapStart = z + (sectionLength - gapLength) / 2; // Center the gap in the section
      const gapEnd = gapStart + gapLength;
      
      gapPositions.push({
        start: gapStart,
        end: gapEnd,
        center: gapStart + gapLength / 2
      });
      
      // Create floor for the first part of the section
      const firstFloorLength = (sectionLength - gapLength) / 2;
      const floorGeometry1 = new THREE.BoxGeometry(hallwayWidth, 1, firstFloorLength);
      const floor1 = new THREE.Mesh(floorGeometry1, floorMaterial);
      floor1.position.set(0, -1.0, z + firstFloorLength / 2);
      floor1.receiveShadow = true;
      levelGroup.add(floor1);
      
      // Create floor for the last part of the section
      const floorGeometry2 = new THREE.BoxGeometry(hallwayWidth, 1, firstFloorLength);
      const floor2 = new THREE.Mesh(floorGeometry2, floorMaterial);
      floor2.position.set(0, -1.0, z + sectionLength - firstFloorLength / 2);
      floor2.receiveShadow = true;
      levelGroup.add(floor2);
      
      levelSections.push({
        start: z,
        end: gapStart,
        type: 'floor'
      });
      
      levelSections.push({
        start: gapStart,
        end: gapEnd,
        type: 'gap'
      });
      
      levelSections.push({
        start: gapEnd,
        end: z + sectionLength,
        type: 'floor'
      });
      
      // Add visual hint for the gap (particles or something)
      const warningLight = new THREE.PointLight(0xff0000, 0.8, 10);
      warningLight.position.set(0, 1, z + sectionLength/2);
      levelGroup.add(warningLight);
    }
    
    // Left wall for this section
    const leftWallGeometry = new THREE.BoxGeometry(1, wallHeight, sectionLength);
    const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
    // FIX 3: Adjust wall height position to match the new floor height
    leftWall.position.set(-hallwayWidth/2 - 0.5, wallHeight/2 - 1.0, z + sectionLength/2);
    leftWall.castShadow = true;
    leftWall.receiveShadow = true;
    levelGroup.add(leftWall);
    
    // Right wall for this section
    const rightWallGeometry = new THREE.BoxGeometry(1, wallHeight, sectionLength);
    const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
    // FIX 3: Adjust wall height position to match the new floor height
    rightWall.position.set(hallwayWidth/2 + 0.5, wallHeight/2 - 1.0, z + sectionLength/2);
    rightWall.castShadow = true;
    rightWall.receiveShadow = true;
    levelGroup.add(rightWall);
  }
  
  // Add end goal marker
  const finishMarkerGeometry = new THREE.BoxGeometry(hallwayWidth, 5, 1);
  const finishMarkerMaterial = new THREE.MeshStandardMaterial({
    color: 0x00ff00,
    emissive: 0x00aa00,
    transparent: true,
    opacity: 0.5
  });
  const finishMarker = new THREE.Mesh(finishMarkerGeometry, finishMarkerMaterial);
  // FIX 3: Adjust marker height
  finishMarker.position.set(0, 1.5, levelLength);
  levelGroup.add(finishMarker);
  
  console.log(`Created crash level with ${gemCount} gems`);
  
  // Store level data in the group for access
  levelGroup.userData = {
    length: levelLength,
    sections: levelSections,
    gaps: gapPositions,
    width: hallwayWidth,
    startPosition: new THREE.Vector3(0, 0, 5) // Starting position for player
  };
  
  return levelGroup;
}

// Reset character to the start of the level
function resetCharacterToStart(character, level) {
  character.position.copy(level.userData.startPosition);
  character.animationState.isJumping = false;
  character.animationState.isInAir = false;
  character.animationState.jumpVelocity = 0;
  
  // Create reset particle effect
  particleSystem.spawn(character.position, 20, 'sparkle');
}

// Check if character is in bounds of the level
function checkLevelBounds(character, level) {
  const levelData = level.userData;
  const characterPos = character.position;
  
  // Check if character is within the hallway width
  if (Math.abs(characterPos.x) > levelData.width / 2) {
    // Push character back into hallway
    const boundaryX = Math.sign(characterPos.x) * (levelData.width / 2 - 0.5);
    character.position.x = boundaryX;
    return false;
  }
  
  // Check if character has fallen off a gap
  let isOnGap = false;
  for (const gap of levelData.gaps) {
    if (characterPos.z > gap.start && characterPos.z < gap.end) {
      isOnGap = true;
      
      // If character is over a gap, make sure gravity is applied
      if (!character.animationState.isInAir) {
        character.animationState.isInAir = true;
        character.animationState.jumpVelocity = 0; // Start falling immediately
      }
      
      // If character is on a gap and falls below a threshold, they fell off
      if (characterPos.y < -5) {
        resetCharacterToStart(character, level);
        return false;
      }
    }
  }
  
  return true;
}

// Check for level completion
function checkLevelCompletion(character, level) {
  // Check if character has reached the end of the level AND collected enough gems
  if (character.position.z >= level.userData.length && score >= 100) {
    // Display level complete message
    alert('Level Complete! You collected ' + score + ' gems!');
    
    // Reset character to start
    resetCharacterToStart(character, level);
    return true;
  } else if (character.position.z >= level.userData.length && score < 100) {
    // Not enough gems, show message and reset to start
    alert('You need to collect 100 gems to complete the level! You only have ' + score);
    resetCharacterToStart(character, level);
    return false;
  }
  
  return false;
}

// Store the original update functions
let originalUpdateCharacter = null;
let originalAnimate = null;
let crashLevel = null;

// Initialize the crash level
function initCrashLevel() {
  // Store original functions if not already stored
  if (!originalUpdateCharacter) {
    originalUpdateCharacter = updateCharacter;
  }
  
  if (!originalAnimate) {
    originalAnimate = animate;
  }
  
  // Remove or hide existing environment elements
  floor.visible = false;
  
  // Hide bamboos in the open world
  bamboos.forEach(bamboo => {
    bamboo.visible = false;
  });
  
  // Hide existing gems
  gems.forEach(gem => {
    gem.visible = false;
  });
  
  // Clear gems array but keep reference
  gems.length = 0;
  
  // Create and add the crash-style level
  crashLevel = createCrashLevel();
  scene.add(crashLevel);
  
  // Get current character and set starting position
  const character = getCurrentCharacter();
  character.position.copy(crashLevel.userData.startPosition);
  
  // Override updateCharacter to include level bounds checking
  updateCharacter = function(delta) {
    // Get current character - proper way to handle character selection
    const character = getCurrentCharacter();
    
    // Process jump input
    if (controls.jump && !character.animationState.isInAir) {
      character.animationState.isJumping = true;
      character.animationState.isInAir = true;
      character.animationState.jumpVelocity = 8;
    }
    
    // Check if character is over a gap before applying gravity or landing checks
    let isOverGap = false;
    
    if (crashLevel) {
      // Check all gap positions in the level
      for (const gap of crashLevel.userData.gaps) {
        if (character.position.z > gap.start && character.position.z < gap.end) {
          isOverGap = true;
          
          // If character is over a gap and not already falling, make them fall
          if (!character.animationState.isInAir) {
            character.animationState.isInAir = true;
            character.animationState.jumpVelocity = 0; // Start falling immediately
          }
          break;
        }
      }
    }
    
    // Apply gravity
    if (character.animationState.isInAir) {
      character.animationState.jumpVelocity -= gravity * delta;
      character.position.y += character.animationState.jumpVelocity * delta;
      
      // Only check for landing if NOT over a gap
      if (!isOverGap && character.position.y <= character.animationState.groundY) {
        character.position.y = character.animationState.groundY;
        character.animationState.isInAir = false;
        character.animationState.isJumping = false;
        
        // Spawn dust particles on landing
        particleSystem.spawn(
          new THREE.Vector3(
            character.position.x,
            character.position.y - 0.5,
            character.position.z
          ),
          10,
          'dust'
        );
      }
    }
    
    // Handle movement
    let moving = false;
    const moveSpeed = 5.0 * delta;
    
    // Get camera direction for relative movement
    let cameraForward = new THREE.Vector3(0, 0, -1);
    cameraForward.applyQuaternion(camera.quaternion);
    cameraForward.y = 0; // Project onto XZ plane
    cameraForward.normalize();
    
    // Get the right vector
    let cameraRight = new THREE.Vector3(cameraForward.z, 0, -cameraForward.x);
    
    // Initialize movement vector
    let moveVector = new THREE.Vector3(0, 0, 0);
    let targetRotationY = character.rotation.y;
    
    // Calculate movement based on camera orientation
    if (controls.moveForward) {
      moveVector.add(cameraForward);
      targetRotationY = Math.atan2(cameraForward.x, cameraForward.z);
      moving = true;
    }
    if (controls.moveBackward) {
      moveVector.sub(cameraForward);
      targetRotationY = Math.atan2(-cameraForward.x, -cameraForward.z);
      moving = true;
    }
    if (controls.moveLeft) {
      moveVector.sub(cameraRight);
      targetRotationY = Math.atan2(-cameraRight.x, -cameraRight.z);
      moving = true;
    }
    if (controls.moveRight) {
      moveVector.add(cameraRight);
      targetRotationY = Math.atan2(cameraRight.x, cameraRight.z);
      moving = true;
    }
    
    // Calculate diagonal movement
    if (controls.moveForwardLeft) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight.clone().multiplyScalar(-1)).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveForwardRight) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveBackwardLeft) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight.clone().multiplyScalar(-1)).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveBackwardRight) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    
    // Normalize and apply movement
    if (moving) {
      moveVector.normalize();
      
      // Apply movement speed
      character.position.x += moveVector.x * moveSpeed;
      character.position.z += moveVector.z * moveSpeed;
      
      // Smoothly rotate character to face movement direction
      const rotationSpeed = 10 * delta;
      character.rotation.y = THREE.MathUtils.lerp(
        character.rotation.y,
        targetRotationY,
        rotationSpeed
      );
      
      // Generate footstep particles
      if (!character.animationState.isInAir && Math.sin(performance.now() * 0.01) > 0.9) {
        particleSystem.spawn(
          new THREE.Vector3(
            character.position.x,
            character.position.y - 0.5,
            character.position.z
          ),
          3,
          'dust'
        );
      }
    }
    
    // Set animation state
    character.animationState.isWalking = moving && !character.animationState.isInAir;
    
    // Check if character is on valid ground and if level is completed
    checkLevelBounds(character, crashLevel);
    checkLevelCompletion(character, crashLevel);
    
    // Return movement status
    return moving;
  };
  
  // Reset score for level
  score = 0;
  gemCountElement.textContent = score;
  
  // Add level UI
  const levelUI = document.createElement('div');
  levelUI.id = 'level-ui';
  levelUI.style.position = 'absolute';
  levelUI.style.top = '100px';
  levelUI.style.left = '20px';
  levelUI.style.color = 'white';
  levelUI.style.fontFamily = 'Arial, sans-serif';
  levelUI.style.backgroundColor = 'rgba(0,0,0,0.6)';
  levelUI.style.padding = '10px';
  levelUI.style.borderRadius = '5px';
  levelUI.style.zIndex = '1000';
  levelUI.innerHTML = 'Goal: Collect 100 gems without falling!';
  document.body.appendChild(levelUI);
  
  return true;
}

// Clean up crash level and return to open world
function cleanupCrashLevel() {
  if (!crashLevel) return false;
  
  // Restore original environment
  floor.visible = true;
  
  // Show bamboos
  bamboos.forEach(bamboo => {
    bamboo.visible = true;
  });
  
  // Remove level UI
  const levelUI = document.getElementById('level-ui');
  if (levelUI) {
    document.body.removeChild(levelUI);
  }
  
  // Restore original gems
  gems.length = 0;
  for (let i = 0; i < 10; i++) {
    const distance = 3 + Math.random() * 15;
    const angle = Math.random() * Math.PI * 2;
    const x = Math.sin(angle) * distance;
    const z = Math.cos(angle) * distance;
    const gem = createGem(x, 0.8, z);
    scene.add(gem);
    gems.push(gem);
  }
  
  // Remove level
  scene.remove(crashLevel);
  crashLevel = null;
  
  // Restore original update function
  if (originalUpdateCharacter) {
    updateCharacter = originalUpdateCharacter;
  }
  
  // Reset score
  score = 0;
  gemCountElement.textContent = score;
  
  // Reset character position
  const character = getCurrentCharacter();
  character.position.set(0, 0, 0);
  
  return true;
}

// Make character manager available globally if it exists
window.addEventListener('load', function() {
  setTimeout(() => {
    if (typeof characterManager !== 'undefined') {
      window.characterManager = characterManager;
    }
  }, 1000);
});

// Call this function to add the level switch button
addLevelSwitchButton();

// Add a button to switch between open world and crash level
function addLevelSwitchButton() {
  const button = document.createElement('button');
  button.textContent = 'Start Crash Level';
  button.style.position = 'absolute';
  button.style.top = '80px';
  button.style.right = '20px';
  button.style.padding = '10px 20px';
  button.style.borderRadius = '5px';
  button.style.border = 'none';
  button.style.backgroundColor = '#ff5500';
  button.style.color = 'white';
  button.style.fontWeight = 'bold';
  button.style.cursor = 'pointer';
  button.style.zIndex = '1000';
  button.id = 'level-switch-button';
  
  let crashLevelActive = false;
  
  button.addEventListener('click', () => {
    if (crashLevelActive) {
      // Return to open world
      cleanupCrashLevel();
      button.textContent = 'Start Crash Level';
      button.style.backgroundColor = '#ff5500';
      crashLevelActive = false;
    } else {
      // Start crash level
      initCrashLevel();
      button.textContent = 'Return to Open World';
      button.style.backgroundColor = '#00aa00';
      crashLevelActive = true;
    }
  });
  
  document.body.appendChild(button);
}

// =========== FIXES FOR PANDA33.HTML GAME ===========

// ===== FIX 1: Arm Animation =====
// The problem is the animation references are correct but the Character Manager 
// implementation isn't properly connecting to the animation system.

// Add this function to properly get the current character
function getCurrentCharacter() {
  if (window.characterManager) {
    return window.characterManager.getCurrentCharacter();
  } 
  return panda; // Default to panda if characterManager not available
}

// ===== FIX 2: Level Switch Button =====
// The button click handler looks correct but may not be executing properly.
// Update the button click handler to ensure it toggles correctly

function fixLevelSwitchButton() {
  const button = document.getElementById('level-switch-button');
  if (!button) return;
  
  // Clear existing event listeners by cloning and replacing
  const newButton = button.cloneNode(true);
  button.parentNode.replaceChild(newButton, button);
  
  let crashLevelActive = false;
  
  newButton.addEventListener('click', () => {
    if (crashLevelActive) {
      // Return to open world
      cleanupCrashLevel();
      newButton.textContent = 'Start Crash Level';
      newButton.style.backgroundColor = '#ff5500';
      crashLevelActive = false;
    } else {
      // Start crash level
      initCrashLevel();
      newButton.textContent = 'Return to Open World';
      newButton.style.backgroundColor = '#00aa00';
      crashLevelActive = true;
    }
  });
  
  console.log("Level switch button fixed");
}

// ===== FIX 3: Remove Panda Belly =====
// The panda belly can be removed by modifying the createPS2Panda function

function removePandaBelly() {
  // Find the panda in the scene
  const character = getCurrentCharacter();
  
  // If it's the panda, remove the belly
  if (character === panda && character.belly) {
    // Set belly visible to false rather than removing to avoid breaking references
    character.belly.visible = false;
    console.log("Panda belly removed");
  }
}

// ===== FIX 4: Camera panning outside walls in crash level =====
// We need to modify the updateCamera function to constrain the camera 
// within the hallway when in crash level mode

function fixCameraConstraints() {
  // Store the original updateCamera function
  const originalUpdateCamera = updateCamera;
  
  // Override the camera update function
  updateCamera = function(delta) {
    const character = getCurrentCharacter();
    
    // Camera controls
    if (controls.cameraTurnLeft) {
      cameraAngle += 2 * delta;
    }
    if (controls.cameraTurnRight) {
      cameraAngle -= 2 * delta;
    }
    if (controls.cameraTiltUp) {
      cameraHeight += 2 * delta;
      cameraHeight = Math.min(6, cameraHeight);
    }
    if (controls.cameraTiltDown) {
      cameraHeight -= 2 * delta;
      cameraHeight = Math.max(1.5, cameraHeight);
    }
    if (controls.cameraZoomIn) {
      cameraDistance -= 3 * delta;
      cameraDistance = Math.max(3, cameraDistance);
    }
    if (controls.cameraZoomOut) {
      cameraDistance += 3 * delta;
      cameraDistance = Math.min(10, cameraDistance);
    }
    
    // Instead of constraining camera angle, we'll allow free horizontal movement
    // but ensure the camera stays within walls by adjusting the position later
    
    // Calculate camera position based on character and angle
    const targetX = character.position.x + Math.sin(cameraAngle) * cameraDistance;
    const targetZ = character.position.z + Math.cos(cameraAngle) * cameraDistance;
    const targetY = character.position.y + cameraHeight;
    
    // Apply constraints to camera position in crash level
    if (crashLevel) {
      // Get hallway width for constraints
      const hallwayWidth = crashLevel.userData.width;
      
      // Calculate x-axis constraints based on distance from hallway center
      // This creates a "flexible" boundary that allows camera to orbit freely
      // when near center but gets constrained when approaching walls
      const characterDistanceFromCenter = Math.abs(character.position.x);
      const maxAllowedDistance = hallwayWidth / 2 - 1; // Keep 1 unit away from walls
      
      // Calculate maximum allowed camera angle deviation based on character position
      // If character is in center, allow full orbit; if near walls, constrain
      const angleConstraintFactor = Math.min(1, (maxAllowedDistance - characterDistanceFromCenter) / maxAllowedDistance);
      
      // Calculate constrained targetX that allows free movement until approaching walls
      let constrainedTargetX = targetX;
      
      // Only apply constraints when character is near walls
      if (Math.abs(character.position.x) > maxAllowedDistance * 0.5) {
        // Bias the camera position toward the center of the hallway
        // The closer to the wall, the more bias is applied
        const centerBias = 1 - angleConstraintFactor;
        constrainedTargetX = targetX * angleConstraintFactor;
      }
      
      // Add one final safety constraint to never go outside the walls
      constrainedTargetX = Math.max(-maxAllowedDistance, Math.min(maxAllowedDistance, constrainedTargetX));
      
      // Apply the constrained movement
      camera.position.x += (constrainedTargetX - camera.position.x) * 5 * delta;
      camera.position.z += (targetZ - camera.position.z) * 5 * delta;
      camera.position.y += (targetY - camera.position.y) * 5 * delta;
    } else {
      // Normal open world camera movement (unconstrained)
      camera.position.x += (targetX - camera.position.x) * 5 * delta;
      camera.position.z += (targetZ - camera.position.z) * 5 * delta;
      camera.position.y += (targetY - camera.position.y) * 5 * delta;
    }
    
    // Look at character with slight offset
    camera.lookAt(
      character.position.x,
      character.position.y + 1,
      character.position.z
    );
  };
  
  console.log("Camera constraints in crash level fixed");
}

// ===== FIX 5: Wall collision in crash level =====
// Improve the wall collision detection to prevent going through walls

function fixWallCollision() {
  // The original checkLevelBounds function needs to be more aggressive
  // and push the character further from the walls
  
  // Store the original function
  const originalCheckLevelBounds = checkLevelBounds;
  
  // Override with improved version
  checkLevelBounds = function(character, level) {
    const levelData = level.userData;
    const characterPos = character.position;
    
    // Check if character is within the hallway width with stronger constraint
    if (Math.abs(characterPos.x) > levelData.width / 2 - 0.8) { // Reduce by character width (0.8)
      // Push character back into hallway with a stronger correction
      const boundaryX = Math.sign(characterPos.x) * (levelData.width / 2 - 0.8);
      character.position.x = boundaryX;
      return false;
    }
    
    // Check if character has fallen off a gap
    let isOnGap = false;
    for (const gap of levelData.gaps) {
      if (characterPos.z > gap.start && characterPos.z < gap.end) {
        isOnGap = true;
        
        // If character is over a gap, make sure gravity is applied
        if (!character.animationState.isInAir) {
          character.animationState.isInAir = true;
          character.animationState.jumpVelocity = 0; // Start falling immediately
        }
        
        // If character is on a gap and falls below a threshold, they fell off
        if (characterPos.y < -5) {
          resetCharacterToStart(character, level);
          return false;
        }
      }
    }
    
    return true;
  };
  
  console.log("Wall collision detection improved");
}

// ===== FIX 6: Gaps in floor not loading =====
// The issue appears to be in the gap creation and collision detection

function fixGapsInFloor() {
  // Store original functions
  const originalCreateCrashLevel = createCrashLevel;
  
  // Override with fixes
  createCrashLevel = function() {
    const levelGroup = new THREE.Group();
    
    // Get stone texture for walls
    const stoneTexture = createStoneWallTexture();
    
    // Create wall material with the texture
    const wallMaterial = new THREE.MeshStandardMaterial({
      map: stoneTexture,
      roughness: 0.8,
      metalness: 0.2,
      bumpMap: stoneTexture,
      bumpScale: 0.05
    });
    
    // Create floor material (path)
    const floorMaterial = new THREE.MeshStandardMaterial({
      map: createJungleFloorTexture(),
      roughness: 0.9,
      metalness: 0.1
    });
    
    // Level parameters
    const levelLength = 300; // Total length of the level
    const sectionLength = 10; // Length of each section
    const hallwayWidth = 8;   // Width of the hallway
    const wallHeight = 6;     // Height of the walls
    
    // Create the level sections
    const levelSections = [];
    const gapPositions = [];  // Store positions of gaps for collision detection
    
    // FIX 4: Track the number of gems we add to ensure we reach 100
    let gemCount = 0;
    
    for (let z = 0; z < levelLength; z += sectionLength) {
      // FIX 2: Make gaps smaller and less frequent (only 10% chance instead of 20%)
      // Also make the gap only 4 units instead of 5
      const isGap = Math.random() > 0.9 && z > 30; // No gaps in the first 30 units
      
      if (!isGap) {
        // Create floor section
        const floorGeometry = new THREE.BoxGeometry(hallwayWidth, 1, sectionLength);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        // FIX 3: Lower the floor position
        floor.position.set(0, -1.0, z + sectionLength/2);
        floor.receiveShadow = true;
        levelGroup.add(floor);
        
        // Add section to array for collision detection
        levelSections.push({
          start: z,
          end: z + sectionLength,
          type: 'floor'
        });
        
        // FIX 3: Add decorative bamboo inside the hallway but lower its position
        const bamboosPerSection = 3;
        for (let i = 0; i < bamboosPerSection; i++) {
          // Position bamboo randomly along hallway edges (not in the center path)
          const side = Math.random() > 0.5 ? 1 : -1;
          const offsetX = side * (1.5 + Math.random() * 2); // Keep bamboo near walls
          const offsetZ = Math.random() * sectionLength;
          
          const bamboo = createBamboo(offsetX, z + offsetZ);
          // FIX 3: Lower bamboo position by adjusting its y position
          bamboo.position.y -= 0.4; // Lower bamboo by 0.4 units
          // Adjust bamboo scale to fit in hallway
          bamboo.scale.set(0.7, 0.7, 0.7);
          levelGroup.add(bamboo);
        }
        
        // FIX 4: Add more gems along the path
        // Ensure we add exactly 100 gems by the end of the level
        // Calculate how many gems we should add to this section
        // to distribute 100 gems evenly across the level
        const sectionsLeft = Math.ceil((levelLength - z) / sectionLength);
        const gemsRemaining = 100 - gemCount;
        const gemsPerSection = Math.ceil(gemsRemaining / sectionsLeft);
        
        // Add gems to this section
        for (let i = 0; i < gemsPerSection && gemCount < 100; i++) {
          const gemX = (Math.random() - 0.5) * 4; // Keep gems within path
          const gemZ = z + Math.random() * sectionLength;
          // FIX 3: Lower gem position as well
          const gem = createGem(gemX, 0.6, gemZ); // Lower from 0.8 to 0.6
          levelGroup.add(gem);
          gems.push(gem); // Add to the global gems array
          gemCount++;
        }
      } else {
        // FIX 2: This is a gap section - make it smaller (only 4 units wide)
        const gapLength = 4; // Reduced from 5 (half section) to 4 units
        const gapStart = z + (sectionLength - gapLength) / 2; // Center the gap in the section
        const gapEnd = gapStart + gapLength;
        
        gapPositions.push({
          start: gapStart,
          end: gapEnd,
          center: gapStart + gapLength / 2
        });
        
        // Create floor for the first part of the section
        const firstFloorLength = (sectionLength - gapLength) / 2;
        const floorGeometry1 = new THREE.BoxGeometry(hallwayWidth, 1, firstFloorLength);
        const floor1 = new THREE.Mesh(floorGeometry1, floorMaterial);
        floor1.position.set(0, -1.0, z + firstFloorLength / 2);
        floor1.receiveShadow = true;
        levelGroup.add(floor1);
        
        // Create floor for the last part of the section
        const floorGeometry2 = new THREE.BoxGeometry(hallwayWidth, 1, firstFloorLength);
        const floor2 = new THREE.Mesh(floorGeometry2, floorMaterial);
        floor2.position.set(0, -1.0, z + sectionLength - firstFloorLength / 2);
        floor2.receiveShadow = true;
        levelGroup.add(floor2);
        
        levelSections.push({
          start: z,
          end: gapStart,
          type: 'floor'
        });
        
        levelSections.push({
          start: gapStart,
          end: gapEnd,
          type: 'gap'
        });
        
        levelSections.push({
          start: gapEnd,
          end: z + sectionLength,
          type: 'floor'
        });
        
        // Add visual hint for the gap (particles or something)
        const warningLight = new THREE.PointLight(0xff0000, 0.8, 10);
        warningLight.position.set(0, 1, z + sectionLength/2);
        levelGroup.add(warningLight);
      }
      
      // Left wall for this section
      const leftWallGeometry = new THREE.BoxGeometry(1, wallHeight, sectionLength);
      const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
      // FIX 3: Adjust wall height position to match the new floor height
      leftWall.position.set(-hallwayWidth/2 - 0.5, wallHeight/2 - 1.0, z + sectionLength/2);
      leftWall.castShadow = true;
      leftWall.receiveShadow = true;
      levelGroup.add(leftWall);
      
      // Right wall for this section
      const rightWallGeometry = new THREE.BoxGeometry(1, wallHeight, sectionLength);
      const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
      // FIX 3: Adjust wall height position to match the new floor height
      rightWall.position.set(hallwayWidth/2 + 0.5, wallHeight/2 - 1.0, z + sectionLength/2);
      rightWall.castShadow = true;
      rightWall.receiveShadow = true;
      levelGroup.add(rightWall);
    }
    
    // Add end goal marker
    const finishMarkerGeometry = new THREE.BoxGeometry(hallwayWidth, 5, 1);
    const finishMarkerMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ff00,
      emissive: 0x00aa00,
      transparent: true,
      opacity: 0.5
    });
    const finishMarker = new THREE.Mesh(finishMarkerGeometry, finishMarkerMaterial);
    // FIX 3: Adjust marker height
    finishMarker.position.set(0, 1.5, levelLength);
    levelGroup.add(finishMarker);
    
    console.log(`Created crash level with ${gemCount} gems`);
    
    // Store level data in the group for access
    levelGroup.userData = {
      length: levelLength,
      sections: levelSections,
      gaps: gapPositions,
      width: hallwayWidth,
      startPosition: new THREE.Vector3(0, 0, 5) // Starting position for player
    };
    
    return levelGroup;
  };
  
  // We also need to fix updateCharacter for gap detection
  const originalUpdateCharacter = updateCharacter;
  
  updateCharacter = function(delta) {
    // Get current character
    const character = getCurrentCharacter();
    
    // Process jump input
    if (controls.jump && !character.animationState.isInAir) {
      character.animationState.isJumping = true;
      character.animationState.isInAir = true;
      character.animationState.jumpVelocity = 8;
    }
    
    // Check if character is over a gap before applying gravity or landing checks
    let isOverGap = false;
    
    if (crashLevel) {
      // Check all gap positions in the level
      for (const gap of crashLevel.userData.gaps) {
        if (character.position.z > gap.start && character.position.z < gap.end) {
          isOverGap = true;
          
          // If character is over a gap and not already falling, make them fall
          if (!character.animationState.isInAir) {
            character.animationState.isInAir = true;
            character.animationState.jumpVelocity = 0; // Start falling immediately
          }
          break;
        }
      }
    }
    
    // Apply gravity
    if (character.animationState.isInAir) {
      character.animationState.jumpVelocity -= gravity * delta;
      character.position.y += character.animationState.jumpVelocity * delta;
      
      // Only check for landing if NOT over a gap
      if (!isOverGap && character.position.y <= character.animationState.groundY) {
        character.position.y = character.animationState.groundY;
        character.animationState.isInAir = false;
        character.animationState.isJumping = false;
        
        // Spawn dust particles on landing
        particleSystem.spawn(
          new THREE.Vector3(
            character.position.x,
            character.position.y - 0.5,
            character.position.z
          ),
          10,
          'dust'
        );
      }
    }
    
    // The rest of the movement code stays the same...
    let moving = false;
    const moveSpeed = 5.0 * delta;
    
    // Get camera direction for relative movement
    let cameraForward = new THREE.Vector3(0, 0, -1);
    cameraForward.applyQuaternion(camera.quaternion);
    cameraForward.y = 0; // Project onto XZ plane
    cameraForward.normalize();
    
    // Get the right vector
    let cameraRight = new THREE.Vector3(cameraForward.z, 0, -cameraForward.x);
    
    // Initialize movement vector
    let moveVector = new THREE.Vector3(0, 0, 0);
    let targetRotationY = character.rotation.y;
    
    // Calculate movement based on camera orientation
    if (controls.moveForward) {
      moveVector.add(cameraForward);
      targetRotationY = Math.atan2(cameraForward.x, cameraForward.z);
      moving = true;
    }
    if (controls.moveBackward) {
      moveVector.sub(cameraForward);
      targetRotationY = Math.atan2(-cameraForward.x, -cameraForward.z);
      moving = true;
    }
    if (controls.moveLeft) {
      moveVector.sub(cameraRight);
      targetRotationY = Math.atan2(-cameraRight.x, -cameraRight.z);
      moving = true;
    }
    if (controls.moveRight) {
      moveVector.add(cameraRight);
      targetRotationY = Math.atan2(cameraRight.x, cameraRight.z);
      moving = true;
    }
    
    // Calculate diagonal movement
    if (controls.moveForwardLeft) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight.clone().multiplyScalar(-1)).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveForwardRight) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveBackwardLeft) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight.clone().multiplyScalar(-1)).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveBackwardRight) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    
    // Normalize and apply movement
    if (moving) {
      moveVector.normalize();
      
      // Apply movement speed
      character.position.x += moveVector.x * moveSpeed;
      character.position.z += moveVector.z * moveSpeed;
      
      // Smoothly rotate character to face movement direction
      const rotationSpeed = 10 * delta;
      character.rotation.y = THREE.MathUtils.lerp(
        character.rotation.y,
        targetRotationY,
        rotationSpeed
      );
      
      // Generate footstep particles
      if (!character.animationState.isInAir && Math.sin(performance.now() * 0.01) > 0.9) {
        particleSystem.spawn(
          new THREE.Vector3(
            character.position.x,
            character.position.y - 0.5,
            character.position.z
          ),
          3,
          'dust'
        );
      }
    }
    
    // Set animation state
    character.animationState.isWalking = moving && !character.animationState.isInAir;
    
    // Check if character is on valid ground and if level is completed
    if (crashLevel) {
      checkLevelBounds(character, crashLevel);
      checkLevelCompletion(character, crashLevel);
    }
    
    // Return movement status
    return moving;
  };
  
  console.log("Gaps in floor fixed");
}

// ===== FIX 7: Lower Bamboo Position =====
// We need to make the bamboo sit on the floor properly

function fixBambooPosition() {
  // Adjust bamboo in the open world
  bamboos.forEach(bamboo => {
    bamboo.position.y -= 0.6; // Lower bamboo to sit properly on the floor
  });
  
  console.log("Bamboo positions adjusted");
}

// Apply all fixes together
function applyAllFixes() {
  console.log("Applying all fixes to the game...");
  
  // Add the getCurrentCharacter function globally
  window.getCurrentCharacter = getCurrentCharacter;
  
  // Fix the level switch button
  fixLevelSwitchButton();
  
  // Remove the panda belly
  removePandaBelly();
  
  // Fix camera constraints
  fixCameraConstraints();
  
  // Fix wall collision
  fixWallCollision();
  
  // Fix gaps in floor
  fixGapsInFloor();
  
  // Fix bamboo position
  fixBambooPosition();
  
  console.log("All fixes applied successfully!");
}

// Call this function to apply all the fixes at once
applyAllFixes();

// Set up touch events for the jump button
const jumpButton = document.getElementById('jump-btn');

if (jumpButton) {
  // Start pressing button
  jumpButton.addEventListener('touchstart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    controls.jump = true;
    jumpButton.classList.add('active');
  }, { passive: false });
  
  // Release button
  ['touchend', 'touchcancel'].forEach(eventType => {
    jumpButton.addEventListener(eventType, (e) => {
      e.preventDefault();
      e.stopPropagation();
      controls.jump = false;
      jumpButton.classList.remove('active');
    }, { passive: false });
  });
  
  // Prevent default
  jumpButton.addEventListener('touchmove', (e) => {
    e.preventDefault();
    e.stopPropagation();
  }, { passive: false });
  
  // Also add keyboard controls for desktop users
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      controls.jump = true;
      jumpButton.classList.add('active');
    }
  });
  
  document.addEventListener('keyup', (e) => {
    if (e.code === 'Space') {
      controls.jump = false;
      jumpButton.classList.remove('active');
    }
  });
  
  console.log("Jump button initialized!");
}

// ===== BAMBOO WEAPON CREATION =====

// Create a bamboo stick weapon that can be held by characters
function createBambooWeapon() {
  const weaponGroup = new THREE.Group();
  
  // Create a pivot point for better twirling
  const pivotPoint = new THREE.Object3D();
  weaponGroup.add(pivotPoint);
  
  // Main bamboo stick
  const bambooTexture = createBambooTexture();
  bambooTexture.wrapS = THREE.RepeatWrapping;
  bambooTexture.wrapT = THREE.RepeatWrapping;
  
  const materialA = new THREE.MeshStandardMaterial({ 
    map: bambooTexture,
    color: 0x2d4f1e,
    roughness: 0.8,
    metalness: 0.1
  });
  
  const materialB = new THREE.MeshStandardMaterial({ 
    map: bambooTexture,
    color: 0x3a6324,
    roughness: 0.8,
    metalness: 0.1
  });
  
  // Create bamboo staff segments - 50% longer
  const stickLength = 3.75; // Increased from 2.5 (50% longer)
  const stickRadius = 0.075;
  const segments = 5;
  
  for (let i = 0; i < segments; i++) {
    const segHeight = stickLength / segments;
    const y = i * segHeight - stickLength / 2;
    
    const geometry = new THREE.CylinderGeometry(
      stickRadius,
      stickRadius - 0.005,
      segHeight,
      8,
      1
    );
    
    const material = i % 2 === 0 ? materialA : materialB;
    const segment = new THREE.Mesh(geometry, material);
    segment.position.y = y;
    segment.castShadow = true;
    
    // Add to the pivot point instead of directly to the group
    pivotPoint.add(segment);
  }
  
  // Add decorative elements to the stick
  
  // Red wrap near handle
  const wrapGeometry = new THREE.CylinderGeometry(stickRadius + 0.01, stickRadius + 0.01, 0.1, 8, 1);
  const wrapMaterial = new THREE.MeshStandardMaterial({
    color: 0xff3333,
    roughness: 0.7,
    metalness: 0.2
  });
  
  const wrap = new THREE.Mesh(wrapGeometry, wrapMaterial);
  wrap.position.y = -stickLength / 2 + 0.3;
  pivotPoint.add(wrap);
  
  // A few leaves at the top
  for (let i = 0; i < 3; i++) {
    const leafGeometry = new THREE.PlaneGeometry(0.3, 0.1, 2, 1);
    const leafMaterial = new THREE.MeshStandardMaterial({
      color: 0x44aa44,
      roughness: 0.8,
      metalness: 0.1,
      side: THREE.DoubleSide
    });
    
    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
    
    const angle = (i * Math.PI * 2) / 3;
    leaf.position.set(
      Math.sin(angle) * 0.1,
      stickLength / 2 - 0.1,
      Math.cos(angle) * 0.1
    );
    
    leaf.rotation.x = Math.random() * Math.PI;
    leaf.rotation.y = angle;
    leaf.rotation.z = Math.PI / 4;
    
    leaf.castShadow = true;
    pivotPoint.add(leaf);
  }
  
  // Set the initial rotation to have staff angled slightly upward and forward
  // This is the "ready for action" pose shown in the screenshot
  pivotPoint.rotation.x = -0.3; // Angle upward slightly
  pivotPoint.rotation.z = -0.4; // Angle forward slightly
  
  // Initialize animation state
  weaponGroup.userData = {
    // Spinning attack state
    isSpinning: false,
    spinStartTime: 0,
    spinDuration: 0,
    maxSpinDuration: 5.0, // Maximum spin time in seconds
    currentRotationSpeed: 0,
    cooldownTime: 0,
    cooldownDuration: 0, // Will be set based on how long button was held
    
    // Propeller trail state
    lastTrailTime: 0,
    trailInterval: 0.05 // Time between trail particles
  };
  
  // Add update function for weapon animations
  weaponGroup.update = function(delta, character) {
    if (this.userData.isSpinning) {
      // Calculate how long we've been spinning
      this.userData.spinDuration += delta;
      
      // Calculate rotation speed based on time spinning
      // Start at 1 rotation per second, accelerate to 4, then decelerate
      let rotationsPerSecond = 1.0;
      
      if (this.userData.spinDuration <= 4.0) {
        // Accelerate phase: 1 DPS to 4 DPS over 4 seconds
        rotationsPerSecond = 1.0 + Math.min(3.0, this.userData.spinDuration);
      } else if (this.userData.spinDuration <= 5.0) {
        // Deceleration phase: 4 DPS back to 1 DPS over last second
        const slowDownFactor = (this.userData.spinDuration - 4.0);
        rotationsPerSecond = 4.0 - (3.0 * slowDownFactor);
      }
      
      // Store current rotation speed
      this.userData.currentRotationSpeed = rotationsPerSecond;
      
      // Convert to radians per second
      const radiansPerSecond = rotationsPerSecond * Math.PI * 2;
      
      // Rotate the pivot point instead of the weapon group
      // This creates a true baton-twirling effect where the entire staff rotates
      
      // Main rotation around Z axis (forward-pointing axis) for baton twirl
      this.children[0].rotation.z += radiansPerSecond * delta;
      
      // Add slight wobble on other axes for realism
      this.children[0].rotation.y += radiansPerSecond * delta * 0.2;
      
      // Add rotation around the X axis for full baton twirling
      this.children[0].rotation.x += radiansPerSecond * delta * 0.8;
      
      // Add propeller trail particles
      if (particleSystem && particleSystem.spawn) {
        this.userData.lastTrailTime += delta;
        
        // Spawn trail particles more frequently based on rotation speed
        const trailFrequency = 0.05 / rotationsPerSecond;
        
        if (this.userData.lastTrailTime > trailFrequency) {
          this.userData.lastTrailTime = 0;
          
          // Calculate positions at both ends of the stick for particles
          const worldMatrix = this.children[0].matrixWorld; // Use pivot's matrix
          
          // Top end of stick
          const topPos = new THREE.Vector3(0, stickLength / 2, 0);
          topPos.applyMatrix4(worldMatrix);
          
          // Bottom end of stick
          const bottomPos = new THREE.Vector3(0, -stickLength / 2, 0);
          bottomPos.applyMatrix4(worldMatrix);
          
          // Spawn particles at both ends
          particleSystem.spawn(topPos, 1, 'sparkle');
          particleSystem.spawn(bottomPos, 1, 'sparkle');
        }
      }
      
      // Check if spin time is up
      if (this.userData.spinDuration >= this.userData.maxSpinDuration || !controls.attack) {
        // End spinning and start cooldown
        const spinTime = this.userData.spinDuration;
        this.userData.isSpinning = false;
        this.userData.spinDuration = 0;
        this.userData.cooldownDuration = spinTime; // Cooldown equals time spent spinning
        this.userData.cooldownTime = this.userData.cooldownDuration;
        
        // Create a final burst of particles if spin was held for at least 2 seconds
        if (spinTime >= 2.0 && particleSystem && particleSystem.spawn) {
          // Calculate character's forward direction
          const forward = new THREE.Vector3(
            Math.sin(character.rotation.y), 
            0, 
            Math.cos(character.rotation.y)
          );
          
          // Spawn particles in a circle around character
          const particleCount = Math.min(20, Math.floor(spinTime * 4));
          const radius = Math.min(3, spinTime * 0.6);
          
          for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2;
            const offsetX = Math.sin(angle) * radius;
            const offsetZ = Math.cos(angle) * radius;
            
            const particlePos = new THREE.Vector3(
              character.position.x + offsetX,
              character.position.y + 0.5,
              character.position.z + offsetZ
            );
            
            particleSystem.spawn(particlePos, 2, 'sparkle');
          }
        }
        
        // Reset the staff to its original position immediately
        // Return to the "ready for action" pose
        this.children[0].rotation.x = -0.3; // Upward angle
        this.children[0].rotation.y = 0;
        this.children[0].rotation.z = -0.4; // Forward angle
      }
    } else if (this.userData.cooldownTime > 0) {
      // In cooldown period
      this.userData.cooldownTime -= delta;
      
      // Slow to a stop during cooldown
      if (this.userData.currentRotationSpeed > 0) {
        // Gradually slow down rotation
        this.userData.currentRotationSpeed *= 0.95;
        const radiansPerSecond = this.userData.currentRotationSpeed * Math.PI * 2;
        this.rotation.x += radiansPerSecond * delta;
        
        // Stop completely once speed is very low
        if (this.userData.currentRotationSpeed < 0.1) {
          this.userData.currentRotationSpeed = 0;
        }
      }
    } else {
      // Idle animation - slight bobbing and subtle rotation
      const time = performance.now() * 0.001;
      this.position.y = Math.sin(time * 1.5) * 0.03 + this.userData.basePositionY; // Use stored value
      
      // Reset rotation when not spinning
      if (this.userData.currentRotationSpeed <= 0) {
        // Reset all rotations on the pivot point to return staff to original position
        ['x', 'y', 'z'].forEach(axis => {
          // Reset the pivot's rotation
          this.children[0].rotation[axis] = THREE.MathUtils.lerp(
            this.children[0].rotation[axis],
            0,
            delta * 5
          );
          
          if (Math.abs(this.children[0].rotation[axis]) < 0.01) {
            this.children[0].rotation[axis] = 0;
          }
        });
      }
    }
  };
  
  // Add spin attack trigger function
  weaponGroup.startSpin = function() {
    // Only allow spinning if not in cooldown
    if (!this.userData.isSpinning && this.userData.cooldownTime <= 0) {
      this.userData.isSpinning = true;
      this.userData.spinStartTime = performance.now() * 0.001;
      this.userData.spinDuration = 0;
      this.userData.lastTrailTime = 0;
      return true;
    }
    return false;
  };
  
  // Function to get cooldown progress (0-1)
  weaponGroup.getCooldownProgress = function() {
    if (this.userData.cooldownTime <= 0) return 0;
    return this.userData.cooldownTime / this.userData.cooldownDuration;
  };
  
  return weaponGroup;
}

// Create spinning propeller trail effect
function createPropellerTrailEffect() {
  const trailGroup = new THREE.Group();
  
  // Create the trail effect (circular blur)
  // Make it larger to wrap around the entire spinning staff
  const trailGeometry = new THREE.RingGeometry(1.2, 2.5, 32);
  
  // Create a radial gradient for the trail
  const trailCanvas = document.createElement('canvas');
  trailCanvas.width = 256;
  trailCanvas.height = 256;
  const ctx = trailCanvas.getContext('2d');
  
  // Create radial gradient
  const gradient = ctx.createRadialGradient(128, 128, 80, 128, 128, 128);
  gradient.addColorStop(0, 'rgba(150, 255, 150, 0.6)');
  gradient.addColorStop(0.5, 'rgba(100, 200, 100, 0.3)');
  gradient.addColorStop(1, 'rgba(50, 150, 50, 0)');
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 256, 256);
  
  const trailTexture = new THREE.CanvasTexture(trailCanvas);
  
  const trailMaterial = new THREE.MeshBasicMaterial({
    map: trailTexture,
    transparent: true,
    opacity: 0.7,
    side: THREE.DoubleSide,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  
  const trail = new THREE.Mesh(trailGeometry, trailMaterial);
  trailGroup.add(trail);
  
  // Make the trail invisible by default
  trailGroup.visible = false;
  
  // Add animation control
  trailGroup.animate = function(character, weapon) {
    if (weapon.userData.isSpinning) {
      // Make trail visible
      this.visible = true;
      
      // Position trail around the spinning weapon
      this.position.copy(character.position);
      this.position.y += 1.0; // Position at hand height
      
      // Add slight offset to left side
      const leftSide = new THREE.Vector3(
        Math.sin(character.rotation.y + Math.PI/2) * 0.6,
        0,
        Math.cos(character.rotation.y + Math.PI/2) * 0.6
      );
      this.position.add(leftSide);
      
      // Scale and orientation based on weapon speed and direction
      const speedFactor = weapon.userData.currentRotationSpeed / 4.0;
      const scaleFactor = 0.8 + speedFactor * 0.5;
      this.scale.set(scaleFactor, scaleFactor, 1);
      
      // Match the trail's orientation to follow the staff movement
      this.quaternion.copy(weapon.children[0].quaternion);
      this.rotateX(Math.PI/2); // Keep ring perpendicular to spinning axis
      
      // Adjust opacity based on speed
      this.children[0].material.opacity = 0.2 + speedFactor * 0.7;
    } else {
      // Fade out when not spinning
      if (this.visible) {
        // Gradually reduce opacity until invisible
        this.children[0].material.opacity *= 0.9;
        
        if (this.children[0].material.opacity < 0.05) {
          this.visible = false;
          this.children[0].material.opacity = 0.7; // Reset for next use
        }
      }
    }
  };
  
  return trailGroup;
}

// ===== ADD WEAPON TO CHARACTERS =====

// Function to add bamboo weapon to a character
function addWeaponToCharacter(character) {
  // Only add if the character doesn't already have a weapon
  if (!character.weapon) {
    const weapon = createBambooWeapon();
    
    // Position weapon at the tip of the left hand
    // Position adjusted to be closer to hand as shown in screenshot
    weapon.position.set(0.8, 0.75, 0.2);
    
    // Add the weapon to the character
    character.add(weapon);
    
    // Store reference to weapon
    character.weapon = weapon;
    
    // Store the base position Y value for use in animations
    weapon.userData.basePositionY = weapon.position.y;
    
    console.log("Weapon added to character at hand height");
  }
}

// ===== UI SETUP FOR ATTACK BUTTON =====

// Update center button of the d-pad to be an attack button
function setupAttackButton() {
  const centerButton = document.getElementById('btn-center');
  
  if (centerButton) {
    // Update appearance
    centerButton.textContent = 'SPIN';
    centerButton.classList.remove('center');
    centerButton.style.backgroundColor = 'rgba(200, 50, 50, 0.6)';
    centerButton.style.fontWeight = 'bold';
    centerButton.style.fontSize = '14px';
    centerButton.style.color = 'white';
    centerButton.style.pointerEvents = 'auto';
    centerButton.style.opacity = '1';
    
    // Add event listeners for attack button (hold functionality)
    centerButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      controls.attack = true;
      centerButton.classList.add('active');
    }, { passive: false });
    
    ['touchend', 'touchcancel'].forEach(eventType => {
      centerButton.addEventListener(eventType, (e) => {
        e.preventDefault();
        e.stopPropagation();
        controls.attack = false;
        centerButton.classList.remove('active');
      }, { passive: false });
    });
    
    // Prevent default
    centerButton.addEventListener('touchmove', (e) => {
      e.preventDefault();
      e.stopPropagation();
    }, { passive: false });
    
    // Add keyboard control (E key for attack)
    document.addEventListener('keydown', (e) => {
      if (e.code === 'KeyE') {
        controls.attack = true;
        centerButton.classList.add('active');
      }
    });
    
    document.addEventListener('keyup', (e) => {
      if (e.code === 'KeyE') {
        controls.attack = false;
        centerButton.classList.remove('active');
      }
    });
    
    // Add style for active state
    const style = document.createElement('style');
    style.textContent = `
      #btn-center.active {
        background-color: rgba(200, 30, 30, 0.9) !important;
      }
    `;
    document.head.appendChild(style);
    
    console.log("Spin attack button set up");
  } else {
    console.error("Center button not found in the DOM");
  }
}

// Add a cooldown indicator for the attack button
function addCooldownIndicator() {
  const centerButton = document.getElementById('btn-center');
  if (!centerButton) return;
  
  // Create cooldown overlay
  const cooldownOverlay = document.createElement('div');
  cooldownOverlay.id = 'cooldown-overlay';
  cooldownOverlay.style.position = 'absolute';
  cooldownOverlay.style.bottom = '0';
  cooldownOverlay.style.left = '0';
  cooldownOverlay.style.width = '100%';
  cooldownOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  cooldownOverlay.style.transition = 'height 0.1s linear';
  cooldownOverlay.style.height = '0';
  cooldownOverlay.style.pointerEvents = 'none';
  
  centerButton.style.position = 'relative';
  centerButton.style.overflow = 'hidden';
  centerButton.appendChild(cooldownOverlay);
  
  // Function to update cooldown display
  window.updateCooldownDisplay = function(progress) {
    if (cooldownOverlay) {
      cooldownOverlay.style.height = (progress * 100) + '%';
    }
  };
}

// ===== INTEGRATION WITH EXISTING CODE =====

// Function to initialize attack feature
function initAttackFeature() {
  // Add attack state to controls
  controls.attack = false;
  
  // Create propeller trail effect
  const propellerTrail = createPropellerTrailEffect();
  scene.add(propellerTrail);
  
  // Set up the attack button in the UI
  setupAttackButton();
  addCooldownIndicator();
  
  // Add weapons to both characters if they exist
  if (panda) {
    addWeaponToCharacter(panda);
  }
  
  // If foxCharacter exists, add weapon to it too
  if (window.characterManager && window.characterManager.getFoxyCharacter()) {
    const foxyCharacter = window.characterManager.getFoxyCharacter();
    if (foxyCharacter) {
      addWeaponToCharacter(foxyCharacter);
    }
  }
  
  // Check for character manager to handle weapon switching
  if (window.characterManager) {
    // Store original getCurrentCharacter function
    const originalGetCurrentCharacter = window.characterManager.getCurrentCharacter;
    
    // Override to ensure both characters have weapons when switched
    window.characterManager.getCurrentCharacter = function() {
      const character = originalGetCurrentCharacter();
      
      // Make sure the character has a weapon
      if (character && !character.weapon) {
        addWeaponToCharacter(character);
      }
      
      return character;
    };
  }
  
  // Use a more efficient way to integrate with the animation system
  // Rather than nesting calls to animate (which can cause slowdown),
  // we'll use a separate update function that will be called by the main loop
  
  // Create an update function for the weapon system
  const weaponSystem = {
    lastUpdateTime: performance.now() * 0.001,
    propellerTrail: propellerTrail,
    
    update: function() {
      const character = getCurrentCharacter();
      if (!character || !character.weapon) return;
      
      // Calculate delta time manually to avoid clock.getDelta() calls
      // which can cause issues with multiple calls in the same frame
      const currentTime = performance.now() * 0.001;
      const delta = Math.min(currentTime - this.lastUpdateTime, 0.1); // Cap at 0.1 to prevent large jumps
      this.lastUpdateTime = currentTime;
      
      // Update weapon animations
      character.weapon.update(delta, character);
      
      // Animate propeller trail effect
      this.propellerTrail.animate(character, character.weapon);
      
      // Check for attack command
      if (controls.attack && !character.weapon.userData.isSpinning && character.weapon.userData.cooldownTime <= 0) {
        character.weapon.startSpin();
      }
      
      // Update cooldown display
      if (window.updateCooldownDisplay) {
        window.updateCooldownDisplay(character.weapon.getCooldownProgress());
      }
    }
  };
  
  // Add the weapon system update to the animation loop
  // This uses a safer approach instead of overriding requestAnimationFrame
  const existingAnimate = window.animate;
  
  if (typeof existingAnimate === 'function') {
    window.animate = function() {
      // Call the original animate function
      existingAnimate.apply(this, arguments);
      
      // Then update our weapon system
      weaponSystem.update();
    };
  }
  
  console.log("Propeller spin attack feature initialized");
}

// Make sure we have the getCurrentCharacter function
function getCurrentCharacter() {
  if (window.characterManager) {
    return window.characterManager.getCurrentCharacter();
  }
  return panda; // Default to panda if characterManager not available
}

// ===== INITIALIZATION =====

// Call this function to set up the attack feature
initAttackFeature();

// ===== SIMPLIFIED BAMBOO FIX =====

// Create improved bamboo preserving lighting
function createEnhancedBamboo(x, z) {
  const bambooGroup = new THREE.Group();
  
  // Triple the height as requested
  const height = (3 + Math.random() * 4) * 3;
  const segments = Math.floor(height * 1.5);
  
  // Create the bamboo texture
  const bambooTexture = createBambooTexture();
  bambooTexture.wrapS = THREE.RepeatWrapping;
  bambooTexture.wrapT = THREE.RepeatWrapping;
  bambooTexture.repeat.set(1, segments/2);
  
  // Materials with texture - preserve original materials approach
  const materialA = new THREE.MeshStandardMaterial({ 
    map: bambooTexture,
    color: 0x2d4f1e,
    roughness: 0.8,
    metalness: 0.1
  });
  
  const materialB = new THREE.MeshStandardMaterial({ 
    map: bambooTexture,
    color: 0x3a6324,
    roughness: 0.8,
    metalness: 0.1
  });
  
  // Create bamboo segments
  for (let i = 0; i < segments; i++) {
    const segHeight = height / segments;
    const y = i * segHeight;
    const radius = 0.2 - (i * 0.005);
    
    const geometry = new THREE.CylinderGeometry(
      radius,
      radius - 0.005,
      segHeight,
      8,
      1
    );
    
    const material = i % 2 === 0 ? materialA : materialB;
    const segment = new THREE.Mesh(geometry, material);
    segment.position.y = y + segHeight/2;
    segment.castShadow = true;
    
    segment.userData.originalMaterial = material;
    segment.userData.segmentIndex = i;
    
    bambooGroup.add(segment);
  }
  
  // Add leaves
  for (let i = 0; i < 4; i++) {
    const leafGeometry = new THREE.PlaneGeometry(0.8, 0.4, 3, 2);
    const leafMaterial = new THREE.MeshStandardMaterial({
      color: 0x44aa44,
      roughness: 0.8,
      metalness: 0.1,
      side: THREE.DoubleSide
    });
    
    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
    
    const segment = Math.floor(segments * 0.7) + i;
    const yPos = (segment * height / segments);
    leaf.position.set(
      (Math.random() - 0.5) * 0.6,
      yPos,
      (Math.random() - 0.5) * 0.6
    );
    
    leaf.rotation.x = Math.random() * Math.PI;
    leaf.rotation.y = Math.random() * Math.PI * 2;
    leaf.rotation.z = Math.random() * Math.PI / 4;
    
    leaf.castShadow = true;
    bambooGroup.add(leaf);
  }
  
  // Position with random height
  const randomHeightOffset = Math.random() * -0.6;
  bambooGroup.position.set(x, randomHeightOffset, z);
  
  // Add simple collision cylinder
  const collisionGeometry = new THREE.CylinderGeometry(0.3, 0.3, height, 8, 1);
  const collisionMaterial = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    wireframe: true,
    visible: false 
  });
  
  const collisionBody = new THREE.Mesh(collisionGeometry, collisionMaterial);
  collisionBody.position.y = height / 2;
  bambooGroup.add(collisionBody);
  
  // Add basic properties
  bambooGroup.userData = {
    type: 'bamboo',
    health: 2,
    isDestructible: true,
    isDestroyed: false,
    collisionBody: collisionBody
  };
  
  return bambooGroup;
}

// Simple collision detection for bamboo
function checkBambooCollisions(character, bamboos) {
  if (!character || !bamboos || !bamboos.length) return false;
  
  const characterPosition = new THREE.Vector2(character.position.x, character.position.z);
  let collision = false;
  
  for (const bamboo of bamboos) {
    // Skip destroyed bamboo
    if (bamboo.userData.isDestroyed) continue;
    
    const bambooPosition = new THREE.Vector2(bamboo.position.x, bamboo.position.z);
    const distance = characterPosition.distanceTo(bambooPosition);
    
    // Check if character is colliding with bamboo
    const collisionRadius = 0.3; // Same as the cylinder radius
    const characterRadius = 0.5; // Approximate character radius
    
    if (distance < collisionRadius + characterRadius) {
      // Calculate push direction (away from bamboo)
      const pushDir = new THREE.Vector2().subVectors(characterPosition, bambooPosition).normalize();
      
      // Push character away
      character.position.x = bamboo.position.x + pushDir.x * (collisionRadius + characterRadius + 0.05);
      character.position.z = bamboo.position.z + pushDir.y * (collisionRadius + characterRadius + 0.05);
      
      collision = true;
    }
  }
  
  return collision;
}

// Initialize the bamboo system
function initEnhancedBamboos() {
  console.log("Initializing enhanced bamboos...");
  
  // Store original bamboos in case we need to restore them
  const originalBamboos = [...bamboos];
  
  // Clear existing bamboos array but don't remove from scene yet
  const bamboosToRemove = [...bamboos];
  bamboos.length = 0;
  
  try {
    // Create new bamboos
    for (let i = 0; i < 30; i++) {
      const distance = 5 + Math.random() * 20;
      const angle = Math.random() * Math.PI * 2;
      const x = Math.sin(angle) * distance;
      const z = Math.cos(angle) * distance;
      
      const bamboo = createEnhancedBamboo(x, z);
      scene.add(bamboo);
      bamboos.push(bamboo);
    }
    
    // Now that new bamboos are created, remove old ones
    bamboosToRemove.forEach(bamboo => scene.remove(bamboo));
    
    console.log("Successfully created " + bamboos.length + " enhanced bamboos");
    
    // Add collision detection to character update
    const originalUpdateCharacter = updateCharacter;
    
    updateCharacter = function(delta) {
      // Call the original function and get its return value (moving status)
      const moving = originalUpdateCharacter(delta);
      
      // Get current character
      const character = getCurrentCharacter();
      
      // Check for bamboo collisions
      checkBambooCollisions(character, bamboos);
      
      // Return the original moving status
      return moving;
    };
    
  } catch (error) {
    console.error("Error creating bamboos:", error);
    
    // Restore original bamboos
    bamboos.push(...originalBamboos);
  }
}

// Ensure we get the current character correctly
function getCurrentCharacter() {
  if (window.characterManager) {
    return window.characterManager.getCurrentCharacter();
  }
  return panda; // Default to panda if characterManager not available
}

// Initialize the enhanced bamboo system
initEnhancedBamboos();

// ===== BAMBOO COLLISION FIX =====

// Enhanced collision detection function
function checkBambooCollisions(character, bamboos) {
  if (!character || !bamboos || !bamboos.length) return false;
  
  const characterPosition = new THREE.Vector2(character.position.x, character.position.z);
  let collision = false;
  
  for (const bamboo of bamboos) {
    // Skip destroyed bamboo
    if (bamboo.userData.isDestroyed) continue;
    
    const bambooPosition = new THREE.Vector2(bamboo.position.x, bamboo.position.z);
    const distance = characterPosition.distanceTo(bambooPosition);
    
    // Use a more generous collision radius to ensure player can't pass through
    const collisionRadius = 0.4; // Increased from 0.3
    const characterRadius = 0.5; // Approximate character radius
    
    if (distance < collisionRadius + characterRadius) {
      // Calculate push direction (away from bamboo)
      const pushDir = new THREE.Vector2().subVectors(characterPosition, bambooPosition).normalize();
      
      // Push character away with more force
      const pushDistance = (collisionRadius + characterRadius + 0.1) - distance;
      character.position.x += pushDir.x * pushDistance;
      character.position.z += pushDir.y * pushDistance;
      
      collision = true;
    }
  }
  
  return collision;
}

// Make sure the character movement system properly integrates the collision detection
function fixBambooCollisionSystem() {
  console.log("Setting up enhanced bamboo collision system...");
  
  // Store the original updateCharacter function if it hasn't been stored already
  if (!window.originalUpdateCharacter) {
    window.originalUpdateCharacter = updateCharacter;
  }
  
  // Override updateCharacter to add more robust collision detection
  updateCharacter = function(delta) {
    // Call the original function to get base movement
    const moving = window.originalUpdateCharacter.call(this, delta);
    
    // Get current character
    const character = getCurrentCharacter();
    
    // Perform collision detection AFTER character movement has been processed
    const collision = checkBambooCollisions(character, bamboos);
    
    // Apply collision effects if needed
    if (collision) {
      // You could add collision sounds or visual effects here
    }
    
    // Return the original moving status
    return moving;
  };
  
  // Ensure bamboo has correct collision bodies
  bamboos.forEach(bamboo => {
    // If bamboo doesn't have proper collision properties, add them
    if (!bamboo.userData.collisionBody) {
      const height = bamboo.children.length * 2; // Estimate height from number of segments
      const collisionGeometry = new THREE.CylinderGeometry(0.4, 0.4, height, 8, 1);
      const collisionMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        wireframe: true,
        visible: false
      });
      
      const collisionBody = new THREE.Mesh(collisionGeometry, collisionMaterial);
      collisionBody.position.y = height / 2;
      bamboo.add(collisionBody);
      
      bamboo.userData.collisionBody = collisionBody;
      bamboo.userData.type = 'bamboo';
    }
  });
}

// Helper function to ensure we get the correct character
function getCurrentCharacter() {
  if (window.characterManager) {
    return window.characterManager.getCurrentCharacter();
  }
  return panda; // Default to panda if characterManager isn't available
}

// Apply the collision fix
fixBambooCollisionSystem();

// ===== BAMBOO DESTRUCTION SYSTEM =====

// Add hit and destruction capabilities to bamboo plants
function enableBambooDestruction() {
  console.log("Enabling bamboo destruction system...");
  
  // Apply hit and destroy methods to all bamboos
  bamboos.forEach(bamboo => {
    if (!bamboo.hit) {
      // Add property for tracking hits
      bamboo.userData.health = 2; // 2 hits to destroy as requested
      bamboo.userData.lastHitTime = 0;
      bamboo.userData.isDestructible = true;
      bamboo.userData.isDestroyed = false;
      
      // Add hit method to handle weapon strikes
      bamboo.hit = function(position, force) {
        // Prevent multiple hits in quick succession
        const now = performance.now() * 0.001;
        if (now - this.userData.lastHitTime < 0.5) return false;
        
        this.userData.lastHitTime = now;
        this.userData.health--;
        
        // Show damage effect
        this.showDamageEffect(position);
        
        // Check if bamboo is now destroyed
        if (this.userData.health <= 0 && !this.userData.isDestroyed) {
          this.destroy(position, force);
          return true;
        }
        
        return false;
      };
      
      // Method to show damage effect
      bamboo.showDamageEffect = function(position) {
        // Visual effect for hit - change colors of segments near hit point
        const hitY = position.y - this.position.y;
        
        this.children.forEach(child => {
          // Only affect bamboo segments, not leaves or collision body
          if (child.userData && child.userData.segmentIndex !== undefined) {
            const segmentY = child.position.y;
            const distance = Math.abs(segmentY - hitY);
            
            // If this segment is close to the hit point
            if (distance < 2) {
              // Create a damaged material to show impact
              const damagedMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513, // Brown damage color
                roughness: 0.9,
                metalness: 0.1
              });
              
              // Store original material if not already stored
              if (!child.userData.originalMaterial) {
                child.userData.originalMaterial = child.material;
              }
              
              // Apply damage material
              child.material = damagedMaterial;
              
              // Restore original material after a delay unless destroyed
              setTimeout(() => {
                if (child && !this.userData.isDestroyed && child.userData.originalMaterial) {
                  child.material = child.userData.originalMaterial;
                }
              }, 300);
            }
          }
        });
        
        // Create particle effect at hit position
        if (particleSystem && particleSystem.spawn) {
          // Position the particles at the hit point
          particleSystem.spawn(position, 10, 'dust');
        }
      };
      
      // Method to destroy the bamboo
      bamboo.destroy = function(position, force) {
        if (this.userData.isDestroyed) return;
        
        console.log("Destroying bamboo at", this.position);
        this.userData.isDestroyed = true;
        
        // Generate debris effect with particles
        if (particleSystem && particleSystem.spawn) {
          // Create multiple particle bursts along the height of the bamboo
          const segments = this.children.filter(child => 
            child.userData && child.userData.segmentIndex !== undefined
          );
          
          const height = segments.length > 0 ? 
            Math.max(...segments.map(s => s.position.y)) * 2 : 10;
          
          for (let y = 1; y < height; y += 2) {
            const particlePos = new THREE.Vector3(
              this.position.x + (Math.random() - 0.5) * 0.3,
              this.position.y + y,
              this.position.z + (Math.random() - 0.5) * 0.3
            );
            
            particleSystem.spawn(particlePos, 5, 'dust');
          }
          
          // Create larger particle burst at hit position
          particleSystem.spawn(position, 15, 'dust');
          
          // Add some sparkle effects for style
          particleSystem.spawn(position, 5, 'sparkle');
        }
        
        // Make bamboo pieces fall down
        const segments = [];
        const leaves = [];
        
        this.children.forEach(child => {
          if (child.userData && child.userData.segmentIndex !== undefined) {
            segments.push(child);
          } else if (child.geometry instanceof THREE.PlaneGeometry) {
            leaves.push(child);
          }
        });
        
        // Apply physics to segments
        segments.forEach(segment => {
          // Calculate direction away from hit point
          const segmentPos = new THREE.Vector3().copy(segment.position);
          segmentPos.add(this.position); // Convert to world position
          
          const direction = new THREE.Vector3().subVectors(segmentPos, position).normalize();
          
          // Add some randomness to direction
          direction.x += (Math.random() - 0.5) * 0.5;
          direction.z += (Math.random() - 0.5) * 0.5;
          
          // Calculate force based on distance from hit
          const distance = segmentPos.distanceTo(position);
          const forceMultiplier = Math.max(0.5, 2 - distance / 2) * (force || 1);
          
          // Store physics data in the segment's userData
          segment.userData.physics = {
            velocity: direction.multiplyScalar(forceMultiplier * (0.5 + Math.random() * 0.5)),
            rotationSpeed: new THREE.Vector3(
              (Math.random() - 0.5) * 5,
              (Math.random() - 0.5) * 5,
              (Math.random() - 0.5) * 5
            ),
            gravity: 9.8
          };
        });
        
        // Apply physics to leaves
        leaves.forEach(leaf => {
          leaf.userData.physics = {
            velocity: new THREE.Vector3(
              (Math.random() - 0.5) * 2,
              Math.random() * 1 + 0.5, // Initial upward velocity
              (Math.random() - 0.5) * 2
            ),
            rotationSpeed: new THREE.Vector3(
              (Math.random() - 0.5) * 3,
              (Math.random() - 0.5) * 3,
              (Math.random() - 0.5) * 3
            ),
            gravity: 1.5 // Lower gravity for leaves
          };
        });
        
        // Disable collision detection by removing or hiding the collision body
        const collisionBody = this.children.find(child => 
          child.geometry instanceof THREE.CylinderGeometry && 
          child.material.wireframe
        );
        
        if (collisionBody) {
          collisionBody.visible = false;
          if (this.userData.collisionBody === collisionBody) {
            this.userData.collisionBody = null;
          }
        }
        
        // Add update function for physics animation
        this.update = function(delta) {
          let allSettled = true;
          
          // Update segment physics
          segments.forEach(segment => {
            if (!segment.userData.physics) return;
            
            // Update position
            segment.position.x += segment.userData.physics.velocity.x * delta;
            segment.position.y += segment.userData.physics.velocity.y * delta;
            segment.position.z += segment.userData.physics.velocity.z * delta;
            
            // Apply gravity
            segment.userData.physics.velocity.y -= segment.userData.physics.gravity * delta;
            
            // Update rotation
            segment.rotation.x += segment.userData.physics.rotationSpeed.x * delta;
            segment.rotation.y += segment.userData.physics.rotationSpeed.y * delta;
            segment.rotation.z += segment.userData.physics.rotationSpeed.z * delta;
            
            // Check if piece has settled on ground
            if (segment.position.y + this.position.y < -0.6) { // Floor position is -0.6
              segment.position.y = -0.6 - this.position.y;
              segment.userData.physics.velocity.y = 0;
              
              // Dampen horizontal movement
              segment.userData.physics.velocity.x *= 0.7;
              segment.userData.physics.velocity.z *= 0.7;
              
              // Slow down rotation
              segment.userData.physics.rotationSpeed.multiplyScalar(0.9);
            }
            
            // Check if still moving
            const speed = segment.userData.physics.velocity.length() + 
                        segment.userData.physics.rotationSpeed.length();
            
            if (speed > 0.1) {
              allSettled = false;
            }
          });
          
          // Update leaf physics
          leaves.forEach(leaf => {
            if (!leaf.userData.physics) return;
            
            // Update position with flutter effect
            leaf.position.x += leaf.userData.physics.velocity.x * delta;
            leaf.position.y += leaf.userData.physics.velocity.y * delta;
            leaf.position.z += leaf.userData.physics.velocity.z * delta;
            
            // Add fluttering
            leaf.position.x += Math.sin(performance.now() * 0.005) * 0.01;
            
            // Apply gravity
            leaf.userData.physics.velocity.y -= leaf.userData.physics.gravity * delta;
            
            // Update rotation
            leaf.rotation.x += leaf.userData.physics.rotationSpeed.x * delta;
            leaf.rotation.y += leaf.userData.physics.rotationSpeed.y * delta;
            leaf.rotation.z += leaf.userData.physics.rotationSpeed.z * delta;
            
            // Check if leaf has settled
            if (leaf.position.y + this.position.y < -0.55) {
              leaf.position.y = -0.55 - this.position.y;
              leaf.userData.physics.velocity.y = 0;
              
              // Dampen horizontal movement
              leaf.userData.physics.velocity.x *= 0.8;
              leaf.userData.physics.velocity.z *= 0.8;
              
              // Slow down rotation
              leaf.userData.physics.rotationSpeed.multiplyScalar(0.95);
            }
            
            // Check if still moving
            const speed = leaf.userData.physics.velocity.length() + 
                       leaf.userData.physics.rotationSpeed.length();
            
            if (speed > 0.1) {
              allSettled = false;
            }
          });
          
          // If all pieces have settled, fade out and remove after delay
          if (allSettled && !this.userData.scheduled) {
            this.userData.scheduled = true;
            setTimeout(() => {
              // Fade out pieces
              const fadeInterval = setInterval(() => {
                let allInvisible = true;
                
                [...segments, ...leaves].forEach(piece => {
                  if (!piece.material) return;
                  
                  if (piece.material.opacity === undefined || piece.material.opacity > 0) {
                    // Enable transparency if not already enabled
                    if (!piece.material.transparent) {
                      piece.material.transparent = true;
                    }
                    
                    // Fade out gradually
                    piece.material.opacity = piece.material.opacity !== undefined ? 
                      Math.max(0, piece.material.opacity - 0.05) : 0.95;
                    
                    if (piece.material.opacity > 0) {
                      allInvisible = false;
                    }
                  }
                });
                
                if (allInvisible) {
                  clearInterval(fadeInterval);
                  
                  // Remove from scene
                  if (this.parent) {
                    this.parent.remove(this);
                    
                    // Filter out from bamboos array
                    const index = bamboos.indexOf(this);
                    if (index > -1) {
                      bamboos.splice(index, 1);
                    }
                  }
                }
              }, 100);
            }, 3000);
          }
        };
      };
    }
  });
  
  // Add bamboo update to animation system
  if (!window.bambooUpdateAdded) {
    window.bambooUpdateAdded = true;
    
    const originalAnimate = animate;
    animate = function() {
      // Call original animate
      originalAnimate();
      
      // Get delta time for physics updates
      const delta = Math.min(clock.getDelta(), 0.1);
      
      // Update all bamboos
      for (let i = bamboos.length - 1; i >= 0; i--) {
        const bamboo = bamboos[i];
        if (bamboo.update && bamboo.userData.isDestroyed) {
          bamboo.update(delta);
        }
      }
    };
  }
}

// Check if weapon hits bamboo
function checkWeaponBambooCollision(character, bamboos) {
  if (!character || !character.weapon || !bamboos || !bamboos.length) return;
  
  // Only check when weapon is spinning (attacking)
  if (!character.weapon.userData.isSpinning) return;
  
  // Calculate the weapon reach
  const characterPosition = character.position.clone();
  const weaponReach = 2.0; // Maximum distance the weapon can reach
  
  for (const bamboo of bamboos) {
    // Skip already destroyed bamboo
    if (bamboo.userData.isDestroyed) continue;
    
    const bambooPosition = new THREE.Vector2(bamboo.position.x, bamboo.position.z);
    const characterPos2D = new THREE.Vector2(characterPosition.x, characterPosition.z);
    const distance = characterPos2D.distanceTo(bambooPosition);
    
    // Check if weapon is close enough to hit bamboo
    if (distance < weaponReach) {
      // Determine hit position
      const hitHeight = 1.0 + Math.random() * 0.5; // Around chest height
      const hitPosition = new THREE.Vector3(
        bamboo.position.x,
        bamboo.position.y + hitHeight,
        bamboo.position.z
      );
      
      // Calculate force based on weapon rotation speed
      const force = character.weapon && character.weapon.userData.currentRotationSpeed ? 
                   character.weapon.userData.currentRotationSpeed * 0.5 : 1.0;
      
      // Apply hit to bamboo
      if (bamboo.hit) {
        bamboo.hit(hitPosition, force);
      }
    }
  }
}

// Set up weapon attack detection
function setupWeaponAttackSystem() {
  // Check if weaponSystem exists
  if (!window.weaponSystem) {
    console.log("Creating new weapon system...");
    // Create a minimal weapon system that checks for bamboo hits
    window.weaponSystem = {
      update: function() {
        // Get current character
        const character = getCurrentCharacter();
        
        // Check if character has a weapon and is attacking
        if (character && character.weapon && character.weapon.userData.isSpinning) {
          // Check for weapon hits on bamboo
          checkWeaponBambooCollision(character, bamboos);
        }
      }
    };
    
    // Add to animation loop
    const originalAnimate = animate;
    animate = function() {
      // Call original animate
      originalAnimate();
      
      // Update weapon system
      if (window.weaponSystem) {
        window.weaponSystem.update();
      }
    };
  } else {
    console.log("Enhancing existing weapon system...");
    // Enhance existing weapon system
    const originalWeaponUpdate = window.weaponSystem.update;
    window.weaponSystem.update = function() {
      // Call original update
      originalWeaponUpdate.call(this);
      
      // Get current character
      const character = getCurrentCharacter();
      
      // Check for weapon hits on bamboo
      checkWeaponBambooCollision(character, bamboos);
    };
  }
}

// Get current character helper function
function getCurrentCharacter() {
  if (window.characterManager) {
    return window.characterManager.getCurrentCharacter();
  }
  return panda; // Default to panda if characterManager isn't available
}

// Initialize bamboo destruction system
enableBambooDestruction();
setupWeaponAttackSystem();

  </script>
</body>
</html>