<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cavernous Brick Breaker - Fortress Edition</title>

 <style>
    #gameContainer {
        position: relative;
        width: 95%;
        height: 90vh;
        margin: 10px auto;
        border: 2px solid #444;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
    }
    canvas { 
        display: block; 
        width: 100%; 
        height: 100%; 
    }    

   body { margin: 0; overflow: hidden; touch-action: none; background-color: #000033; }
        
        #score { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            color: white; 
            font-family: Arial, sans-serif;
            font-size: 18px;
            z-index: 10;
        }
        #cash {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #33cc33;
            font-family: Arial, sans-serif;
            font-size: 18px;
            z-index: 10;
        }
        #ballCount {
            position: absolute;
            top: 35px;
            left: 10px;
            color: #ffaa00;
            font-family: Arial, sans-serif;
            font-size: 16px;
            z-index: 10;
        }
        #instructions {
            position: absolute;
            top: 60px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 36px;
            display: none;
            text-align: center;
            z-index: 10;
        }
        #startButton {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            display: none;
            z-index: 10;
        }
        #launchButton {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 100;
            user-select: none;
        }
        #levelSelector {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #levelSelector select {
            padding: 5px;
            border-radius: 5px;
        }
        #pauseButton {
            position: absolute;
            top: 10px;
            right: 120px;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #pauseButton:hover {
            background-color: #777;
        }
        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 50, 0.7);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        #pauseOverlay h2 {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 36px;
            margin-bottom: 20px;
        }
        #resumeButton {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
        }
        #resumeButton:hover {
            background-color: #45a049;
        }
        .pause-icon {
            width: 12px;
            height: 14px;
            position: relative;
            margin-right: 5px;
        }
        .pause-icon::before, .pause-icon::after {
            content: '';
            position: absolute;
            background-color: white;
            width: 4px;
            height: 14px;
        }
        .pause-icon::before {
            left: 0;
        }
        .pause-icon::after {
            right: 0;
        }
        .play-icon {
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 7px 0 7px 12px;
            border-color: transparent transparent transparent white;
            margin-right: 5px;
        }
        
        /* Store styles */
        #storeContainer {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 20;
            background-color: rgba(0, 0, 50, 0.8);
            padding: 12px;
            border-radius: 10px;
            max-width: 90%;
            border: 2px solid #444;
        }
        
        .store-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 8px;
            border: 2px solid #666;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
            min-width: 80px;
        }
        
        .store-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 200, 255, 0.5);
            border-color: #0cf;
        }
        
        .store-item-disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .store-item-disabled:hover {
            transform: none;
            box-shadow: none;
            border-color: #666;
        }
        
        .item-icon {
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 5px;
            font-size: 28px;
        }
        
        .item-cost {
            color: #33ff33;
            font-family: Arial, sans-serif;
            font-size: 15px;
            font-weight: bold;
        }
        
        .item-name {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 11px;
            text-align: center;
            margin-top: 3px;
        }
        
        .notification {
            position: absolute;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
            animation: floatUp 2s ease-out forwards;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px);
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">Score: 0</div>
        <div id="cash">Cash: $3</div>
        <div id="ballCount">Balls: 1</div>
        <div id="instructions">Arrow Keys or Mouse to Move | Space or Click to Launch | Breach the Fortress Above!</div>
        <div id="levelSelector">
            <label>Level:</label>
            <select id="levelSelect">
                <option value="1">Level 1 - Galton Board</option>
                <option value="2">Level 2 - Maze Runner</option>
                <option value="3">Level 3 - The Fortress</option>
                <option value="4">Level 4 - Chaos Chamber</option>
                <option value="5">Level 5 - The Gauntlet</option>
            </select>
        </div>
        <button id="pauseButton"><span class="pause-icon"></span>Pause</button>
        <div id="gameOver">Game Over</div>
        <button id="startButton">Restart</button>
        <button id="launchButton">Launch Ball</button>
        
        <div id="pauseOverlay">
            <h2>Paused</h2>
            <button id="resumeButton">Resume</button>
        </div>
        
        <div id="storeContainer">
            <div class="store-item" id="buyMultiball" title="Launch 3 extra balls">
                <div class="item-icon">‚öæ</div>
                <div class="item-cost">$2</div>
                <div class="item-name">Multi Ball</div>
            </div>
            <div class="store-item" id="buyExpandPaddle" title="Wider paddle for 10 seconds">
                <div class="item-icon">‚ÜîÔ∏è</div>
                <div class="item-cost">$1</div>
                <div class="item-name">Expand</div>
            </div>
            <div class="store-item" id="buyLaser" title="Shoot lasers to destroy bricks">
                <div class="item-icon">üî´</div>
                <div class="item-cost">$2</div>
                <div class="item-name">Laser</div>
            </div>
            <div class="store-item" id="buyBomb" title="Massive explosion destroys nearby bricks">
                <div class="item-icon">üí£</div>
                <div class="item-cost">$3</div>
                <div class="item-name">Mega Bomb</div>
            </div>
            <div class="store-item" id="buySlowTime" title="Slow ball speed for 8 seconds">
                <div class="item-icon">‚è±Ô∏è</div>
                <div class="item-cost">$1</div>
                <div class="item-name">Slow Time</div>
            </div>
            <div class="store-item" id="buyPaddleMultiball" title="Auto-launch balls for 15 seconds">
                <div class="item-icon">üéØ</div>
                <div class="item-cost">$4</div>
                <div class="item-name">Ball Rain</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    let scene, camera, renderer, paddle, balls = [], bricks = [], powerups = [], lasers = [], bombs = [];
    let ballSpeed = 0.09;
    let paddleSpeed = 0.25;
    let score = 0;
    let cash = 3;
    let level = 1;
    let gameActive = false;
    let gamePaused = false;
    let ballLaunched = false;
    let keys = {};
    let mouseX = 0;
    let touchX = 0;
    let animationFrameId = null;
    
    // Expanded boundaries for cavernous levels
    let leftBound = -14;
    let rightBound = 14;
    let topBound = 30;  // Much taller!
    let bottomBound = -10;
    
    // Store powerup timers
    let paddleExpandTimer = null;
    let laserActiveTimer = null;
    let slowTimeTimer = null;
    let paddleMultiballTimer = null;
    let remainingPaddleBalls = 0;
    
    // Powerup effects
    let paddleExpanded = false;
    let laserActive = false;
    let slowTimeActive = false;
    const normalPaddleWidth = 3;
    const expandedPaddleWidth = 5;
    
    function init() {
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x001144);
        
        // Enhanced camera for larger view
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35;
        camera.position.y = 10;
        camera.lookAt(0, 10, 0);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        const container = document.getElementById('gameContainer');
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        // Lighting - enhanced for larger scene
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const pointLight1 = new THREE.PointLight(0xffffff, 0.8);
        pointLight1.position.set(10, 20, 10);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xffffff, 0.8);
        pointLight2.position.set(-10, 20, 10);
        scene.add(pointLight2);
        
        // Create paddle
        const paddleGeometry = new THREE.BoxGeometry(normalPaddleWidth, 0.5, 1);
        const paddleMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        paddle = new THREE.Mesh(paddleGeometry, paddleMaterial);
        paddle.position.y = bottomBound + 0.5;
        scene.add(paddle);
        
        // Create ball
        const ballGeometry = new THREE.SphereGeometry(0.4, 16, 16);
        const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.y = bottomBound + 0.9;
        ball.direction = new THREE.Vector3(0.5, 1, 0).normalize();
        balls.push(ball);
        scene.add(ball);
        
        // Setup game boundaries
        setupGameBoundaries();
        
        // Create bricks
        createBricks();
        
        // Event listeners
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);
        document.addEventListener('mousemove', (e) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        });
        
        renderer.domElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = renderer.domElement.getBoundingClientRect();
            touchX = ((e.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
        });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = renderer.domElement.getBoundingClientRect();
            touchX = ((e.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
        });
        
        document.getElementById('launchButton').addEventListener('click', launchBall);
        document.getElementById('startButton').addEventListener('click', restartGame);
        document.getElementById('pauseButton').addEventListener('click', togglePause);
        document.getElementById('resumeButton').addEventListener('click', resumeGame);
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !ballLaunched && gameActive) {
                e.preventDefault();
                launchBall();
            }
        });
        
        renderer.domElement.addEventListener('click', () => {
            if (!ballLaunched && gameActive) {
                launchBall();
            }
        });
        
        // Level selector
        document.getElementById('levelSelect').addEventListener('change', (e) => {
            level = parseInt(e.target.value);
            if (!gameActive) {
                createBricks();
            }
        });
        
        // Store button event listeners
        document.getElementById('buyMultiball').addEventListener('click', () => buyPowerup('multiball', 2));
        document.getElementById('buyExpandPaddle').addEventListener('click', () => buyPowerup('expand', 1));
        document.getElementById('buyLaser').addEventListener('click', () => buyPowerup('laser', 2));
        document.getElementById('buyBomb').addEventListener('click', () => buyPowerup('bomb', 3));
        document.getElementById('buySlowTime').addEventListener('click', () => buyPowerup('slowtime', 1));
        document.getElementById('buyPaddleMultiball').addEventListener('click', () => buyPowerup('paddleMultiball', 4));
        
        // Window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('gameContainer');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        updateScore();
        updateCash();
        animate();
    }
    
    function setupGameBoundaries() {
        // Visual boundaries for massive cavern
        const wallMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x333366,
            transparent: true,
            opacity: 0.3
        });
        
        // Remove old walls if they exist
        scene.children.filter(child => child.userData.isWall).forEach(wall => scene.remove(wall));
        
        // Left wall
        const leftWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, (topBound - bottomBound) + 5, 2),
            wallMaterial
        );
        leftWall.position.set(leftBound - 0.25, (topBound + bottomBound) / 2, 0);
        leftWall.userData.isWall = true;
        scene.add(leftWall);
        
        // Right wall
        const rightWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, (topBound - bottomBound) + 5, 2),
            wallMaterial
        );
        rightWall.position.set(rightBound + 0.25, (topBound + bottomBound) / 2, 0);
        rightWall.userData.isWall = true;
        scene.add(rightWall);
        
        // Top wall
        const topWall = new THREE.Mesh(
            new THREE.BoxGeometry((rightBound - leftBound) + 1, 0.5, 2),
            wallMaterial
        );
        topWall.position.set(0, topBound + 0.25, 0);
        topWall.userData.isWall = true;
        scene.add(topWall);
    }
    
    function createBricks() {
        // Clear existing bricks
        bricks.forEach(brick => scene.remove(brick));
        bricks = [];
        
        const brickWidth = 1.8;
        const brickHeight = 0.6;
        const brickDepth = 1;
        const cols = 14;
        
        // Calculate zones (bottom third, middle third, top third)
        const zoneHeight = (topBound - bottomBound - 5) / 3;
        const bottomZoneTop = bottomBound + 5 + zoneHeight;
        const middleZoneTop = bottomZoneTop + zoneHeight;
        
        if (level === 1) {
            // Level 1: Galton Board
            createBottomZone(cols, brickWidth, brickHeight, brickDepth, bottomZoneTop);
            createMiddleZone(cols, brickWidth, brickHeight, brickDepth, bottomZoneTop, middleZoneTop);
            createGaltonBoard(cols, brickWidth, brickHeight, brickDepth, middleZoneTop);
        } else if (level === 2) {
            // Level 2: Vertical Maze
            createBottomZone(cols, brickWidth, brickHeight, brickDepth, bottomZoneTop);
            createMiddleZone(cols, brickWidth, brickHeight, brickDepth, bottomZoneTop, middleZoneTop);
            createVerticalMaze(cols, brickWidth, brickHeight, brickDepth, middleZoneTop);
        } else if (level === 3) {
            // Level 3: The Fortress
            createBottomZone(cols, brickWidth, brickHeight, brickDepth, bottomZoneTop);
            createMiddleZone(cols, brickWidth, brickHeight, brickDepth, bottomZoneTop, middleZoneTop);
            createFortress(cols, brickWidth, brickHeight, brickDepth, middleZoneTop);
        } else if (level === 4) {
            // Level 4: Chaos Chamber
            createBottomZone(cols, brickWidth, brickHeight, brickDepth, bottomZoneTop);
            createMiddleZone(cols, brickWidth, brickHeight, brickDepth, bottomZoneTop, middleZoneTop);
            createChaos(cols, brickWidth, brickHeight, brickDepth, middleZoneTop);
        } else if (level === 5) {
            // Level 5: The Gauntlet
            createBottomZone(cols, brickWidth, brickHeight, brickDepth, bottomZoneTop);
            createMiddleZone(cols, brickWidth, brickHeight, brickDepth, bottomZoneTop, middleZoneTop);
            createGauntlet(cols, brickWidth, brickHeight, brickDepth, middleZoneTop);
        }
    }
    
    function createBottomZone(cols, brickWidth, brickHeight, brickDepth, zoneTop) {
        // Bottom zone: Easy 1-hit bricks, scattered pattern for easy access
        const rows = 8;
        const startY = bottomBound + 5;
        
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Create gaps for easier access
                if (Math.random() > 0.75) continue;
                
                const x = leftBound + (col + 0.5) * (rightBound - leftBound) / cols;
                const y = startY + row * brickHeight * 1.2;
                
                createBrick(x, y, brickWidth, brickHeight, brickDepth, 'normal', 1);
            }
        }
    }
    
    function createMiddleZone(cols, brickWidth, brickHeight, brickDepth, startY, endY) {
        // Middle zone: Mix of normal and tough bricks
        const rows = Math.floor((endY - startY) / (brickHeight * 1.2));
        
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (Math.random() > 0.7) continue;
                
                const x = leftBound + (col + 0.5) * (rightBound - leftBound) / cols;
                const y = startY + row * brickHeight * 1.2;
                
                const brickType = Math.random() > 0.6 ? 'tough' : 'normal';
                const hits = brickType === 'tough' ? 2 : 1;
                
                createBrick(x, y, brickWidth, brickHeight, brickDepth, brickType, hits);
            }
        }
    }
    
    function createGaltonBoard(cols, brickWidth, brickHeight, brickDepth, startY) {
        // Galton board: staggered pegs of unbreakable bricks
        const rows = 12;
        
        for (let row = 0; row < rows; row++) {
            const offset = row % 2 === 0 ? 0 : 0.5;
            const numPegs = row % 2 === 0 ? 7 : 6;
            
            for (let peg = 0; peg < numPegs; peg++) {
                const x = leftBound + (peg + offset + 1) * (rightBound - leftBound) / 8;
                const y = startY + row * brickHeight * 1.5;
                
                createBrick(x, y, brickWidth * 0.8, brickHeight, brickDepth, 'metal', Infinity);
            }
        }
        
        // Add some breakable gaps
        for (let i = 0; i < 15; i++) {
            const x = leftBound + Math.random() * (rightBound - leftBound);
            const y = startY + Math.random() * (rows * brickHeight * 1.5);
            createBrick(x, y, brickWidth * 0.6, brickHeight * 0.6, brickDepth, 'tough', 3);
        }
    }
    
    function createVerticalMaze(cols, brickWidth, brickHeight, brickDepth, startY) {
        // Vertical maze with narrow passages
        const rows = 15;
        
        for (let row = 0; row < rows; row++) {
            // Create walls with gaps
            const gapPos = Math.floor(Math.random() * (cols - 2)) + 1;
            const gapWidth = 1 + Math.floor(Math.random() * 2);
            
            for (let col = 0; col < cols; col++) {
                if (col >= gapPos && col < gapPos + gapWidth) {
                    // This is a gap - maybe add a tough brick
                    if (Math.random() > 0.7) {
                        const x = leftBound + (col + 0.5) * (rightBound - leftBound) / cols;
                        const y = startY + row * brickHeight * 1.3;
                        createBrick(x, y, brickWidth * 0.8, brickHeight, brickDepth, 'tough', 2);
                    }
                } else {
                    const x = leftBound + (col + 0.5) * (rightBound - leftBound) / cols;
                    const y = startY + row * brickHeight * 1.3;
                    createBrick(x, y, brickWidth, brickHeight, brickDepth, 'metal', Infinity);
                }
            }
        }
    }
    
    function createFortress(cols, brickWidth, brickHeight, brickDepth, startY) {
        // Fortress: layers of defense with strategic weak points
        const rows = 14;
        
        // Outer walls
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const x = leftBound + (col + 0.5) * (rightBound - leftBound) / cols;
                const y = startY + row * brickHeight * 1.2;
                
                // Create fortress walls
                if (col === 0 || col === cols - 1 || 
                    (row % 3 === 0 && col % 3 !== 1) ||
                    (row % 5 === 2 && col % 2 === 0)) {
                    createBrick(x, y, brickWidth, brickHeight, brickDepth, 'metal', Infinity);
                } else if (Math.random() > 0.5) {
                    // Tough bricks in between
                    createBrick(x, y, brickWidth, brickHeight, brickDepth, 'tough', 3);
                }
            }
        }
        
        // Add treasure room at top (valuable but protected)
        const topRow = rows - 1;
        for (let col = 4; col < 10; col++) {
            const x = leftBound + (col + 0.5) * (rightBound - leftBound) / cols;
            const y = startY + topRow * brickHeight * 1.2;
            if (col === 6 || col === 7) {
                // Small gap to enter
                createBrick(x, y, brickWidth * 0.5, brickHeight, brickDepth, 'tough', 1);
            } else {
                createBrick(x, y, brickWidth, brickHeight, brickDepth, 'metal', Infinity);
            }
        }
    }
    
    function createChaos(cols, brickWidth, brickHeight, brickDepth, startY) {
        // Chaotic pattern with random unbreakable obstacles
        const totalBricks = 120;
        
        for (let i = 0; i < totalBricks; i++) {
            const x = leftBound + Math.random() * (rightBound - leftBound);
            const y = startY + Math.random() * 18;
            
            const rand = Math.random();
            if (rand > 0.7) {
                createBrick(x, y, brickWidth, brickHeight, brickDepth, 'metal', Infinity);
            } else if (rand > 0.4) {
                createBrick(x, y, brickWidth * 0.9, brickHeight, brickDepth, 'tough', 2);
            } else {
                createBrick(x, y, brickWidth * 0.8, brickHeight, brickDepth, 'normal', 1);
            }
        }
    }
    
    function createGauntlet(cols, brickWidth, brickHeight, brickDepth, startY) {
        // The ultimate challenge: narrow passages through dense defenses
        const rows = 16;
        
        for (let row = 0; row < rows; row++) {
            // Create zigzag pattern
            const zigzagOffset = Math.sin(row * 0.5) * 3;
            
            for (let col = 0; col < cols; col++) {
                const x = leftBound + (col + 0.5) * (rightBound - leftBound) / cols;
                const y = startY + row * brickHeight * 1.1;
                
                // Create narrow winding path
                const distFromCenter = Math.abs(col - (cols/2 + zigzagOffset));
                
                if (distFromCenter > 1.5) {
                    createBrick(x, y, brickWidth, brickHeight, brickDepth, 'metal', Infinity);
                } else if (distFromCenter > 0.8 && Math.random() > 0.5) {
                    createBrick(x, y, brickWidth * 0.9, brickHeight, brickDepth, 'tough', 3);
                }
            }
        }
    }
    
    function createBrick(x, y, width, height, depth, type, hitsRequired) {
        let color;
        switch(type) {
            case 'normal':
                color = 0x3399ff;
                break;
            case 'tough':
                color = 0xff9933;
                break;
            case 'metal':
                color = 0x666666;
                break;
            default:
                color = 0x3399ff;
        }
        
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshPhongMaterial({ 
            color: color,
            shininess: type === 'metal' ? 100 : 30
        });
        const brick = new THREE.Mesh(geometry, material);
        brick.position.set(x, y, 0);
        brick.userData = {
            type: type,
            hits: hitsRequired,
            maxHits: hitsRequired
        };
        
        scene.add(brick);
        bricks.push(brick);
    }
    
    function movePaddle() {
        if (gamePaused) return;
        
        let targetX = paddle.position.x;
        
        if (keys['ArrowLeft'] || keys['a']) {
            targetX -= paddleSpeed;
        }
        if (keys['ArrowRight'] || keys['d']) {
            targetX += paddleSpeed;
        }
        
        // Mouse control
        if (mouseX !== 0) {
            targetX = mouseX * (rightBound - 2);
        }
        
        // Touch control
        if (touchX !== 0) {
            targetX = touchX * (rightBound - 2);
        }
        
        // Constrain paddle
        const paddleWidth = paddleExpanded ? expandedPaddleWidth : normalPaddleWidth;
        const halfWidth = paddleWidth / 2;
        paddle.position.x = Math.max(leftBound + halfWidth, Math.min(rightBound - halfWidth, targetX));
        
        // If ball not launched, keep it with paddle
        if (!ballLaunched && balls.length > 0) {
            balls[0].position.x = paddle.position.x;
        }
    }
    
    function launchBall() {
        if (ballLaunched || !gameActive) return;
        
        ballLaunched = true;
        balls[0].direction = new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            1,
            0
        ).normalize();
        
        document.getElementById('launchButton').style.display = 'none';
    }
    
    function moveBall() {
        if (gamePaused) return;
        
        const currentSpeed = slowTimeActive ? ballSpeed * 0.5 : ballSpeed;
        
        balls.forEach((ball, index) => {
            ball.position.x += ball.direction.x * currentSpeed;
            ball.position.y += ball.direction.y * currentSpeed;
            
            // Wall collisions
            if (ball.position.x <= leftBound + 0.4 || ball.position.x >= rightBound - 0.4) {
                ball.direction.x *= -1;
                ball.position.x = Math.max(leftBound + 0.4, Math.min(rightBound - 0.4, ball.position.x));
            }
            
            // Top collision
            if (ball.position.y >= topBound - 0.4) {
                ball.direction.y *= -1;
                ball.position.y = topBound - 0.4;
            }
            
            // Paddle collision
            const paddleWidth = paddleExpanded ? expandedPaddleWidth : normalPaddleWidth;
            if (ball.position.y <= paddle.position.y + 0.5 &&
                ball.position.y >= paddle.position.y - 0.5 &&
                Math.abs(ball.position.x - paddle.position.x) < paddleWidth / 2) {
                
                ball.direction.y = Math.abs(ball.direction.y);
                const hitOffset = (ball.position.x - paddle.position.x) / (paddleWidth / 2);
                ball.direction.x = hitOffset * 0.8;
                ball.direction.normalize();
                ball.position.y = paddle.position.y + 0.5;
            }
            
            // Bottom boundary - lose ball
            if (ball.position.y < bottomBound - 1) {
                if (balls.length === 1) {
                    gameOver();
                } else {
                    scene.remove(ball);
                    balls.splice(index, 1);
                    updateBallCount();
                }
            }
            
            // Brick collisions
            checkBrickCollisions(ball);
        });
    }
    
    function checkBrickCollisions(ball) {
        for (let i = bricks.length - 1; i >= 0; i--) {
            const brick = bricks[i];
            const brickBox = new THREE.Box3().setFromObject(brick);
            const ballBox = new THREE.Box3().setFromObject(ball);
            
            if (brickBox.intersectsBox(ballBox)) {
                // Determine collision side
                const ballCenter = ball.position;
                const brickCenter = brick.position;
                const dx = ballCenter.x - brickCenter.x;
                const dy = ballCenter.y - brickCenter.y;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    ball.direction.x *= -1;
                } else {
                    ball.direction.y *= -1;
                }
                
                // Handle brick hit
                if (brick.userData.type === 'metal') {
                    // Unbreakable - just bounce
                    continue;
                }
                
                brick.userData.hits--;
                
                if (brick.userData.hits <= 0) {
                    // Brick destroyed
                    scene.remove(brick);
                    bricks.splice(i, 1);
                    
                    // Award points based on brick type and position
                    let points = 10;
                    if (brick.userData.type === 'tough') points = 25;
                    if (brick.position.y > topBound - 10) points *= 3; // Top zone bonus
                    else if (brick.position.y > topBound - 18) points *= 2; // Middle zone bonus
                    
                    score += points;
                    updateScore();
                    
                    // High drop rate for powerups (40%)
                    if (Math.random() < 0.4) {
                        spawnPowerup(brick.position.x, brick.position.y);
                    }
                    
                    // Cash reward (enhanced)
                    if (Math.random() < 0.35) {
                        cash++;
                        updateCash();
                        showNotification(`+$1`, brick.position.x, brick.position.y);
                    }
                    
                    // Check win condition
                    if (bricks.filter(b => b.userData.type !== 'metal').length === 0) {
                        levelComplete();
                    }
                } else {
                    // Update brick color based on remaining hits
                    const hitRatio = brick.userData.hits / brick.userData.maxHits;
                    if (brick.userData.type === 'tough') {
                        brick.material.color.setHex(hitRatio > 0.5 ? 0xff9933 : 0xff3333);
                    }
                }
                
                break;
            }
        }
    }
    
    function spawnPowerup(x, y) {
        const powerupTypes = [
            { type: 'multiball', color: 0xff00ff, size: 0.4, emoji: '‚öæ' },
            { type: 'expandPaddle', color: 0x00ffff, size: 0.4, emoji: '‚ÜîÔ∏è' },
            { type: 'slowBall', color: 0xffff00, size: 0.4, emoji: '‚è±Ô∏è' },
            { type: 'laser', color: 0xff0000, size: 0.4, emoji: 'üî´' },
            { type: 'extraBall', color: 0x00ff00, size: 0.4, emoji: 'üéæ' },
            { type: 'bomb', color: 0xff6600, size: 0.5, emoji: 'üí£' },
            { type: 'cash', color: 0x33ff33, size: 0.3, emoji: 'üí∞' }
        ];
        
        const powerup = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
        
        const geometry = new THREE.SphereGeometry(powerup.size, 16, 16);
        const material = new THREE.MeshPhongMaterial({ 
            color: powerup.color,
            emissive: powerup.color,
            emissiveIntensity: 0.5
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, y, 0);
        mesh.userData = { type: powerup.type, fallSpeed: 0.08 };
        
        scene.add(mesh);
        powerups.push(mesh);
    }
    
    function updatePowerups() {
        if (gamePaused) return;
        
        for (let i = powerups.length - 1; i >= 0; i--) {
            const powerup = powerups[i];
            powerup.position.y -= powerup.userData.fallSpeed;
            
            // Check paddle collision
            const paddleWidth = paddleExpanded ? expandedPaddleWidth : normalPaddleWidth;
            if (powerup.position.y <= paddle.position.y + 0.5 &&
                powerup.position.y >= paddle.position.y - 0.5 &&
                Math.abs(powerup.position.x - paddle.position.x) < paddleWidth / 2) {
                
                activatePowerup(powerup.userData.type);
                scene.remove(powerup);
                powerups.splice(i, 1);
            } else if (powerup.position.y < bottomBound - 2) {
                scene.remove(powerup);
                powerups.splice(i, 1);
            }
        }
    }
    
    function activatePowerup(type) {
        showNotification(type.toUpperCase(), paddle.position.x, paddle.position.y + 2);
        
        switch(type) {
            case 'multiball':
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const newBall = balls[0].clone();
                        newBall.direction = new THREE.Vector3(
                            (Math.random() - 0.5) * 1.5,
                            Math.random() * 0.5 + 0.5,
                            0
                        ).normalize();
                        balls.push(newBall);
                        scene.add(newBall);
                        updateBallCount();
                    }, i * 200);
                }
                break;
                
            case 'expandPaddle':
                if (paddleExpandTimer) clearTimeout(paddleExpandTimer);
                paddleExpanded = true;
                paddle.geometry.dispose();
                paddle.geometry = new THREE.BoxGeometry(expandedPaddleWidth, 0.5, 1);
                paddleExpandTimer = setTimeout(() => {
                    paddleExpanded = false;
                    paddle.geometry.dispose();
                    paddle.geometry = new THREE.BoxGeometry(normalPaddleWidth, 0.5, 1);
                }, 10000);
                break;
                
            case 'slowBall':
                if (slowTimeTimer) clearTimeout(slowTimeTimer);
                slowTimeActive = true;
                slowTimeTimer = setTimeout(() => {
                    slowTimeActive = false;
                }, 8000);
                break;
                
            case 'laser':
                if (laserActiveTimer) clearTimeout(laserActiveTimer);
                laserActive = true;
                paddle.material.color.setHex(0xff0000);
                laserActiveTimer = setTimeout(() => {
                    laserActive = false;
                    paddle.material.color.setHex(0x00ff00);
                }, 6000);
                break;
                
            case 'extraBall':
                const newBall = balls[0].clone();
                newBall.direction = new THREE.Vector3(
                    Math.random() - 0.5,
                    1,
                    0
                ).normalize();
                balls.push(newBall);
                scene.add(newBall);
                updateBallCount();
                break;
                
            case 'bomb':
                activateBomb();
                break;
                
            case 'cash':
                cash += 2;
                updateCash();
                break;
        }
    }
    
    function activateBomb() {
        // Create massive explosion effect
        const explosionRadius = 6;
        const explosionGeometry = new THREE.SphereGeometry(0.1, 16, 16);
        const explosionMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff6600,
            transparent: true,
            opacity: 0.8
        });
        const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
        
        // Place explosion in middle of screen
        explosion.position.set(0, (topBound + bottomBound) / 2, 0);
        scene.add(explosion);
        bombs.push(explosion);
        
        // Animate explosion
        let scale = 1;
        const expandInterval = setInterval(() => {
            if (gamePaused) return;
            
            scale += 1;
            explosion.scale.set(scale, scale, scale);
            explosion.material.opacity -= 0.05;
            
            if (scale >= 12) {
                clearInterval(expandInterval);
                scene.remove(explosion);
                const index = bombs.indexOf(explosion);
                if (index > -1) bombs.splice(index, 1);
            }
        }, 50);
        
        // Destroy bricks in radius
        setTimeout(() => {
            for (let i = bricks.length - 1; i >= 0; i--) {
                const brick = bricks[i];
                if (brick.userData.type === 'metal') continue;
                
                const distance = explosion.position.distanceTo(brick.position);
                if (distance < explosionRadius) {
                    let points = 10;
                    if (brick.userData.type === 'tough') points = 25;
                    score += points;
                    
                    scene.remove(brick);
                    bricks.splice(i, 1);
                }
            }
            updateScore();
        }, 300);
    }
    
    function clearBombs() {
        bombs.forEach(bomb => scene.remove(bomb));
        bombs = [];
    }
    
    function updateLasers() {
        if (gamePaused) return;
        
        // Auto-fire lasers if active
        if (laserActive && Math.random() < 0.15) {
            fireLaser();
        }
        
        // Move lasers
        for (let i = lasers.length - 1; i >= 0; i--) {
            const laser = lasers[i];
            laser.position.y += 0.3;
            
            // Check brick collisions
            for (let j = bricks.length - 1; j >= 0; j--) {
                const brick = bricks[j];
                if (brick.userData.type === 'metal') continue;
                
                const brickBox = new THREE.Box3().setFromObject(brick);
                const laserBox = new THREE.Box3().setFromObject(laser);
                
                if (brickBox.intersectsBox(laserBox)) {
                    brick.userData.hits--;
                    
                    if (brick.userData.hits <= 0) {
                        let points = 10;
                        if (brick.userData.type === 'tough') points = 25;
                        if (brick.position.y > topBound - 10) points *= 3;
                        else if (brick.position.y > topBound - 18) points *= 2;
                        
                        score += points;
                        updateScore();
                        
                        scene.remove(brick);
                        bricks.splice(j, 1);
                        
                        if (Math.random() < 0.3) {
                            spawnPowerup(brick.position.x, brick.position.y);
                        }
                    }
                    
                    scene.remove(laser);
                    lasers.splice(i, 1);
                    break;
                }
            }
            
            // Remove if off screen
            if (laser.position.y > topBound + 2) {
                scene.remove(laser);
                lasers.splice(i, 1);
            }
        }
    }
    
    function fireLaser() {
        const laserGeometry = new THREE.BoxGeometry(0.2, 1, 0.2);
        const laserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const laser = new THREE.Mesh(laserGeometry, laserMaterial);
        laser.position.set(paddle.position.x, paddle.position.y + 1, 0);
        
        scene.add(laser);
        lasers.push(laser);
    }
    
    function clearLasers() {
        lasers.forEach(laser => scene.remove(laser));
        lasers = [];
    }
    
    function buyPowerup(type, cost) {
        if (cash < cost) {
            showNotification('Not enough cash!', 0, bottomBound + 3);
            return;
        }
        
        cash -= cost;
        updateCash();
        
        switch(type) {
            case 'multiball':
                activatePowerup('multiball');
                break;
            case 'expand':
                activatePowerup('expandPaddle');
                break;
            case 'laser':
                activatePowerup('laser');
                break;
            case 'bomb':
                activateBomb();
                break;
            case 'slowtime':
                activatePowerup('slowBall');
                break;
            case 'paddleMultiball':
                if (paddleMultiballTimer) clearInterval(paddleMultiballTimer);
                remainingPaddleBalls = 15;
                paddleMultiballTimer = setInterval(() => {
                    if (gamePaused) return;
                    if (remainingPaddleBalls > 0) {
                        const newBall = balls[0].clone();
                        newBall.position.y = paddle.position.y + 1;
                        newBall.position.x = paddle.position.x + (Math.random() - 0.5) * 2;
                        newBall.direction = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.8,
                            1,
                            0
                        ).normalize();
                        balls.push(newBall);
                        scene.add(newBall);
                        remainingPaddleBalls--;
                        updateBallCount();
                    } else {
                        clearInterval(paddleMultiballTimer);
                        paddleMultiballTimer = null;
                    }
                }, 1000);
                break;
        }
    }
    
    function showNotification(text, x, y) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = text;
        
        const screenPos = toScreenPosition(x, y);
        notification.style.left = screenPos.x + 'px';
        notification.style.top = screenPos.y + 'px';
        
        document.getElementById('gameContainer').appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 2000);
    }
    
    function toScreenPosition(x, y) {
        const vector = new THREE.Vector3(x, y, 0);
        vector.project(camera);
        
        const container = document.getElementById('gameContainer');
        const widthHalf = container.clientWidth / 2;
        const heightHalf = container.clientHeight / 2;
        
        return {
            x: (vector.x * widthHalf) + widthHalf,
            y: -(vector.y * heightHalf) + heightHalf
        };
    }
    
    function updateScore() {
        document.getElementById('score').textContent = `Score: ${score}`;
    }
    
    function updateCash() {
        document.getElementById('cash').textContent = `Cash: $${cash}`;
        
        // Update store button states
        updateStoreButtons();
    }
    
    function updateBallCount() {
        document.getElementById('ballCount').textContent = `Balls: ${balls.length}`;
    }
    
    function updateStoreButtons() {
        const items = [
            { id: 'buyMultiball', cost: 2 },
            { id: 'buyExpandPaddle', cost: 1 },
            { id: 'buyLaser', cost: 2 },
            { id: 'buyBomb', cost: 3 },
            { id: 'buySlowTime', cost: 1 },
            { id: 'buyPaddleMultiball', cost: 4 }
        ];
        
        items.forEach(item => {
            const button = document.getElementById(item.id);
            if (cash < item.cost) {
                button.classList.add('store-item-disabled');
            } else {
                button.classList.remove('store-item-disabled');
            }
        });
    }
    
    function levelComplete() {
        showNotification('LEVEL COMPLETE!', 0, topBound / 2);
        cash += 10;
        updateCash();
        
        setTimeout(() => {
            if (level < 5) {
                level++;
                document.getElementById('levelSelect').value = level;
                createBricks();
                showNotification(`LEVEL ${level}`, 0, topBound / 2);
            } else {
                showNotification('YOU WIN!', 0, topBound / 2);
                setTimeout(() => {
                    gameOver();
                }, 2000);
            }
        }, 2000);
    }
    
    function gameOver() {
        gameActive = false;
        document.getElementById('gameOver').style.display = 'block';
        document.getElementById('startButton').style.display = 'block';
        document.getElementById('launchButton').style.display = 'none';
        
        if (paddleMultiballTimer) {
            clearInterval(paddleMultiballTimer);
            paddleMultiballTimer = null;
            remainingPaddleBalls = 0;
        }
        
        clearBombs();
        clearLasers();
    }
    
    function restartGame() {
        gameActive = true;
        gamePaused = false;
        paddle.position.x = 0;
        
        const pauseButton = document.getElementById('pauseButton');
        pauseButton.innerHTML = '<span class="pause-icon"></span>Pause';
        document.getElementById('pauseOverlay').style.display = 'none';
        
        // Reset balls
        balls.forEach((b, index) => {
            if (index > 0) scene.remove(b);
        });
        balls = [balls[0]];
        
        powerups.forEach(p => scene.remove(p));
        powerups = [];
        
        clearLasers();
        clearBombs();
        
        balls[0].position.y = bottomBound + 0.9;
        balls[0].position.x = paddle.position.x;
        ballLaunched = false;
        
        level = parseInt(document.getElementById('levelSelect').value);
        ballSpeed = 0.09;
        
        setupGameBoundaries();
        createBricks();
        
        score = 0;
        cash = 3;
        updateScore();
        updateCash();
        updateBallCount();
        
        document.getElementById('gameOver').style.display = 'none';
        document.getElementById('startButton').style.display = 'none';
        document.getElementById('launchButton').style.display = 'block';
        
        if (!animationFrameId) {
            animate();
        }
    }
    
    function togglePause() {
        gamePaused = !gamePaused;
        const pauseButton = document.getElementById('pauseButton');
        const pauseOverlay = document.getElementById('pauseOverlay');
        
        if (gamePaused) {
            pauseButton.innerHTML = '<span class="play-icon"></span>Resume';
            pauseOverlay.style.display = 'flex';
        } else {
            pauseButton.innerHTML = '<span class="pause-icon"></span>Pause';
            pauseOverlay.style.display = 'none';
        }
    }
    
    function resumeGame() {
        if (gamePaused) {
            togglePause();
        }
    }
    
    function animate() {
        animationFrameId = requestAnimationFrame(animate);
        
        if (gameActive) {
            if (!gamePaused) {
                movePaddle();
                moveBall();
                updatePowerups();
                updateLasers();
            }
            
            renderer.render(scene, camera);
        }
    }
    
    document.addEventListener('click', function() {
        renderer.domElement.focus();
    });
    
    window.addEventListener('load', init);
    </script>
</body>
</html>
