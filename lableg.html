<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth Legacy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            user-select: none;
        }
        
        #root {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
        }
        
        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }
        
        .game-ui > * {
            pointer-events: auto;
        }
        
        /* HUD Styles */
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.1);
            min-width: 200px;
        }
        
        .health-bar, .mana-bar, .stamina-bar, .xp-bar {
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            margin: 5px 0;
            position: relative;
            overflow: hidden;
        }
        
        .health-fill {
            background: linear-gradient(90deg, #ff3333, #ff6666);
            height: 100%;
            transition: width 0.3s;
        }
        
        .mana-fill {
            background: linear-gradient(90deg, #3366ff, #6699ff);
            height: 100%;
            transition: width 0.3s;
        }
        
        .stamina-fill {
            background: linear-gradient(90deg, #33ff33, #66ff66);
            height: 100%;
            transition: width 0.3s;
        }
        
        .xp-fill {
            background: linear-gradient(90deg, #ffaa33, #ffcc66);
            height: 100%;
            transition: width 0.3s;
        }
        
        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        /* Inventory */
        .inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.1);
        }
        
        .inventory-slot {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .inventory-slot:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }
        
        .inventory-slot.active {
            border-color: #ffaa33;
            box-shadow: 0 0 10px #ffaa33;
        }
        
        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            background: rgba(0,0,0,0.8);
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        /* Minimap */
        .minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0,0,0,0.8);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .minimap-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Menus */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        
        .menu {
            background: linear-gradient(135deg, #1a1a2e, #0f0f1e);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.1);
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .menu h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(45deg, #ffaa33, #ff6633);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255,170,51,0.5);
        }
        
        .menu h2 {
            font-size: 28px;
            margin: 20px 0 10px;
            color: #ffaa33;
        }
        
        .menu-button {
            display: block;
            width: 100%;
            padding: 15px 30px;
            margin: 10px 0;
            font-size: 20px;
            background: linear-gradient(135deg, #ffaa33, #ff6633);
            border: none;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
        }
        
        .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255,170,51,0.5);
        }
        
        .menu-button:active {
            transform: translateY(0);
        }
        
        .menu-button.secondary {
            background: linear-gradient(135deg, #333, #555);
            font-size: 16px;
        }
        
        /* Game Messages */
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: fadeInOut 3s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -40%); }
            20% { opacity: 1; transform: translate(-50%, -50%); }
            80% { opacity: 1; transform: translate(-50%, -50%); }
            100% { opacity: 0; transform: translate(-50%, -60%); }
        }
        
        /* Dialog */
        .dialog-box {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            background: rgba(0,0,0,0.9);
            border: 2px solid #ffaa33;
            border-radius: 10px;
            padding: 20px;
        }
        
        .dialog-speaker {
            color: #ffaa33;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .dialog-text {
            line-height: 1.6;
        }
        
        .dialog-continue {
            margin-top: 10px;
            text-align: right;
            color: #888;
            font-size: 14px;
        }
        
        /* Loading Screen */
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading h1 {
            font-size: 48px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #ffaa33, #ff6633);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .loading-bar {
            width: 300px;
            height: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            overflow: hidden;
        }
        
        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffaa33, #ff6633);
            transition: width 0.3s;
        }
        
        .loading-text {
            margin-top: 20px;
            color: #888;
        }
        
        /* Weapon Upgrade Menu */
        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .upgrade-item {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upgrade-item:hover {
            background: rgba(255,255,255,0.1);
            border-color: #ffaa33;
        }
        
        .upgrade-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .upgrade-item h3 {
            color: #ffaa33;
            margin-bottom: 10px;
        }
        
        .upgrade-cost {
            color: #ff6666;
            font-weight: bold;
        }
        
        /* Mobile Controls */
        @media (max-width: 768px) {
            .hud {
                top: 10px;
                left: 10px;
                font-size: 14px;
                padding: 10px;
            .error-log {
                position: fixed;
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-height: 300px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.9);
                border: 2px solid #ff3333;
                border-radius: 5px;
                padding: 15px;
                font-size: 12px;
                font-family: monospace;
                color: #ff9999;
                z-index: 9999;
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            }
            
            .error-log::before {
                content: 'DEBUG LOG:';
                display: block;
                color: #ff3333;
                font-weight: bold;
                margin-bottom: 10px;
            }
            
            .minimap {
                width: 150px;
                height: 150px;
            }
            
            .inventory {
                bottom: 10px;
            }
            
            .inventory-slot {
                width: 40px;
                height: 40px;
            }
            
            .menu {
                padding: 20px;
            }
            
            .menu h1 {
                font-size: 32px;
            }
            
            .virtual-joystick {
                position: absolute;
                bottom: 20px;
                left: 20px;
                width: 120px;
                height: 120px;
                background: rgba(255,255,255,0.1);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .joystick-knob {
                width: 50px;
                height: 50px;
                background: rgba(255,255,255,0.3);
                border-radius: 50%;
                position: absolute;
            }
            
            .action-buttons {
                position: absolute;
                bottom: 20px;
                right: 20px;
                display: flex;
                gap: 10px;
            }
            
            .action-button {
                width: 60px;
                height: 60px;
                background: rgba(255,255,255,0.2);
                border: 2px solid rgba(255,255,255,0.3);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 20px;
            }
        }
    </style>
    <script>
        // Script loading verification
        window.addEventListener('load', function() {
            console.log('Page fully loaded');
            console.log('React available:', typeof React !== 'undefined');
            console.log('ReactDOM available:', typeof ReactDOM !== 'undefined');
            console.log('THREE available:', typeof THREE !== 'undefined');
        });
    </script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="root">
        <div style="color: white; text-align: center; padding: 50px;">
            Loading scripts...
        </div>
    </div>
    <div id="error-log" class="error-log" style="display:none;"></div>
    
    <script>
        // Create a more robust initialization system
        window.gameInitialized = false;
        window.initializationErrors = [];
        
        function updateLoadingMessage(msg) {
            const root = document.getElementById('root');
            if (root) {
                root.innerHTML = '<div style="color: white; text-align: center; padding: 50px;">' + msg + '</div>';
            }
        }
        
        function checkDependencies() {
            updateLoadingMessage('Checking dependencies...');
            
            if (typeof React === 'undefined') {
                window.initializationErrors.push('React not loaded');
                return false;
            }
            if (typeof ReactDOM === 'undefined') {
                window.initializationErrors.push('ReactDOM not loaded');
                return false;
            }
            if (typeof THREE === 'undefined') {
                window.initializationErrors.push('Three.js not loaded');
                return false;
            }
            return true;
        }
        
        function initializeGame() {
            if (window.gameInitialized) return;
            
            if (!checkDependencies()) {
                const errorDiv = document.getElementById('error-log');
                errorDiv.innerHTML = 'Missing dependencies: ' + window.initializationErrors.join(', ');
                errorDiv.style.display = 'block';
                updateLoadingMessage('Failed to load dependencies');
                return;
            }
            
            updateLoadingMessage('Dependencies loaded, initializing game...');
            window.gameInitialized = true;
            
            // Now run the main game code
            try {
            
            // Game Constants
        const GAME_VERSION = '1.0.0';
        const SAVE_KEY = 'labyrinthLegacySave';
        
        // Global error tracking for mobile debugging
        window.gameErrors = [];
        window.logError = (message, error) => {
            const errorMsg = `${new Date().toISOString().substr(11, 8)}: ${message} ${error ? '- ' + (error.message || error) : ''}`;
            window.gameErrors.push(errorMsg);
            console.error(message, error);
            
            // Display errors on screen
            const errorDiv = document.getElementById('error-log');
            if (errorDiv) {
                errorDiv.innerHTML = window.gameErrors.slice(-5).join('<br>');
                errorDiv.style.display = 'block';
            }
        };
        
        // Add console logging for debugging
        console.log('Labyrinth Legacy starting...');
        window.logError('Game script loaded');
        
        // Game State Management
        class GameState {
            constructor() {
                this.player = {
                    level: 1,
                    xp: 0,
                    xpToNext: 100,
                    health: 100,
                    maxHealth: 100,
                    mana: 50,
                    maxMana: 50,
                    stamina: 100,
                    maxStamina: 100,
                    position: { x: 0, y: 0, z: 0 },
                    rotation: 0,
                    gold: 0,
                    currentFloor: 1,
                    weapon: 'sword',
                    swordLevel: 1,
                    staffUnlocked: false,
                    staffAbilities: []
                };
                
                this.inventory = {
                    items: [],
                    maxSlots: 20,
                    equipped: {
                        weapon: { type: 'sword', level: 1, damage: 10 }
                    }
                };
                
                this.hub = {
                    npcsAwakened: [],
                    facilitiesUnlocked: ['portal'],
                    currentLocation: 'dungeon' // 'hub' or 'dungeon'
                };
                
                this.dungeon = {
                    currentFloor: 1,
                    rooms: [],
                    enemies: [],
                    treasures: [],
                    keyFound: false
                };
                
                this.settings = {
                    musicVolume: 0.5,
                    sfxVolume: 0.7,
                    sensitivity: 1.0
                };
            }
            
            save() {
                const saveData = {
                    version: GAME_VERSION,
                    timestamp: Date.now(),
                    player: this.player,
                    inventory: this.inventory,
                    hub: this.hub,
                    dungeon: {
                        currentFloor: this.dungeon.currentFloor,
                        keyFound: this.dungeon.keyFound
                    },
                    settings: this.settings
                };
                
                try {
                    localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                    return true;
                } catch (e) {
                    console.error('Failed to save game:', e);
                    return false;
                }
            }
            
            load() {
                try {
                    const saveData = localStorage.getItem(SAVE_KEY);
                    if (!saveData) return false;
                    
                    const data = JSON.parse(saveData);
                    if (data.version !== GAME_VERSION) {
                        console.warn('Save version mismatch');
                        // Handle version migration here
                    }
                    
                    this.player = { ...this.player, ...data.player };
                    this.inventory = { ...this.inventory, ...data.inventory };
                    this.hub = { ...this.hub, ...data.hub };
                    this.dungeon.currentFloor = data.dungeon.currentFloor;
                    this.dungeon.keyFound = data.dungeon.keyFound;
                    this.settings = { ...this.settings, ...data.settings };
                    
                    return true;
                } catch (e) {
                    console.error('Failed to load game:', e);
                    return false;
                }
            }
            
            reset() {
                const newState = new GameState();
                Object.assign(this, newState);
                localStorage.removeItem(SAVE_KEY);
            }
        }
        
        // Dungeon Generation
        class DungeonGenerator {
            constructor() {
                this.roomTypes = ['main', 'radial', 'cardinal', 'treasure', 'boss'];
                this.themes = [
                    { name: 'stone', floors: [1, 10], color: 0x666666 },
                    { name: 'crystal', floors: [11, 20], color: 0x6666ff },
                    { name: 'ruins', floors: [21, 30], color: 0x996633 },
                    { name: 'crypt', floors: [31, 40], color: 0x333333 },
                    { name: 'forest', floors: [41, 50], color: 0x336633 }
                ];
            }
            
            generateFloor(floorNumber) {
                const theme = this.getTheme(floorNumber);
                const roomCount = Math.min(3 + Math.floor(floorNumber / 10) * 2, 9);
                const rooms = [];
                
                // Generate main room (always at center)
                rooms.push({
                    id: 'main',
                    type: 'main',
                    position: { x: 0, z: 0 },
                    size: { width: 20, height: 20 },
                    connections: [],
                    enemies: this.generateEnemies(floorNumber, 'main'),
                    treasures: this.generateTreasures(floorNumber, 'main'),
                    theme: theme.name,
                    hasPortal: true
                });
                
                // Generate radial rooms
                const radialCount = Math.min(Math.floor(roomCount / 2), 4);
                for (let i = 0; i < radialCount; i++) {
                    const angle = (i / radialCount) * Math.PI * 2;
                    const distance = 40;
                    rooms.push({
                        id: `radial_${i}`,
                        type: 'radial',
                        position: {
                            x: Math.cos(angle) * distance,
                            z: Math.sin(angle) * distance
                        },
                        size: { width: 15, height: 15 },
                        connections: ['main'],
                        enemies: this.generateEnemies(floorNumber, 'radial'),
                        treasures: this.generateTreasures(floorNumber, 'radial'),
                        theme: theme.name,
                        hasKey: i === 0 // First radial room has the key
                    });
                    rooms[0].connections.push(`radial_${i}`);
                }
                
                // Generate cardinal rooms (bosses)
                if (floorNumber % 5 === 0) {
                    const cardinalPositions = [
                        { x: 0, z: -60 }, // North
                        { x: 60, z: 0 },  // East
                        { x: 0, z: 60 },  // South
                        { x: -60, z: 0 }  // West
                    ];
                    
                    const cardinalIndex = Math.floor((floorNumber / 5 - 1) % 4);
                    const pos = cardinalPositions[cardinalIndex];
                    
                    rooms.push({
                        id: 'cardinal',
                        type: 'cardinal',
                        position: pos,
                        size: { width: 25, height: 25 },
                        connections: ['main'],
                        enemies: this.generateBoss(floorNumber),
                        treasures: this.generateBossTreasure(floorNumber),
                        theme: theme.name,
                        isBossRoom: true
                    });
                    rooms[0].connections.push('cardinal');
                }
                
                return {
                    floor: floorNumber,
                    theme: theme,
                    rooms: rooms,
                    completed: false
                };
            }
            
            getTheme(floor) {
                for (const theme of this.themes) {
                    if (floor >= theme.floors[0] && floor <= theme.floors[1]) {
                        return theme;
                    }
                }
                return this.themes[0];
            }
            
            generateEnemies(floor, roomType) {
                const enemies = [];
                const baseCount = roomType === 'main' ? 2 : roomType === 'radial' ? 3 : 1;
                const count = baseCount + Math.floor(floor / 10);
                
                for (let i = 0; i < count; i++) {
                    enemies.push({
                        id: `enemy_${Date.now()}_${i}`,
                        type: this.getEnemyType(floor, roomType),
                        level: floor,
                        health: 50 + floor * 10,
                        maxHealth: 50 + floor * 10,
                        damage: 5 + floor * 2,
                        speed: 1 + floor * 0.1,
                        xpReward: 10 + floor * 5,
                        position: {
                            x: (Math.random() - 0.5) * 10,
                            z: (Math.random() - 0.5) * 10
                        },
                        drops: this.generateDrops(floor)
                    });
                }
                
                return enemies;
            }
            
            generateBoss(floor) {
                return [{
                    id: `boss_${floor}`,
                    type: 'boss',
                    name: this.getBossName(floor),
                    level: floor,
                    health: 500 + floor * 50,
                    maxHealth: 500 + floor * 50,
                    damage: 20 + floor * 5,
                    speed: 0.8,
                    xpReward: 100 + floor * 20,
                    position: { x: 0, z: 0 },
                    drops: this.generateBossDrops(floor),
                    specialItem: this.getSpecialItem(floor)
                }];
            }
            
            getEnemyType(floor, roomType) {
                const types = ['goblin', 'skeleton', 'spider', 'shade', 'crystal_guardian'];
                const index = Math.floor(floor / 10) % types.length;
                return types[index];
            }
            
            getBossName(floor) {
                const names = [
                    'Corrupted Overseer',
                    'Crystal Sentinel',
                    'Dream Warden',
                    'Shadow Archon',
                    'Forest Ancient'
                ];
                return names[Math.floor((floor / 5 - 1) % names.length)];
            }
            
            generateTreasures(floor, roomType) {
                const treasures = [];
                const count = roomType === 'main' ? 1 : roomType === 'radial' ? 2 : 0;
                
                for (let i = 0; i < count; i++) {
                    treasures.push({
                        id: `treasure_${Date.now()}_${i}`,
                        type: 'chest',
                        rarity: this.getChestRarity(floor),
                        position: {
                            x: (Math.random() - 0.5) * 15,
                            z: (Math.random() - 0.5) * 15
                        },
                        contents: this.generateChestContents(floor),
                        opened: false
                    });
                }
                
                return treasures;
            }
            
            generateBossTreasure(floor) {
                return [{
                    id: `boss_treasure_${floor}`,
                    type: 'legendary_chest',
                    rarity: 'legendary',
                    position: { x: 0, z: 5 },
                    contents: this.generateBossChestContents(floor),
                    opened: false
                }];
            }
            
            getChestRarity(floor) {
                const roll = Math.random();
                if (roll < 0.6) return 'common';
                if (roll < 0.85) return 'uncommon';
                if (roll < 0.95) return 'rare';
                return 'legendary';
            }
            
            generateDrops(floor) {
                return [
                    { type: 'gold', amount: 10 + floor * 5, chance: 0.5 },
                    { type: 'health_potion', amount: 1, chance: 0.2 },
                    { type: 'mana_potion', amount: 1, chance: 0.2 }
                ];
            }
            
            generateBossDrops(floor) {
                return [
                    { type: 'gold', amount: 100 + floor * 20, chance: 1 },
                    { type: 'weapon_upgrade', amount: 1, chance: 0.5 },
                    { type: 'rare_material', amount: 1, chance: 0.3 }
                ];
            }
            
            generateChestContents(floor) {
                const rarity = this.getChestRarity(floor);
                const contents = [];
                
                contents.push({
                    type: 'gold',
                    amount: (rarity === 'common' ? 20 : rarity === 'uncommon' ? 50 : rarity === 'rare' ? 100 : 200) + floor * 10
                });
                
                if (Math.random() < 0.3) {
                    contents.push({
                        type: 'health_potion',
                        amount: rarity === 'common' ? 1 : 2
                    });
                }
                
                if (Math.random() < 0.2 && rarity !== 'common') {
                    contents.push({
                        type: 'weapon_material',
                        amount: 1
                    });
                }
                
                return contents;
            }
            
            generateBossChestContents(floor) {
                return [
                    { type: 'gold', amount: 500 + floor * 50 },
                    { type: 'legendary_material', amount: 1 },
                    { type: 'skill_unlock', skillId: this.getSkillUnlock(floor) }
                ];
            }
            
            getSpecialItem(floor) {
                const items = [
                    { id: 'memory_fragment_1', name: 'Aurelius\'s First Memory' },
                    { id: 'memory_fragment_2', name: 'The Collapse' },
                    { id: 'memory_fragment_3', name: 'The First Transfer' },
                    { id: 'memory_fragment_4', name: 'Centuries of Rule' },
                    { id: 'memory_fragment_5', name: 'The Truth Revealed' }
                ];
                return items[Math.floor((floor / 5 - 1) % items.length)];
            }
            
            getSkillUnlock(floor) {
                const skills = ['fireball', 'ice_shard', 'lightning_bolt', 'earth_spike', 'void_blast'];
                return skills[Math.floor((floor / 5 - 1) % skills.length)];
            }
        }
        
        // React Components
        const { useState, useEffect, useRef, useCallback, useMemo } = React;
        
        // Test component to verify React is working
        const TestComponent = () => {
            window.logError('TestComponent rendered');
            return React.createElement('div', { 
                style: { color: 'white', padding: '20px', textAlign: 'center' } 
            }, 'React is working! Loading game...');
        };
        
        // Loading Screen Component
        const LoadingScreen = ({ progress, message }) => {
            return React.createElement('div', { className: 'loading' },
                React.createElement('h1', null, 'Labyrinth Legacy'),
                React.createElement('div', { className: 'loading-bar' },
                    React.createElement('div', { 
                        className: 'loading-fill',
                        style: { width: `${progress}%` }
                    })
                ),
                React.createElement('div', { className: 'loading-text' }, message),
                React.createElement('div', { 
                    style: { 
                        marginTop: '20px', 
                        fontSize: '12px', 
                        color: '#666',
                        maxWidth: '400px',
                        textAlign: 'center'
                    } 
                }, 'If stuck here, the game may have encountered an error during initialization.')
            );
        };
        
        // Main Menu Component
        const MainMenu = ({ onStart, onContinue, onSettings, hasSave }) => {
            return React.createElement('div', { className: 'menu-overlay' },
                React.createElement('div', { className: 'menu' },
                    React.createElement('h1', null, 'Labyrinth Legacy'),
                    React.createElement('p', { style: { textAlign: 'center', marginBottom: '30px', color: '#888' } }, 
                        'An ancient labyrinth awaits. Will you uncover its secrets?'
                    ),
                    hasSave && React.createElement('button', { 
                        className: 'menu-button',
                        onClick: onContinue
                    }, 'Continue Adventure'),
                    React.createElement('button', { 
                        className: 'menu-button',
                        onClick: onStart
                    }, 'New Game'),
                    React.createElement('button', { 
                        className: 'menu-button secondary',
                        onClick: onSettings
                    }, 'Settings')
                )
            );
        };
        
        // HUD Component
        const HUD = ({ gameState }) => {
            const { player } = gameState;
            
            return React.createElement('div', { className: 'hud' },
                React.createElement('div', { style: { marginBottom: '10px' } },
                    `Level ${player.level} - Floor ${gameState.dungeon.currentFloor}`
                ),
                React.createElement('div', { className: 'health-bar' },
                    React.createElement('div', { 
                        className: 'health-fill',
                        style: { width: `${(player.health / player.maxHealth) * 100}%` }
                    }),
                    React.createElement('div', { className: 'bar-text' }, 
                        `${Math.floor(player.health)}/${player.maxHealth}`
                    )
                ),
                React.createElement('div', { className: 'mana-bar' },
                    React.createElement('div', { 
                        className: 'mana-fill',
                        style: { width: `${(player.mana / player.maxMana) * 100}%` }
                    }),
                    React.createElement('div', { className: 'bar-text' }, 
                        `${Math.floor(player.mana)}/${player.maxMana}`
                    )
                ),
                React.createElement('div', { className: 'stamina-bar' },
                    React.createElement('div', { 
                        className: 'stamina-fill',
                        style: { width: `${(player.stamina / player.maxStamina) * 100}%` }
                    }),
                    React.createElement('div', { className: 'bar-text' }, 
                        `${Math.floor(player.stamina)}/${player.maxStamina}`
                    )
                ),
                React.createElement('div', { className: 'xp-bar' },
                    React.createElement('div', { 
                        className: 'xp-fill',
                        style: { width: `${(player.xp / player.xpToNext) * 100}%` }
                    }),
                    React.createElement('div', { className: 'bar-text' }, 
                        `XP: ${player.xp}/${player.xpToNext}`
                    )
                ),
                React.createElement('div', { style: { marginTop: '10px' } },
                    `Gold: ${player.gold}`
                )
            );
        };
        
        // Inventory Component
        const Inventory = ({ gameState, onItemUse }) => {
            const [selectedSlot, setSelectedSlot] = useState(0);
            const slots = Array(8).fill(null);
            
            // Fill slots with items
            gameState.inventory.items.slice(0, 8).forEach((item, i) => {
                slots[i] = item;
            });
            
            return React.createElement('div', { className: 'inventory' },
                slots.map((item, index) => 
                    React.createElement('div', {
                        key: index,
                        className: `inventory-slot ${selectedSlot === index ? 'active' : ''}`,
                        onClick: () => {
                            setSelectedSlot(index);
                            if (item) onItemUse(item);
                        }
                    },
                        item && React.createElement('div', null,
                            React.createElement('div', null, item.icon || '?'),
                            item.count > 1 && React.createElement('div', { className: 'item-count' }, item.count)
                        )
                    )
                )
            );
        };
        
        // Minimap Component
        const Minimap = ({ gameState }) => {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                if (!canvasRef.current) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const scale = 2;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw rooms
                if (gameState.dungeon.rooms) {
                    gameState.dungeon.rooms.forEach(room => {
                        const x = canvas.width / 2 + room.position.x * scale;
                        const z = canvas.height / 2 + room.position.z * scale;
                        const w = room.size.width * scale;
                        const h = room.size.height * scale;
                        
                        ctx.fillStyle = room.type === 'main' ? '#444' : 
                                       room.type === 'cardinal' ? '#633' : '#333';
                        ctx.fillRect(x - w/2, z - h/2, w, h);
                        
                        // Draw connections
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 2;
                        room.connections.forEach(connId => {
                            const connRoom = gameState.dungeon.rooms.find(r => r.id === connId);
                            if (connRoom) {
                                ctx.beginPath();
                                ctx.moveTo(x, z);
                                ctx.lineTo(
                                    canvas.width / 2 + connRoom.position.x * scale,
                                    canvas.height / 2 + connRoom.position.z * scale
                                );
                                ctx.stroke();
                            }
                        });
                    });
                }
                
                // Draw player
                ctx.fillStyle = '#ffaa33';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 4, 0, Math.PI * 2);
                ctx.fill();
            }, [gameState.dungeon.rooms, gameState.player.position]);
            
            return React.createElement('div', { className: 'minimap' },
                React.createElement('canvas', {
                    ref: canvasRef,
                    className: 'minimap-canvas',
                    width: 200,
                    height: 200
                })
            );
        };
        
        // Dialog Component
        const Dialog = ({ speaker, text, onContinue }) => {
            useEffect(() => {
                const handleKey = (e) => {
                    if (e.key === ' ' || e.key === 'Enter') {
                        onContinue();
                    }
                };
                window.addEventListener('keydown', handleKey);
                return () => window.removeEventListener('keydown', handleKey);
            }, [onContinue]);
            
            return React.createElement('div', { className: 'dialog-box' },
                React.createElement('div', { className: 'dialog-speaker' }, speaker),
                React.createElement('div', { className: 'dialog-text' }, text),
                React.createElement('div', { className: 'dialog-continue' }, 
                    'Press SPACE to continue'
                )
            );
        };
        
        // Game Message Component
        const GameMessage = ({ message }) => {
            if (!message) return null;
            
            return React.createElement('div', { 
                className: 'game-message',
                key: message
            }, message);
        };
        
        // Hub Menu Component
        const HubMenu = ({ gameState, onClose, onUpgrade, onTalk }) => {
            const [selectedNPC, setSelectedNPC] = useState(null);
            
            const npcs = [
                { id: 'mira', name: 'Mira', role: 'Blacksmith\'s Daughter', unlocked: gameState.hub.npcsAwakened.includes('mira') },
                { id: 'kaelin', name: 'Elder Kaelin', role: 'Historian', unlocked: gameState.hub.npcsAwakened.includes('kaelin') },
                { id: 'leta', name: 'Leta', role: 'Physician', unlocked: gameState.hub.npcsAwakened.includes('leta') },
                { id: 'corvus', name: 'Corvus', role: 'Messenger', unlocked: gameState.hub.npcsAwakened.includes('corvus') },
                { id: 'soren', name: 'Soren', role: 'Scholar', unlocked: gameState.hub.npcsAwakened.includes('soren') }
            ];
            
            return React.createElement('div', { className: 'menu-overlay' },
                React.createElement('div', { className: 'menu' },
                    React.createElement('h1', null, 'Dawnhaven Hub'),
                    React.createElement('h2', null, 'Awakened Townspeople'),
                    React.createElement('div', { className: 'upgrade-grid' },
                        npcs.map(npc => 
                            React.createElement('div', {
                                key: npc.id,
                                className: `upgrade-item ${!npc.unlocked ? 'locked' : ''}`,
                                onClick: () => {
                                    if (npc.unlocked) {
                                        setSelectedNPC(npc.id);
                                        onTalk(npc.id);
                                    }
                                }
                            },
                                React.createElement('h3', null, npc.name),
                                React.createElement('p', null, npc.role),
                                React.createElement('p', { style: { marginTop: '10px' } }, 
                                    npc.unlocked ? 'Talk' : 'Still sleeping...'
                                )
                            )
                        )
                    ),
                    React.createElement('h2', null, 'Weapon Upgrades'),
                    React.createElement('button', { 
                        className: 'menu-button secondary',
                        onClick: () => onUpgrade('sword')
                    }, `Upgrade Sword (Cost: ${gameState.player.swordLevel * 100} XP)`),
                    gameState.player.staffUnlocked && React.createElement('button', { 
                        className: 'menu-button secondary',
                        onClick: () => onUpgrade('staff')
                    }, 'Unlock Staff Ability'),
                    React.createElement('button', { 
                        className: 'menu-button',
                        onClick: onClose
                    }, 'Return to Dungeon')
                )
            );
        };
        
        // Main Game Component
        const Game = () => {
            window.logError('Game component rendering');
            
            const mountRef = useRef(null);
            const sceneRef = useRef(null);
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);
            const playerRef = useRef(null);
            
            const [loading, setLoading] = useState(true);
            const [loadingProgress, setLoadingProgress] = useState(0);
            const [loadingMessage, setLoadingMessage] = useState('Initializing...');
            
            window.logError('Game state initialized');
            
            const [gameState, setGameState] = useState(() => new GameState());
            const [showMenu, setShowMenu] = useState(true);
            const [showHub, setShowHub] = useState(false);
            const [currentDialog, setCurrentDialog] = useState(null);
            const [gameMessage, setGameMessage] = useState('');
            const [errors, setErrors] = useState([]);
            
            const dungeonGenerator = useMemo(() => new DungeonGenerator(), []);
            
            // Initialize Three.js
            useEffect(() => {
                if (!mountRef.current) return;
                
                try {
                    setLoadingMessage('Creating world...');
                    setLoadingProgress(20);
                
                // Scene setup
                const scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x000000, 0, 100);
                scene.background = new THREE.Color(0x000011);
                sceneRef.current = scene;
                
                // Camera setup
                const camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.set(0, 10, 20);
                camera.lookAt(0, 0, 0);
                cameraRef.current = camera;
                
                // Renderer setup
                const renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: 'high-performance'
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;
                
                setLoadingProgress(40);
                setLoadingMessage('Loading assets...');
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
                
                // Player setup (using cylinder since CapsuleGeometry isn't in r128)
                const playerGroup = new THREE.Group();
                
                // Create player with cylinder body
                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
                const playerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x002200,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, playerMaterial);
                body.position.y = 0.75;
                body.castShadow = true;
                body.receiveShadow = true;
                playerGroup.add(body);
                
                // Add sphere for head
                const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const head = new THREE.Mesh(headGeometry, playerMaterial);
                head.position.y = 1.8;
                head.castShadow = true;
                playerGroup.add(head);
                
                playerGroup.position.y = 0;
                scene.add(playerGroup);
                playerRef.current = playerGroup;
                
                setLoadingProgress(60);
                setLoadingMessage('Generating dungeon...');
                
                // Store the floor generation for later
                const initialFloorGeneration = () => {
                    try {
                        generateDungeonFloor(1);
                        setLoadingProgress(80);
                        setLoadingMessage('Preparing adventure...');
                        
                        setTimeout(() => {
                            setLoadingProgress(100);
                            setLoadingMessage('Ready!');
                            setTimeout(() => setLoading(false), 500);
                        }, 500);
                    } catch (error) {
                        console.error('Error generating dungeon:', error);
                        setLoadingMessage('Error loading game. Please refresh.');
                    }
                };
                
                // Delay to ensure everything is loaded
                setTimeout(initialFloorGeneration, 100);
                
                // Handle resize
                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);
                
                // Animation loop
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    // Update player position from game state
                    if (playerRef.current && gameState && gameState.player) {
                        playerRef.current.position.x = gameState.player.position.x;
                        playerRef.current.position.z = gameState.player.position.z;
                        playerRef.current.rotation.y = gameState.player.rotation;
                    }
                    
                    // Camera follow player
                    if (cameraRef.current && playerRef.current) {
                        const cameraOffset = new THREE.Vector3(0, 10, 20);
                        cameraOffset.applyQuaternion(playerRef.current.quaternion);
                        cameraRef.current.position.lerp(
                            playerRef.current.position.clone().add(cameraOffset),
                            0.1
                        );
                        cameraRef.current.lookAt(playerRef.current.position);
                    }
                    
                    if (rendererRef.current && sceneRef.current && cameraRef.current) {
                        rendererRef.current.render(sceneRef.current, cameraRef.current);
                    }
                };
                animate();
                
                return () => {
                    window.removeEventListener('resize', handleResize);
                    if (mountRef.current && rendererRef.current && rendererRef.current.domElement) {
                        try {
                            mountRef.current.removeChild(rendererRef.current.domElement);
                        } catch (e) {
                            // Already removed
                        }
                    }
                    if (rendererRef.current) {
                        rendererRef.current.dispose();
                    }
                };
                } catch (error) {
                    console.error('Error initializing game:', error);
                    setLoadingMessage('Error: ' + error.message);
                    setLoading(false);
                }
            }, []);
            
            // Generate dungeon floor - define before use
            const generateDungeonFloor = (floor) => {
                if (!sceneRef.current) return;
                
                console.log('Generating floor', floor);
                
                // Clear existing dungeon
                const toRemove = [];
                sceneRef.current.traverse((child) => {
                    if (child.userData.isDungeon) {
                        toRemove.push(child);
                    }
                });
                toRemove.forEach(child => {
                    sceneRef.current.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                
                // Generate new floor
                const floorData = dungeonGenerator.generateFloor(floor);
                setGameState(prev => ({
                    ...prev,
                    dungeon: {
                        ...prev.dungeon,
                        ...floorData,
                        currentFloor: floor
                    }
                }));
                
                // Create room meshes
                floorData.rooms.forEach(room => {
                    // Floor
                    const floorGeometry = new THREE.PlaneGeometry(room.size.width, room.size.height);
                    const floorMaterial = new THREE.MeshStandardMaterial({ 
                        color: floorData.theme.color,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                    floorMesh.rotation.x = -Math.PI / 2;
                    floorMesh.position.set(room.position.x, 0, room.position.z);
                    floorMesh.receiveShadow = true;
                    floorMesh.userData.isDungeon = true;
                    sceneRef.current.add(floorMesh);
                    
                    // Walls
                    const wallHeight = 5;
                    const wallThickness = 0.5;
                    const wallMaterial = new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color(floorData.theme.color).multiplyScalar(0.5),
                        roughness: 0.9,
                        metalness: 0.1
                    });
                    
                    // Create walls with gaps for connections
                    const walls = [
                        { pos: [0, wallHeight/2, -room.size.height/2], size: [room.size.width, wallHeight, wallThickness], rot: [0, 0, 0] },
                        { pos: [0, wallHeight/2, room.size.height/2], size: [room.size.width, wallHeight, wallThickness], rot: [0, 0, 0] },
                        { pos: [-room.size.width/2, wallHeight/2, 0], size: [wallThickness, wallHeight, room.size.height], rot: [0, 0, 0] },
                        { pos: [room.size.width/2, wallHeight/2, 0], size: [wallThickness, wallHeight, room.size.height], rot: [0, 0, 0] }
                    ];
                    
                    walls.forEach(wall => {
                        const wallGeometry = new THREE.BoxGeometry(...wall.size);
                        const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                        wallMesh.position.set(
                            room.position.x + wall.pos[0],
                            wall.pos[1],
                            room.position.z + wall.pos[2]
                        );
                        wallMesh.castShadow = true;
                        wallMesh.receiveShadow = true;
                        wallMesh.userData.isDungeon = true;
                        sceneRef.current.add(wallMesh);
                    });
                    
                    // Add portal in main room
                    if (room.hasPortal) {
                        const portalGeometry = new THREE.RingGeometry(1.5, 2, 32);
                        const portalMaterial = new THREE.MeshStandardMaterial({
                            color: 0x6666ff,
                            emissive: 0x6666ff,
                            emissiveIntensity: 0.5,
                            side: THREE.DoubleSide
                        });
                        const portal = new THREE.Mesh(portalGeometry, portalMaterial);
                        portal.position.set(room.position.x, 0.1, room.position.z);
                        portal.rotation.x = -Math.PI / 2;
                        portal.userData.isDungeon = true;
                        portal.userData.isPortal = true;
                        sceneRef.current.add(portal);
                    }
                    
                    // Add enemies
                    room.enemies.forEach(enemy => {
                        const enemyGeometry = enemy.type === 'boss' ? 
                            new THREE.BoxGeometry(2, 4, 2) :
                            new THREE.ConeGeometry(0.5, 1.5, 8);
                        const enemyMaterial = new THREE.MeshStandardMaterial({
                            color: enemy.type === 'boss' ? 0xff0000 : 0xff6600,
                            emissive: enemy.type === 'boss' ? 0x660000 : 0x331100,
                            emissiveIntensity: 0.3
                        });
                        const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                        enemyMesh.position.set(
                            room.position.x + enemy.position.x,
                            enemy.type === 'boss' ? 2 : 0.75,
                            room.position.z + enemy.position.z
                        );
                        enemyMesh.castShadow = true;
                        enemyMesh.userData.isDungeon = true;
                        enemyMesh.userData.isEnemy = true;
                        enemyMesh.userData.enemyData = enemy;
                        sceneRef.current.add(enemyMesh);
                    });
                    
                    // Add treasures
                    room.treasures.forEach(treasure => {
                        const chestGeometry = new THREE.BoxGeometry(1, 1, 1);
                        const chestMaterial = new THREE.MeshStandardMaterial({
                            color: treasure.rarity === 'legendary' ? 0xffaa00 : 
                                   treasure.rarity === 'rare' ? 0xaa66ff :
                                   treasure.rarity === 'uncommon' ? 0x66aaff : 0x888888,
                            metalness: 0.5,
                            roughness: 0.3
                        });
                        const chestMesh = new THREE.Mesh(chestGeometry, chestMaterial);
                        chestMesh.position.set(
                            room.position.x + treasure.position.x,
                            0.5,
                            room.position.z + treasure.position.z
                        );
                        chestMesh.castShadow = true;
                        chestMesh.userData.isDungeon = true;
                        chestMesh.userData.isTreasure = true;
                        chestMesh.userData.treasureData = treasure;
                        sceneRef.current.add(chestMesh);
                    });
                });
                
                showGameMessage(`Entered Floor ${floor}`);
            };
            
            // Show game message
            const showGameMessage = (message) => {
                setGameMessage(message);
                setTimeout(() => setGameMessage(''), 3000);
            };
            
            // Handle game start
            const handleStart = () => {
                setGameState(new GameState());
                generateDungeonFloor(1);
                setShowMenu(false);
                showGameMessage('Your journey begins...');
            };
            
            // Handle continue
            const handleContinue = () => {
                const state = new GameState();
                if (state.load()) {
                    setGameState(state);
                    generateDungeonFloor(state.dungeon.currentFloor);
                    setShowMenu(false);
                    showGameMessage('Welcome back, adventurer!');
                }
            };
            
            // Handle save
            const handleSave = () => {
                if (gameState.save()) {
                    showGameMessage('Game saved!');
                } else {
                    showGameMessage('Failed to save game');
                }
            };
            
            // Input handling
            useEffect(() => {
                if (showMenu || loading) return;
                
                const keys = {};
                const mouseMovement = { x: 0, y: 0 };
                let isPointerLocked = false;
                
                const handleKeyDown = (e) => {
                    keys[e.key.toLowerCase()] = true;
                    
                    // Quick save
                    if (e.key === 'F5') {
                        e.preventDefault();
                        handleSave();
                    }
                    
                    // Open hub menu
                    if (e.key === 'h' && gameState.hub.currentLocation === 'hub') {
                        setShowHub(true);
                    }
                    
                    // Escape to menu
                    if (e.key === 'Escape') {
                        setShowMenu(true);
                    }
                };
                
                const handleKeyUp = (e) => {
                    keys[e.key.toLowerCase()] = false;
                };
                
                const handleMouseMove = (e) => {
                    if (isPointerLocked) {
                        mouseMovement.x = e.movementX;
                        mouseMovement.y = e.movementY;
                    }
                };
                
                const handleClick = () => {
                    if (!isPointerLocked && rendererRef.current) {
                        rendererRef.current.domElement.requestPointerLock();
                    }
                };
                
                const handlePointerLockChange = () => {
                    isPointerLocked = document.pointerLockElement === rendererRef.current?.domElement;
                };
                
                // Add event listeners
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('click', handleClick);
                document.addEventListener('pointerlockchange', handlePointerLockChange);
                
                // Game update loop
                const gameLoop = setInterval(() => {
                    // Movement
                    const moveSpeed = 0.2;
                    const rotSpeed = 0.03;
                    
                    setGameState(prev => {
                        const newState = { ...prev };
                        const player = newState.player;
                        
                        // Rotation
                        if (mouseMovement.x !== 0) {
                            player.rotation -= mouseMovement.x * rotSpeed * gameState.settings.sensitivity;
                            mouseMovement.x = 0;
                        }
                        
                        // Movement
                        const forward = { 
                            x: Math.sin(player.rotation) * moveSpeed,
                            z: Math.cos(player.rotation) * moveSpeed
                        };
                        const right = {
                            x: Math.cos(player.rotation) * moveSpeed,
                            z: -Math.sin(player.rotation) * moveSpeed
                        };
                        
                        if (keys['w']) {
                            player.position.x += forward.x;
                            player.position.z += forward.z;
                        }
                        if (keys['s']) {
                            player.position.x -= forward.x;
                            player.position.z -= forward.z;
                        }
                        if (keys['a']) {
                            player.position.x -= right.x;
                            player.position.z -= right.z;
                        }
                        if (keys['d']) {
                            player.position.x += right.x;
                            player.position.z += right.z;
                        }
                        
                        // Regeneration
                        if (player.stamina < player.maxStamina) {
                            player.stamina = Math.min(player.maxStamina, player.stamina + 0.2);
                        }
                        if (player.mana < player.maxMana) {
                            player.mana = Math.min(player.maxMana, player.mana + 0.1);
                        }
                        
                        return newState;
                    });
                }, 16);
                
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('click', handleClick);
                    document.removeEventListener('pointerlockchange', handlePointerLockChange);
                    clearInterval(gameLoop);
                };
            }, [showMenu, loading, gameState, handleSave]);
            
            // Handle item use
            const handleItemUse = (item) => {
                if (item.type === 'health_potion') {
                    setGameState(prev => ({
                        ...prev,
                        player: {
                            ...prev.player,
                            health: Math.min(prev.player.maxHealth, prev.player.health + 50)
                        }
                    }));
                    showGameMessage('Health restored!');
                }
            };
            
            // Handle NPC talk
            const handleNPCTalk = (npcId) => {
                const dialogs = {
                    mira: "Your sword looks worn. Bring me materials and I can improve it!",
                    kaelin: "The obelisks... they weren't always corrupted. Something changed centuries ago.",
                    leta: "Rest here if you're wounded. The labyrinth takes its toll on everyone.",
                    corvus: "I've seen strange things in my travels. The capital grows restless.",
                    soren: "These visions... they speak of a consciousness that refuses to die."
                };
                
                setCurrentDialog({
                    speaker: npcId.charAt(0).toUpperCase() + npcId.slice(1),
                    text: dialogs[npcId] || "..."
                });
            };
            
            // Handle weapon upgrade
            const handleWeaponUpgrade = (weapon) => {
                if (weapon === 'sword') {
                    const cost = gameState.player.swordLevel * 100;
                    if (gameState.player.xp >= cost) {
                        setGameState(prev => ({
                            ...prev,
                            player: {
                                ...prev.player,
                                xp: prev.player.xp - cost,
                                swordLevel: prev.player.swordLevel + 1
                            },
                            inventory: {
                                ...prev.inventory,
                                equipped: {
                                    ...prev.inventory.equipped,
                                    weapon: {
                                        ...prev.inventory.equipped.weapon,
                                        level: prev.player.swordLevel + 1,
                                        damage: 10 + (prev.player.swordLevel + 1) * 5
                                    }
                                }
                            }
                        }));
                        showGameMessage(`Sword upgraded to level ${gameState.player.swordLevel + 1}!`);
                    } else {
                        showGameMessage('Not enough XP!');
                    }
                }
            };
            
            // Check for save data
            const hasSaveData = useMemo(() => {
                try {
                    return localStorage.getItem(SAVE_KEY) !== null;
                } catch (e) {
                    return false;
                }
            }, []);
            
            window.logError('Game component about to return JSX');
            
            if (loading) {
                return React.createElement(LoadingScreen, {
                    progress: loadingProgress,
                    message: loadingMessage
                });
            }
            
            return React.createElement('div', null,
                React.createElement('div', { ref: mountRef, style: { position: 'absolute', top: 0, left: 0 } }),
                React.createElement('div', { className: 'game-ui' },
                    !showMenu && !showHub && React.createElement(React.Fragment, null,
                        React.createElement(HUD, { gameState }),
                        React.createElement(Inventory, { gameState, onItemUse: handleItemUse }),
                        React.createElement(Minimap, { gameState }),
                        React.createElement(GameMessage, { message: gameMessage }),
                        currentDialog && React.createElement(Dialog, {
                            speaker: currentDialog.speaker,
                            text: currentDialog.text,
                            onContinue: () => setCurrentDialog(null)
                        })
                    ),
                    showMenu && React.createElement(MainMenu, {
                        onStart: handleStart,
                        onContinue: handleContinue,
                        onSettings: () => showGameMessage('Settings coming soon!'),
                        hasSave: hasSaveData
                    }),
                    showHub && React.createElement(HubMenu, {
                        gameState,
                        onClose: () => setShowHub(false),
                        onUpgrade: handleWeaponUpgrade,
                        onTalk: handleNPCTalk
                    })
                )
            );
        };
        
        // Check for save data
        const hasSaveData = useMemo(() => {
            return localStorage.getItem(SAVE_KEY) !== null;
        }, []);
        
        // Add error boundary
        window.addEventListener('error', (e) => {
            window.logError('Runtime error', e.error);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            window.logError('Promise rejection', e.reason);
        });
        
        // Check if Three.js loaded
        if (typeof THREE === 'undefined') {
            window.logError('Three.js failed to load', 'THREE is undefined');
        } else {
            window.logError('Three.js loaded successfully');
        }
        
        // Check if React loaded
        if (typeof React === 'undefined') {
            window.logError('React failed to load', 'React is undefined');
        } else {
            window.logError('React loaded successfully');
        }
        
        // Render the game
        try {
            const rootElement = document.getElementById('root');
            if (!rootElement) {
                window.logError('Root element not found');
                return;
            }
            
            // First test with simple component
            window.logError('Testing with simple component first');
            
            // Try React 18 createRoot first, fallback to React 17 render
            if (ReactDOM.createRoot) {
                window.logError('Using React 18 createRoot');
                const root = ReactDOM.createRoot(rootElement);
                // Test with simple component first
                root.render(React.createElement(TestComponent));
                window.logError('Test component rendered, now rendering game in 1 second...');
                
                // Then render the actual game
                setTimeout(() => {
                    try {
                        window.logError('Rendering actual game');
                        root.render(React.createElement(Game));
                        window.logError('Game rendered successfully');
                    } catch (gameError) {
                        window.logError('Error rendering game', gameError);
                        root.render(React.createElement('div', { 
                            style: { color: 'red', padding: '20px' } 
                        }, 'Game error: ' + gameError.message));
                    }
                }, 1000);
            } else {
                window.logError('Using React 17 render');
                ReactDOM.render(React.createElement(TestComponent), rootElement);
                setTimeout(() => {
                    ReactDOM.render(React.createElement(Game), rootElement);
                }, 1000);
            }
        } catch (error) {
            window.logError('Failed to render React app', error);
            // Show error in root element as fallback
            const rootElement = document.getElementById('root');
            if (rootElement) {
                rootElement.innerHTML = '<div style="color: red; padding: 20px;">Failed to initialize: ' + error.message + '</div>';
            }
        }
        
            } catch (error) {
                const errorDiv = document.getElementById('error-log');
                errorDiv.innerHTML = 'Game initialization error: ' + error.message + '<br>' + error.stack;
                errorDiv.style.display = 'block';
                updateLoadingMessage('Game initialization failed');
            }
        }
        
        // Try to initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }
        
        // Also try when all resources are loaded
        window.addEventListener('load', initializeGame);
        
        // Fallback timer
        setTimeout(initializeGame, 3000);
    </script>
</body>
</html>d. The labyrinth takes its toll on everyone.",
                    corvus: "I've seen strange things in my travels. The capital grows restless.",
                    soren: "These visions... they speak of a consciousness that refuses to die."
                };
                
                setCurrentDialog({
                    speaker: npcId.charAt(0).toUpperCase() + npcId.slice(1),
                    text: dialogs[npcId] || "..."
                });
            };
            
            // Handle weapon upgrade
            const handleWeaponUpgrade = (weapon) => {
                if (weapon === 'sword') {
                    const cost = gameState.player.swordLevel * 100;
                    if (gameState.player.xp >= cost) {
                        setGameState(prev => ({
                            ...prev,
                            player: {
                                ...prev.player,
                                xp: prev.player.xp - cost,
                                swordLevel: prev.player.swordLevel + 1
                            },
                            inventory: {
                                ...prev.inventory,
                                equipped: {
                                    ...prev.inventory.equipped,
                                    weapon: {
                                        ...prev.inventory.equipped.weapon,
                                        level: prev.player.swordLevel + 1,
                                        damage: 10 + (prev.player.swordLevel + 1) * 5
                                    }
                                }
                            }
                        }));
                        showGameMessage(`Sword upgraded to level ${gameState.player.swordLevel + 1}!`);
                    } else {
                        showGameMessage('Not enough XP!');
                    }
                }
            };
            
            // Check for save data
            const hasSaveData = useMemo(() => {
                return localStorage.getItem(SAVE_KEY) !== null;
            }, []);
            
            window.logError('Game component about to return JSX');
            
            if (loading) {
                return React.createElement(LoadingScreen, {
                    progress: loadingProgress,
                    message: loadingMessage
                });
            }
            
            return React.createElement('div', null,
                React.createElement('div', { ref: mountRef, style: { position: 'absolute', top: 0, left: 0 } }),
                React.createElement('div', { className: 'game-ui' },
                    !showMenu && !showHub && React.createElement(React.Fragment, null,
                        React.createElement(HUD, { gameState }),
                        React.createElement(Inventory, { gameState, onItemUse: handleItemUse }),
                        React.createElement(Minimap, { gameState }),
                        React.createElement(GameMessage, { message: gameMessage }),
                        currentDialog && React.createElement(Dialog, {
                            speaker: currentDialog.speaker,
                            text: currentDialog.text,
                            onContinue: () => setCurrentDialog(null)
                        })
                    ),
                    showMenu && React.createElement(MainMenu, {
                        onStart: handleStart,
                        onContinue: handleContinue,
                        onSettings: () => showGameMessage('Settings coming soon!'),
                        hasSave: hasSaveData
                    }),
                    showHub && React.createElement(HubMenu, {
                        gameState,
                        onClose: () => setShowHub(false),
                        onUpgrade: handleWeaponUpgrade,
                        onTalk: handleNPCTalk
                    })
                )
            );
        };
        
        // Render the game
        try {
            const rootElement = document.getElementById('root');
            if (!rootElement) {
                window.logError('Root element not found');
                return;
            }
            
            // First test with simple component
            window.logError('Testing with simple component first');
            
            // Try React 18 createRoot first, fallback to React 17 render
            if (ReactDOM.createRoot) {
                window.logError('Using React 18 createRoot');
                const root = ReactDOM.createRoot(rootElement);
                // Test with simple component first
                root.render(React.createElement(TestComponent));
                window.logError('Test component rendered, now rendering game in 1 second...');
                
                // Then render the actual game
                setTimeout(() => {
                    try {
                        window.logError('Rendering actual game');
                        root.render(React.createElement(Game));
                        window.logError('Game rendered successfully');
                    } catch (gameError) {
                        window.logError('Error rendering game', gameError);
                        root.render(React.createElement('div', { 
                            style: { color: 'red', padding: '20px' } 
                        }, 'Game error: ' + gameError.message));
                    }
                }, 1000);
            } else {
                window.logError('Using React 17 render');
                ReactDOM.render(React.createElement(TestComponent), rootElement);
                setTimeout(() => {
                    ReactDOM.render(React.createElement(Game), rootElement);
                }, 1000);
            }
        } catch (error) {
            window.logError('Failed to render React app', error);
            // Show error in root element as fallback
            const rootElement = document.getElementById('root');
            if (rootElement) {
                rootElement.innerHTML = '<div style="color: red; padding: 20px;">Failed to initialize: ' + error.message + '</div>';
            }
        }
        
            } catch (error) {
                const errorDiv = document.getElementById('error-log');
                errorDiv.innerHTML = 'Game initialization error: ' + error.message + '<br>' + error.stack;
                errorDiv.style.display = 'block';
                updateLoadingMessage('Game initialization failed');
            }
        }
        
        // Try to initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }
        
        // Also try when all resources are loaded
        window.addEventListener('load', initializeGame);
        
        // Fallback timer
        setTimeout(initializeGame, 3000);
    </script>
</body>
</html>
