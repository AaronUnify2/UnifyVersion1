<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mystic Forest Walker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load modular game systems before main game code -->
    <script>window.jsLoadErrors = [];</script>
    <script src="js/enemies.js" onerror="window.jsLoadErrors.push('enemies.js')"></script>
    <script src="js/bosses.js" onerror="window.jsLoadErrors.push('bosses.js')"></script>
    <script src="js/encounters.js" onerror="window.jsLoadErrors.push('encounters.js')"></script>
    <script src="js/slime-companion.js" onerror="window.jsLoadErrors.push('slime-companion.js')"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            overflow: hidden;
            background: #0a0a12;
            font-family: 'Press Start 2P', cursive;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
        }
        
        #debugDisplay {
            display: none; /* Hidden for now - change to 'block' to debug */
            position: fixed;
            bottom: 120px;
            left: 10px;
            color: #0f0;
            font-size: 8px;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            max-width: 300px;
            max-height: 150px;
            overflow: hidden;
            z-index: 9999;
            pointer-events: none;
            white-space: pre-wrap;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 10px;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
            line-height: 1.8;
            z-index: 100;
        }
        
        #stats .level {
            color: #ffd700;
            font-size: 14px;
        }
        
        #healthBar {
            width: 150px;
            height: 16px;
            background: #333;
            border: 3px solid #222;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(180deg, #ff6b6b, #c0392b);
            transition: width 0.3s;
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3);
        }
        
        #xpBar {
            width: 150px;
            height: 10px;
            background: #333;
            border: 2px solid #222;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        #xpFill {
            height: 100%;
            background: linear-gradient(180deg, #9b59b6, #8e44ad);
            transition: width 0.3s;
        }
        
        #dpad {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }
        
        .dpad-btn {
            position: absolute;
            width: 46px;
            height: 46px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: rgba(255,255,255,0.7);
            transition: all 0.1s;
            backdrop-filter: blur(4px);
        }
        
        .dpad-btn:active, .dpad-btn.active {
            background: rgba(255,255,255,0.35);
            transform: scale(0.95);
            border-color: rgba(255,255,255,0.6);
        }
        
        #dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
        #dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
        #dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
        #dpad-right { right: 0; top: 50%; transform: translateY(-50%); }
        
        #magicBtn {
            position: absolute;
            bottom: 50px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #9b59b6, #6c3483);
            border: 4px solid #bb8fce;
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #9b59b6;
            box-shadow: 0 0 20px rgba(155,89,182,0.5), inset 0 -4px 10px rgba(0,0,0,0.3);
            transition: all 0.1s;
        }
        
        #magicBtn:active {
            transform: scale(0.9);
            box-shadow: 0 0 30px rgba(155,89,182,0.8), inset 0 -4px 10px rgba(0,0,0,0.3);
        }
        
        #viewArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            pointer-events: auto;
        }
        
        #damageFlash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,0,0,0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
        
        #levelUp {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 24px;
            text-shadow: 0 0 20px #ffd700, 0 0 40px #ff8c00;
            opacity: 0;
            pointer-events: none;
            animation: none;
        }
        
        @keyframes levelUpAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1) translateY(-50px); }
        }
        
        #killCount {
            position: absolute;
            top: 80px;
            right: 10px;
            color: #ff6b6b;
            font-size: 12px;
            text-shadow: 2px 2px 0 #000;
        }
        
        #stats .gold {
            color: #ffd700;
            margin-top: 8px;
            font-size: 12px;
        }
        
        #menuBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 60px;
            height: 60px;
            background: linear-gradient(180deg, rgba(108,92,231,0.9), rgba(68,52,191,0.9));
            border: 3px solid #bb8fce;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            color: #fff;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(108,92,231,0.5);
            z-index: 100;
        }
        
        #menuBtn .btn-label {
            font-size: 8px;
            margin-top: 2px;
            font-family: 'Press Start 2P', cursive;
        }
        
        #menuBtn:active {
            background: linear-gradient(180deg, rgba(138,122,255,0.9), rgba(98,82,221,0.9));
            transform: scale(0.95);
        }
        
        #upgradeMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
            pointer-events: auto;
        }
        
        #menuContent {
            background: linear-gradient(180deg, #2c2c54, #1a1a2e);
            border: 4px solid #6c5ce7;
            border-radius: 16px;
            padding: 20px;
            max-width: 340px;
            width: 90%;
            box-shadow: 0 0 30px rgba(108,92,231,0.5);
        }
        
        #menuContent h2 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
            text-shadow: 0 0 10px #ffd700;
        }
        
        .upgrade-item {
            display: flex;
            align-items: center;
            background: rgba(0,0,0,0.3);
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 12px;
            gap: 10px;
        }
        
        .upgrade-item.maxed {
            border-color: #27ae60;
            opacity: 0.7;
        }
        
        .upgrade-icon {
            font-size: 28px;
            width: 40px;
            text-align: center;
        }
        
        .upgrade-info {
            flex: 1;
        }
        
        .upgrade-name {
            color: #fff;
            font-size: 10px;
            margin-bottom: 2px;
        }
        
        .upgrade-desc {
            color: #888;
            font-size: 7px;
            margin-bottom: 4px;
        }
        
        .upgrade-level {
            color: #9b59b6;
            font-size: 8px;
        }
        
        .upgrade-btn {
            background: linear-gradient(180deg, #f39c12, #d68910);
            border: 2px solid #ffd700;
            border-radius: 6px;
            padding: 8px 12px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            cursor: pointer;
            pointer-events: auto;
            min-width: 70px;
        }
        
        .upgrade-btn:disabled {
            background: #555;
            border-color: #666;
            color: #888;
            cursor: not-allowed;
        }
        
        .upgrade-btn:not(:disabled):active {
            transform: scale(0.95);
        }
        
        #closeMenu {
            width: 100%;
            margin-top: 15px;
            padding: 12px;
            background: linear-gradient(180deg, #c0392b, #96281b);
            border: 2px solid #e74c3c;
            border-radius: 8px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        #closeMenu:active {
            transform: scale(0.98);
        }
        
        #boomCooldown {
            display: none;
            margin-top: 10px;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
        }
        
        #boomCooldown.active {
            display: block;
        }
        
        .cooldown-label {
            color: #e74c3c;
            font-size: 8px;
            margin-bottom: 4px;
            text-align: center;
        }
        
        .cooldown-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .cooldown-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        #boomIndicator {
            position: absolute;
            bottom: 140px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at 30% 30%, #e74c3c, #96281b);
            border: 3px solid #f39c12;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #fff;
            pointer-events: auto;
            opacity: 0.5;
        }
        
        #boomIndicator.ready {
            opacity: 1;
            box-shadow: 0 0 15px rgba(231,76,60,0.7);
            animation: boomPulse 1s ease-in-out infinite;
        }
        
        @keyframes boomPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* First-Person Toggle Button */
        #fpToggle {
            position: absolute;
            top: 80px;
            left: 10px;
            width: 45px;
            height: 45px;
            background: linear-gradient(180deg, rgba(52,73,94,0.9), rgba(44,62,80,0.9));
            border: 2px solid #95a5a6;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #fff;
            pointer-events: auto;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s;
        }
        
        #fpToggle:hover {
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        
        #fpToggle:active {
            transform: scale(0.95);
        }
        
        #fpToggle.active {
            background: linear-gradient(180deg, rgba(46,204,113,0.9), rgba(39,174,96,0.9));
            border-color: #2ecc71;
            box-shadow: 0 0 10px rgba(46,204,113,0.5);
        }
        
        #fpToggle .fp-label {
            font-size: 6px;
            font-family: 'Press Start 2P', cursive;
            margin-top: 2px;
        }
        
        #bossHealthBar {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }
        
        #bossHealthBar.active {
            display: flex;
        }
        
        .boss-name {
            color: #e74c3c;
            font-size: 12px;
            margin-bottom: 5px;
            text-shadow: 2px 2px 0 #000, 0 0 10px #e74c3c;
        }
        
        .boss-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border: 3px solid #8b0000;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(139,0,0,0.5);
        }
        
        .boss-fill {
            height: 100%;
            background: linear-gradient(180deg, #e74c3c, #8b0000);
            transition: width 0.2s;
            box-shadow: inset 0 -3px 6px rgba(0,0,0,0.3);
        }
        
        #dialogueBox {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            border: 3px solid #ffd700;
            border-radius: 12px;
            padding: 15px 25px;
            max-width: 320px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 200;
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
            pointer-events: auto;
        }
        
        #dialogueBox.active {
            display: flex;
            animation: dialoguePop 0.3s ease-out;
        }
        
        @keyframes dialoguePop {
            0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        
        .dialogue-speaker {
            color: #ffd700;
            font-size: 10px;
            margin-bottom: 8px;
            text-shadow: 0 0 10px #ffd700;
        }
        
        .dialogue-text {
            color: #fff;
            font-size: 9px;
            text-align: center;
            line-height: 1.6;
        }
        
        .dialogue-continue {
            margin-top: 12px;
            padding: 8px 20px;
            background: linear-gradient(180deg, #f39c12, #d68910);
            border: 2px solid #ffd700;
            border-radius: 6px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.1s;
        }
        
        .dialogue-continue:hover {
            background: linear-gradient(180deg, #f5b041, #e59400);
        }
        
        .dialogue-continue:active {
            transform: scale(0.95);
        }
        
        #rewardNotification {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg, rgba(39,174,96,0.9), rgba(30,130,76,0.9));
            border: 3px solid #2ecc71;
            border-radius: 10px;
            padding: 12px 24px;
            display: none;
            z-index: 200;
            box-shadow: 0 0 25px rgba(46,204,113,0.5);
        }
        
        #rewardNotification.active {
            display: block;
            animation: rewardSlide 0.4s ease-out;
        }
        
        @keyframes rewardSlide {
            0% { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        #rewardText {
            color: #fff;
            font-size: 11px;
            text-shadow: 0 0 10px #fff;
        }
        
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            z-index: 1000;
        }
        
        #gameOver h1 {
            color: #c0392b;
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #c0392b;
        }
        
        #gameOver p {
            font-size: 12px;
            margin: 10px 0;
        }
        
        #restartBtn {
            margin-top: 30px;
            padding: 15px 30px;
            background: #27ae60;
            border: none;
            border-radius: 8px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        #instructions {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 7px;
            text-align: center;
            white-space: nowrap;
            max-width: 95vw;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        @media (max-width: 600px) {
            #instructions {
                font-size: 6px;
                white-space: normal;
                max-width: 90vw;
                line-height: 1.4;
            }
        }
        
        /* Debug Panel Styles */
        #debugPanel {
            position: fixed;
            top: 80px;
            right: 10px;
            background: rgba(0, 0, 0, 0.92);
            border: 2px solid #0f0;
            border-radius: 8px;
            padding: 10px;
            z-index: 9999;
            display: none;
            max-height: calc(100vh - 100px);
            max-width: 200px;
            overflow: hidden;
            pointer-events: auto;
            touch-action: none !important;
        }
        
        #debugPanel.active {
            display: block;
        }
        
        #debugPanel h3 {
            color: #0f0;
            font-size: 10px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid #0f0;
            padding-bottom: 5px;
            touch-action: none !important;
        }
        
        #debugPanelContent {
            max-height: calc(100vh - 160px);
            overflow-y: auto !important;
            overflow-x: hidden;
            padding-right: 5px;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            scrollbar-width: thin;
            scrollbar-color: #0f0 #222;
            touch-action: pan-y !important;
        }
        
        #debugPanelContent * {
            touch-action: pan-y !important;
        }
        
        #debugPanelContent::-webkit-scrollbar {
            width: 6px;
        }
        
        #debugPanelContent::-webkit-scrollbar-track {
            background: #222;
            border-radius: 3px;
        }
        
        #debugPanelContent::-webkit-scrollbar-thumb {
            background: #0f0;
            border-radius: 3px;
        }
        
        .debug-section {
            margin-bottom: 10px;
            touch-action: pan-y !important;
        }
        
        .debug-section-title {
            color: #ff0;
            font-size: 8px;
            margin-bottom: 5px;
        }
        
        .debug-btn {
            display: block;
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 4px;
            background: linear-gradient(180deg, #333, #222);
            border: 1px solid #0f0;
            border-radius: 4px;
            color: #0f0;
            font-family: 'Press Start 2P', cursive;
            font-size: 7px;
            cursor: pointer;
            text-align: left;
            transition: all 0.1s;
        }
        
        .debug-btn:hover {
            background: linear-gradient(180deg, #444, #333);
            border-color: #0f0;
            box-shadow: 0 0 5px #0f0;
        }
        
        .debug-btn:active {
            transform: scale(0.98);
            background: #0f0;
            color: #000;
        }
        
        .debug-btn.blue {
            border-color: #00bfff;
            color: #00bfff;
        }
        
        .debug-btn.blue:hover {
            box-shadow: 0 0 5px #00bfff;
        }
        
        .debug-btn.blue:active {
            background: #00bfff;
            color: #000;
        }
        
        .debug-btn.gold {
            border-color: #ffd700;
            color: #ffd700;
        }
        
        .debug-btn.gold:hover {
            box-shadow: 0 0 5px #ffd700;
        }
        
        .debug-btn.gold:active {
            background: #ffd700;
            color: #000;
        }
        
        .debug-btn.purple {
            border-color: #9b59b6;
            color: #9b59b6;
        }
        
        .debug-btn.purple:hover {
            box-shadow: 0 0 5px #9b59b6;
        }
        
        .debug-btn.purple:active {
            background: #9b59b6;
            color: #000;
        }
        
        .debug-btn.red {
            border-color: #e74c3c;
            color: #e74c3c;
        }
        
        .debug-btn.red:hover {
            box-shadow: 0 0 5px #e74c3c;
        }
        
        .debug-btn.red:active {
            background: #e74c3c;
            color: #000;
        }
        
        #debugToggle {
            position: fixed;
            top: 80px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #0f0;
            border-radius: 8px;
            color: #0f0;
            font-size: 16px;
            cursor: pointer;
            z-index: 10000;
            pointer-events: auto;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        #debugToggle.unlocked {
            display: flex;
        }
        
        #debugToggle:hover {
            box-shadow: 0 0 10px #0f0;
        }
        
        #debugToggle.panel-open {
            right: 220px;
        }
        
        /* Smaller screens */
        @media (max-height: 600px) {
            #debugPanel {
                top: 60px;
                max-height: calc(100vh - 70px);
                padding: 8px;
                font-size: 90%;
            }
            #debugPanelContent {
                max-height: calc(100vh - 120px);
            }
            #debugPanel h3 {
                font-size: 9px;
            }
            .debug-btn {
                padding: 6px 8px;
                font-size: 6px;
            }
            #debugToggle {
                top: 60px;
                width: 35px;
                height: 35px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="debugDisplay">v3 - Loading...</div>
    <script>
        // Check for load errors from head scripts
        var dbg = document.getElementById('debugDisplay');
        if (window.jsLoadErrors && window.jsLoadErrors.length > 0) {
            dbg.textContent = 'v3 - LOAD FAILED: ' + window.jsLoadErrors.join(', ');
        } else {
            dbg.textContent = 'v3 - Scripts loaded OK';
        }
        window.onerror = function(msg, url, line) {
            dbg.textContent = 'v3 ERROR: ' + msg + ' L' + line;
            return false;
        };
    </script>
    
    <div id="ui">
        <div id="stats">
            <div class="level">LVL <span id="levelNum">1</span></div>
            <div>HP</div>
            <div id="healthBar"><div id="healthFill" style="width: 100%"></div></div>
            <div>XP</div>
            <div id="xpBar"><div id="xpFill" style="width: 0%"></div></div>
            <div class="gold">üí∞ <span id="goldNum">0</span></div>
        </div>
        
        <div id="killCount">‚ò† <span id="kills">0</span></div>
        
        <div id="bossHealthBar">
            <div class="boss-name" id="bossName">BOSS</div>
            <div class="boss-bar"><div class="boss-fill" id="bossFill"></div></div>
        </div>
        
        <div id="dialogueBox">
            <div class="dialogue-speaker" id="dialogueSpeaker"></div>
            <div class="dialogue-text" id="dialogueText"></div>
            <button class="dialogue-continue" id="dialogueContinue">Continue ‚ñ∏</button>
        </div>
        
        <div id="rewardNotification">
            <span id="rewardText"></span>
        </div>
        
        <div id="menuBtn">üõí<span class="btn-label">SHOP</span></div>
        
        <div id="upgradeMenu">
            <div id="menuContent">
                <h2>UPGRADES</h2>
                <div class="upgrade-item" id="upgrade-magnet">
                    <div class="upgrade-icon">üß≤</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">Magnet</div>
                        <div class="upgrade-desc">Increase pickup range</div>
                        <div class="upgrade-level">Level: <span class="lvl">0</span>/8</div>
                    </div>
                    <button class="upgrade-btn" data-upgrade="magnet">
                        <span class="cost">üí∞ 10</span>
                    </button>
                </div>
                <div class="upgrade-item" id="upgrade-swords">
                    <div class="upgrade-icon">‚öîÔ∏è</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">Ring of Swords</div>
                        <div class="upgrade-desc">Orbiting swords (100% magic dmg)</div>
                        <div class="upgrade-level">Level: <span class="lvl">0</span>/8</div>
                    </div>
                    <button class="upgrade-btn" data-upgrade="swords">
                        <span class="cost">üí∞ 50</span>
                    </button>
                </div>
                <div class="upgrade-item" id="upgrade-boom">
                    <div class="upgrade-icon">üí•</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">Boom</div>
                        <div class="upgrade-desc">8-way blast (100% magic dmg)</div>
                        <div class="upgrade-level">Level: <span class="lvl">0</span>/30</div>
                    </div>
                    <button class="upgrade-btn" data-upgrade="boom">
                        <span class="cost">üí∞ 30</span>
                    </button>
                </div>
                <div id="boomCooldown">
                    <div class="cooldown-label">BOOM</div>
                    <div class="cooldown-bar"><div class="cooldown-fill" id="boomFill"></div></div>
                </div>
                <button id="closeMenu">CLOSE</button>
            </div>
        </div>
        
        <div id="viewArea"></div>
        
        <div id="dpad">
            <div class="dpad-btn" id="dpad-up">‚ñ≤</div>
            <div class="dpad-btn" id="dpad-down">‚ñº</div>
            <div class="dpad-btn" id="dpad-left">‚óÑ</div>
            <div class="dpad-btn" id="dpad-right">‚ñ∫</div>
        </div>
        
        <div id="magicBtn">‚ú¶</div>
        
        <div id="boomIndicator">üí•</div>
        
        <button id="fpToggle">üëÅÔ∏è<span class="fp-label">VIEW</span></button>
        
        <div id="instructions">üì± SWIPE+D-PAD ‚Ä¢ üíª CLICK TO ENABLE MOUSE LOOK ‚Ä¢ WASD+MOUSE ‚Ä¢ CLICK=SHOOT ‚Ä¢ SPACE=BOOM ‚Ä¢ V=VIEW</div>
    </div>
    
    <div id="damageFlash"></div>
    <div id="levelUp">LEVEL UP!</div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p>Level Reached: <span id="finalLevel">1</span></p>
        <p>Enemies Slain: <span id="finalKills">0</span></p>
        <p>Gold Collected: <span id="finalGold">0</span></p>
        <button id="restartBtn">RESTART</button>
    </div>
    
    <!-- Debug Panel -->
    <button id="debugToggle">üîß</button>
    <div id="debugPanel">
        <h3>üîß DEBUG PANEL</h3>
        
        <div id="debugPanelContent">
            <div class="debug-section">
                <div class="debug-section-title">üìú STORY PROGRESS</div>
                <div id="storyStageDisplay" style="color: #0f0; font-size: 7px; margin-bottom: 5px;">Stage: 0 - swordInStone</div>
                <button class="debug-btn" onclick="debugStory('prev')">‚¨ÖÔ∏è Previous Stage</button>
                <button class="debug-btn" onclick="debugStory('next')">‚û°Ô∏è Next Stage</button>
                <button class="debug-btn gold" onclick="debugStory('spawn')">‚ñ∂Ô∏è Spawn Current</button>
                <button class="debug-btn red" onclick="debugStory('reset')">üîÑ Reset Story</button>
            </div>
            
            <div class="debug-section">
                <div class="debug-section-title">üìñ STORY ENCOUNTERS</div>
                <button class="debug-btn gold" onclick="debugSpawn('princess')">üë∏ Princess Tower</button>
                <button class="debug-btn purple" onclick="debugSpawn('witch')">üßô‚Äç‚ôÄÔ∏è Witch Hut</button>
                <button class="debug-btn gold" onclick="debugSpawn('dharma')">‚ò∏Ô∏è Dharmachakra</button>
            </div>
            
            <div class="debug-section">
                <div class="debug-section-title">üó°Ô∏è SWORD IN STONE</div>
                <button class="debug-btn" onclick="debugSpawn('sword')">Act 1: Goblin's Ambition</button>
                <button class="debug-btn" onclick="debugSpawn('swordAct2')">Act 2: The Bribe</button>
                <button class="debug-btn red" onclick="debugSpawn('swordAct3')">Act 3: Land Giant</button>
            </div>
            
            <div class="debug-section">
                <div class="debug-section-title">‚öîÔ∏è OTHER ENCOUNTERS</div>
                <button class="debug-btn blue" onclick="debugSpawn('portal')">‚òÅÔ∏è Cloud Portal</button>
                <button class="debug-btn gold" onclick="debugSpawn('chest')">üì¶ Treasure Chest</button>
                <button class="debug-btn purple" onclick="debugSpawn('store')">üè™ Monster Store</button>
            </div>
            
            <div class="debug-section">
                <div class="debug-section-title">üëπ BOSSES</div>
                <button class="debug-btn red" onclick="debugSpawn('boss')">üíÄ Random Boss</button>
                <button class="debug-btn red" onclick="debugSpawn('evilTree')">üå≥ Evil Tree</button>
                <button class="debug-btn red" onclick="debugSpawn('troll')">üëπ Troll Boss</button>
            </div>
            
            <div class="debug-section">
                <div class="debug-section-title">‚ö° PLAYER CHEATS</div>
                <button class="debug-btn" onclick="debugCheat('level')">üìà +5 Levels</button>
                <button class="debug-btn gold" onclick="debugCheat('gold')">üí∞ +500 Gold</button>
                <button class="debug-btn" onclick="debugCheat('health')">‚ù§Ô∏è Full Health</button>
                <button class="debug-btn purple" onclick="debugCheat('swords')">‚öîÔ∏è +1 Sword</button>
                <button class="debug-btn gold" onclick="debugCheat('dharmaWheel')">‚ò∏Ô∏è Dharma Wheel</button>
                <button class="debug-btn gold" onclick="debugCheat('bonusSwords')">üó°Ô∏è Bonus Swords</button>
            </div>
            
            <div class="debug-section">
                <div class="debug-section-title">üßπ CLEANUP</div>
                <button class="debug-btn red" onclick="debugCleanup('encounter')">‚ùå Clear Encounter</button>
                <button class="debug-btn red" onclick="debugCleanup('enemies')">‚ùå Clear Enemies</button>
                <button class="debug-btn red" onclick="debugCleanup('bosses')">‚ùå Clear Bosses</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            renderDistance: 80,
            fogNear: 30,
            fogFar: 90,
            chunkSize: 30,
            treeDensity: 0.0045,
            playerSpeed: 0.12,
            enemyBaseHealth: 30,
            enemyBaseDamage: 5,
            baseXpToLevel: 50,
            projectileBaseSpeed: 0.5,
            projectileBaseDamage: 15,
            enemySpawnRadius: 35,
            enemyMaxCount: 12,
            enemySpawnInterval: 2000
        };
        
        // ============================================
        // DEBUG LOGGING (on-screen for mobile)
        // ============================================
        const debugLog = [];
        let debugFrameCount = 0;
        function debug(msg) {
            try {
                debugLog.push(msg);
                if (debugLog.length > 12) debugLog.shift();
                const el = document.getElementById('debugDisplay');
                if (el) el.textContent = debugLog.join('\n');
            } catch(e) {
                // Silently fail
            }
        }
        debug('Script loaded');
        debug('THREE: ' + (typeof THREE !== 'undefined'));
        debug('encounterState: ' + (typeof encounterState !== 'undefined'));

        // ============================================
        // PIXEL ART TEXTURE GENERATORS
        // ============================================
        function createPixelTexture(width, height, drawFunc) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            drawFunc(ctx, width, height);
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        function createTreeTexture(type = 0) {
            return createPixelTexture(32, 64, (ctx, w, h) => {
                const colors = [
                    { trunk: '#5d4037', leaves: ['#2e7d32', '#388e3c', '#43a047'] },
                    { trunk: '#4e342e', leaves: ['#1b5e20', '#2e7d32', '#388e3c'] },
                    { trunk: '#6d4c41', leaves: ['#558b2f', '#689f38', '#7cb342'] },
                    { trunk: '#3e2723', leaves: ['#4a148c', '#6a1b9a', '#7b1fa2'] } // Mystic purple tree
                ];
                const c = colors[type % colors.length];
                
                // Trunk
                ctx.fillStyle = c.trunk;
                ctx.fillRect(13, 30, 6, 34);
                ctx.fillStyle = '#3e2723';
                ctx.fillRect(14, 30, 2, 34);
                
                // Leaves layers
                const leafPatterns = [
                    { y: 5, w: 24, h: 14 },
                    { y: 15, w: 28, h: 12 },
                    { y: 24, w: 22, h: 10 }
                ];
                
                leafPatterns.forEach((p, i) => {
                    ctx.fillStyle = c.leaves[i % c.leaves.length];
                    ctx.fillRect((w - p.w) / 2, p.y, p.w, p.h);
                    
                    // Add pixel details
                    ctx.fillStyle = c.leaves[(i + 1) % c.leaves.length];
                    for (let j = 0; j < 6; j++) {
                        const px = (w - p.w) / 2 + Math.random() * p.w;
                        const py = p.y + Math.random() * p.h;
                        ctx.fillRect(Math.floor(px), Math.floor(py), 2, 2);
                    }
                });
                
                // Top
                ctx.fillStyle = c.leaves[0];
                ctx.fillRect(12, 0, 8, 6);
            });
        }

        function createGrassTexture() {
            return createPixelTexture(64, 64, (ctx, w, h) => {
                // Base
                ctx.fillStyle = '#1a472a';
                ctx.fillRect(0, 0, w, h);
                
                // Grass variation
                const colors = ['#2d5a3f', '#1e5631', '#174023', '#236b3f'];
                for (let i = 0; i < 100; i++) {
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    ctx.fillRect(
                        Math.floor(Math.random() * w),
                        Math.floor(Math.random() * h),
                        2, 2
                    );
                }
                
                // Small flowers
                const flowerColors = ['#e91e63', '#ffeb3b', '#03a9f4', '#ff9800'];
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                    ctx.fillRect(
                        Math.floor(Math.random() * w),
                        Math.floor(Math.random() * h),
                        2, 2
                    );
                }
            });
        }

        function createRockTexture() {
            return createPixelTexture(16, 16, (ctx, w, h) => {
                ctx.fillStyle = '#5d6d7e';
                ctx.beginPath();
                ctx.arc(8, 10, 7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#85929e';
                ctx.fillRect(4, 6, 4, 3);
                ctx.fillRect(9, 8, 3, 2);
                
                ctx.fillStyle = '#34495e';
                ctx.fillRect(6, 11, 5, 3);
            });
        }

        function createMushroomTexture() {
            return createPixelTexture(16, 24, (ctx, w, h) => {
                // Stem
                ctx.fillStyle = '#faf0e6';
                ctx.fillRect(6, 12, 4, 12);
                
                // Cap
                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.ellipse(8, 10, 7, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Spots
                ctx.fillStyle = '#fff';
                ctx.fillRect(4, 7, 3, 3);
                ctx.fillRect(9, 5, 2, 2);
                ctx.fillRect(10, 10, 2, 2);
            });
        }

        function createXPOrbTexture() {
            return createPixelTexture(16, 16, (ctx, w, h) => {
                // Outer glow
                ctx.fillStyle = '#9b59b6';
                ctx.beginPath();
                ctx.arc(8, 8, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner
                ctx.fillStyle = '#bb8fce';
                ctx.beginPath();
                ctx.arc(8, 8, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Shine
                ctx.fillStyle = '#fff';
                ctx.fillRect(5, 5, 3, 3);
            });
        }

        function createGoldOrbTexture() {
            return createPixelTexture(16, 16, (ctx, w, h) => {
                // Outer glow
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(8, 8, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(8, 8, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Shine
                ctx.fillStyle = '#fff';
                ctx.fillRect(5, 4, 3, 3);
                
                // Coin detail
                ctx.fillStyle = '#d68910';
                ctx.fillRect(7, 6, 2, 4);
            });
        }

        function createSwordTexture() {
            return createPixelTexture(16, 32, (ctx, w, h) => {
                // Blade
                ctx.fillStyle = '#bdc3c7';
                ctx.fillRect(6, 0, 4, 20);
                
                // Blade shine
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(7, 0, 2, 18);
                
                // Blade tip
                ctx.fillStyle = '#bdc3c7';
                ctx.beginPath();
                ctx.moveTo(6, 0);
                ctx.lineTo(10, 0);
                ctx.lineTo(8, -4);
                ctx.fill();
                
                // Guard
                ctx.fillStyle = '#f39c12';
                ctx.fillRect(2, 20, 12, 3);
                
                // Handle
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(6, 23, 4, 8);
                
                // Pommel
                ctx.fillStyle = '#f39c12';
                ctx.fillRect(5, 30, 6, 2);
            });
        }

        function createBoomProjectileTexture() {
            return createPixelTexture(24, 24, (ctx, w, h) => {
                // Outer fire
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(12, 12, 11, 0, Math.PI * 2);
                ctx.fill();
                
                // Mid fire
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(12, 12, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner fire
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath();
                ctx.arc(12, 12, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(12, 12, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        

        // ============================================
        // GAME STATE
        // ============================================
        // NOTE: encounterState is defined in encounters.js (loaded before this script)
        
        let gameState = {
            player: {
                level: 1,
                xp: 0,
                health: 100,
                maxHealth: 100,
                position: new THREE.Vector3(0, 0, 0),
                rotation: 0,
                gold: 0
            },
            upgrades: {
                magnet: { level: 0, maxLevel: 8, baseCost: 10, costMult: 1.5 },
                swords: { level: 0, maxLevel: 8, baseCost: 50, costMult: 1.8 },
                boom: { level: 0, maxLevel: 30, baseCost: 30, costMult: 1.3 }
            },
            kills: 0,
            enemies: [],
            projectiles: [],
            xpOrbs: [],
            goldOrbs: [],
            swords: [],
            boomProjectiles: [],
            boomCooldown: 0,
            boomMaxCooldown: 30 * 60, // 30 seconds at 60fps
            bosses: [],
            bossActive: false,
            cameraZoom: 1,
            targetCameraZoom: 1,
            dialogue: null,
            dialogueTimer: 0,
            chunks: new Map(),
            isGameOver: false,
            menuOpen: false,
            hasDharmaWheel: false, // Dharma wheel reward from Dharmachakra encounter
            firstPersonMode: false, // Toggle first-person camera view
            // Win condition tracking
            debugUnlocked: false,
            gameStartTime: null, // Set when game starts
            pacifistCheckDone: false, // Only check once at 90 seconds
            skyKingVictory: false, // Completed all sky giant stages
            pacifistVictory: false // No kills for first 90 seconds
        };

        // ============================================
        // THREE.JS SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x1a1a2e);

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x1a1a2e, CONFIG.fogNear, CONFIG.fogFar);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 8, 12);
        camera.lookAt(0, 0, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
        scene.add(ambientLight);

        const moonLight = new THREE.DirectionalLight(0x8888ff, 0.4);
        moonLight.position.set(10, 20, 10);
        scene.add(moonLight);

        // Ground
        const groundTexture = createGrassTexture();
        groundTexture.wrapS = THREE.RepeatWrapping;
        groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(50, 50);

        const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        scene.add(ground);

        // Player visual
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);

        // Player body (simple pixel character)
        function createPlayerTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Cloak
                ctx.fillStyle = '#2980b9';
                ctx.fillRect(8, 16, 16, 24);
                ctx.fillRect(6, 40, 20, 8);
                
                // Head
                ctx.fillStyle = '#fad7a0';
                ctx.fillRect(10, 6, 12, 12);
                
                // Hair
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(10, 4, 12, 6);
                ctx.fillRect(8, 6, 4, 4);
                
                // Eyes
                ctx.fillStyle = '#3498db';
                ctx.fillRect(12, 10, 3, 3);
                ctx.fillRect(17, 10, 3, 3);
                
                // Hood
                ctx.fillStyle = '#1a5276';
                ctx.fillRect(6, 2, 20, 6);
                ctx.fillRect(4, 6, 4, 12);
                ctx.fillRect(24, 6, 4, 12);
            });
        }

        const playerTexture = createPlayerTexture();
        const playerMaterial = new THREE.SpriteMaterial({ map: playerTexture });
        const playerSprite = new THREE.Sprite(playerMaterial);
        playerSprite.scale.set(3, 4.5, 1);
        playerSprite.position.y = 2;
        playerGroup.add(playerSprite);

        // Compass/navigation line
        const compassGeometry = new THREE.BufferGeometry();
        const compassPositions = new Float32Array([0, 0.1, 0, 0, 0.1, -10]);
        compassGeometry.setAttribute('position', new THREE.BufferAttribute(compassPositions, 3));
        const compassMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffd700, 
            transparent: true, 
            opacity: 0.6 
        });
        const compassLine = new THREE.Line(compassGeometry, compassMaterial);
        compassLine.visible = false;
        scene.add(compassLine);

        // ============================================
        // WORLD GENERATION
        // ============================================
        const treeTextures = [
            createTreeTexture(0),
            createTreeTexture(1),
            createTreeTexture(2),
            createTreeTexture(3)
        ];

        const rockTexture = createRockTexture();
        const mushroomTexture = createMushroomTexture();

        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function generateChunk(chunkX, chunkZ) {
            const key = `${chunkX},${chunkZ}`;
            if (gameState.chunks.has(key)) return;

            const chunkGroup = new THREE.Group();
            chunkGroup.userData = { chunkX, chunkZ };
            
            const baseX = chunkX * CONFIG.chunkSize;
            const baseZ = chunkZ * CONFIG.chunkSize;

            // Trees
            for (let i = 0; i < CONFIG.chunkSize * CONFIG.chunkSize * CONFIG.treeDensity; i++) {
                const seed = chunkX * 10000 + chunkZ * 100 + i;
                const rand1 = seededRandom(seed);
                const rand2 = seededRandom(seed + 1);
                const rand3 = seededRandom(seed + 2);
                
                const x = baseX + rand1 * CONFIG.chunkSize;
                const z = baseZ + rand2 * CONFIG.chunkSize;
                
                const treeType = Math.floor(rand3 * treeTextures.length);
                const treeMaterial = new THREE.SpriteMaterial({ 
                    map: treeTextures[treeType],
                    transparent: true
                });
                const tree = new THREE.Sprite(treeMaterial);
                tree.scale.set(4, 8, 1);
                tree.position.set(x, 3.5, z);
                chunkGroup.add(tree);
            }

            // Rocks
            for (let i = 0; i < 3; i++) {
                const seed = chunkX * 20000 + chunkZ * 200 + i;
                const rand1 = seededRandom(seed);
                const rand2 = seededRandom(seed + 1);
                
                const x = baseX + rand1 * CONFIG.chunkSize;
                const z = baseZ + rand2 * CONFIG.chunkSize;
                
                const rockMaterial = new THREE.SpriteMaterial({ 
                    map: rockTexture,
                    transparent: true
                });
                const rock = new THREE.Sprite(rockMaterial);
                rock.scale.set(1.5, 1.5, 1);
                rock.position.set(x, 0.3, z);
                chunkGroup.add(rock);
            }

            // Mushrooms
            for (let i = 0; i < 2; i++) {
                const seed = chunkX * 30000 + chunkZ * 300 + i;
                const rand1 = seededRandom(seed);
                const rand2 = seededRandom(seed + 1);
                
                const x = baseX + rand1 * CONFIG.chunkSize;
                const z = baseZ + rand2 * CONFIG.chunkSize;
                
                const mushMaterial = new THREE.SpriteMaterial({ 
                    map: mushroomTexture,
                    transparent: true
                });
                const mushroom = new THREE.Sprite(mushMaterial);
                mushroom.scale.set(1, 1.5, 1);
                mushroom.position.set(x, 0.5, z);
                chunkGroup.add(mushroom);
            }

            scene.add(chunkGroup);
            gameState.chunks.set(key, chunkGroup);
        }

        function updateChunks() {
            const playerChunkX = Math.floor(gameState.player.position.x / CONFIG.chunkSize);
            const playerChunkZ = Math.floor(gameState.player.position.z / CONFIG.chunkSize);
            const viewDist = Math.ceil(CONFIG.renderDistance / CONFIG.chunkSize);

            // Generate nearby chunks
            for (let x = -viewDist; x <= viewDist; x++) {
                for (let z = -viewDist; z <= viewDist; z++) {
                    generateChunk(playerChunkX + x, playerChunkZ + z);
                }
            }

            // Remove far chunks
            for (const [key, chunk] of gameState.chunks) {
                const [cx, cz] = key.split(',').map(Number);
                const dx = cx - playerChunkX;
                const dz = cz - playerChunkZ;
                if (Math.abs(dx) > viewDist + 1 || Math.abs(dz) > viewDist + 1) {
                    scene.remove(chunk);
                    gameState.chunks.delete(key);
                }
            }
        }

        // ============================================
        // PROJECTILE SYSTEM
        // ============================================
        function getRainbowColor(level) {
            const hue = (level * 30) % 360;
            const color = new THREE.Color();
            color.setHSL(hue / 360, 1, 0.5);
            return color;
        }

        function createProjectileTexture(level) {
            const size = Math.min(16 + level * 2, 48);
            return createPixelTexture(size, size, (ctx, w, h) => {
                const color = getRainbowColor(level);
                const hex = '#' + color.getHexString();
                
                // Outer glow
                ctx.fillStyle = hex;
                ctx.beginPath();
                ctx.arc(w/2, h/2, w/2 - 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner bright
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(w/2, h/2, w/4, 0, Math.PI * 2);
                ctx.fill();
                
                // Sparkles
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const r = w/3;
                    const px = w/2 + Math.cos(angle) * r;
                    const py = h/2 + Math.sin(angle) * r;
                    ctx.fillRect(px - 1, py - 1, 2, 2);
                }
            });
        }

        function shootProjectile() {
            const level = gameState.player.level;
            const texture = createProjectileTexture(level);
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const size = 1 + level * 0.15;
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(size, size, 1);
            
            const startPos = gameState.player.position.clone();
            startPos.y = 1.5;
            sprite.position.copy(startPos);

            // Direction based on player rotation
            const direction = new THREE.Vector3(
                -Math.sin(gameState.player.rotation),
                0,
                -Math.cos(gameState.player.rotation)
            );

            const projectile = {
                sprite,
                direction,
                speed: CONFIG.projectileBaseSpeed + level * 0.02,
                damage: CONFIG.projectileBaseDamage * (1 + level * 0.5),
                life: 120
            };

            scene.add(sprite);
            gameState.projectiles.push(projectile);
        }

        function updateProjectiles() {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                
                proj.sprite.position.x += proj.direction.x * proj.speed;
                proj.sprite.position.z += proj.direction.z * proj.speed;
                proj.life--;

                // Rotate for effect
                proj.sprite.material.rotation += 0.1;

                let hitSomething = false;

                // Check collision with enemies
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = proj.sprite.position.x - enemy.sprite.position.x;
                    const dz = proj.sprite.position.z - enemy.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < 1.5) {
                        enemy.health -= proj.damage;
                        enemy.hitFlash = 10;

                        if (enemy.health <= 0) {
                            // Drop XP
                            spawnXPOrb(enemy.sprite.position.clone(), enemy.type.xp);
                            // Maybe drop gold
                            if (Math.random() < enemy.type.goldChance && enemy.type.gold > 0) {
                                spawnGoldOrb(enemy.sprite.position.clone(), enemy.type.gold);
                            }
                            scene.remove(enemy.sprite);
                            gameState.enemies.splice(j, 1);
                            gameState.kills++;
                            document.getElementById('kills').textContent = gameState.kills;
                        }

                        hitSomething = true;
                        break;
                    }
                }

                // Check collision with encounter guards
                if (!hitSomething && typeof encounterState !== 'undefined' && encounterState.encounterGuards) {
                    for (const guard of encounterState.encounterGuards) {
                        const dx = proj.sprite.position.x - guard.sprite.position.x;
                        const dz = proj.sprite.position.z - guard.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < 1.5) {
                            damageEncounterGuard(guard, proj.damage);
                            hitSomething = true;
                            break;
                        }
                    }
                }
                
                // Check collision with forest cloud sprites (near portal)
                if (!hitSomething && encounterState.forestCloudSprites) {
                    for (const cloudSprite of encounterState.forestCloudSprites) {
                        const dx = proj.sprite.position.x - cloudSprite.sprite.position.x;
                        const dz = proj.sprite.position.z - cloudSprite.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < 1.5) {
                            cloudSprite.health -= proj.damage;
                            cloudSprite.hitFlash = 10;
                            hitSomething = true;
                            break;
                        }
                    }
                }
                
                // Check collision with monster store slimes (if slime companion system loaded)
                if (!hitSomething && typeof slimeCompanionState !== 'undefined' && slimeCompanionState.storeSlimes) {
                    for (const storeSlime of slimeCompanionState.storeSlimes) {
                        const dx = proj.sprite.position.x - storeSlime.sprite.position.x;
                        const dz = proj.sprite.position.z - storeSlime.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < 1.5) {
                            if (typeof damageStoreSlime === 'function') {
                                damageStoreSlime(storeSlime, proj.damage);
                            }
                            hitSomething = true;
                            break;
                        }
                    }
                }

                // Check collision with bosses
                if (!hitSomething) {
                    for (const boss of gameState.bosses) {
                        const dx = proj.sprite.position.x - boss.sprite.position.x;
                        const dz = proj.sprite.position.z - boss.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < 4) {
                            boss.health -= proj.damage;
                            boss.hitFlash = 10;
                            hitSomething = true;
                            break;
                        }
                    }
                }
                
                // Check collision with Land Giant
                if (!hitSomething && encounterState.landGiant) {
                    const giant = encounterState.landGiant;
                    const dx = proj.sprite.position.x - giant.sprite.position.x;
                    const dz = proj.sprite.position.z - giant.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 5) {
                        giant.health -= proj.damage;
                        giant.hitFlash = 10;
                        hitSomething = true;
                    }
                }

                // Check collision with cloud arena enemies
                if (!hitSomething && encounterState.inCloudArena) {
                    hitSomething = checkArenaProjectileHits(proj.sprite.position, proj.damage);
                }

                if (hitSomething || proj.life <= 0) {
                    scene.remove(proj.sprite);
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        // ============================================
        // XP SYSTEM
        // ============================================
        const xpOrbTexture = createXPOrbTexture();
        const goldOrbTexture = createGoldOrbTexture();

        function getPickupRange() {
            const baseRange = 2;
            const magnetBonus = gameState.upgrades.magnet.level * 1.5;
            return baseRange + magnetBonus;
        }

        function spawnXPOrb(position, amount) {
            const material = new THREE.SpriteMaterial({ 
                map: xpOrbTexture, 
                transparent: true 
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1, 1, 1);
            sprite.position.copy(position);
            sprite.position.y = 0.5;

            const orb = {
                sprite,
                amount,
                bobOffset: Math.random() * Math.PI * 2
            };

            scene.add(sprite);
            gameState.xpOrbs.push(orb);
        }

        function spawnGoldOrb(position, amount) {
            const material = new THREE.SpriteMaterial({ 
                map: goldOrbTexture, 
                transparent: true 
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1.2, 1.2, 1);
            sprite.position.copy(position);
            sprite.position.y = 0.5;
            // Offset slightly from XP orb
            sprite.position.x += (Math.random() - 0.5) * 1.5;
            sprite.position.z += (Math.random() - 0.5) * 1.5;

            const orb = {
                sprite,
                amount,
                bobOffset: Math.random() * Math.PI * 2
            };

            scene.add(sprite);
            gameState.goldOrbs.push(orb);
        }

        function updateXPOrbs() {
            const time = Date.now() * 0.003;
            const pickupRange = getPickupRange();
            
            for (let i = gameState.xpOrbs.length - 1; i >= 0; i--) {
                const orb = gameState.xpOrbs[i];
                
                // Bob up and down
                orb.sprite.position.y = 0.5 + Math.sin(time + orb.bobOffset) * 0.2;

                // Check pickup
                const dx = gameState.player.position.x - orb.sprite.position.x;
                const dz = gameState.player.position.z - orb.sprite.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                // Magnet pull effect
                if (dist < pickupRange * 2 && gameState.upgrades.magnet.level > 0) {
                    const pullSpeed = 0.05 + gameState.upgrades.magnet.level * 0.02;
                    orb.sprite.position.x += (dx / dist) * pullSpeed;
                    orb.sprite.position.z += (dz / dist) * pullSpeed;
                }

                if (dist < pickupRange) {
                    gainXP(orb.amount);
                    scene.remove(orb.sprite);
                    gameState.xpOrbs.splice(i, 1);
                }

                // Remove if too far
                if (dist > CONFIG.renderDistance * 2) {
                    scene.remove(orb.sprite);
                    gameState.xpOrbs.splice(i, 1);
                }
            }
        }

        function updateGoldOrbs() {
            const time = Date.now() * 0.003;
            const pickupRange = getPickupRange();
            
            for (let i = gameState.goldOrbs.length - 1; i >= 0; i--) {
                const orb = gameState.goldOrbs[i];
                
                // Bob and spin
                orb.sprite.position.y = 0.6 + Math.sin(time + orb.bobOffset) * 0.15;
                orb.sprite.material.rotation = time * 2;

                // Check pickup
                const dx = gameState.player.position.x - orb.sprite.position.x;
                const dz = gameState.player.position.z - orb.sprite.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                // Magnet pull effect
                if (dist < pickupRange * 2 && gameState.upgrades.magnet.level > 0) {
                    const pullSpeed = 0.05 + gameState.upgrades.magnet.level * 0.02;
                    orb.sprite.position.x += (dx / dist) * pullSpeed;
                    orb.sprite.position.z += (dz / dist) * pullSpeed;
                }

                if (dist < pickupRange) {
                    gainGold(orb.amount);
                    scene.remove(orb.sprite);
                    gameState.goldOrbs.splice(i, 1);
                }

                // Remove if too far
                if (dist > CONFIG.renderDistance * 2) {
                    scene.remove(orb.sprite);
                    gameState.goldOrbs.splice(i, 1);
                }
            }
        }

        function gainGold(amount) {
            gameState.player.gold += amount;
            document.getElementById('goldNum').textContent = gameState.player.gold;
            updateUpgradeMenu();
        }

        // ============================================
        // RING OF SWORDS SYSTEM
        // ============================================
        const swordTexture = createSwordTexture();

        function updateSwordCount() {
            const targetCount = gameState.upgrades.swords.level;
            
            // Remove excess swords
            while (gameState.swords.length > targetCount) {
                const sword = gameState.swords.pop();
                scene.remove(sword.sprite);
            }
            
            // Add new swords
            while (gameState.swords.length < targetCount) {
                const material = new THREE.SpriteMaterial({ 
                    map: swordTexture, 
                    transparent: true 
                });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(1.2, 2.4, 1);
                
                const sword = {
                    sprite,
                    angle: (gameState.swords.length / targetCount) * Math.PI * 2,
                    hitCooldowns: new Map() // Track hit cooldowns per enemy
                };
                
                scene.add(sprite);
                gameState.swords.push(sword);
            }
            
            // Redistribute angles evenly
            gameState.swords.forEach((sword, i) => {
                sword.angle = (i / gameState.swords.length) * Math.PI * 2;
            });
        }

        function updateSwords() {
            if (gameState.swords.length === 0) return;
            
            const orbitRadius = 3;
            const orbitSpeed = 0.03;
            const swordDamage = CONFIG.projectileBaseDamage * (1 + gameState.player.level * 0.25) * 1.0;
            
            gameState.swords.forEach((sword, i) => {
                sword.angle += orbitSpeed;
                
                const x = gameState.player.position.x + Math.cos(sword.angle) * orbitRadius;
                const z = gameState.player.position.z + Math.sin(sword.angle) * orbitRadius;
                
                sword.sprite.position.set(x, 1.5, z);
                sword.sprite.material.rotation = -sword.angle + Math.PI / 2;
                
                // Check collision with enemies
                for (const enemy of gameState.enemies) {
                    const dx = sword.sprite.position.x - enemy.sprite.position.x;
                    const dz = sword.sprite.position.z - enemy.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 1.5) {
                        // Check hit cooldown for this enemy
                        const lastHit = sword.hitCooldowns.get(enemy) || 0;
                        const now = Date.now();
                        
                        if (now - lastHit > 500) { // 500ms cooldown per enemy
                            enemy.health -= swordDamage;
                            enemy.hitFlash = 10;
                            sword.hitCooldowns.set(enemy, now);
                            
                            if (enemy.health <= 0) {
                                spawnXPOrb(enemy.sprite.position.clone(), enemy.type.xp);
                                if (Math.random() < enemy.type.goldChance && enemy.type.gold > 0) {
                                    spawnGoldOrb(enemy.sprite.position.clone(), enemy.type.gold);
                                }
                                scene.remove(enemy.sprite);
                                const idx = gameState.enemies.indexOf(enemy);
                                if (idx > -1) gameState.enemies.splice(idx, 1);
                                gameState.kills++;
                                document.getElementById('kills').textContent = gameState.kills;
                            }
                        }
                    }
                }
                
                // Check collision with bosses
                for (const boss of gameState.bosses) {
                    const dx = sword.sprite.position.x - boss.sprite.position.x;
                    const dz = sword.sprite.position.z - boss.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 4) {
                        const lastHit = sword.hitCooldowns.get(boss) || 0;
                        const now = Date.now();
                        
                        if (now - lastHit > 500) {
                            boss.health -= swordDamage;
                            boss.hitFlash = 10;
                            sword.hitCooldowns.set(boss, now);
                        }
                    }
                }
                
                // Check collision with Land Giant
                if (encounterState.landGiant) {
                    const giant = encounterState.landGiant;
                    const dx = sword.sprite.position.x - giant.sprite.position.x;
                    const dz = sword.sprite.position.z - giant.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 5) {
                        const lastHit = sword.hitCooldowns.get(giant) || 0;
                        const now = Date.now();
                        
                        if (now - lastHit > 500) {
                            giant.health -= swordDamage;
                            giant.hitFlash = 10;
                            sword.hitCooldowns.set(giant, now);
                        }
                    }
                }
                
                // Check collision with encounter guards
                for (const guard of encounterState.encounterGuards) {
                    const dx = sword.sprite.position.x - guard.sprite.position.x;
                    const dz = sword.sprite.position.z - guard.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 1.5) {
                        const lastHit = sword.hitCooldowns.get(guard) || 0;
                        const now = Date.now();
                        
                        if (now - lastHit > 500) {
                            damageEncounterGuard(guard, swordDamage);
                            sword.hitCooldowns.set(guard, now);
                        }
                    }
                }
                
                // Check collision with forest cloud sprites
                if (encounterState.forestCloudSprites) {
                    for (const cloudSprite of encounterState.forestCloudSprites) {
                        const dx = sword.sprite.position.x - cloudSprite.sprite.position.x;
                        const dz = sword.sprite.position.z - cloudSprite.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < 2) {
                            const lastHit = sword.hitCooldowns.get(cloudSprite) || 0;
                            const now = Date.now();
                            
                            if (now - lastHit > 500) {
                                cloudSprite.health -= swordDamage;
                                cloudSprite.hitFlash = 10;
                                sword.hitCooldowns.set(cloudSprite, now);
                            }
                        }
                    }
                }
                
                // Check collision with monster store slimes
                if (typeof slimeCompanionState !== 'undefined' && slimeCompanionState.storeSlimes) {
                    for (const storeSlime of slimeCompanionState.storeSlimes) {
                        const dx = sword.sprite.position.x - storeSlime.sprite.position.x;
                        const dz = sword.sprite.position.z - storeSlime.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < 1.5) {
                            const lastHit = sword.hitCooldowns.get(storeSlime) || 0;
                            const now = Date.now();
                            
                            if (now - lastHit > 500) {
                                if (typeof damageStoreSlime === 'function') {
                                    damageStoreSlime(storeSlime, swordDamage);
                                }
                                sword.hitCooldowns.set(storeSlime, now);
                            }
                        }
                    }
                }
                
                // Check collision with arena bosses
                if (encounterState.inCloudArena) {
                    for (const boss of encounterState.arenaBosses) {
                        const dx = sword.sprite.position.x - boss.sprite.position.x;
                        const dz = sword.sprite.position.z - boss.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < 5) {
                            const lastHit = sword.hitCooldowns.get(boss) || 0;
                            const now = Date.now();
                            
                            if (now - lastHit > 500) {
                                boss.health -= swordDamage;
                                boss.hitFlash = 10;
                                sword.hitCooldowns.set(boss, now);
                            }
                        }
                    }
                    
                    // Check collision with arena enemies
                    for (const enemy of encounterState.arenaEnemies) {
                        const dx = sword.sprite.position.x - enemy.sprite.position.x;
                        const dz = sword.sprite.position.z - enemy.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < 2) {
                            const lastHit = sword.hitCooldowns.get(enemy) || 0;
                            const now = Date.now();
                            
                            if (now - lastHit > 500) {
                                enemy.health -= swordDamage;
                                enemy.hitFlash = 10;
                                sword.hitCooldowns.set(enemy, now);
                            }
                        }
                    }
                }
                
                // Clean up old cooldown entries
                for (const [target, time] of sword.hitCooldowns) {
                    const isValidTarget = gameState.enemies.includes(target) || 
                        gameState.bosses.includes(target) || 
                        encounterState.encounterGuards.includes(target) || 
                        encounterState.arenaBosses.includes(target) || 
                        encounterState.arenaEnemies.includes(target) ||
                        (encounterState.forestCloudSprites && encounterState.forestCloudSprites.includes(target)) ||
                        (typeof slimeCompanionState !== 'undefined' && slimeCompanionState.storeSlimes && slimeCompanionState.storeSlimes.includes(target));
                    if (!isValidTarget) {
                        sword.hitCooldowns.delete(target);
                    }
                }
            });
        }

        // ============================================
        // BOOM ABILITY SYSTEM
        // ============================================
        const boomProjectileTexture = createBoomProjectileTexture();

        function getBoomCooldown() {
            const baseCooldown = 30 * 60; // 30 seconds at 60fps
            const reduction = gameState.upgrades.boom.level * 0.025; // 2.5% per level
            return Math.max(baseCooldown * (1 - reduction), 60 * 3); // Min 3 seconds
        }

        function getBoomDamage() {
            const baseDamage = CONFIG.projectileBaseDamage * (1 + gameState.player.level * 0.25) * 1.0;
            const bonus = 1 + gameState.upgrades.boom.level * 0.05; // 5% per level
            return baseDamage * bonus;
        }

        function fireBoom() {
            if (gameState.upgrades.boom.level === 0) return;
            if (gameState.boomCooldown > 0) return;
            if (gameState.dialogueTimer > 0) return; // Disable during dialogue
            
            const damage = getBoomDamage();
            
            // Fire in 8 directions
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                
                const material = new THREE.SpriteMaterial({ 
                    map: boomProjectileTexture, 
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(2, 2, 1);
                sprite.position.copy(gameState.player.position);
                sprite.position.y = 1.5;
                
                const projectile = {
                    sprite,
                    direction: new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)),
                    speed: 0.3,
                    damage: damage,
                    life: 180
                };
                
                scene.add(sprite);
                gameState.boomProjectiles.push(projectile);
            }
            
            gameState.boomCooldown = getBoomCooldown();
            gameState.boomMaxCooldown = getBoomCooldown();
            updateBoomIndicator();
        }

        function updateBoomProjectiles() {
            for (let i = gameState.boomProjectiles.length - 1; i >= 0; i--) {
                const proj = gameState.boomProjectiles[i];
                
                proj.sprite.position.x += proj.direction.x * proj.speed;
                proj.sprite.position.z += proj.direction.z * proj.speed;
                proj.life--;
                
                // Pulsing effect
                const pulse = 1 + Math.sin(Date.now() * 0.01) * 0.2;
                proj.sprite.scale.set(2 * pulse, 2 * pulse, 1);
                proj.sprite.material.rotation += 0.05;
                
                // Check collision with enemies
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = proj.sprite.position.x - enemy.sprite.position.x;
                    const dz = proj.sprite.position.z - enemy.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 2) {
                        enemy.health -= proj.damage;
                        enemy.hitFlash = 10;
                        
                        if (enemy.health <= 0) {
                            spawnXPOrb(enemy.sprite.position.clone(), enemy.type.xp);
                            if (Math.random() < enemy.type.goldChance && enemy.type.gold > 0) {
                                spawnGoldOrb(enemy.sprite.position.clone(), enemy.type.gold);
                            }
                            scene.remove(enemy.sprite);
                            gameState.enemies.splice(j, 1);
                            gameState.kills++;
                            document.getElementById('kills').textContent = gameState.kills;
                        }
                        
                        // Boom projectiles pass through enemies
                    }
                }
                
                // Check collision with encounter guards
                for (const guard of encounterState.encounterGuards) {
                    const dx = proj.sprite.position.x - guard.sprite.position.x;
                    const dz = proj.sprite.position.z - guard.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 2) {
                        damageEncounterGuard(guard, proj.damage);
                        // Boom passes through
                    }
                }
                
                // Check collision with forest cloud sprites
                if (encounterState.forestCloudSprites) {
                    for (const cloudSprite of encounterState.forestCloudSprites) {
                        const dx = proj.sprite.position.x - cloudSprite.sprite.position.x;
                        const dz = proj.sprite.position.z - cloudSprite.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < 2) {
                            cloudSprite.health -= proj.damage;
                            cloudSprite.hitFlash = 10;
                            // Boom passes through
                        }
                    }
                }
                
                // Check collision with monster store slimes
                if (typeof slimeCompanionState !== 'undefined' && slimeCompanionState.storeSlimes) {
                    for (const storeSlime of slimeCompanionState.storeSlimes) {
                        const dx = proj.sprite.position.x - storeSlime.sprite.position.x;
                        const dz = proj.sprite.position.z - storeSlime.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < 2) {
                            if (typeof damageStoreSlime === 'function') {
                                damageStoreSlime(storeSlime, proj.damage);
                            }
                            // Boom passes through
                        }
                    }
                }
                
                // Check collision with bosses
                for (const boss of gameState.bosses) {
                    const dx = proj.sprite.position.x - boss.sprite.position.x;
                    const dz = proj.sprite.position.z - boss.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 4) {
                        boss.health -= proj.damage;
                        boss.hitFlash = 10;
                        // Boom projectiles pass through
                    }
                }
                
                // Check collision with Land Giant
                if (encounterState.landGiant) {
                    const giant = encounterState.landGiant;
                    const dx = proj.sprite.position.x - giant.sprite.position.x;
                    const dz = proj.sprite.position.z - giant.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 5) {
                        giant.health -= proj.damage;
                        giant.hitFlash = 10;
                        // Boom projectiles pass through
                    }
                }
                
                // Check collision with arena bosses
                if (encounterState.inCloudArena) {
                    for (const boss of encounterState.arenaBosses) {
                        const dx = proj.sprite.position.x - boss.sprite.position.x;
                        const dz = proj.sprite.position.z - boss.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < 5) {
                            boss.health -= proj.damage;
                            boss.hitFlash = 10;
                            // Boom passes through
                        }
                    }
                    
                    // Check collision with arena enemies
                    for (const enemy of encounterState.arenaEnemies) {
                        const dx = proj.sprite.position.x - enemy.sprite.position.x;
                        const dz = proj.sprite.position.z - enemy.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < 2) {
                            enemy.health -= proj.damage;
                            enemy.hitFlash = 10;
                            // Boom passes through
                        }
                    }
                }
                
                if (proj.life <= 0) {
                    scene.remove(proj.sprite);
                    gameState.boomProjectiles.splice(i, 1);
                }
            }
        }

        function updateBoomCooldown() {
            if (gameState.boomCooldown > 0) {
                gameState.boomCooldown--;
                updateBoomIndicator();
            }
        }

        function updateBoomIndicator() {
            const indicator = document.getElementById('boomIndicator');
            const fill = document.getElementById('boomFill');
            
            if (gameState.upgrades.boom.level === 0) {
                indicator.style.display = 'none';
                return;
            }
            
            indicator.style.display = 'flex';
            
            if (gameState.boomCooldown <= 0) {
                indicator.classList.add('ready');
            } else {
                indicator.classList.remove('ready');
            }
            
            const cooldownPercent = ((gameState.boomMaxCooldown - gameState.boomCooldown) / gameState.boomMaxCooldown) * 100;
            fill.style.width = cooldownPercent + '%';
        }

        // ============================================
        // BOSS SYSTEM (now in bosses.js)
        // ============================================
        // bossTextures will be initialized by bosses.js
        // NOTE: shouldSpawnEncounter is now in encounters.js

        function gainXP(amount) {
            gameState.player.xp += amount;
            const xpNeeded = CONFIG.baseXpToLevel * Math.pow(1.5, gameState.player.level - 1);
            
            if (gameState.player.xp >= xpNeeded) {
                gameState.player.xp -= xpNeeded;
                gameState.player.level++;
                gameState.player.maxHealth = 100 + gameState.player.level * 10;
                gameState.player.health = gameState.player.maxHealth;
                
                document.getElementById('levelNum').textContent = gameState.player.level;
                
                // Level up animation
                const levelUpEl = document.getElementById('levelUp');
                levelUpEl.style.animation = 'none';
                levelUpEl.offsetHeight; // Trigger reflow
                levelUpEl.style.animation = 'levelUpAnim 1.5s ease-out forwards';
            }

            updateUI();
        }

        // ============================================
        // PLAYER DAMAGE
        // ============================================
        function takeDamage(amount) {
            if (gameState.isGameOver) return;
            
            gameState.player.health -= amount;
            
            // Flash effect
            const flash = document.getElementById('damageFlash');
            flash.style.opacity = '1';
            setTimeout(() => flash.style.opacity = '0', 100);

            if (gameState.player.health <= 0) {
                gameOver();
            }

            updateUI();
        }

        function gameOver() {
            gameState.isGameOver = true;
            document.getElementById('finalLevel').textContent = gameState.player.level;
            document.getElementById('finalKills').textContent = gameState.kills;
            document.getElementById('finalGold').textContent = gameState.player.gold;
            document.getElementById('gameOver').style.display = 'flex';
        }

        function restartGame() {
            // Clear enemies
            gameState.enemies.forEach(e => scene.remove(e.sprite));
            gameState.enemies = [];

            // Clear projectiles
            gameState.projectiles.forEach(p => scene.remove(p.sprite));
            gameState.projectiles = [];

            // Clear XP orbs
            gameState.xpOrbs.forEach(o => scene.remove(o.sprite));
            gameState.xpOrbs = [];

            // Clear gold orbs
            gameState.goldOrbs.forEach(o => scene.remove(o.sprite));
            gameState.goldOrbs = [];

            // Clear swords
            gameState.swords.forEach(s => scene.remove(s.sprite));
            gameState.swords = [];

            // Clear boom projectiles
            gameState.boomProjectiles.forEach(p => scene.remove(p.sprite));
            gameState.boomProjectiles = [];

            // Clear bosses
            gameState.bosses.forEach(b => {
                scene.remove(b.sprite);
                if (b.club) scene.remove(b.club);
                b.projectiles.forEach(p => scene.remove(p.sprite));
            });
            gameState.bosses = [];

            // Clear encounters
            if (encounterState.currentEncounter) {
                cleanupEncounter();
            }
            encounterState.encounterGuards.forEach(g => scene.remove(g.sprite));
            encounterState.encounterGuards = [];

            // Clear treasure chests
            encounterState.treasureChests.forEach(c => scene.remove(c.sprite));
            encounterState.treasureChests = [];
            
            // Reset encounter system (if loaded)
            if (typeof resetEncounterSystem === 'function') {
                resetEncounterSystem();
            }
            
            // Reset slime companion system (if loaded)
            if (typeof resetSlimeCompanion === 'function') {
                resetSlimeCompanion();
            }

            // Reset player
            gameState.player = {
                level: 1,
                xp: 0,
                health: 100,
                maxHealth: 100,
                position: new THREE.Vector3(0, 0, 0),
                rotation: 0,
                gold: 0
            };

            // Reset upgrades
            gameState.upgrades = {
                magnet: { level: 0, maxLevel: 8, baseCost: 10, costMult: 1.5 },
                swords: { level: 0, maxLevel: 8, baseCost: 50, costMult: 1.8 },
                boom: { level: 0, maxLevel: 30, baseCost: 30, costMult: 1.3 }
            };

            gameState.kills = 0;
            gameState.boomCooldown = 0;
            gameState.bossActive = false;
            gameState.cameraZoom = 1;
            gameState.targetCameraZoom = 1;
            gameState.hasDharmaWheel = false;
            encounterState.currentEncounter = null;
            encounterState.currentEncounterComplete = false;
            gameState.dialogue = null;
            gameState.dialogueTimer = 0;
            gameState.isGameOver = false;
            gameState.menuOpen = false;
            
            // Reset win condition tracking (but keep debugUnlocked - that's permanent!)
            gameState.gameStartTime = Date.now();
            gameState.pacifistCheckDone = false;
            gameState.skyKingVictory = false;
            gameState.pacifistVictory = false;
            
            // Reset first-person mode
            gameState.firstPersonMode = false;
            camera.fov = 60;
            camera.updateProjectionMatrix();
            playerGroup.visible = true;
            const fpBtn = document.getElementById('fpToggle');
            if (fpBtn) fpBtn.classList.remove('active');
            
            // Reset cloud arena state
            if (encounterState.inCloudArena) {
                // Restore forest environment
                ground.material = savedGroundMaterial;
                scene.fog.color.setHex(savedFogColor);
                renderer.setClearColor(savedFogColor);
            }
            cleanupPortal();
            gameState.cloudArena = null;
            encounterState.cloudPortal = null;
            encounterState.inCloudArena = false;
            encounterState.arenaBosses.forEach(b => scene.remove(b.sprite));
            encounterState.arenaBosses = [];
            encounterState.arenaEnemies.forEach(e => scene.remove(e.sprite));
            encounterState.arenaEnemies = [];
            gameState.savedForestPosition = null;
            encounterState.arenaStage = 0;
            encounterState.storyEncounterStage = 0;
            encounterState.pendingArenaExit = false;

            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('levelNum').textContent = '1';
            document.getElementById('kills').textContent = '0';
            document.getElementById('goldNum').textContent = '0';
            document.getElementById('boomIndicator').style.display = 'none';
            document.getElementById('boomCooldown').classList.remove('active');
            hideDialogue();
            
            updateUI();
            updateUpgradeMenu();
        }

        function updateUI() {
            const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';

            const xpNeeded = CONFIG.baseXpToLevel * Math.pow(1.5, gameState.player.level - 1);
            const xpPercent = (gameState.player.xp / xpNeeded) * 100;
            document.getElementById('xpFill').style.width = xpPercent + '%';
            
            document.getElementById('goldNum').textContent = gameState.player.gold;
        }

        // ============================================
        // DIALOGUE SYSTEM
        // ============================================
        function showDialogue(speaker, text) {
            document.getElementById('dialogueSpeaker').textContent = speaker;
            document.getElementById('dialogueText').textContent = text;
            document.getElementById('dialogueBox').classList.add('active');
            
            gameState.dialogueTimer = 99999; // Keep paused until button clicked
        }

        function hideDialogue() {
            document.getElementById('dialogueBox').classList.remove('active');
            gameState.dialogueTimer = 0;
            
            // Check if we need to exit cloud arena after this dialogue
            if (typeof checkPendingArenaExit === 'function') {
                checkPendingArenaExit();
            }
        }

        function setupDialogueButton() {
            const btn = document.getElementById('dialogueContinue');
            btn.addEventListener('click', hideDialogue);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                hideDialogue();
            });
        }

        function showReward(text) {
            document.getElementById('rewardText').textContent = text;
            document.getElementById('rewardNotification').classList.add('active');
            
            setTimeout(() => {
                document.getElementById('rewardNotification').classList.remove('active');
            }, 3000);
        }

        function updateDialogue() {
            // Dialogue is now dismissed by button click
            // This function just keeps the timer active for mob pausing
        }

        // ============================================
        // COMPASS SYSTEM
        // ============================================
        function updateCompass() {
            let target = null;
            let targetType = null;

            // Priority: active encounter > boss
            if (encounterState.currentEncounter && !encounterState.currentEncounter.rewardGiven) {
                target = encounterState.currentEncounter.position;
                targetType = 'encounter';
            } else if (gameState.bosses.length > 0) {
                target = gameState.bosses[0].sprite.position;
                targetType = 'boss';
            }

            if (target) {
                compassLine.visible = true;
                
                // Calculate direction to target
                const dx = target.x - gameState.player.position.x;
                const dz = target.z - gameState.player.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist > 5) {
                    // Normalize and scale the line length
                    const lineLength = Math.min(8, dist * 0.15);
                    
                    // Update line positions
                    const positions = compassLine.geometry.attributes.position.array;
                    // Start point (near player)
                    positions[0] = gameState.player.position.x + (dx / dist) * 2;
                    positions[1] = 0.2;
                    positions[2] = gameState.player.position.z + (dz / dist) * 2;
                    // End point (towards target)
                    positions[3] = gameState.player.position.x + (dx / dist) * (2 + lineLength);
                    positions[4] = 0.2;
                    positions[5] = gameState.player.position.z + (dz / dist) * (2 + lineLength);
                    
                    compassLine.geometry.attributes.position.needsUpdate = true;
                    
                    // Color based on target type
                    if (targetType === 'encounter') {
                        compassMaterial.color.setHex(0x2ecc71); // Green for positive
                    } else {
                        compassMaterial.color.setHex(0xe74c3c); // Red for boss
                    }
                    
                    // Pulse opacity
                    const pulse = 0.4 + Math.sin(Date.now() * 0.005) * 0.3;
                    compassMaterial.opacity = pulse;
                } else {
                    compassLine.visible = false;
                }
            } else {
                compassLine.visible = false;
            }
        }

        // ============================================
        // UPGRADE MENU SYSTEM
        // ============================================
        function getUpgradeCost(upgradeKey) {
            const upgrade = gameState.upgrades[upgradeKey];
            return Math.floor(upgrade.baseCost * Math.pow(upgrade.costMult, upgrade.level));
        }

        function canAffordUpgrade(upgradeKey) {
            return gameState.player.gold >= getUpgradeCost(upgradeKey);
        }

        function isUpgradeMaxed(upgradeKey) {
            const upgrade = gameState.upgrades[upgradeKey];
            return upgrade.level >= upgrade.maxLevel;
        }

        function purchaseUpgrade(upgradeKey) {
            if (isUpgradeMaxed(upgradeKey) || !canAffordUpgrade(upgradeKey)) return;
            
            const cost = getUpgradeCost(upgradeKey);
            gameState.player.gold -= cost;
            gameState.upgrades[upgradeKey].level++;
            
            // Apply upgrade effects
            if (upgradeKey === 'swords') {
                updateSwordCount();
            } else if (upgradeKey === 'boom') {
                updateBoomIndicator();
                document.getElementById('boomCooldown').classList.add('active');
            }
            
            updateUI();
            updateUpgradeMenu();
        }

        function updateUpgradeMenu() {
            const upgrades = ['magnet', 'swords', 'boom'];
            
            upgrades.forEach(key => {
                const item = document.getElementById(`upgrade-${key}`);
                const btn = item.querySelector('.upgrade-btn');
                const lvlSpan = item.querySelector('.lvl');
                const costSpan = btn.querySelector('.cost');
                
                const upgrade = gameState.upgrades[key];
                lvlSpan.textContent = upgrade.level;
                
                if (isUpgradeMaxed(key)) {
                    item.classList.add('maxed');
                    btn.disabled = true;
                    costSpan.textContent = 'MAX';
                } else {
                    item.classList.remove('maxed');
                    const cost = getUpgradeCost(key);
                    costSpan.textContent = `üí∞ ${cost}`;
                    btn.disabled = !canAffordUpgrade(key);
                }
            });
            
            // Update boom cooldown display
            if (gameState.upgrades.boom.level > 0) {
                document.getElementById('boomCooldown').classList.add('active');
            }
        }

        function openMenu() {
            gameState.menuOpen = true;
            document.getElementById('upgradeMenu').style.display = 'flex';
            updateUpgradeMenu();
        }

        function closeMenu() {
            gameState.menuOpen = false;
            document.getElementById('upgradeMenu').style.display = 'none';
        }

        function setupMenuControls() {
            document.getElementById('menuBtn').addEventListener('click', openMenu);
            document.getElementById('menuBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                openMenu();
            });
            
            document.getElementById('closeMenu').addEventListener('click', closeMenu);
            document.getElementById('closeMenu').addEventListener('touchstart', (e) => {
                e.preventDefault();
                closeMenu();
            });
            
            // Upgrade buttons
            document.querySelectorAll('.upgrade-btn').forEach(btn => {
                const upgrade = btn.dataset.upgrade;
                btn.addEventListener('click', () => purchaseUpgrade(upgrade));
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    purchaseUpgrade(upgrade);
                });
            });
            
            // Boom indicator click
            document.getElementById('boomIndicator').addEventListener('click', fireBoom);
            document.getElementById('boomIndicator').addEventListener('touchstart', (e) => {
                e.preventDefault();
                fireBoom();
            });
        }

        // ============================================
        // CONTROLS
        // ============================================
        const controls = {
            up: false,
            down: false,
            left: false,
            right: false
        };

        // Multi-touch tracking for simultaneous d-pad and camera control
        let cameraTouch = null; // Track the touch used for camera rotation
        let cameraTouchStartX = 0;
        let isDragging = false;

        // Track which touches are on d-pad buttons
        const dpadTouches = new Set();

        // D-Pad controls
        function setupDPad() {
            const buttons = {
                'dpad-up': 'up',
                'dpad-down': 'down',
                'dpad-left': 'left',
                'dpad-right': 'right'
            };

            for (const [id, dir] of Object.entries(buttons)) {
                const btn = document.getElementById(id);
                
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    controls[dir] = true;
                    btn.classList.add('active');
                    // Track this touch as a d-pad touch
                    for (const touch of e.changedTouches) {
                        dpadTouches.add(touch.identifier);
                    }
                });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    controls[dir] = false;
                    btn.classList.remove('active');
                    // Remove from d-pad touches
                    for (const touch of e.changedTouches) {
                        dpadTouches.delete(touch.identifier);
                    }
                });

                btn.addEventListener('touchcancel', (e) => {
                    controls[dir] = false;
                    btn.classList.remove('active');
                    for (const touch of e.changedTouches) {
                        dpadTouches.delete(touch.identifier);
                    }
                });

                // Mouse support for desktop
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    controls[dir] = true;
                    btn.classList.add('active');
                });

                btn.addEventListener('mouseup', () => {
                    controls[dir] = false;
                    btn.classList.remove('active');
                });

                btn.addEventListener('mouseleave', () => {
                    controls[dir] = false;
                    btn.classList.remove('active');
                });
            }
        }

        // Magic button
        function setupMagicButton() {
            const btn = document.getElementById('magicBtn');
            let canShoot = true;

            function shoot() {
                if (canShoot && !gameState.isGameOver && gameState.dialogueTimer <= 0) {
                    shootProjectile();
                    canShoot = false;
                    setTimeout(() => canShoot = true, 250);
                }
            }

            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                // Track magic button touches too
                for (const touch of e.changedTouches) {
                    dpadTouches.add(touch.identifier);
                }
                shoot();
            });

            btn.addEventListener('touchend', (e) => {
                for (const touch of e.changedTouches) {
                    dpadTouches.delete(touch.identifier);
                }
            });

            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                shoot();
            });
        }

        // View swipe control - now works anywhere on screen with multi-touch
        function setupViewControl() {
            const viewArea = document.getElementById('viewArea');
            const canvas = document.getElementById('gameCanvas');

            // Check if an element is a UI control that shouldn't trigger camera rotation
            function isUIElement(element) {
                const uiIds = ['dpad', 'dpad-up', 'dpad-down', 'dpad-left', 'dpad-right', 
                               'magicBtn', 'menuBtn', 'restartBtn', 'boomBtn', 'slimeStoreMenu',
                               'debugToggle', 'debugPanel', 'fpToggle'];
                while (element) {
                    if (uiIds.includes(element.id) || 
                        element.classList?.contains('dpad-btn') ||
                        element.classList?.contains('upgrade-btn') ||
                        element.classList?.contains('dialogue-btn') ||
                        element.classList?.contains('store-btn') ||
                        element.classList?.contains('debug-btn') ||
                        element.id === 'upgradeMenu' ||
                        element.id === 'dialogueBox' ||
                        element.id === 'slimeStoreMenu' ||
                        element.id === 'debugPanel') {
                        return true;
                    }
                    element = element.parentElement;
                }
                return false;
            }

            // Global touch handlers for camera rotation
            document.addEventListener('touchstart', (e) => {
                // Find a touch that's not on a UI element to use for camera
                for (const touch of e.changedTouches) {
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (!isUIElement(element) && cameraTouch === null) {
                        cameraTouch = touch.identifier;
                        cameraTouchStartX = touch.clientX;
                        isDragging = true;
                        break;
                    }
                }
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (cameraTouch === null || gameState.dialogueTimer > 0) return;
                
                // Find our camera touch
                for (const touch of e.changedTouches) {
                    if (touch.identifier === cameraTouch) {
                        const dx = touch.clientX - cameraTouchStartX;
                        gameState.player.rotation += dx * 0.005;
                        cameraTouchStartX = touch.clientX;
                        break;
                    }
                }
            }, { passive: true });

            document.addEventListener('touchend', (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === cameraTouch) {
                        cameraTouch = null;
                        isDragging = false;
                        break;
                    }
                }
            });

            document.addEventListener('touchcancel', (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === cameraTouch) {
                        cameraTouch = null;
                        isDragging = false;
                        break;
                    }
                }
            });

            // ============================================
            // DESKTOP MOUSE CONTROLS
            // ============================================
            // Click canvas to enable mouse look (pointer lock)
            // Move mouse to rotate camera
            // Left click to shoot
            
            let mouseEnabled = false;
            
            // Request pointer lock when clicking on canvas/viewArea
            canvas.addEventListener('click', (e) => {
                if (gameState.isGameOver || gameState.menuOpen) return;
                if (isUIElement(e.target)) return;
                
                // If not locked, request lock
                if (document.pointerLockElement !== canvas) {
                    canvas.requestPointerLock();
                }
            });
            
            // Handle pointer lock change
            document.addEventListener('pointerlockchange', () => {
                mouseEnabled = (document.pointerLockElement === canvas);
                if (mouseEnabled) {
                    console.log('Mouse look enabled - move mouse to rotate, click to shoot, ESC to exit');
                }
            });
            
            // Mouse movement for camera rotation (when pointer locked)
            document.addEventListener('mousemove', (e) => {
                if (!mouseEnabled || gameState.dialogueTimer > 0 || gameState.isGameOver || gameState.menuOpen) return;
                
                // Use movementX for smooth rotation
                const sensitivity = 0.003;
                gameState.player.rotation += e.movementX * sensitivity;
            });
            
            // Left click to shoot (when pointer locked)
            document.addEventListener('mousedown', (e) => {
                if (!mouseEnabled || gameState.dialogueTimer > 0 || gameState.isGameOver || gameState.menuOpen) return;
                
                if (e.button === 0) { // Left click
                    shootProjectile();
                }
            });
            
            // Right click for boom (optional alternative)
            document.addEventListener('contextmenu', (e) => {
                if (mouseEnabled) {
                    e.preventDefault();
                    if (!gameState.dialogueTimer && !gameState.isGameOver && !gameState.menuOpen) {
                        fireBoom();
                    }
                }
            });
        }

        // Keyboard support
        function setupKeyboard() {
            document.addEventListener('keydown', (e) => {
                if (gameState.menuOpen) {
                    if (e.key === 'Escape') closeMenu();
                    return;
                }
                if (gameState.dialogueTimer > 0) return; // Disable controls during dialogue
                switch(e.key.toLowerCase()) {
                    case 'w': case 'arrowup': controls.up = true; break;
                    case 's': case 'arrowdown': controls.down = true; break;
                    case 'a': case 'arrowleft': controls.left = true; break;
                    case 'd': case 'arrowright': controls.right = true; break;
                    case ' ': 
                        e.preventDefault(); // Prevent page scroll
                        fireBoom(); 
                        break;
                    case 'q': shootProjectile(); break; // Q as backup for shooting
                    case 'v': toggleFirstPerson(); break; // V to toggle first-person view
                    case 'e': case 'escape': 
                        if (gameState.menuOpen) closeMenu();
                        else openMenu();
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w': case 'arrowup': controls.up = false; break;
                    case 's': case 'arrowdown': controls.down = false; break;
                    case 'a': case 'arrowleft': controls.left = false; break;
                    case 'd': case 'arrowright': controls.right = false; break;
                }
            });
        }
        
        // Toggle first-person camera view
        function toggleFirstPerson() {
            gameState.firstPersonMode = !gameState.firstPersonMode;
            
            // Update FOV for more immersive first-person
            if (gameState.firstPersonMode) {
                camera.fov = 90;
                showReward('üëÅÔ∏è FIRST-PERSON VIEW');
            } else {
                camera.fov = 60;
                showReward('üé• THIRD-PERSON VIEW');
            }
            camera.updateProjectionMatrix();
            
            // Update the toggle button appearance
            const fpBtn = document.getElementById('fpToggle');
            if (fpBtn) {
                fpBtn.classList.toggle('active', gameState.firstPersonMode);
            }
        }
        
        // Setup first-person toggle button
        function setupFPToggle() {
            const fpBtn = document.getElementById('fpToggle');
            if (fpBtn) {
                fpBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    toggleFirstPerson();
                });
                fpBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    toggleFirstPerson();
                });
            }
        }

        // Restart button
        document.getElementById('restartBtn').addEventListener('click', restartGame);
        document.getElementById('restartBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            restartGame();
        });

        // ============================================
        // GAME LOOP
        // ============================================
        let lastSpawnTime = 0;

        function updatePlayer() {
            if (gameState.isGameOver) return;
            if (gameState.dialogueTimer > 0) return; // Pause player during dialogue

            const moveSpeed = CONFIG.playerSpeed;
            let moved = false;

            if (controls.up) {
                gameState.player.position.x -= Math.sin(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z -= Math.cos(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.down) {
                gameState.player.position.x += Math.sin(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z += Math.cos(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.left) {
                gameState.player.position.x -= Math.cos(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z += Math.sin(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.right) {
                gameState.player.position.x += Math.cos(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z -= Math.sin(gameState.player.rotation) * moveSpeed;
                moved = true;
            }

            // Update player visual position
            playerGroup.position.copy(gameState.player.position);
            
            // Hide player in first-person mode
            playerGroup.visible = !gameState.firstPersonMode;

            // Update camera based on view mode
            if (gameState.firstPersonMode) {
                // First-person camera - at player eye level, looking forward
                const eyeHeight = 1.8;
                const lookDist = 10;
                
                camera.position.x = gameState.player.position.x;
                camera.position.z = gameState.player.position.z;
                camera.position.y = eyeHeight;
                
                // Look in the direction the player is facing
                camera.lookAt(
                    gameState.player.position.x - Math.sin(gameState.player.rotation) * lookDist,
                    eyeHeight,
                    gameState.player.position.z - Math.cos(gameState.player.rotation) * lookDist
                );
            } else {
                // Third-person camera (original)
                const camDist = 12 * gameState.cameraZoom;
                const camHeight = 8 * gameState.cameraZoom;
                camera.position.x = gameState.player.position.x + Math.sin(gameState.player.rotation) * camDist;
                camera.position.z = gameState.player.position.z + Math.cos(gameState.player.rotation) * camDist;
                camera.position.y = camHeight;
                camera.lookAt(
                    gameState.player.position.x,
                    2,
                    gameState.player.position.z
                );
            }

            // Update ground position to follow player
            ground.position.x = gameState.player.position.x;
            ground.position.z = gameState.player.position.z;
        }

        function animate() {
            requestAnimationFrame(animate);
            debugFrameCount++;
            
            // Show frame count every frame for first 5 frames, then every 60
            if (debugFrameCount <= 5 || debugFrameCount % 60 === 0) {
                debug('F' + debugFrameCount + ' menu:' + gameState.menuOpen + ' over:' + gameState.isGameOver);
            }

            try {
                if (!gameState.isGameOver && !gameState.menuOpen) {
                    updatePlayer();
                    
                    // Only update forest systems when not in cloud arena
                    const inArena = typeof encounterState !== 'undefined' && encounterState && encounterState.inCloudArena;
                    if (!inArena) {
                        updateChunks();
                        updateEnemies();
                        updateBosses();
                        // Use new modular encounter system
                        if (typeof updateEncounterSystem === 'function') {
                            updateEncounterSystem();
                        }
                    } else {
                        // Update cloud arena (handled by encounter system)
                        if (typeof updateEncounterSystem === 'function') {
                            updateEncounterSystem();
                        }
                    }
                    
                    // These work in both forest and arena
                    updateProjectiles();
                    updateXPOrbs();
                    updateGoldOrbs();
                    updateSwords();
                    updateBoomProjectiles();
                    updateBoomCooldown();
                    updateDialogue();
                    updateCompass();
                    updateCameraZoom();
                    
                    // Check for pacifist victory (no kills in first 90 seconds)
                    checkPacifistVictory();
                    
                    // Update slime companion system (if loaded)
                    if (typeof updateSlimeCompanion === 'function') {
                        updateSlimeCompanion();
                    }

                    // Spawn enemies (only in forest)
                    if (!inArena) {
                        const now = Date.now();
                        if (now - lastSpawnTime > CONFIG.enemySpawnInterval) {
                            spawnEnemy();
                            
                            // 10% chance for a major event (encounter or boss from story sequence)
                            // Only if no boss/encounter/store currently active and level 5+
                            if (typeof canSpawnMajorEvent === 'function' && canSpawnMajorEvent() && Math.random() < 0.10) {
                                // Always spawn from story sequence (bosses are now included in sequence)
                                if (typeof spawnStoryEncounter === 'function') {
                                    spawnStoryEncounter();
                                } else if (typeof spawnEncounter === 'function') {
                                    spawnEncounter();
                                }
                            }
                            
                            // Maybe spawn a treasure chest (independent, 8% chance)
                            if (typeof shouldSpawnChest === 'function' && shouldSpawnChest()) {
                                if (typeof spawnTreasureChest === 'function') spawnTreasureChest();
                            }
                            
                            lastSpawnTime = now;
                        }
                    }
                }
            } catch (error) {
                debug('ERR: ' + error.message);
            }

            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            debug('init() starting...');
            try {
                // Set game start time for win condition tracking
                gameState.gameStartTime = Date.now();
                
                setupDPad();
                debug('DPad setup');
                setupMagicButton();
                debug('Magic button setup');
                setupViewControl();
                setupKeyboard();
                setupMenuControls();
                setupDialogueButton();
                setupFPToggle();
                debug('Controls setup');
                
                // Initialize encounter system (includes portal textures)
                debug('encounterState exists: ' + (typeof encounterState !== 'undefined'));
                debug('initEncounterSystem exists: ' + (typeof initEncounterSystem === 'function'));
                if (typeof initEncounterSystem === 'function') {
                    initEncounterSystem();
                    debug('Encounter system initialized');
                }

                // Generate initial chunks
                updateChunks();
                debug('Chunks generated');
                
                // Initialize UI
                updateUpgradeMenu();
                
                // Initialize slime companion system (if loaded)
                if (typeof initSlimeCompanion === 'function') {
                    initSlimeCompanion();
                }
                debug('Init complete, starting animate');

                // Start animation
                animate();

                // Start spawning enemies
                setTimeout(() => {
                    for (let i = 0; i < 3; i++) {
                        spawnEnemy();
                    }
                    debug('Initial enemies spawned');
                }, 1000);
                
                // Hide instructions after 45 seconds
                setTimeout(() => {
                    const instructions = document.getElementById('instructions');
                    if (instructions) {
                        instructions.style.transition = 'opacity 2s ease-out';
                        instructions.style.opacity = '0';
                        setTimeout(() => {
                            instructions.style.display = 'none';
                        }, 2000);
                    }
                }, 45000);
            } catch (error) {
                debug('INIT ERROR: ' + error.message);
            }
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // GLOBAL DAMAGE HELPER (for external systems like slime companion)
        // ============================================
        // This function can be called by any system to damage the Land Giant
        function damageLandGiant(damage) {
            if (encounterState && encounterState.landGiant) {
                encounterState.landGiant.health -= damage;
                encounterState.landGiant.hitFlash = 10;
                return true;
            }
            return false;
        }
        
        // Expose for external use
        window.damageLandGiant = damageLandGiant;

        // ============================================
        // WIN CONDITIONS & DEBUG UNLOCK SYSTEM
        // ============================================
        
        // Unlock the debug menu (called when any win condition is met)
        function unlockDebugMenu(reason) {
            if (gameState.debugUnlocked) return; // Already unlocked
            
            gameState.debugUnlocked = true;
            
            // Show the debug toggle button
            const debugToggle = document.getElementById('debugToggle');
            if (debugToggle) {
                debugToggle.classList.add('unlocked');
            }
            
            console.log('Debug menu unlocked! Reason:', reason);
        }
        
        // Check for pacifist victory (no kills in first 90 seconds)
        function checkPacifistVictory() {
            if (gameState.pacifistCheckDone) return;
            if (!gameState.gameStartTime) return;
            
            const elapsedSeconds = (Date.now() - gameState.gameStartTime) / 1000;
            
            if (elapsedSeconds >= 90) {
                gameState.pacifistCheckDone = true;
                
                if (gameState.kills === 0) {
                    // Pacifist victory!
                    gameState.pacifistVictory = true;
                    unlockDebugMenu('pacifist');
                    
                    showDialogue('üïäÔ∏è PACIFIST VICTORY!', 
                        '"You have walked through the forest without harming a single creature for 90 seconds. ' +
                        'Your peaceful nature has been rewarded. The debug tools are now yours to command!"');
                    
                    showReward('üïäÔ∏è PACIFIST RUN COMPLETE! DEBUG MENU UNLOCKED!');
                }
            }
        }
        
        // Called when completing the final sky giant arena (Ghost Trio - stage 2)
        function triggerSkyKingVictory() {
            if (gameState.skyKingVictory) return; // Already achieved
            
            gameState.skyKingVictory = true;
            unlockDebugMenu('skyKing');
            
            // This dialogue will be shown after the arena win dialogue
            setTimeout(() => {
                showDialogue('üëë KING OF FOREST & SKY! üëë', 
                    '"You have conquered both the earthly realm and the heavens above! ' +
                    'All creatures bow before your might. The debug tools are now yours to command!"');
                
                showReward('üëë ALL SKY GIANTS DEFEATED! DEBUG MENU UNLOCKED!');
            }, 4000); // Delay to show after arena win dialogue
        }
        
        // Expose for external use (encounters.js will call this)
        window.triggerSkyKingVictory = triggerSkyKingVictory;
        window.unlockDebugMenu = unlockDebugMenu;

        // ============================================
        // DEBUG PANEL FUNCTIONS
        // ============================================
        
        // Toggle debug panel visibility
        document.getElementById('debugToggle').addEventListener('click', function() {
            const panel = document.getElementById('debugPanel');
            const toggle = document.getElementById('debugToggle');
            panel.classList.toggle('active');
            toggle.classList.toggle('panel-open');
        });
        
        // Enable touch scrolling for the debug panel content
        const debugScrollContainer = document.getElementById('debugPanelContent');
        let debugTouchStartY = 0;
        let debugScrollStartTop = 0;
        let debugIsScrolling = false;
        
        debugScrollContainer.addEventListener('touchstart', (e) => {
            debugTouchStartY = e.touches[0].clientY;
            debugScrollStartTop = debugScrollContainer.scrollTop;
            debugIsScrolling = true;
        }, { passive: true });
        
        debugScrollContainer.addEventListener('touchmove', (e) => {
            if (!debugIsScrolling) return;
            
            const touchY = e.touches[0].clientY;
            const deltaY = debugTouchStartY - touchY;
            debugScrollContainer.scrollTop = debugScrollStartTop + deltaY;
            
            // Prevent the page from scrolling
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });
        
        debugScrollContainer.addEventListener('touchend', () => {
            debugIsScrolling = false;
        }, { passive: true });
        
        debugScrollContainer.addEventListener('touchcancel', () => {
            debugIsScrolling = false;
        }, { passive: true });
        
        // Prevent the outer debug panel from any touch scroll behavior
        const debugPanel = document.getElementById('debugPanel');
        debugPanel.addEventListener('touchmove', (e) => {
            // Allow scrolling only inside the scroll container
            if (!debugScrollContainer.contains(e.target)) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Debug spawn function
        function debugSpawn(type) {
            // First, close any active dialogue
            if (gameState.dialogueTimer > 0) {
                gameState.dialogueTimer = 0;
                document.getElementById('dialogueBox').classList.remove('active');
            }
            
            console.log('Debug spawn:', type);
            
            switch(type) {
                case 'princess':
                    if (typeof spawnSpecificEncounter === 'function') {
                        cleanupEncounter();
                        spawnSpecificEncounter('princessTower');
                    } else {
                        alert('spawnSpecificEncounter not available');
                    }
                    break;
                    
                case 'witch':
                    if (typeof spawnSpecificEncounter === 'function') {
                        cleanupEncounter();
                        spawnSpecificEncounter('witchHut');
                    } else {
                        alert('spawnSpecificEncounter not available');
                    }
                    break;
                    
                case 'dharma':
                    if (typeof spawnDharmachakraEncounter === 'function') {
                        cleanupEncounter();
                        spawnDharmachakraEncounter();
                    } else {
                        alert('spawnDharmachakraEncounter not available');
                    }
                    break;
                    
                case 'sword':
                    if (typeof spawnSpecificEncounter === 'function') {
                        cleanupEncounter();
                        spawnSpecificEncounter('swordInStone');
                    } else {
                        alert('spawnSpecificEncounter not available');
                    }
                    break;
                    
                case 'swordAct2':
                    if (typeof spawnSpecificEncounter === 'function') {
                        cleanupEncounter();
                        spawnSpecificEncounter('swordInStoneAct2');
                    } else {
                        alert('spawnSpecificEncounter not available');
                    }
                    break;
                    
                case 'swordAct3':
                    if (typeof spawnSpecificEncounter === 'function') {
                        cleanupEncounter();
                        spawnSpecificEncounter('swordInStoneAct3');
                    } else {
                        alert('spawnSpecificEncounter not available');
                    }
                    break;
                    
                case 'portal':
                    if (typeof spawnCloudPortal === 'function') {
                        spawnCloudPortal();
                    } else {
                        alert('spawnCloudPortal not available');
                    }
                    break;
                    
                case 'chest':
                    if (typeof spawnTreasureChest === 'function') {
                        spawnTreasureChest();
                    } else {
                        alert('spawnTreasureChest not available');
                    }
                    break;
                    
                case 'store':
                    if (typeof spawnMonsterStore === 'function') {
                        spawnMonsterStore();
                    } else {
                        alert('spawnMonsterStore not available');
                    }
                    break;
                    
                case 'boss':
                    if (typeof spawnBoss === 'function') {
                        spawnBoss();
                    } else {
                        alert('spawnBoss not available');
                    }
                    break;
                    
                case 'evilTree':
                    if (typeof spawnSpecificBoss === 'function') {
                        spawnSpecificBoss('evilTree');
                    } else if (typeof spawnBoss === 'function') {
                        // Fallback - just spawn random boss
                        spawnBoss();
                    } else {
                        alert('Boss spawn not available');
                    }
                    break;
                    
                case 'troll':
                    if (typeof spawnSpecificBoss === 'function') {
                        spawnSpecificBoss('troll');
                    } else if (typeof spawnBoss === 'function') {
                        // Fallback - just spawn random boss
                        spawnBoss();
                    } else {
                        alert('Boss spawn not available');
                    }
                    break;
            }
        }
        
        // Debug story function
        function debugStory(action) {
            console.log('Debug story:', action);
            
            // Update display helper
            function updateStoryDisplay() {
                const stage = encounterState.storyStage;
                const event = STORY_SEQUENCE[stage] || 'storyComplete';
                document.getElementById('storyStageDisplay').textContent = 
                    `Stage: ${stage} - ${event}`;
            }
            
            switch(action) {
                case 'prev':
                    if (encounterState.storyStage > 0) {
                        encounterState.storyStage--;
                        updateStoryDisplay();
                        showReward('‚¨ÖÔ∏è Story stage: ' + encounterState.storyStage);
                    }
                    break;
                    
                case 'next':
                    if (encounterState.storyStage < STORY_SEQUENCE.length - 1) {
                        encounterState.storyStage++;
                        updateStoryDisplay();
                        showReward('‚û°Ô∏è Story stage: ' + encounterState.storyStage);
                    }
                    break;
                    
                case 'spawn':
                    // Clear current encounter first
                    if (typeof cleanupEncounter === 'function') {
                        cleanupEncounter();
                    }
                    // Close dialogue
                    if (gameState.dialogueTimer > 0) {
                        gameState.dialogueTimer = 0;
                        document.getElementById('dialogueBox').classList.remove('active');
                    }
                    // Spawn the current story event
                    if (typeof spawnStoryEncounter === 'function') {
                        spawnStoryEncounter();
                    }
                    updateStoryDisplay();
                    break;
                    
                case 'reset':
                    encounterState.storyStage = 0;
                    encounterState.arenaStage = 0;
                    updateStoryDisplay();
                    showReward('üîÑ Story reset to beginning!');
                    break;
            }
        }
        
        // Update story display periodically
        setInterval(() => {
            if (typeof encounterState !== 'undefined' && typeof STORY_SEQUENCE !== 'undefined') {
                const stage = encounterState.storyStage;
                const event = STORY_SEQUENCE[stage] || 'storyComplete';
                const display = document.getElementById('storyStageDisplay');
                if (display) {
                    display.textContent = `Stage: ${stage} - ${event}`;
                }
            }
        }, 1000);
        
        // Debug cheat function
        function debugCheat(type) {
            console.log('Debug cheat:', type);
            
            switch(type) {
                case 'level':
                    for (let i = 0; i < 5; i++) {
                        gameState.player.level++;
                        gameState.player.maxHealth += 10;
                        gameState.player.health = gameState.player.maxHealth;
                    }
                    document.getElementById('levelNum').textContent = gameState.player.level;
                    document.getElementById('healthFill').style.width = '100%';
                    showReward('üìà +5 LEVELS!');
                    break;
                    
                case 'gold':
                    gameState.player.gold += 500;
                    document.getElementById('goldNum').textContent = gameState.player.gold;
                    showReward('üí∞ +500 GOLD!');
                    break;
                    
                case 'health':
                    gameState.player.health = gameState.player.maxHealth;
                    document.getElementById('healthFill').style.width = '100%';
                    showReward('‚ù§Ô∏è FULL HEALTH!');
                    break;
                    
                case 'swords':
                    gameState.upgrades.swords = Math.min(8, gameState.upgrades.swords + 1);
                    updateSwordRing();
                    updateUpgradeUI();
                    showReward('‚öîÔ∏è +1 SWORD!');
                    break;
                    
                case 'dharmaWheel':
                    if (typeof spawnPlayerDharmaWheel === 'function') {
                        spawnPlayerDharmaWheel();
                        showReward('‚ò∏Ô∏è DHARMA WHEEL!');
                    } else {
                        alert('spawnPlayerDharmaWheel not available');
                    }
                    break;
                    
                case 'bonusSwords':
                    if (typeof spawnBonusSwords === 'function') {
                        spawnBonusSwords();
                        showReward('üó°Ô∏è BONUS SWORDS!');
                    } else {
                        alert('spawnBonusSwords not available');
                    }
                    break;
            }
        }
        
        // Debug cleanup function
        function debugCleanup(type) {
            console.log('Debug cleanup:', type);
            
            switch(type) {
                case 'encounter':
                    if (typeof cleanupEncounter === 'function') {
                        cleanupEncounter();
                        showReward('üßπ ENCOUNTER CLEARED');
                    }
                    break;
                    
                case 'enemies':
                    for (const enemy of gameState.enemies) {
                        scene.remove(enemy.sprite);
                    }
                    gameState.enemies = [];
                    showReward('üßπ ENEMIES CLEARED');
                    break;
                    
                case 'bosses':
                    for (const boss of gameState.bosses) {
                        scene.remove(boss.sprite);
                    }
                    gameState.bosses = [];
                    document.getElementById('bossHealthBar').classList.remove('active');
                    showReward('üßπ BOSSES CLEARED');
                    break;
            }
        }

        // Start game
        init();
    </script>
</body>
    </html>
