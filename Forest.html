<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mystic Forest Walker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            overflow: hidden;
            background: #0a0a12;
            font-family: 'Press Start 2P', cursive;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 10px;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
            line-height: 1.8;
            z-index: 100;
        }
        
        #stats .level {
            color: #ffd700;
            font-size: 14px;
        }
        
        #healthBar {
            width: 150px;
            height: 16px;
            background: #333;
            border: 3px solid #222;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(180deg, #ff6b6b, #c0392b);
            transition: width 0.3s;
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3);
        }
        
        #xpBar {
            width: 150px;
            height: 10px;
            background: #333;
            border: 2px solid #222;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        #xpFill {
            height: 100%;
            background: linear-gradient(180deg, #9b59b6, #8e44ad);
            transition: width 0.3s;
        }
        
        #dpad {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }
        
        .dpad-btn {
            position: absolute;
            width: 46px;
            height: 46px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: rgba(255,255,255,0.7);
            transition: all 0.1s;
            backdrop-filter: blur(4px);
        }
        
        .dpad-btn:active, .dpad-btn.active {
            background: rgba(255,255,255,0.35);
            transform: scale(0.95);
            border-color: rgba(255,255,255,0.6);
        }
        
        #dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
        #dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
        #dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
        #dpad-right { right: 0; top: 50%; transform: translateY(-50%); }
        
        #magicBtn {
            position: absolute;
            bottom: 50px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #9b59b6, #6c3483);
            border: 4px solid #bb8fce;
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #9b59b6;
            box-shadow: 0 0 20px rgba(155,89,182,0.5), inset 0 -4px 10px rgba(0,0,0,0.3);
            transition: all 0.1s;
        }
        
        #magicBtn:active {
            transform: scale(0.9);
            box-shadow: 0 0 30px rgba(155,89,182,0.8), inset 0 -4px 10px rgba(0,0,0,0.3);
        }
        
        #viewArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            pointer-events: auto;
        }
        
        #damageFlash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,0,0,0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
        
        #levelUp {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 24px;
            text-shadow: 0 0 20px #ffd700, 0 0 40px #ff8c00;
            opacity: 0;
            pointer-events: none;
            animation: none;
        }
        
        @keyframes levelUpAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1) translateY(-50px); }
        }
        
        #killCount {
            position: absolute;
            top: 80px;
            right: 10px;
            color: #ff6b6b;
            font-size: 12px;
            text-shadow: 2px 2px 0 #000;
        }
        
        #stats .gold {
            color: #ffd700;
            margin-top: 8px;
            font-size: 12px;
        }
        
        #menuBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 60px;
            height: 60px;
            background: linear-gradient(180deg, rgba(108,92,231,0.9), rgba(68,52,191,0.9));
            border: 3px solid #bb8fce;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            color: #fff;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(108,92,231,0.5);
            z-index: 100;
        }
        
        #menuBtn .btn-label {
            font-size: 8px;
            margin-top: 2px;
            font-family: 'Press Start 2P', cursive;
        }
        
        #menuBtn:active {
            background: linear-gradient(180deg, rgba(138,122,255,0.9), rgba(98,82,221,0.9));
            transform: scale(0.95);
        }
        
        #upgradeMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
            pointer-events: auto;
        }
        
        #menuContent {
            background: linear-gradient(180deg, #2c2c54, #1a1a2e);
            border: 4px solid #6c5ce7;
            border-radius: 16px;
            padding: 20px;
            max-width: 340px;
            width: 90%;
            box-shadow: 0 0 30px rgba(108,92,231,0.5);
        }
        
        #menuContent h2 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
            text-shadow: 0 0 10px #ffd700;
        }
        
        .upgrade-item {
            display: flex;
            align-items: center;
            background: rgba(0,0,0,0.3);
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 12px;
            gap: 10px;
        }
        
        .upgrade-item.maxed {
            border-color: #27ae60;
            opacity: 0.7;
        }
        
        .upgrade-icon {
            font-size: 28px;
            width: 40px;
            text-align: center;
        }
        
        .upgrade-info {
            flex: 1;
        }
        
        .upgrade-name {
            color: #fff;
            font-size: 10px;
            margin-bottom: 2px;
        }
        
        .upgrade-desc {
            color: #888;
            font-size: 7px;
            margin-bottom: 4px;
        }
        
        .upgrade-level {
            color: #9b59b6;
            font-size: 8px;
        }
        
        .upgrade-btn {
            background: linear-gradient(180deg, #f39c12, #d68910);
            border: 2px solid #ffd700;
            border-radius: 6px;
            padding: 8px 12px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            cursor: pointer;
            pointer-events: auto;
            min-width: 70px;
        }
        
        .upgrade-btn:disabled {
            background: #555;
            border-color: #666;
            color: #888;
            cursor: not-allowed;
        }
        
        .upgrade-btn:not(:disabled):active {
            transform: scale(0.95);
        }
        
        #closeMenu {
            width: 100%;
            margin-top: 15px;
            padding: 12px;
            background: linear-gradient(180deg, #c0392b, #96281b);
            border: 2px solid #e74c3c;
            border-radius: 8px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        #closeMenu:active {
            transform: scale(0.98);
        }
        
        #boomCooldown {
            display: none;
            margin-top: 10px;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
        }
        
        #boomCooldown.active {
            display: block;
        }
        
        .cooldown-label {
            color: #e74c3c;
            font-size: 8px;
            margin-bottom: 4px;
            text-align: center;
        }
        
        .cooldown-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .cooldown-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        #boomIndicator {
            position: absolute;
            bottom: 140px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at 30% 30%, #e74c3c, #96281b);
            border: 3px solid #f39c12;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #fff;
            pointer-events: auto;
            opacity: 0.5;
        }
        
        #boomIndicator.ready {
            opacity: 1;
            box-shadow: 0 0 15px rgba(231,76,60,0.7);
            animation: boomPulse 1s ease-in-out infinite;
        }
        
        @keyframes boomPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        #bossHealthBar {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }
        
        #bossHealthBar.active {
            display: flex;
        }
        
        .boss-name {
            color: #e74c3c;
            font-size: 12px;
            margin-bottom: 5px;
            text-shadow: 2px 2px 0 #000, 0 0 10px #e74c3c;
        }
        
        .boss-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border: 3px solid #8b0000;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(139,0,0,0.5);
        }
        
        .boss-fill {
            height: 100%;
            background: linear-gradient(180deg, #e74c3c, #8b0000);
            transition: width 0.2s;
            box-shadow: inset 0 -3px 6px rgba(0,0,0,0.3);
        }
        
        #dialogueBox {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            border: 3px solid #ffd700;
            border-radius: 12px;
            padding: 15px 25px;
            max-width: 320px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 200;
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
            pointer-events: auto;
        }
        
        #dialogueBox.active {
            display: flex;
            animation: dialoguePop 0.3s ease-out;
        }
        
        @keyframes dialoguePop {
            0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        
        .dialogue-speaker {
            color: #ffd700;
            font-size: 10px;
            margin-bottom: 8px;
            text-shadow: 0 0 10px #ffd700;
        }
        
        .dialogue-text {
            color: #fff;
            font-size: 9px;
            text-align: center;
            line-height: 1.6;
        }
        
        .dialogue-continue {
            margin-top: 12px;
            padding: 8px 20px;
            background: linear-gradient(180deg, #f39c12, #d68910);
            border: 2px solid #ffd700;
            border-radius: 6px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.1s;
        }
        
        .dialogue-continue:hover {
            background: linear-gradient(180deg, #f5b041, #e59400);
        }
        
        .dialogue-continue:active {
            transform: scale(0.95);
        }
        
        #rewardNotification {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg, rgba(39,174,96,0.9), rgba(30,130,76,0.9));
            border: 3px solid #2ecc71;
            border-radius: 10px;
            padding: 12px 24px;
            display: none;
            z-index: 200;
            box-shadow: 0 0 25px rgba(46,204,113,0.5);
        }
        
        #rewardNotification.active {
            display: block;
            animation: rewardSlide 0.4s ease-out;
        }
        
        @keyframes rewardSlide {
            0% { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        #rewardText {
            color: #fff;
            font-size: 11px;
            text-shadow: 0 0 10px #fff;
        }
        
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            z-index: 1000;
        }
        
        #gameOver h1 {
            color: #c0392b;
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #c0392b;
        }
        
        #gameOver p {
            font-size: 12px;
            margin: 10px 0;
        }
        
        #restartBtn {
            margin-top: 30px;
            padding: 15px 30px;
            background: #27ae60;
            border: none;
            border-radius: 8px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        #instructions {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 8px;
            text-align: center;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="stats">
            <div class="level">LVL <span id="levelNum">1</span></div>
            <div>HP</div>
            <div id="healthBar"><div id="healthFill" style="width: 100%"></div></div>
            <div>XP</div>
            <div id="xpBar"><div id="xpFill" style="width: 0%"></div></div>
            <div class="gold">üí∞ <span id="goldNum">0</span></div>
        </div>
        
        <div id="killCount">‚ò† <span id="kills">0</span></div>
        
        <div id="bossHealthBar">
            <div class="boss-name" id="bossName">BOSS</div>
            <div class="boss-bar"><div class="boss-fill" id="bossFill"></div></div>
        </div>
        
        <div id="dialogueBox">
            <div class="dialogue-speaker" id="dialogueSpeaker"></div>
            <div class="dialogue-text" id="dialogueText"></div>
            <button class="dialogue-continue" id="dialogueContinue">Continue ‚ñ∏</button>
        </div>
        
        <div id="rewardNotification">
            <span id="rewardText"></span>
        </div>
        
        <div id="menuBtn">üõí<span class="btn-label">SHOP</span></div>
        
        <div id="upgradeMenu">
            <div id="menuContent">
                <h2>UPGRADES</h2>
                <div class="upgrade-item" id="upgrade-magnet">
                    <div class="upgrade-icon">üß≤</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">Magnet</div>
                        <div class="upgrade-desc">Increase pickup range</div>
                        <div class="upgrade-level">Level: <span class="lvl">0</span>/8</div>
                    </div>
                    <button class="upgrade-btn" data-upgrade="magnet">
                        <span class="cost">üí∞ 10</span>
                    </button>
                </div>
                <div class="upgrade-item" id="upgrade-swords">
                    <div class="upgrade-icon">‚öîÔ∏è</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">Ring of Swords</div>
                        <div class="upgrade-desc">Orbiting swords (100% magic dmg)</div>
                        <div class="upgrade-level">Level: <span class="lvl">0</span>/8</div>
                    </div>
                    <button class="upgrade-btn" data-upgrade="swords">
                        <span class="cost">üí∞ 50</span>
                    </button>
                </div>
                <div class="upgrade-item" id="upgrade-boom">
                    <div class="upgrade-icon">üí•</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">Boom</div>
                        <div class="upgrade-desc">8-way blast (100% magic dmg)</div>
                        <div class="upgrade-level">Level: <span class="lvl">0</span>/30</div>
                    </div>
                    <button class="upgrade-btn" data-upgrade="boom">
                        <span class="cost">üí∞ 30</span>
                    </button>
                </div>
                <div id="boomCooldown">
                    <div class="cooldown-label">BOOM</div>
                    <div class="cooldown-bar"><div class="cooldown-fill" id="boomFill"></div></div>
                </div>
                <button id="closeMenu">CLOSE</button>
            </div>
        </div>
        
        <div id="viewArea"></div>
        
        <div id="dpad">
            <div class="dpad-btn" id="dpad-up">‚ñ≤</div>
            <div class="dpad-btn" id="dpad-down">‚ñº</div>
            <div class="dpad-btn" id="dpad-left">‚óÑ</div>
            <div class="dpad-btn" id="dpad-right">‚ñ∫</div>
        </div>
        
        <div id="magicBtn">‚ú¶</div>
        
        <div id="boomIndicator">üí•</div>
        
        <div id="instructions">SWIPE TO LOOK ‚Ä¢ D-PAD TO MOVE ‚Ä¢ ‚ú¶ ATTACK ‚Ä¢ üõí SHOP</div>
    </div>
    
    <div id="damageFlash"></div>
    <div id="levelUp">LEVEL UP!</div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p>Level Reached: <span id="finalLevel">1</span></p>
        <p>Enemies Slain: <span id="finalKills">0</span></p>
        <p>Gold Collected: <span id="finalGold">0</span></p>
        <button id="restartBtn">RESTART</button>
    </div>

    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            renderDistance: 80,
            fogNear: 30,
            fogFar: 90,
            chunkSize: 30,
            treeDensity: 0.0045,
            playerSpeed: 0.12,
            enemyBaseHealth: 30,
            enemyBaseDamage: 5,
            baseXpToLevel: 50,
            projectileBaseSpeed: 0.5,
            projectileBaseDamage: 15,
            enemySpawnRadius: 35,
            enemyMaxCount: 12,
            enemySpawnInterval: 2000
        };

        // ============================================
        // PIXEL ART TEXTURE GENERATORS
        // ============================================
        function createPixelTexture(width, height, drawFunc) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            drawFunc(ctx, width, height);
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        function createTreeTexture(type = 0) {
            return createPixelTexture(32, 64, (ctx, w, h) => {
                const colors = [
                    { trunk: '#5d4037', leaves: ['#2e7d32', '#388e3c', '#43a047'] },
                    { trunk: '#4e342e', leaves: ['#1b5e20', '#2e7d32', '#388e3c'] },
                    { trunk: '#6d4c41', leaves: ['#558b2f', '#689f38', '#7cb342'] },
                    { trunk: '#3e2723', leaves: ['#4a148c', '#6a1b9a', '#7b1fa2'] } // Mystic purple tree
                ];
                const c = colors[type % colors.length];
                
                // Trunk
                ctx.fillStyle = c.trunk;
                ctx.fillRect(13, 30, 6, 34);
                ctx.fillStyle = '#3e2723';
                ctx.fillRect(14, 30, 2, 34);
                
                // Leaves layers
                const leafPatterns = [
                    { y: 5, w: 24, h: 14 },
                    { y: 15, w: 28, h: 12 },
                    { y: 24, w: 22, h: 10 }
                ];
                
                leafPatterns.forEach((p, i) => {
                    ctx.fillStyle = c.leaves[i % c.leaves.length];
                    ctx.fillRect((w - p.w) / 2, p.y, p.w, p.h);
                    
                    // Add pixel details
                    ctx.fillStyle = c.leaves[(i + 1) % c.leaves.length];
                    for (let j = 0; j < 6; j++) {
                        const px = (w - p.w) / 2 + Math.random() * p.w;
                        const py = p.y + Math.random() * p.h;
                        ctx.fillRect(Math.floor(px), Math.floor(py), 2, 2);
                    }
                });
                
                // Top
                ctx.fillStyle = c.leaves[0];
                ctx.fillRect(12, 0, 8, 6);
            });
        }

        function createGrassTexture() {
            return createPixelTexture(64, 64, (ctx, w, h) => {
                // Base
                ctx.fillStyle = '#1a472a';
                ctx.fillRect(0, 0, w, h);
                
                // Grass variation
                const colors = ['#2d5a3f', '#1e5631', '#174023', '#236b3f'];
                for (let i = 0; i < 100; i++) {
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    ctx.fillRect(
                        Math.floor(Math.random() * w),
                        Math.floor(Math.random() * h),
                        2, 2
                    );
                }
                
                // Small flowers
                const flowerColors = ['#e91e63', '#ffeb3b', '#03a9f4', '#ff9800'];
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                    ctx.fillRect(
                        Math.floor(Math.random() * w),
                        Math.floor(Math.random() * h),
                        2, 2
                    );
                }
            });
        }

        function createRockTexture() {
            return createPixelTexture(16, 16, (ctx, w, h) => {
                ctx.fillStyle = '#5d6d7e';
                ctx.beginPath();
                ctx.arc(8, 10, 7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#85929e';
                ctx.fillRect(4, 6, 4, 3);
                ctx.fillRect(9, 8, 3, 2);
                
                ctx.fillStyle = '#34495e';
                ctx.fillRect(6, 11, 5, 3);
            });
        }

        function createMushroomTexture() {
            return createPixelTexture(16, 24, (ctx, w, h) => {
                // Stem
                ctx.fillStyle = '#faf0e6';
                ctx.fillRect(6, 12, 4, 12);
                
                // Cap
                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.ellipse(8, 10, 7, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Spots
                ctx.fillStyle = '#fff';
                ctx.fillRect(4, 7, 3, 3);
                ctx.fillRect(9, 5, 2, 2);
                ctx.fillRect(10, 10, 2, 2);
            });
        }

        // Enemy sprite textures
        function createSlimeTexture() {
            return createPixelTexture(32, 32, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.ellipse(16, 20, 14, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Highlight
                ctx.fillStyle = '#2ecc71';
                ctx.beginPath();
                ctx.ellipse(16, 18, 10, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.fillRect(10, 16, 5, 5);
                ctx.fillRect(18, 16, 5, 5);
                ctx.fillStyle = '#000';
                ctx.fillRect(12, 18, 2, 2);
                ctx.fillRect(20, 18, 2, 2);
                
                // Shine
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillRect(8, 14, 3, 3);
            });
        }

        function createSkeletonTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Skull
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(10, 2, 12, 14);
                ctx.fillRect(8, 6, 16, 8);
                
                // Eyes
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(11, 7, 4, 4);
                ctx.fillRect(17, 7, 4, 4);
                ctx.fillStyle = '#000';
                ctx.fillRect(12, 8, 2, 2);
                ctx.fillRect(18, 8, 2, 2);
                
                // Nose
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(15, 11, 2, 3);
                
                // Teeth
                ctx.fillStyle = '#bdc3c7';
                ctx.fillRect(12, 14, 8, 2);
                
                // Spine
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(14, 16, 4, 20);
                
                // Ribs
                ctx.fillStyle = '#bdc3c7';
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(8, 18 + i * 4, 16, 2);
                }
                
                // Arms
                ctx.fillRect(4, 18, 4, 14);
                ctx.fillRect(24, 18, 4, 14);
                
                // Legs
                ctx.fillRect(10, 36, 4, 12);
                ctx.fillRect(18, 36, 4, 12);
            });
        }

        function createGoblinTexture() {
            return createPixelTexture(32, 40, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#6b8e23';
                ctx.fillRect(8, 16, 16, 16);
                
                // Head
                ctx.fillStyle = '#7cba3d';
                ctx.fillRect(6, 4, 20, 14);
                
                // Ears
                ctx.fillStyle = '#6b8e23';
                ctx.fillRect(2, 6, 6, 8);
                ctx.fillRect(24, 6, 6, 8);
                
                // Eyes
                ctx.fillStyle = '#ff0';
                ctx.fillRect(10, 8, 4, 4);
                ctx.fillRect(18, 8, 4, 4);
                ctx.fillStyle = '#000';
                ctx.fillRect(11, 9, 2, 2);
                ctx.fillRect(19, 9, 2, 2);
                
                // Nose
                ctx.fillStyle = '#5a7a1e';
                ctx.fillRect(14, 11, 4, 4);
                
                // Mouth
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(12, 15, 8, 2);
                
                // Legs
                ctx.fillStyle = '#6b8e23';
                ctx.fillRect(10, 32, 4, 8);
                ctx.fillRect(18, 32, 4, 8);
                
                // Arms
                ctx.fillRect(4, 18, 4, 10);
                ctx.fillRect(24, 18, 4, 10);
            });
        }

        function createGhostTexture() {
            return createPixelTexture(32, 40, (ctx, w, h) => {
                // Body
                ctx.fillStyle = 'rgba(200, 220, 255, 0.8)';
                ctx.beginPath();
                ctx.ellipse(16, 16, 12, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Tail
                ctx.fillRect(6, 24, 20, 10);
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(6 + i * 6, 34, 4, 6);
                }
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(9, 12, 5, 6);
                ctx.fillRect(18, 12, 5, 6);
                
                // Glow
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(10, 8, 4, 3);
                ctx.fillRect(19, 8, 4, 3);
            });
        }

        function createBatTexture() {
            return createPixelTexture(40, 24, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#2c2c54';
                ctx.beginPath();
                ctx.ellipse(20, 14, 8, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Wings
                ctx.fillStyle = '#40407a';
                // Left wing
                ctx.beginPath();
                ctx.moveTo(12, 14);
                ctx.lineTo(2, 6);
                ctx.lineTo(4, 16);
                ctx.lineTo(12, 18);
                ctx.fill();
                
                // Right wing
                ctx.beginPath();
                ctx.moveTo(28, 14);
                ctx.lineTo(38, 6);
                ctx.lineTo(36, 16);
                ctx.lineTo(28, 18);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(16, 11, 3, 3);
                ctx.fillRect(21, 11, 3, 3);
                
                // Ears
                ctx.fillStyle = '#2c2c54';
                ctx.fillRect(14, 4, 4, 6);
                ctx.fillRect(22, 4, 4, 6);
            });
        }

        function createWizardTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Robe
                ctx.fillStyle = '#4a235a';
                ctx.fillRect(8, 20, 16, 22);
                ctx.fillRect(6, 42, 20, 6);
                
                // Face
                ctx.fillStyle = '#fad7a0';
                ctx.fillRect(10, 14, 12, 10);
                
                // Hat
                ctx.fillStyle = '#6c3483';
                ctx.fillRect(6, 10, 20, 6);
                ctx.fillRect(10, 2, 12, 10);
                ctx.fillRect(14, 0, 4, 4);
                
                // Star on hat
                ctx.fillStyle = '#f1c40f';
                ctx.fillRect(14, 4, 4, 4);
                
                // Eyes
                ctx.fillStyle = '#9b59b6';
                ctx.fillRect(12, 16, 3, 3);
                ctx.fillRect(17, 16, 3, 3);
                
                // Beard
                ctx.fillStyle = '#bdc3c7';
                ctx.fillRect(10, 22, 12, 8);
                ctx.fillRect(12, 30, 8, 4);
                ctx.fillRect(14, 34, 4, 2);
                
                // Staff
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(26, 10, 3, 38);
                ctx.fillStyle = '#9b59b6';
                ctx.fillRect(24, 6, 7, 6);
            });
        }

        function createXPOrbTexture() {
            return createPixelTexture(16, 16, (ctx, w, h) => {
                // Outer glow
                ctx.fillStyle = '#9b59b6';
                ctx.beginPath();
                ctx.arc(8, 8, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner
                ctx.fillStyle = '#bb8fce';
                ctx.beginPath();
                ctx.arc(8, 8, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Shine
                ctx.fillStyle = '#fff';
                ctx.fillRect(5, 5, 3, 3);
            });
        }

        function createGoldOrbTexture() {
            return createPixelTexture(16, 16, (ctx, w, h) => {
                // Outer glow
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(8, 8, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(8, 8, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Shine
                ctx.fillStyle = '#fff';
                ctx.fillRect(5, 4, 3, 3);
                
                // Coin detail
                ctx.fillStyle = '#d68910';
                ctx.fillRect(7, 6, 2, 4);
            });
        }

        function createSwordTexture() {
            return createPixelTexture(16, 32, (ctx, w, h) => {
                // Blade
                ctx.fillStyle = '#bdc3c7';
                ctx.fillRect(6, 0, 4, 20);
                
                // Blade shine
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(7, 0, 2, 18);
                
                // Blade tip
                ctx.fillStyle = '#bdc3c7';
                ctx.beginPath();
                ctx.moveTo(6, 0);
                ctx.lineTo(10, 0);
                ctx.lineTo(8, -4);
                ctx.fill();
                
                // Guard
                ctx.fillStyle = '#f39c12';
                ctx.fillRect(2, 20, 12, 3);
                
                // Handle
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(6, 23, 4, 8);
                
                // Pommel
                ctx.fillStyle = '#f39c12';
                ctx.fillRect(5, 30, 6, 2);
            });
        }

        function createBoomProjectileTexture() {
            return createPixelTexture(24, 24, (ctx, w, h) => {
                // Outer fire
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(12, 12, 11, 0, Math.PI * 2);
                ctx.fill();
                
                // Mid fire
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(12, 12, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner fire
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath();
                ctx.arc(12, 12, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(12, 12, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ============================================
        // BOSS SPRITE TEXTURES
        // ============================================
        function createDragonTexture() {
            return createPixelTexture(96, 80, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#8b0000';
                ctx.beginPath();
                ctx.ellipse(48, 50, 30, 20, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Body scales
                ctx.fillStyle = '#a52a2a';
                for (let i = 0; i < 5; i++) {
                    ctx.fillRect(30 + i * 8, 45, 6, 10);
                }
                
                // Neck
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(55, 30, 15, 25);
                
                // Head
                ctx.fillStyle = '#a52a2a';
                ctx.fillRect(50, 15, 30, 22);
                ctx.fillRect(70, 20, 15, 12);
                
                // Horns
                ctx.fillStyle = '#2c2c2c';
                ctx.fillRect(52, 8, 6, 12);
                ctx.fillRect(68, 8, 6, 12);
                
                // Eye
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(72, 22, 8, 6);
                ctx.fillStyle = '#000';
                ctx.fillRect(76, 24, 3, 3);
                
                // Nostril smoke
                ctx.fillStyle = '#ff6600';
                ctx.fillRect(82, 26, 4, 4);
                
                // Wings
                ctx.fillStyle = '#6b0000';
                // Left wing
                ctx.beginPath();
                ctx.moveTo(35, 35);
                ctx.lineTo(5, 15);
                ctx.lineTo(10, 35);
                ctx.lineTo(5, 50);
                ctx.lineTo(35, 50);
                ctx.fill();
                
                // Wing membrane lines
                ctx.fillStyle = '#4a0000';
                ctx.fillRect(10, 25, 20, 2);
                ctx.fillRect(12, 35, 18, 2);
                ctx.fillRect(10, 45, 20, 2);
                
                // Tail
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(10, 50, 25, 10);
                ctx.fillRect(2, 48, 12, 8);
                
                // Tail spike
                ctx.fillStyle = '#2c2c2c';
                ctx.beginPath();
                ctx.moveTo(2, 48);
                ctx.lineTo(-5, 52);
                ctx.lineTo(2, 56);
                ctx.fill();
                
                // Legs
                ctx.fillStyle = '#6b0000';
                ctx.fillRect(35, 65, 10, 15);
                ctx.fillRect(55, 65, 10, 15);
                
                // Claws
                ctx.fillStyle = '#2c2c2c';
                ctx.fillRect(33, 77, 4, 3);
                ctx.fillRect(38, 77, 4, 3);
                ctx.fillRect(43, 77, 4, 3);
                ctx.fillRect(53, 77, 4, 3);
                ctx.fillRect(58, 77, 4, 3);
                ctx.fillRect(63, 77, 4, 3);
                
                // Belly
                ctx.fillStyle = '#d4a574';
                ctx.beginPath();
                ctx.ellipse(48, 55, 18, 12, 0, 0, Math.PI);
                ctx.fill();
            });
        }

        function createTrollTexture() {
            return createPixelTexture(64, 96, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#556b2f';
                ctx.fillRect(12, 35, 40, 45);
                
                // Body texture
                ctx.fillStyle = '#4a5f28';
                for (let i = 0; i < 8; i++) {
                    ctx.fillRect(15 + (i % 4) * 10, 40 + Math.floor(i / 4) * 20, 6, 6);
                }
                
                // Head
                ctx.fillStyle = '#6b8e23';
                ctx.fillRect(14, 8, 36, 32);
                
                // Brow ridge
                ctx.fillStyle = '#556b2f';
                ctx.fillRect(14, 14, 36, 8);
                
                // Eyes
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(18, 18, 10, 8);
                ctx.fillRect(36, 18, 10, 8);
                ctx.fillStyle = '#000';
                ctx.fillRect(22, 20, 4, 4);
                ctx.fillRect(40, 20, 4, 4);
                
                // Nose
                ctx.fillStyle = '#4a5f28';
                ctx.fillRect(28, 24, 8, 10);
                
                // Mouth with tusks
                ctx.fillStyle = '#3d4a1f';
                ctx.fillRect(20, 32, 24, 6);
                ctx.fillStyle = '#fffff0';
                ctx.fillRect(22, 30, 5, 8);
                ctx.fillRect(37, 30, 5, 8);
                
                // Ears
                ctx.fillStyle = '#6b8e23';
                ctx.fillRect(8, 15, 8, 14);
                ctx.fillRect(48, 15, 8, 14);
                
                // Arms
                ctx.fillStyle = '#6b8e23';
                ctx.fillRect(0, 38, 14, 35);
                ctx.fillRect(50, 38, 14, 35);
                
                // Hands
                ctx.fillStyle = '#556b2f';
                ctx.fillRect(-2, 70, 14, 12);
                ctx.fillRect(52, 70, 14, 12);
                
                // Legs
                ctx.fillStyle = '#556b2f';
                ctx.fillRect(14, 78, 14, 18);
                ctx.fillRect(36, 78, 14, 18);
                
                // Feet
                ctx.fillStyle = '#4a5f28';
                ctx.fillRect(10, 92, 18, 4);
                ctx.fillRect(36, 92, 18, 4);
                
                // Loincloth
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(14, 75, 36, 10);
            });
        }

        function createEvilTreeTexture() {
            return createPixelTexture(80, 112, (ctx, w, h) => {
                // Main trunk
                ctx.fillStyle = '#2c1810';
                ctx.fillRect(28, 50, 24, 62);
                
                // Trunk texture/bark
                ctx.fillStyle = '#1a0f0a';
                ctx.fillRect(30, 55, 4, 50);
                ctx.fillRect(38, 52, 3, 55);
                ctx.fillRect(46, 58, 4, 48);
                
                // Roots
                ctx.fillStyle = '#2c1810';
                ctx.fillRect(18, 100, 15, 12);
                ctx.fillRect(47, 100, 15, 12);
                ctx.fillRect(10, 105, 12, 7);
                ctx.fillRect(58, 105, 12, 7);
                
                // Face area (darker)
                ctx.fillStyle = '#1a0f0a';
                ctx.fillRect(30, 55, 20, 30);
                
                // Evil eyes
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(32, 60, 7, 7);
                ctx.fillRect(42, 60, 7, 7);
                
                // Glowing pupils
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(34, 62, 3, 3);
                ctx.fillRect(44, 62, 3, 3);
                
                // Evil mouth
                ctx.fillStyle = '#0a0505';
                ctx.fillRect(33, 74, 14, 8);
                
                // Teeth
                ctx.fillStyle = '#8b7355';
                ctx.fillRect(35, 74, 3, 4);
                ctx.fillRect(40, 74, 3, 4);
                ctx.fillRect(37, 78, 3, 4);
                ctx.fillRect(42, 78, 3, 4);
                
                // Branch arms
                ctx.fillStyle = '#2c1810';
                // Left arm
                ctx.fillRect(8, 45, 22, 10);
                ctx.fillRect(4, 35, 10, 14);
                ctx.fillRect(0, 28, 8, 12);
                
                // Left fingers
                ctx.fillRect(-4, 22, 6, 10);
                ctx.fillRect(2, 20, 5, 8);
                ctx.fillRect(8, 25, 5, 8);
                
                // Right arm
                ctx.fillRect(50, 45, 22, 10);
                ctx.fillRect(66, 35, 10, 14);
                ctx.fillRect(72, 28, 8, 12);
                
                // Right fingers
                ctx.fillRect(78, 22, 6, 10);
                ctx.fillRect(73, 20, 5, 8);
                ctx.fillRect(67, 25, 5, 8);
                
                // Crown/top branches
                ctx.fillStyle = '#1a3d1a';
                ctx.beginPath();
                ctx.moveTo(40, 0);
                ctx.lineTo(20, 30);
                ctx.lineTo(30, 28);
                ctx.lineTo(15, 50);
                ctx.lineTo(65, 50);
                ctx.lineTo(50, 28);
                ctx.lineTo(60, 30);
                ctx.closePath();
                ctx.fill();
                
                // Darker foliage spots
                ctx.fillStyle = '#0f2b0f';
                ctx.fillRect(25, 35, 8, 8);
                ctx.fillRect(42, 32, 10, 10);
                ctx.fillRect(32, 20, 6, 8);
                ctx.fillRect(22, 15, 8, 6);
                ctx.fillRect(48, 18, 7, 7);
                
                // Glowing magical spots
                ctx.fillStyle = '#9b59b6';
                ctx.fillRect(28, 38, 3, 3);
                ctx.fillRect(48, 35, 3, 3);
                ctx.fillRect(38, 25, 3, 3);
            });
        }

        function createTrollClubTexture() {
            return createPixelTexture(20, 48, (ctx, w, h) => {
                // Handle
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(8, 20, 6, 28);
                
                // Handle wrap
                ctx.fillStyle = '#654321';
                ctx.fillRect(8, 25, 6, 4);
                ctx.fillRect(8, 35, 6, 4);
                
                // Club head
                ctx.fillStyle = '#5d4037';
                ctx.beginPath();
                ctx.ellipse(10, 12, 10, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Spikes/bumps
                ctx.fillStyle = '#4a3728';
                ctx.fillRect(2, 8, 5, 5);
                ctx.fillRect(14, 6, 5, 5);
                ctx.fillRect(6, 2, 5, 5);
                ctx.fillRect(12, 14, 4, 4);
                ctx.fillRect(3, 15, 4, 4);
            });
        }

        function createBossFireballTexture() {
            return createPixelTexture(32, 32, (ctx, w, h) => {
                // Outer flame
                ctx.fillStyle = '#ff4500';
                ctx.beginPath();
                ctx.arc(16, 16, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Mid flame
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(16, 16, 11, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner flame
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(16, 16, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Core
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(16, 16, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Hot center
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(16, 16, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function createTreeMagicTexture() {
            return createPixelTexture(24, 24, (ctx, w, h) => {
                // Outer magic
                ctx.fillStyle = '#9b59b6';
                ctx.beginPath();
                ctx.arc(12, 12, 11, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner swirl
                ctx.fillStyle = '#8e44ad';
                ctx.beginPath();
                ctx.arc(12, 12, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Core
                ctx.fillStyle = '#bb8fce';
                ctx.beginPath();
                ctx.arc(12, 12, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Sparkle
                ctx.fillStyle = '#fff';
                ctx.fillRect(10, 10, 4, 4);
            });
        }

        // ============================================
        // ENCOUNTER TEXTURES
        // ============================================
        function createPrincessTowerTexture() {
            return createPixelTexture(64, 128, (ctx, w, h) => {
                // Tower base
                ctx.fillStyle = '#5d6d7e';
                ctx.fillRect(12, 40, 40, 88);
                
                // Stone texture
                ctx.fillStyle = '#4a5568';
                for (let y = 0; y < 11; y++) {
                    for (let x = 0; x < 5; x++) {
                        const offset = y % 2 === 0 ? 0 : 4;
                        ctx.fillRect(12 + x * 8 + offset, 40 + y * 8, 7, 7);
                    }
                }
                
                // Tower top / battlements
                ctx.fillStyle = '#5d6d7e';
                ctx.fillRect(8, 32, 48, 12);
                for (let i = 0; i < 6; i++) {
                    ctx.fillRect(8 + i * 8, 24, 6, 10);
                }
                
                // Window
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(24, 50, 16, 24);
                ctx.fillStyle = '#85c1e9';
                ctx.fillRect(26, 52, 12, 20);
                
                // Window bars
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(31, 52, 2, 20);
                ctx.fillRect(26, 60, 12, 2);
                
                // Princess in window
                ctx.fillStyle = '#fad7a0';
                ctx.fillRect(28, 56, 8, 8);
                // Hair
                ctx.fillStyle = '#f4d03f';
                ctx.fillRect(27, 53, 10, 5);
                ctx.fillRect(26, 56, 3, 8);
                ctx.fillRect(35, 56, 3, 8);
                // Crown
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(28, 51, 8, 3);
                ctx.fillRect(29, 49, 2, 3);
                ctx.fillRect(33, 49, 2, 3);
                // Eyes
                ctx.fillStyle = '#3498db';
                ctx.fillRect(29, 58, 2, 2);
                ctx.fillRect(33, 58, 2, 2);
                
                // Door
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(24, 100, 16, 28);
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(26, 102, 12, 24);
                // Door handle
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(34, 114, 3, 3);
                
                // Flag pole
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(30, 0, 4, 28);
                
                // Flag
                ctx.fillStyle = '#e91e63';
                ctx.fillRect(34, 2, 20, 14);
                ctx.fillStyle = '#fff';
                ctx.fillRect(38, 6, 4, 6);
                ctx.fillRect(44, 6, 4, 6);
            });
        }

        function createPrincessTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Dress
                ctx.fillStyle = '#e91e63';
                ctx.fillRect(8, 20, 16, 24);
                ctx.fillRect(4, 40, 24, 8);
                
                // Dress details
                ctx.fillStyle = '#c2185b';
                ctx.fillRect(10, 24, 4, 16);
                ctx.fillRect(18, 24, 4, 16);
                
                // Face
                ctx.fillStyle = '#fad7a0';
                ctx.fillRect(10, 8, 12, 14);
                
                // Hair
                ctx.fillStyle = '#f4d03f';
                ctx.fillRect(8, 4, 16, 8);
                ctx.fillRect(6, 8, 4, 16);
                ctx.fillRect(22, 8, 4, 16);
                
                // Crown
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(10, 2, 12, 4);
                ctx.fillRect(11, 0, 3, 3);
                ctx.fillRect(15, -1, 2, 4);
                ctx.fillRect(18, 0, 3, 3);
                
                // Gems on crown
                ctx.fillStyle = '#e91e63';
                ctx.fillRect(15, 0, 2, 2);
                
                // Eyes
                ctx.fillStyle = '#3498db';
                ctx.fillRect(12, 12, 3, 3);
                ctx.fillRect(17, 12, 3, 3);
                
                // Smile
                ctx.fillStyle = '#c2185b';
                ctx.fillRect(14, 18, 4, 2);
                
                // Arms
                ctx.fillStyle = '#fad7a0';
                ctx.fillRect(4, 22, 4, 10);
                ctx.fillRect(24, 22, 4, 10);
            });
        }

        function createGoldenSkeletonTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Skull
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(10, 2, 12, 14);
                ctx.fillRect(8, 6, 16, 8);
                
                // Eyes
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(11, 7, 4, 4);
                ctx.fillRect(17, 7, 4, 4);
                ctx.fillStyle = '#000';
                ctx.fillRect(12, 8, 2, 2);
                ctx.fillRect(18, 8, 2, 2);
                
                // Nose
                ctx.fillStyle = '#b8860b';
                ctx.fillRect(15, 11, 2, 3);
                
                // Teeth
                ctx.fillStyle = '#fff';
                ctx.fillRect(12, 14, 8, 2);
                
                // Spine
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(14, 16, 4, 20);
                
                // Ribs
                ctx.fillStyle = '#daa520';
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(8, 18 + i * 4, 16, 2);
                }
                
                // Arms
                ctx.fillRect(4, 18, 4, 14);
                ctx.fillRect(24, 18, 4, 14);
                
                // Legs
                ctx.fillRect(10, 36, 4, 12);
                ctx.fillRect(18, 36, 4, 12);
                
                // Crown
                ctx.fillStyle = '#fff';
                ctx.fillRect(10, 0, 12, 3);
                ctx.fillRect(12, -2, 2, 3);
                ctx.fillRect(18, -2, 2, 3);
            });
        }

        function createSwordInStoneTexture() {
            return createPixelTexture(48, 64, (ctx, w, h) => {
                // Stone base
                ctx.fillStyle = '#5d6d7e';
                ctx.beginPath();
                ctx.ellipse(24, 50, 22, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Stone top
                ctx.fillStyle = '#6c7a89';
                ctx.beginPath();
                ctx.ellipse(24, 45, 18, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Stone texture
                ctx.fillStyle = '#4a5568';
                ctx.fillRect(12, 44, 6, 8);
                ctx.fillRect(28, 46, 8, 6);
                ctx.fillRect(18, 50, 5, 5);
                
                // Crack in stone
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(22, 40, 4, 20);
                
                // Sword blade
                ctx.fillStyle = '#bdc3c7';
                ctx.fillRect(21, 8, 6, 36);
                
                // Blade shine
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(22, 10, 2, 32);
                
                // Blade edge
                ctx.fillStyle = '#95a5a6';
                ctx.fillRect(26, 10, 1, 32);
                
                // Sword tip
                ctx.fillStyle = '#bdc3c7';
                ctx.beginPath();
                ctx.moveTo(21, 8);
                ctx.lineTo(27, 8);
                ctx.lineTo(24, 0);
                ctx.fill();
                
                // Guard
                ctx.fillStyle = '#f1c40f';
                ctx.fillRect(14, 42, 20, 4);
                ctx.fillStyle = '#d4ac0d';
                ctx.fillRect(12, 43, 4, 2);
                ctx.fillRect(32, 43, 4, 2);
                
                // Handle
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(21, 46, 6, 10);
                
                // Handle wrap
                ctx.fillStyle = '#654321';
                ctx.fillRect(21, 48, 6, 2);
                ctx.fillRect(21, 52, 6, 2);
                
                // Pommel
                ctx.fillStyle = '#f1c40f';
                ctx.fillRect(20, 55, 8, 5);
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(22, 56, 4, 3);
                
                // Glow effect
                ctx.fillStyle = 'rgba(241, 196, 15, 0.3)';
                ctx.beginPath();
                ctx.arc(24, 30, 15, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function createWitchHutTexture() {
            return createPixelTexture(80, 96, (ctx, w, h) => {
                // Hut base
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(15, 50, 50, 46);
                
                // Wood planks
                ctx.fillStyle = '#4e342e';
                for (let i = 0; i < 5; i++) {
                    ctx.fillRect(15, 50 + i * 10, 50, 2);
                }
                
                // Roof
                ctx.fillStyle = '#2c2c54';
                ctx.beginPath();
                ctx.moveTo(40, 5);
                ctx.lineTo(5, 55);
                ctx.lineTo(75, 55);
                ctx.closePath();
                ctx.fill();
                
                // Roof shingles
                ctx.fillStyle = '#1a1a3a';
                for (let row = 0; row < 5; row++) {
                    for (let i = 0; i < 8 + row; i++) {
                        const y = 15 + row * 10;
                        const xStart = 15 - row * 5;
                        ctx.fillRect(xStart + i * 8, y, 7, 8);
                    }
                }
                
                // Chimney
                ctx.fillStyle = '#4a3728';
                ctx.fillRect(55, 15, 10, 30);
                // Smoke
                ctx.fillStyle = 'rgba(150, 150, 150, 0.6)';
                ctx.beginPath();
                ctx.arc(60, 10, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(58, 3, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Door
                ctx.fillStyle = '#3e2723';
                ctx.fillRect(32, 65, 16, 31);
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(34, 67, 12, 27);
                // Door handle
                ctx.fillStyle = '#9b59b6';
                ctx.fillRect(42, 80, 3, 3);
                
                // Window
                ctx.fillStyle = '#1a1a3a';
                ctx.fillRect(20, 60, 10, 12);
                ctx.fillStyle = '#9b59b6';
                ctx.fillRect(21, 61, 8, 10);
                // Window glow
                ctx.fillStyle = '#bb8fce';
                ctx.fillRect(23, 63, 4, 6);
                
                // Cauldron outside
                ctx.fillStyle = '#2c2c2c';
                ctx.beginPath();
                ctx.ellipse(70, 90, 8, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                // Bubbles
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(68, 86, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(72, 84, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Mushrooms
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.ellipse(10, 92, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#faf0e6';
                ctx.fillRect(9, 92, 3, 4);
                ctx.fillStyle = '#fff';
                ctx.fillRect(8, 90, 2, 2);
                ctx.fillRect(12, 89, 2, 2);
            });
        }

        function createWitchTexture() {
            return createPixelTexture(32, 56, (ctx, w, h) => {
                // Robe
                ctx.fillStyle = '#2c2c54';
                ctx.fillRect(8, 24, 16, 26);
                ctx.fillRect(4, 46, 24, 10);
                
                // Robe trim
                ctx.fillStyle = '#9b59b6';
                ctx.fillRect(8, 24, 16, 3);
                ctx.fillRect(4, 46, 24, 2);
                
                // Face
                ctx.fillStyle = '#a8e6cf';
                ctx.fillRect(10, 14, 12, 12);
                
                // Nose (pointy)
                ctx.fillStyle = '#7bc89c';
                ctx.fillRect(14, 18, 4, 6);
                ctx.fillRect(15, 24, 2, 2);
                
                // Eyes
                ctx.fillStyle = '#9b59b6';
                ctx.fillRect(11, 16, 4, 4);
                ctx.fillRect(17, 16, 4, 4);
                ctx.fillStyle = '#000';
                ctx.fillRect(12, 17, 2, 2);
                ctx.fillRect(18, 17, 2, 2);
                
                // Smile
                ctx.fillStyle = '#2c2c54';
                ctx.fillRect(12, 22, 8, 2);
                
                // Hat
                ctx.fillStyle = '#2c2c54';
                ctx.fillRect(6, 10, 20, 6);
                ctx.fillRect(10, 2, 12, 10);
                ctx.fillRect(13, -2, 6, 6);
                
                // Hat band
                ctx.fillStyle = '#9b59b6';
                ctx.fillRect(10, 10, 12, 2);
                
                // Hat buckle
                ctx.fillStyle = '#f1c40f';
                ctx.fillRect(14, 9, 4, 4);
                
                // Arms
                ctx.fillStyle = '#a8e6cf';
                ctx.fillRect(4, 26, 4, 12);
                ctx.fillRect(24, 26, 4, 12);
                
                // Broom
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(26, 20, 3, 36);
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(24, 50, 7, 6);
                ctx.fillStyle = '#c9a86c';
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(24 + i * 2, 52, 1, 4);
                }
            });
        }

        function createHeartTexture() {
            return createPixelTexture(24, 24, (ctx, w, h) => {
                ctx.fillStyle = '#e91e63';
                // Left bump
                ctx.beginPath();
                ctx.arc(8, 9, 6, 0, Math.PI * 2);
                ctx.fill();
                // Right bump
                ctx.beginPath();
                ctx.arc(16, 9, 6, 0, Math.PI * 2);
                ctx.fill();
                // Bottom point
                ctx.beginPath();
                ctx.moveTo(2, 10);
                ctx.lineTo(12, 22);
                ctx.lineTo(22, 10);
                ctx.fill();
                
                // Shine
                ctx.fillStyle = '#f48fb1';
                ctx.beginPath();
                ctx.arc(7, 7, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function createTreasureChestTexture() {
            return createPixelTexture(32, 28, (ctx, w, h) => {
                // Chest body
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(2, 10, 28, 18);
                
                // Chest lid
                ctx.fillStyle = '#a0522d';
                ctx.fillRect(2, 4, 28, 8);
                ctx.fillRect(4, 2, 24, 4);
                
                // Wood grain
                ctx.fillStyle = '#6b3510';
                ctx.fillRect(4, 12, 24, 2);
                ctx.fillRect(4, 18, 24, 2);
                ctx.fillRect(4, 24, 24, 2);
                
                // Metal bands
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(0, 8, 32, 3);
                ctx.fillRect(0, 20, 32, 3);
                ctx.fillRect(14, 4, 4, 24);
                
                // Lock
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(13, 10, 6, 8);
                ctx.fillStyle = '#000';
                ctx.fillRect(15, 14, 2, 3);
                
                // Shine on metal
                ctx.fillStyle = '#fff8dc';
                ctx.fillRect(2, 8, 4, 1);
                ctx.fillRect(2, 20, 4, 1);
                
                // Chest shadow/depth
                ctx.fillStyle = '#5d3a1a';
                ctx.fillRect(2, 26, 28, 2);
            });
        }

        function createOpenChestTexture() {
            return createPixelTexture(32, 32, (ctx, w, h) => {
                // Open lid (tilted back)
                ctx.fillStyle = '#a0522d';
                ctx.fillRect(2, 0, 28, 6);
                ctx.fillRect(4, 4, 24, 8);
                
                // Lid inside
                ctx.fillStyle = '#6b3510';
                ctx.fillRect(6, 6, 20, 4);
                
                // Chest body
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(2, 14, 28, 18);
                
                // Inside of chest (dark)
                ctx.fillStyle = '#3d2314';
                ctx.fillRect(4, 14, 24, 8);
                
                // Gold coins inside!
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(10, 17, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(16, 16, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(22, 17, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(13, 19, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(19, 19, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Metal bands
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(0, 22, 32, 3);
                ctx.fillRect(14, 14, 4, 18);
                
                // Chest shadow
                ctx.fillStyle = '#5d3a1a';
                ctx.fillRect(2, 30, 28, 2);
            });
        }

        function createRockFaceTexture() {
            return createPixelTexture(32, 20, (ctx, w, h) => {
                // Face on rock (appears after sword removed)
                ctx.fillStyle = '#4a5568';
                
                // Eyes
                ctx.fillRect(6, 6, 6, 4);
                ctx.fillRect(20, 6, 6, 4);
                
                // Eyebrows (happy)
                ctx.fillRect(5, 4, 8, 2);
                ctx.fillRect(19, 4, 8, 2);
                
                // Smile
                ctx.fillRect(10, 14, 12, 2);
                ctx.fillRect(8, 12, 4, 2);
                ctx.fillRect(20, 12, 4, 2);
            });
        }

        // ============================================
        // GAME STATE
        // ============================================
        let gameState = {
            player: {
                level: 1,
                xp: 0,
                health: 100,
                maxHealth: 100,
                position: new THREE.Vector3(0, 0, 0),
                rotation: 0,
                gold: 0
            },
            upgrades: {
                magnet: { level: 0, maxLevel: 8, baseCost: 10, costMult: 1.5 },
                swords: { level: 0, maxLevel: 8, baseCost: 50, costMult: 1.8 },
                boom: { level: 0, maxLevel: 30, baseCost: 30, costMult: 1.3 }
            },
            kills: 0,
            enemies: [],
            projectiles: [],
            xpOrbs: [],
            goldOrbs: [],
            swords: [],
            boomProjectiles: [],
            boomCooldown: 0,
            boomMaxCooldown: 30 * 60, // 30 seconds at 60fps
            bosses: [],
            bossActive: false,
            cameraZoom: 1,
            targetCameraZoom: 1,
            encounter: null,
            encounterGuards: [],
            encounterComplete: false,
            dialogue: null,
            dialogueTimer: 0,
            treasureChests: [],
            chunks: new Map(),
            isGameOver: false,
            menuOpen: false
        };

        // ============================================
        // THREE.JS SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x1a1a2e);

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x1a1a2e, CONFIG.fogNear, CONFIG.fogFar);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 8, 12);
        camera.lookAt(0, 0, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
        scene.add(ambientLight);

        const moonLight = new THREE.DirectionalLight(0x8888ff, 0.4);
        moonLight.position.set(10, 20, 10);
        scene.add(moonLight);

        // Ground
        const groundTexture = createGrassTexture();
        groundTexture.wrapS = THREE.RepeatWrapping;
        groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(50, 50);

        const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        scene.add(ground);

        // Player visual
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);

        // Player body (simple pixel character)
        function createPlayerTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Cloak
                ctx.fillStyle = '#2980b9';
                ctx.fillRect(8, 16, 16, 24);
                ctx.fillRect(6, 40, 20, 8);
                
                // Head
                ctx.fillStyle = '#fad7a0';
                ctx.fillRect(10, 6, 12, 12);
                
                // Hair
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(10, 4, 12, 6);
                ctx.fillRect(8, 6, 4, 4);
                
                // Eyes
                ctx.fillStyle = '#3498db';
                ctx.fillRect(12, 10, 3, 3);
                ctx.fillRect(17, 10, 3, 3);
                
                // Hood
                ctx.fillStyle = '#1a5276';
                ctx.fillRect(6, 2, 20, 6);
                ctx.fillRect(4, 6, 4, 12);
                ctx.fillRect(24, 6, 4, 12);
            });
        }

        const playerTexture = createPlayerTexture();
        const playerMaterial = new THREE.SpriteMaterial({ map: playerTexture });
        const playerSprite = new THREE.Sprite(playerMaterial);
        playerSprite.scale.set(3, 4.5, 1);
        playerSprite.position.y = 2;
        playerGroup.add(playerSprite);

        // Compass/navigation line
        const compassGeometry = new THREE.BufferGeometry();
        const compassPositions = new Float32Array([0, 0.1, 0, 0, 0.1, -10]);
        compassGeometry.setAttribute('position', new THREE.BufferAttribute(compassPositions, 3));
        const compassMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffd700, 
            transparent: true, 
            opacity: 0.6 
        });
        const compassLine = new THREE.Line(compassGeometry, compassMaterial);
        compassLine.visible = false;
        scene.add(compassLine);

        // ============================================
        // WORLD GENERATION
        // ============================================
        const treeTextures = [
            createTreeTexture(0),
            createTreeTexture(1),
            createTreeTexture(2),
            createTreeTexture(3)
        ];

        const rockTexture = createRockTexture();
        const mushroomTexture = createMushroomTexture();

        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function generateChunk(chunkX, chunkZ) {
            const key = `${chunkX},${chunkZ}`;
            if (gameState.chunks.has(key)) return;

            const chunkGroup = new THREE.Group();
            chunkGroup.userData = { chunkX, chunkZ };
            
            const baseX = chunkX * CONFIG.chunkSize;
            const baseZ = chunkZ * CONFIG.chunkSize;

            // Trees
            for (let i = 0; i < CONFIG.chunkSize * CONFIG.chunkSize * CONFIG.treeDensity; i++) {
                const seed = chunkX * 10000 + chunkZ * 100 + i;
                const rand1 = seededRandom(seed);
                const rand2 = seededRandom(seed + 1);
                const rand3 = seededRandom(seed + 2);
                
                const x = baseX + rand1 * CONFIG.chunkSize;
                const z = baseZ + rand2 * CONFIG.chunkSize;
                
                const treeType = Math.floor(rand3 * treeTextures.length);
                const treeMaterial = new THREE.SpriteMaterial({ 
                    map: treeTextures[treeType],
                    transparent: true
                });
                const tree = new THREE.Sprite(treeMaterial);
                tree.scale.set(4, 8, 1);
                tree.position.set(x, 3.5, z);
                chunkGroup.add(tree);
            }

            // Rocks
            for (let i = 0; i < 3; i++) {
                const seed = chunkX * 20000 + chunkZ * 200 + i;
                const rand1 = seededRandom(seed);
                const rand2 = seededRandom(seed + 1);
                
                const x = baseX + rand1 * CONFIG.chunkSize;
                const z = baseZ + rand2 * CONFIG.chunkSize;
                
                const rockMaterial = new THREE.SpriteMaterial({ 
                    map: rockTexture,
                    transparent: true
                });
                const rock = new THREE.Sprite(rockMaterial);
                rock.scale.set(1.5, 1.5, 1);
                rock.position.set(x, 0.3, z);
                chunkGroup.add(rock);
            }

            // Mushrooms
            for (let i = 0; i < 2; i++) {
                const seed = chunkX * 30000 + chunkZ * 300 + i;
                const rand1 = seededRandom(seed);
                const rand2 = seededRandom(seed + 1);
                
                const x = baseX + rand1 * CONFIG.chunkSize;
                const z = baseZ + rand2 * CONFIG.chunkSize;
                
                const mushMaterial = new THREE.SpriteMaterial({ 
                    map: mushroomTexture,
                    transparent: true
                });
                const mushroom = new THREE.Sprite(mushMaterial);
                mushroom.scale.set(1, 1.5, 1);
                mushroom.position.set(x, 0.5, z);
                chunkGroup.add(mushroom);
            }

            scene.add(chunkGroup);
            gameState.chunks.set(key, chunkGroup);
        }

        function updateChunks() {
            const playerChunkX = Math.floor(gameState.player.position.x / CONFIG.chunkSize);
            const playerChunkZ = Math.floor(gameState.player.position.z / CONFIG.chunkSize);
            const viewDist = Math.ceil(CONFIG.renderDistance / CONFIG.chunkSize);

            // Generate nearby chunks
            for (let x = -viewDist; x <= viewDist; x++) {
                for (let z = -viewDist; z <= viewDist; z++) {
                    generateChunk(playerChunkX + x, playerChunkZ + z);
                }
            }

            // Remove far chunks
            for (const [key, chunk] of gameState.chunks) {
                const [cx, cz] = key.split(',').map(Number);
                const dx = cx - playerChunkX;
                const dz = cz - playerChunkZ;
                if (Math.abs(dx) > viewDist + 1 || Math.abs(dz) > viewDist + 1) {
                    scene.remove(chunk);
                    gameState.chunks.delete(key);
                }
            }
        }

        // ============================================
        // ENEMY SYSTEM
        // ============================================
        const enemyTypes = [
            { name: 'slime', texture: createSlimeTexture, scale: [2.5, 2.5], speed: 0.03, healthMult: 0.8, damageMult: 0.7, xp: 10, gold: 0, goldChance: 0.1 },
            { name: 'goblin', texture: createGoblinTexture, scale: [2.5, 3.2], speed: 0.05, healthMult: 1, damageMult: 1, xp: 15, gold: 5, goldChance: 0.4 },
            { name: 'skeleton', texture: createSkeletonTexture, scale: [2.5, 4], speed: 0.04, healthMult: 1.2, damageMult: 1.1, xp: 20, gold: 8, goldChance: 0.5 },
            { name: 'ghost', texture: createGhostTexture, scale: [2.5, 3.2], speed: 0.045, healthMult: 0.9, damageMult: 1.3, xp: 25, gold: 10, goldChance: 0.3 },
            { name: 'bat', texture: createBatTexture, scale: [3, 2], speed: 0.06, healthMult: 0.6, damageMult: 0.8, xp: 12, gold: 3, goldChance: 0.2 },
            { name: 'wizard', texture: createWizardTexture, scale: [2.5, 4], speed: 0.03, healthMult: 1.5, damageMult: 1.5, xp: 35, gold: 20, goldChance: 0.7 }
        ];

        function spawnEnemy() {
            if (gameState.enemies.length >= CONFIG.enemyMaxCount || gameState.isGameOver) return;

            const angle = Math.random() * Math.PI * 2;
            const dist = CONFIG.enemySpawnRadius * (0.7 + Math.random() * 0.3);
            
            const x = gameState.player.position.x + Math.cos(angle) * dist;
            const z = gameState.player.position.z + Math.sin(angle) * dist;

            // Select enemy type based on level
            const maxTypeIndex = Math.min(Math.floor(gameState.player.level / 2), enemyTypes.length - 1);
            const typeIndex = Math.floor(Math.random() * (maxTypeIndex + 1));
            const type = enemyTypes[typeIndex];

            const texture = type.texture();
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(type.scale[0], type.scale[1], 1);
            sprite.position.set(x, type.scale[1] / 2, z);

            const enemy = {
                sprite,
                type,
                health: CONFIG.enemyBaseHealth * type.healthMult * (1 + gameState.player.level * 0.2),
                maxHealth: CONFIG.enemyBaseHealth * type.healthMult * (1 + gameState.player.level * 0.2),
                damage: CONFIG.enemyBaseDamage * type.damageMult * (1 + gameState.player.level * 0.15),
                attackCooldown: 0,
                hitFlash: 0
            };

            scene.add(sprite);
            gameState.enemies.push(enemy);
        }

        function updateEnemies(delta) {
            // Pause during dialogue
            if (gameState.dialogueTimer > 0) return;
            
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                // Move towards player
                const dx = gameState.player.position.x - enemy.sprite.position.x;
                const dz = gameState.player.position.z - enemy.sprite.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist > 1.5) {
                    enemy.sprite.position.x += (dx / dist) * enemy.type.speed;
                    enemy.sprite.position.z += (dz / dist) * enemy.type.speed;
                } else if (enemy.attackCooldown <= 0) {
                    // Attack player
                    takeDamage(enemy.damage);
                    enemy.attackCooldown = 60;
                }

                enemy.attackCooldown = Math.max(0, enemy.attackCooldown - 1);

                // Hit flash effect
                if (enemy.hitFlash > 0) {
                    enemy.hitFlash--;
                    enemy.sprite.material.color.setHex(enemy.hitFlash % 4 < 2 ? 0xffffff : 0xff0000);
                } else {
                    enemy.sprite.material.color.setHex(0xffffff);
                }

                // Remove if too far
                if (dist > CONFIG.renderDistance * 1.5) {
                    scene.remove(enemy.sprite);
                    gameState.enemies.splice(i, 1);
                }
            }
        }

        // ============================================
        // PROJECTILE SYSTEM
        // ============================================
        function getRainbowColor(level) {
            const hue = (level * 30) % 360;
            const color = new THREE.Color();
            color.setHSL(hue / 360, 1, 0.5);
            return color;
        }

        function createProjectileTexture(level) {
            const size = Math.min(16 + level * 2, 48);
            return createPixelTexture(size, size, (ctx, w, h) => {
                const color = getRainbowColor(level);
                const hex = '#' + color.getHexString();
                
                // Outer glow
                ctx.fillStyle = hex;
                ctx.beginPath();
                ctx.arc(w/2, h/2, w/2 - 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner bright
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(w/2, h/2, w/4, 0, Math.PI * 2);
                ctx.fill();
                
                // Sparkles
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const r = w/3;
                    const px = w/2 + Math.cos(angle) * r;
                    const py = h/2 + Math.sin(angle) * r;
                    ctx.fillRect(px - 1, py - 1, 2, 2);
                }
            });
        }

        function shootProjectile() {
            const level = gameState.player.level;
            const texture = createProjectileTexture(level);
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const size = 1 + level * 0.15;
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(size, size, 1);
            
            const startPos = gameState.player.position.clone();
            startPos.y = 1.5;
            sprite.position.copy(startPos);

            // Direction based on player rotation
            const direction = new THREE.Vector3(
                -Math.sin(gameState.player.rotation),
                0,
                -Math.cos(gameState.player.rotation)
            );

            const projectile = {
                sprite,
                direction,
                speed: CONFIG.projectileBaseSpeed + level * 0.02,
                damage: CONFIG.projectileBaseDamage * (1 + level * 0.25),
                life: 120
            };

            scene.add(sprite);
            gameState.projectiles.push(projectile);
        }

        function updateProjectiles() {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                
                proj.sprite.position.x += proj.direction.x * proj.speed;
                proj.sprite.position.z += proj.direction.z * proj.speed;
                proj.life--;

                // Rotate for effect
                proj.sprite.material.rotation += 0.1;

                let hitSomething = false;

                // Check collision with enemies
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = proj.sprite.position.x - enemy.sprite.position.x;
                    const dz = proj.sprite.position.z - enemy.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < 1.5) {
                        enemy.health -= proj.damage;
                        enemy.hitFlash = 10;

                        if (enemy.health <= 0) {
                            // Drop XP
                            spawnXPOrb(enemy.sprite.position.clone(), enemy.type.xp);
                            // Maybe drop gold
                            if (Math.random() < enemy.type.goldChance && enemy.type.gold > 0) {
                                spawnGoldOrb(enemy.sprite.position.clone(), enemy.type.gold);
                            }
                            scene.remove(enemy.sprite);
                            gameState.enemies.splice(j, 1);
                            gameState.kills++;
                            document.getElementById('kills').textContent = gameState.kills;
                        }

                        hitSomething = true;
                        break;
                    }
                }

                // Check collision with encounter guards
                if (!hitSomething) {
                    for (const guard of gameState.encounterGuards) {
                        const dx = proj.sprite.position.x - guard.sprite.position.x;
                        const dz = proj.sprite.position.z - guard.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < 1.5) {
                            damageEncounterGuard(guard, proj.damage);
                            hitSomething = true;
                            break;
                        }
                    }
                }

                // Check collision with bosses
                if (!hitSomething) {
                    for (const boss of gameState.bosses) {
                        const dx = proj.sprite.position.x - boss.sprite.position.x;
                        const dz = proj.sprite.position.z - boss.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < 4) {
                            boss.health -= proj.damage;
                            boss.hitFlash = 10;
                            hitSomething = true;
                            break;
                        }
                    }
                }

                if (hitSomething || proj.life <= 0) {
                    scene.remove(proj.sprite);
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        // ============================================
        // XP SYSTEM
        // ============================================
        const xpOrbTexture = createXPOrbTexture();
        const goldOrbTexture = createGoldOrbTexture();

        function getPickupRange() {
            const baseRange = 2;
            const magnetBonus = gameState.upgrades.magnet.level * 1.5;
            return baseRange + magnetBonus;
        }

        function spawnXPOrb(position, amount) {
            const material = new THREE.SpriteMaterial({ 
                map: xpOrbTexture, 
                transparent: true 
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1, 1, 1);
            sprite.position.copy(position);
            sprite.position.y = 0.5;

            const orb = {
                sprite,
                amount,
                bobOffset: Math.random() * Math.PI * 2
            };

            scene.add(sprite);
            gameState.xpOrbs.push(orb);
        }

        function spawnGoldOrb(position, amount) {
            const material = new THREE.SpriteMaterial({ 
                map: goldOrbTexture, 
                transparent: true 
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1.2, 1.2, 1);
            sprite.position.copy(position);
            sprite.position.y = 0.5;
            // Offset slightly from XP orb
            sprite.position.x += (Math.random() - 0.5) * 1.5;
            sprite.position.z += (Math.random() - 0.5) * 1.5;

            const orb = {
                sprite,
                amount,
                bobOffset: Math.random() * Math.PI * 2
            };

            scene.add(sprite);
            gameState.goldOrbs.push(orb);
        }

        function updateXPOrbs() {
            const time = Date.now() * 0.003;
            const pickupRange = getPickupRange();
            
            for (let i = gameState.xpOrbs.length - 1; i >= 0; i--) {
                const orb = gameState.xpOrbs[i];
                
                // Bob up and down
                orb.sprite.position.y = 0.5 + Math.sin(time + orb.bobOffset) * 0.2;

                // Check pickup
                const dx = gameState.player.position.x - orb.sprite.position.x;
                const dz = gameState.player.position.z - orb.sprite.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                // Magnet pull effect
                if (dist < pickupRange * 2 && gameState.upgrades.magnet.level > 0) {
                    const pullSpeed = 0.05 + gameState.upgrades.magnet.level * 0.02;
                    orb.sprite.position.x += (dx / dist) * pullSpeed;
                    orb.sprite.position.z += (dz / dist) * pullSpeed;
                }

                if (dist < pickupRange) {
                    gainXP(orb.amount);
                    scene.remove(orb.sprite);
                    gameState.xpOrbs.splice(i, 1);
                }

                // Remove if too far
                if (dist > CONFIG.renderDistance * 2) {
                    scene.remove(orb.sprite);
                    gameState.xpOrbs.splice(i, 1);
                }
            }
        }

        function updateGoldOrbs() {
            const time = Date.now() * 0.003;
            const pickupRange = getPickupRange();
            
            for (let i = gameState.goldOrbs.length - 1; i >= 0; i--) {
                const orb = gameState.goldOrbs[i];
                
                // Bob and spin
                orb.sprite.position.y = 0.6 + Math.sin(time + orb.bobOffset) * 0.15;
                orb.sprite.material.rotation = time * 2;

                // Check pickup
                const dx = gameState.player.position.x - orb.sprite.position.x;
                const dz = gameState.player.position.z - orb.sprite.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                // Magnet pull effect
                if (dist < pickupRange * 2 && gameState.upgrades.magnet.level > 0) {
                    const pullSpeed = 0.05 + gameState.upgrades.magnet.level * 0.02;
                    orb.sprite.position.x += (dx / dist) * pullSpeed;
                    orb.sprite.position.z += (dz / dist) * pullSpeed;
                }

                if (dist < pickupRange) {
                    gainGold(orb.amount);
                    scene.remove(orb.sprite);
                    gameState.goldOrbs.splice(i, 1);
                }

                // Remove if too far
                if (dist > CONFIG.renderDistance * 2) {
                    scene.remove(orb.sprite);
                    gameState.goldOrbs.splice(i, 1);
                }
            }
        }

        function gainGold(amount) {
            gameState.player.gold += amount;
            document.getElementById('goldNum').textContent = gameState.player.gold;
            updateUpgradeMenu();
        }

        // ============================================
        // RING OF SWORDS SYSTEM
        // ============================================
        const swordTexture = createSwordTexture();

        function updateSwordCount() {
            const targetCount = gameState.upgrades.swords.level;
            
            // Remove excess swords
            while (gameState.swords.length > targetCount) {
                const sword = gameState.swords.pop();
                scene.remove(sword.sprite);
            }
            
            // Add new swords
            while (gameState.swords.length < targetCount) {
                const material = new THREE.SpriteMaterial({ 
                    map: swordTexture, 
                    transparent: true 
                });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(1.2, 2.4, 1);
                
                const sword = {
                    sprite,
                    angle: (gameState.swords.length / targetCount) * Math.PI * 2,
                    hitCooldowns: new Map() // Track hit cooldowns per enemy
                };
                
                scene.add(sprite);
                gameState.swords.push(sword);
            }
            
            // Redistribute angles evenly
            gameState.swords.forEach((sword, i) => {
                sword.angle = (i / gameState.swords.length) * Math.PI * 2;
            });
        }

        function updateSwords() {
            if (gameState.swords.length === 0) return;
            
            const orbitRadius = 3;
            const orbitSpeed = 0.03;
            const swordDamage = CONFIG.projectileBaseDamage * (1 + gameState.player.level * 0.25) * 1.0;
            
            gameState.swords.forEach((sword, i) => {
                sword.angle += orbitSpeed;
                
                const x = gameState.player.position.x + Math.cos(sword.angle) * orbitRadius;
                const z = gameState.player.position.z + Math.sin(sword.angle) * orbitRadius;
                
                sword.sprite.position.set(x, 1.5, z);
                sword.sprite.material.rotation = -sword.angle + Math.PI / 2;
                
                // Check collision with enemies
                for (const enemy of gameState.enemies) {
                    const dx = sword.sprite.position.x - enemy.sprite.position.x;
                    const dz = sword.sprite.position.z - enemy.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 1.5) {
                        // Check hit cooldown for this enemy
                        const lastHit = sword.hitCooldowns.get(enemy) || 0;
                        const now = Date.now();
                        
                        if (now - lastHit > 500) { // 500ms cooldown per enemy
                            enemy.health -= swordDamage;
                            enemy.hitFlash = 10;
                            sword.hitCooldowns.set(enemy, now);
                            
                            if (enemy.health <= 0) {
                                spawnXPOrb(enemy.sprite.position.clone(), enemy.type.xp);
                                if (Math.random() < enemy.type.goldChance && enemy.type.gold > 0) {
                                    spawnGoldOrb(enemy.sprite.position.clone(), enemy.type.gold);
                                }
                                scene.remove(enemy.sprite);
                                const idx = gameState.enemies.indexOf(enemy);
                                if (idx > -1) gameState.enemies.splice(idx, 1);
                                gameState.kills++;
                                document.getElementById('kills').textContent = gameState.kills;
                            }
                        }
                    }
                }
                
                // Check collision with bosses
                for (const boss of gameState.bosses) {
                    const dx = sword.sprite.position.x - boss.sprite.position.x;
                    const dz = sword.sprite.position.z - boss.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 4) {
                        const lastHit = sword.hitCooldowns.get(boss) || 0;
                        const now = Date.now();
                        
                        if (now - lastHit > 500) {
                            boss.health -= swordDamage;
                            boss.hitFlash = 10;
                            sword.hitCooldowns.set(boss, now);
                        }
                    }
                }
                
                // Check collision with encounter guards
                for (const guard of gameState.encounterGuards) {
                    const dx = sword.sprite.position.x - guard.sprite.position.x;
                    const dz = sword.sprite.position.z - guard.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 1.5) {
                        const lastHit = sword.hitCooldowns.get(guard) || 0;
                        const now = Date.now();
                        
                        if (now - lastHit > 500) {
                            damageEncounterGuard(guard, swordDamage);
                            sword.hitCooldowns.set(guard, now);
                        }
                    }
                }
                
                // Clean up old cooldown entries
                for (const [target, time] of sword.hitCooldowns) {
                    if (!gameState.enemies.includes(target) && !gameState.bosses.includes(target) && !gameState.encounterGuards.includes(target)) {
                        sword.hitCooldowns.delete(target);
                    }
                }
            });
        }

        // ============================================
        // BOOM ABILITY SYSTEM
        // ============================================
        const boomProjectileTexture = createBoomProjectileTexture();

        function getBoomCooldown() {
            const baseCooldown = 30 * 60; // 30 seconds at 60fps
            const reduction = gameState.upgrades.boom.level * 0.025; // 2.5% per level
            return Math.max(baseCooldown * (1 - reduction), 60 * 3); // Min 3 seconds
        }

        function getBoomDamage() {
            const baseDamage = CONFIG.projectileBaseDamage * (1 + gameState.player.level * 0.25) * 1.0;
            const bonus = 1 + gameState.upgrades.boom.level * 0.05; // 5% per level
            return baseDamage * bonus;
        }

        function fireBoom() {
            if (gameState.upgrades.boom.level === 0) return;
            if (gameState.boomCooldown > 0) return;
            if (gameState.dialogueTimer > 0) return; // Disable during dialogue
            
            const damage = getBoomDamage();
            
            // Fire in 8 directions
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                
                const material = new THREE.SpriteMaterial({ 
                    map: boomProjectileTexture, 
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(2, 2, 1);
                sprite.position.copy(gameState.player.position);
                sprite.position.y = 1.5;
                
                const projectile = {
                    sprite,
                    direction: new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)),
                    speed: 0.3,
                    damage: damage,
                    life: 180
                };
                
                scene.add(sprite);
                gameState.boomProjectiles.push(projectile);
            }
            
            gameState.boomCooldown = getBoomCooldown();
            gameState.boomMaxCooldown = getBoomCooldown();
            updateBoomIndicator();
        }

        function updateBoomProjectiles() {
            for (let i = gameState.boomProjectiles.length - 1; i >= 0; i--) {
                const proj = gameState.boomProjectiles[i];
                
                proj.sprite.position.x += proj.direction.x * proj.speed;
                proj.sprite.position.z += proj.direction.z * proj.speed;
                proj.life--;
                
                // Pulsing effect
                const pulse = 1 + Math.sin(Date.now() * 0.01) * 0.2;
                proj.sprite.scale.set(2 * pulse, 2 * pulse, 1);
                proj.sprite.material.rotation += 0.05;
                
                // Check collision with enemies
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = proj.sprite.position.x - enemy.sprite.position.x;
                    const dz = proj.sprite.position.z - enemy.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 2) {
                        enemy.health -= proj.damage;
                        enemy.hitFlash = 10;
                        
                        if (enemy.health <= 0) {
                            spawnXPOrb(enemy.sprite.position.clone(), enemy.type.xp);
                            if (Math.random() < enemy.type.goldChance && enemy.type.gold > 0) {
                                spawnGoldOrb(enemy.sprite.position.clone(), enemy.type.gold);
                            }
                            scene.remove(enemy.sprite);
                            gameState.enemies.splice(j, 1);
                            gameState.kills++;
                            document.getElementById('kills').textContent = gameState.kills;
                        }
                        
                        // Boom projectiles pass through enemies
                    }
                }
                
                // Check collision with encounter guards
                for (const guard of gameState.encounterGuards) {
                    const dx = proj.sprite.position.x - guard.sprite.position.x;
                    const dz = proj.sprite.position.z - guard.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 2) {
                        damageEncounterGuard(guard, proj.damage);
                        // Boom passes through
                    }
                }
                
                // Check collision with bosses
                for (const boss of gameState.bosses) {
                    const dx = proj.sprite.position.x - boss.sprite.position.x;
                    const dz = proj.sprite.position.z - boss.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 4) {
                        boss.health -= proj.damage;
                        boss.hitFlash = 10;
                        // Boom projectiles pass through
                    }
                }
                
                if (proj.life <= 0) {
                    scene.remove(proj.sprite);
                    gameState.boomProjectiles.splice(i, 1);
                }
            }
        }

        function updateBoomCooldown() {
            if (gameState.boomCooldown > 0) {
                gameState.boomCooldown--;
                updateBoomIndicator();
            }
        }

        function updateBoomIndicator() {
            const indicator = document.getElementById('boomIndicator');
            const fill = document.getElementById('boomFill');
            
            if (gameState.upgrades.boom.level === 0) {
                indicator.style.display = 'none';
                return;
            }
            
            indicator.style.display = 'flex';
            
            if (gameState.boomCooldown <= 0) {
                indicator.classList.add('ready');
            } else {
                indicator.classList.remove('ready');
            }
            
            const cooldownPercent = ((gameState.boomMaxCooldown - gameState.boomCooldown) / gameState.boomMaxCooldown) * 100;
            fill.style.width = cooldownPercent + '%';
        }

        // ============================================
        // BOSS SYSTEM
        // ============================================
        const bossTextures = {
            dragon: createDragonTexture(),
            troll: createTrollTexture(),
            evilTree: createEvilTreeTexture(),
            trollClub: createTrollClubTexture(),
            fireball: createBossFireballTexture(),
            treeMagic: createTreeMagicTexture()
        };

        const encounterTextures = {
            princessTower: createPrincessTowerTexture(),
            princess: createPrincessTexture(),
            goldenSkeleton: createGoldenSkeletonTexture(),
            swordInStone: createSwordInStoneTexture(),
            witchHut: createWitchHutTexture(),
            witch: createWitchTexture(),
            heart: createHeartTexture(),
            treasureChest: createTreasureChestTexture(),
            openChest: createOpenChestTexture()
        };

        // Fun facts for treasure chests
        const funFacts = [
            "The princess in the tower window after rescue? That's actually her sister. She's waiting for her own hero",
            "Only a fool laughs at the mighty dragon.",
            "Sir Cowardice the Lame invented the brilliant tactic of standing OUTSIDE the evil tree's range. ",
            "Legend says with 8 orbiting swords, a hero could survive while standing perfectly still. Of course, no one's ever tried it. ",
            "Those 'wizards' are actually Dogmatic Buddhists of the Forest. ",
            "The forest seems dangerous, but most inhabitants are peaceful and kind. They just absolutely HATE people. ",
            "Why do monsters carry gold? Legend speaks of an underground monster only shop",
            "Orbiting swords are great for the forest, terrible for dinner parties. Some heroes stab their swords into stones just to enjoy a meal in peace.",
            "The skeletons? Fallen heroes who drank lots of milk. The ghosts? Heroes' who didn't drink enough milk.",
            "The little green forest people are called goblins. But NEVER let them hear you say it. "
        ];

        const bossTypes = [
            { 
                name: 'dragon', 
                texture: 'dragon',
                scale: [12, 10], 
                speed: 0.04,
                behavior: 'chase_shoot',
                attackCooldown: 120,
                xpMultiplier: 0.8,
                goldDrop: 100
            },
            { 
                name: 'troll', 
                texture: 'troll',
                scale: [8, 12], 
                speed: 0.035,
                behavior: 'chase_club',
                clubDamageMultiplier: 2,
                xpMultiplier: 0.8,
                goldDrop: 80
            },
            { 
                name: 'evilTree', 
                texture: 'evilTree',
                scale: [10, 14], 
                speed: 0,
                behavior: 'stationary_magic',
                attackCooldown: 90,
                boomCooldown: 600,
                xpMultiplier: 0.8,
                goldDrop: 120
            }
        ];

        function getBossHealth() {
            // 100 hits to kill based on current player damage
            const playerDamage = CONFIG.projectileBaseDamage * (1 + gameState.player.level * 0.25);
            return playerDamage * 100;
        }

        function getBossDamage() {
            return CONFIG.enemyBaseDamage * (2 + gameState.player.level * 0.3);
        }

        function shouldSpawnBoss() {
            if (gameState.bosses.length > 0) return false; // Only one boss at a time
            if (gameState.encounter) return false; // No boss during encounters
            
            const level = gameState.player.level;
            if (level < 4) return false; // No bosses before level 4
            
            // Spawn chance increases with level - REDUCED BY 50%
            // Level 4: ~1% chance per spawn check
            // Level 9+: ~7.5% chance per spawn check
            const baseChance = 0.01; // Was 0.02
            const levelBonus = Math.min((level - 4) * 0.0125, 0.065); // Was 0.025 and 0.13
            const spawnChance = baseChance + levelBonus;
            
            return Math.random() < spawnChance;
        }

        function shouldSpawnEncounter() {
            if (gameState.encounter) return false; // Only one encounter at a time
            if (gameState.bosses.length > 0) return false; // No encounter during boss
            
            const level = gameState.player.level;
            if (level < 4) return false; // No encounters before level 4
            
            // Same chance as reduced boss spawns
            const baseChance = 0.01;
            const levelBonus = Math.min((level - 4) * 0.0125, 0.065);
            const spawnChance = baseChance + levelBonus;
            
            return Math.random() < spawnChance;
        }

        function spawnBoss() {
            const angle = Math.random() * Math.PI * 2;
            const dist = CONFIG.enemySpawnRadius * 1.2;
            
            const x = gameState.player.position.x + Math.cos(angle) * dist;
            const z = gameState.player.position.z + Math.sin(angle) * dist;

            const typeIndex = Math.floor(Math.random() * bossTypes.length);
            const type = bossTypes[typeIndex];

            const material = new THREE.SpriteMaterial({ 
                map: bossTextures[type.texture], 
                transparent: true 
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(type.scale[0], type.scale[1], 1);
            sprite.position.set(x, type.scale[1] / 2, z);

            const boss = {
                sprite,
                type,
                health: getBossHealth(),
                maxHealth: getBossHealth(),
                damage: getBossDamage(),
                attackTimer: 0,
                boomTimer: type.boomCooldown || 0,
                hitFlash: 0,
                projectiles: [],
                club: null,
                clubAngle: 0
            };

            // Create troll's club
            if (type.behavior === 'chase_club') {
                const clubMaterial = new THREE.SpriteMaterial({
                    map: bossTextures.trollClub,
                    transparent: true
                });
                const clubSprite = new THREE.Sprite(clubMaterial);
                clubSprite.scale.set(2.5, 6, 1);
                scene.add(clubSprite);
                boss.club = clubSprite;
            }

            scene.add(sprite);
            gameState.bosses.push(boss);
            gameState.bossActive = true;
            gameState.targetCameraZoom = 1.8; // Zoom out camera
        }

        function updateBosses() {
            // Pause during dialogue
            if (gameState.dialogueTimer > 0) return;
            
            const playerDamage = CONFIG.projectileBaseDamage * (1 + gameState.player.level * 0.25);
            
            for (let i = gameState.bosses.length - 1; i >= 0; i--) {
                const boss = gameState.bosses[i];
                const type = boss.type;
                
                const dx = gameState.player.position.x - boss.sprite.position.x;
                const dz = gameState.player.position.z - boss.sprite.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                // Movement based on behavior
                if (type.speed > 0 && dist > 3) {
                    boss.sprite.position.x += (dx / dist) * type.speed;
                    boss.sprite.position.z += (dz / dist) * type.speed;
                }

                // Behavior-specific updates
                if (type.behavior === 'chase_shoot') {
                    // Dragon shoots fireballs
                    boss.attackTimer++;
                    if (boss.attackTimer >= type.attackCooldown) {
                        shootBossProjectile(boss, 'fireball', dx, dz, dist);
                        boss.attackTimer = 0;
                    }
                } else if (type.behavior === 'chase_club') {
                    // Troll has orbiting club
                    boss.clubAngle += 0.05;
                    const clubRadius = 5;
                    const clubX = boss.sprite.position.x + Math.cos(boss.clubAngle) * clubRadius;
                    const clubZ = boss.sprite.position.z + Math.sin(boss.clubAngle) * clubRadius;
                    boss.club.position.set(clubX, 3, clubZ);
                    boss.club.material.rotation = -boss.clubAngle;
                    
                    // Club damages player
                    const clubDx = gameState.player.position.x - clubX;
                    const clubDz = gameState.player.position.z - clubZ;
                    const clubDist = Math.sqrt(clubDx * clubDx + clubDz * clubDz);
                    if (clubDist < 2.5) {
                        takeDamage(boss.damage * type.clubDamageMultiplier);
                    }
                    
                    // Club damages regular enemies
                    for (const enemy of gameState.enemies) {
                        const eDx = enemy.sprite.position.x - clubX;
                        const eDz = enemy.sprite.position.z - clubZ;
                        const eDist = Math.sqrt(eDx * eDx + eDz * eDz);
                        if (eDist < 2.5) {
                            enemy.health -= playerDamage * 2;
                            enemy.hitFlash = 10;
                        }
                    }
                } else if (type.behavior === 'stationary_magic') {
                    // Evil tree shoots magic and occasionally booms
                    boss.attackTimer++;
                    boss.boomTimer++;
                    
                    if (boss.attackTimer >= type.attackCooldown && dist < 30) {
                        shootBossProjectile(boss, 'treeMagic', dx, dz, dist);
                        boss.attackTimer = 0;
                    }
                    
                    if (boss.boomTimer >= type.boomCooldown) {
                        fireBossBoom(boss);
                        boss.boomTimer = 0;
                    }
                }

                // Contact damage for melee bosses
                if (dist < 4 && type.speed > 0) {
                    takeDamage(boss.damage * 0.5);
                }

                // Hit flash effect
                if (boss.hitFlash > 0) {
                    boss.hitFlash--;
                    boss.sprite.material.color.setHex(boss.hitFlash % 4 < 2 ? 0xffffff : 0xff0000);
                } else {
                    boss.sprite.material.color.setHex(0xffffff);
                }

                // Update boss projectiles
                updateBossProjectiles(boss);

                // Check if boss is dead
                if (boss.health <= 0) {
                    // Drop massive XP
                    const xpNeeded = CONFIG.baseXpToLevel * Math.pow(1.5, gameState.player.level - 1);
                    const xpDrop = Math.floor(xpNeeded * type.xpMultiplier);
                    
                    // Drop multiple XP orbs for visual effect
                    for (let j = 0; j < 10; j++) {
                        const orbPos = boss.sprite.position.clone();
                        orbPos.x += (Math.random() - 0.5) * 4;
                        orbPos.z += (Math.random() - 0.5) * 4;
                        spawnXPOrb(orbPos, Math.floor(xpDrop / 10));
                    }
                    
                    // Drop gold
                    for (let j = 0; j < 5; j++) {
                        const goldPos = boss.sprite.position.clone();
                        goldPos.x += (Math.random() - 0.5) * 3;
                        goldPos.z += (Math.random() - 0.5) * 3;
                        spawnGoldOrb(goldPos, Math.floor(type.goldDrop / 5));
                    }
                    
                    // Clean up
                    scene.remove(boss.sprite);
                    if (boss.club) scene.remove(boss.club);
                    boss.projectiles.forEach(p => scene.remove(p.sprite));
                    gameState.bosses.splice(i, 1);
                    gameState.kills++;
                    document.getElementById('kills').textContent = gameState.kills;
                    
                    if (gameState.bosses.length === 0) {
                        gameState.bossActive = false;
                        gameState.targetCameraZoom = 1; // Reset camera
                    }
                }

                // Remove boss if too far (player ran away)
                if (dist > CONFIG.renderDistance * 2.5) {
                    scene.remove(boss.sprite);
                    if (boss.club) scene.remove(boss.club);
                    boss.projectiles.forEach(p => scene.remove(p.sprite));
                    gameState.bosses.splice(i, 1);
                    
                    if (gameState.bosses.length === 0) {
                        gameState.bossActive = false;
                        gameState.targetCameraZoom = 1;
                    }
                }
            }
            
            // Clean up dead enemies from boss attacks
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                if (enemy.health <= 0) {
                    spawnXPOrb(enemy.sprite.position.clone(), enemy.type.xp);
                    if (Math.random() < enemy.type.goldChance && enemy.type.gold > 0) {
                        spawnGoldOrb(enemy.sprite.position.clone(), enemy.type.gold);
                    }
                    scene.remove(enemy.sprite);
                    gameState.enemies.splice(i, 1);
                    gameState.kills++;
                    document.getElementById('kills').textContent = gameState.kills;
                }
            }
        }

        function shootBossProjectile(boss, type, dx, dz, dist) {
            const texture = type === 'fireball' ? bossTextures.fireball : bossTextures.treeMagic;
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2.5, 2.5, 1);
            sprite.position.copy(boss.sprite.position);
            sprite.position.y = 2;
            
            const projectile = {
                sprite,
                direction: new THREE.Vector3(dx / dist, 0, dz / dist),
                speed: 0.2,
                damage: boss.damage,
                life: 300,
                type
            };
            
            scene.add(sprite);
            boss.projectiles.push(projectile);
        }

        function fireBossBoom(boss) {
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                
                const material = new THREE.SpriteMaterial({
                    map: bossTextures.treeMagic,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(3, 3, 1);
                sprite.position.copy(boss.sprite.position);
                sprite.position.y = 4;
                
                const projectile = {
                    sprite,
                    direction: new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)),
                    speed: 0.25,
                    damage: boss.damage * 1.5,
                    life: 200,
                    type: 'boom'
                };
                
                scene.add(sprite);
                boss.projectiles.push(projectile);
            }
        }

        function updateBossProjectiles(boss) {
            const playerDamage = CONFIG.projectileBaseDamage * (1 + gameState.player.level * 0.25);
            
            for (let i = boss.projectiles.length - 1; i >= 0; i--) {
                const proj = boss.projectiles[i];
                
                proj.sprite.position.x += proj.direction.x * proj.speed;
                proj.sprite.position.z += proj.direction.z * proj.speed;
                proj.life--;
                proj.sprite.material.rotation += 0.1;
                
                // Check hit player
                const dx = gameState.player.position.x - proj.sprite.position.x;
                const dz = gameState.player.position.z - proj.sprite.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < 2) {
                    takeDamage(proj.damage);
                    scene.remove(proj.sprite);
                    boss.projectiles.splice(i, 1);
                    continue;
                }
                
                // Boss projectiles damage regular enemies
                for (const enemy of gameState.enemies) {
                    const eDx = enemy.sprite.position.x - proj.sprite.position.x;
                    const eDz = enemy.sprite.position.z - proj.sprite.position.z;
                    const eDist = Math.sqrt(eDx * eDx + eDz * eDz);
                    
                    if (eDist < 1.5) {
                        enemy.health -= playerDamage * 3;
                        enemy.hitFlash = 10;
                    }
                }
                
                if (proj.life <= 0) {
                    scene.remove(proj.sprite);
                    boss.projectiles.splice(i, 1);
                }
            }
        }

        function updateCameraZoom() {
            // Smoothly interpolate camera zoom
            const zoomSpeed = 0.02;
            gameState.cameraZoom += (gameState.targetCameraZoom - gameState.cameraZoom) * zoomSpeed;
            
            // Update boss health bar
            const bossBar = document.getElementById('bossHealthBar');
            if (gameState.bosses.length > 0) {
                const boss = gameState.bosses[0];
                bossBar.classList.add('active');
                
                const bossNames = {
                    dragon: 'üêâ DRAGON',
                    troll: 'üëπ TROLL',
                    evilTree: 'üå≥ EVIL TREE'
                };
                document.getElementById('bossName').textContent = bossNames[boss.type.name] || 'BOSS';
                
                const healthPercent = (boss.health / boss.maxHealth) * 100;
                document.getElementById('bossFill').style.width = Math.max(0, healthPercent) + '%';
            } else {
                bossBar.classList.remove('active');
            }
        }

        // ============================================
        // POSITIVE ENCOUNTER SYSTEM
        // ============================================
        const encounterTypes = [
            {
                name: 'princessTower',
                texture: 'princessTower',
                scale: [8, 16],
                guardType: 'goldenSkeleton',
                guardCount: 15,
                guardHealthMult: 2,
                cameraZoom: 2.5,
                reward: 'magnet',
                rewardText: 'üß≤ MAGNET UPGRADED!'
            },
            {
                name: 'swordInStone',
                texture: 'swordInStone',
                scale: [6, 8],
                guardType: 'goblin',
                guardCount: 20,
                guardHealthMult: 1,
                cameraZoom: 2.2,
                reward: 'swords',
                rewardText: '‚öîÔ∏è SWORD ADDED!'
            },
            {
                name: 'witchHut',
                texture: 'witchHut',
                scale: [10, 12],
                guardType: 'wizard',
                guardCount: 20,
                guardHealthMult: 1,
                cameraZoom: 2.3,
                reward: 'boom',
                rewardText: 'üí• BOOM UPGRADED!'
            }
        ];

        function spawnEncounter() {
            const angle = Math.random() * Math.PI * 2;
            const dist = CONFIG.enemySpawnRadius * 1.3;
            
            const x = gameState.player.position.x + Math.cos(angle) * dist;
            const z = gameState.player.position.z + Math.sin(angle) * dist;

            const typeIndex = Math.floor(Math.random() * encounterTypes.length);
            const type = encounterTypes[typeIndex];

            // Create main structure
            const material = new THREE.SpriteMaterial({
                map: encounterTextures[type.texture],
                transparent: true
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(type.scale[0], type.scale[1], 1);
            sprite.position.set(x, type.scale[1] / 2, z);
            scene.add(sprite);

            // Spawn guards around the structure
            const guards = [];
            for (let i = 0; i < type.guardCount; i++) {
                const guardAngle = (i / type.guardCount) * Math.PI * 2;
                const guardDist = 6 + Math.random() * 4;
                const gx = x + Math.cos(guardAngle) * guardDist;
                const gz = z + Math.sin(guardAngle) * guardDist;

                let guardTexture, guardScale;
                if (type.guardType === 'goldenSkeleton') {
                    guardTexture = encounterTextures.goldenSkeleton;
                    guardScale = [2.5, 4];
                } else if (type.guardType === 'goblin') {
                    guardTexture = createGoblinTexture();
                    guardScale = [2.5, 3.2];
                } else {
                    guardTexture = createWizardTexture();
                    guardScale = [2.5, 4];
                }

                const guardMaterial = new THREE.SpriteMaterial({
                    map: guardTexture,
                    transparent: true
                });
                const guardSprite = new THREE.Sprite(guardMaterial);
                guardSprite.scale.set(guardScale[0], guardScale[1], 1);
                guardSprite.position.set(gx, guardScale[1] / 2, gz);
                scene.add(guardSprite);

                const baseHealth = CONFIG.enemyBaseHealth * (1 + gameState.player.level * 0.2);
                const guard = {
                    sprite: guardSprite,
                    health: baseHealth * type.guardHealthMult,
                    maxHealth: baseHealth * type.guardHealthMult,
                    damage: CONFIG.enemyBaseDamage * (1 + gameState.player.level * 0.15),
                    speed: 0.04,
                    attackCooldown: 0,
                    hitFlash: 0,
                    isGuard: true
                };
                guards.push(guard);
            }
            gameState.encounterGuards = guards;

            gameState.encounter = {
                sprite,
                type,
                position: new THREE.Vector3(x, 0, z),
                complete: false,
                rewardGiven: false,
                npc: null,
                npcTarget: null,
                heartEffect: null
            };

            gameState.targetCameraZoom = type.cameraZoom;
        }

        function updateEncounter() {
            if (!gameState.encounter) return;

            const enc = gameState.encounter;
            const type = enc.type;

            // Update guards (they attack the player) - but pause during dialogue
            if (gameState.dialogueTimer <= 0) {
                for (let i = gameState.encounterGuards.length - 1; i >= 0; i--) {
                    const guard = gameState.encounterGuards[i];
                    
                    const dx = gameState.player.position.x - guard.sprite.position.x;
                    const dz = gameState.player.position.z - guard.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    // Move toward player
                    if (dist > 1.5) {
                        guard.sprite.position.x += (dx / dist) * guard.speed;
                        guard.sprite.position.z += (dz / dist) * guard.speed;
                    } else if (guard.attackCooldown <= 0) {
                        takeDamage(guard.damage);
                        guard.attackCooldown = 60;
                    }

                    guard.attackCooldown = Math.max(0, guard.attackCooldown - 1);

                    // Hit flash
                    if (guard.hitFlash > 0) {
                        guard.hitFlash--;
                        guard.sprite.material.color.setHex(guard.hitFlash % 4 < 2 ? 0xffffff : 0xff0000);
                    } else {
                        guard.sprite.material.color.setHex(0xffffff);
                    }
                }
            }

            // Check if all guards defeated
            if (gameState.encounterGuards.length === 0 && !enc.complete) {
                enc.complete = true;
                onEncounterComplete();
            }

            // Handle post-completion behavior
            if (enc.complete && !enc.rewardGiven) {
                if (type.name === 'princessTower') {
                    updatePrincessEncounter();
                } else if (type.name === 'swordInStone') {
                    updateSwordEncounter();
                } else if (type.name === 'witchHut') {
                    updateWitchEncounter();
                }
            }

            // Update heart effect
            if (enc.heartEffect) {
                enc.heartEffect.position.y += 0.05;
                enc.heartEffect.material.opacity -= 0.01;
                if (enc.heartEffect.material.opacity <= 0) {
                    scene.remove(enc.heartEffect);
                    enc.heartEffect = null;
                }
            }

            // Clean up if player goes too far OR if cleanup timer expired
            const dx = gameState.player.position.x - enc.position.x;
            const dz = gameState.player.position.z - enc.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            // Timer-based cleanup: 30 seconds after reward is claimed
            if (enc.rewardGiven && enc.cleanupTimer !== undefined) {
                enc.cleanupTimer--;
                if (enc.cleanupTimer <= 0) {
                    cleanupEncounter();
                    return;
                }
            }

            // Distance-based cleanup (only if reward was given)
            if (dist > CONFIG.renderDistance * 3 && enc.rewardGiven) {
                cleanupEncounter();
            }
        }

        function onEncounterComplete() {
            const enc = gameState.encounter;
            const type = enc.type;

            if (type.name === 'princessTower') {
                // Spawn princess NPC
                const material = new THREE.SpriteMaterial({
                    map: encounterTextures.princess,
                    transparent: true
                });
                const npc = new THREE.Sprite(material);
                npc.scale.set(2.5, 4, 1);
                npc.position.copy(enc.position);
                npc.position.y = 2;
                scene.add(npc);
                enc.npc = npc;
            } else if (type.name === 'swordInStone') {
                // Sword is ready to collect - show dialogue hint
                showDialogue('‚ú® MAGICAL SWORD', 'Touch the stone to claim your reward!');
            } else if (type.name === 'witchHut') {
                // Spawn witch NPC
                const material = new THREE.SpriteMaterial({
                    map: encounterTextures.witch,
                    transparent: true
                });
                const npc = new THREE.Sprite(material);
                npc.scale.set(2.5, 4.5, 1);
                npc.position.copy(enc.position);
                npc.position.x += 8;
                npc.position.z += 3;
                npc.position.y = 2.25;
                scene.add(npc);
                enc.npc = npc;

                // Witch speaks immediately
                showDialogue('üßô‚Äç‚ôÄÔ∏è WITCH', '"Oh my! You see... I was trying to summon ONE handsome wizard for... um... companionship. Please don\'t tell anyone about this... "');
                giveEncounterReward();
            }
        }

        function updatePrincessEncounter() {
            const enc = gameState.encounter;
            if (!enc.npc) return;

            // Princess walks toward player
            const dx = gameState.player.position.x - enc.npc.position.x;
            const dz = gameState.player.position.z - enc.npc.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 2) {
                enc.npc.position.x += (dx / dist) * 0.06;
                enc.npc.position.z += (dz / dist) * 0.06;
            } else if (!enc.rewardGiven) {
                // Kiss! Show heart and give reward
                spawnHeartEffect(enc.npc.position.clone());
                showDialogue('üë∏ PRINCESS', '"My magnetic rescuer! Finally, I\'m free! Now I can live my dream of practicing EVIL MAGIC in the forest! ...What? Don\'t look at me like that. "');
                giveEncounterReward();
            }
        }

        function updateSwordEncounter() {
            const enc = gameState.encounter;
            
            // Check if player touches the stone
            const dx = gameState.player.position.x - enc.position.x;
            const dz = gameState.player.position.z - enc.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist < 3 && !enc.rewardGiven) {
                showDialogue('ü™® STONE', '"Ahh, sweet relief! That sword was such a pain in my side. Take it, please! It\'s all yours!"');
                giveEncounterReward();
            }
        }

        function updateWitchEncounter() {
            // Witch encounter completes immediately in onEncounterComplete
        }

        function spawnHeartEffect(position) {
            const material = new THREE.SpriteMaterial({
                map: encounterTextures.heart,
                transparent: true
            });
            const heart = new THREE.Sprite(material);
            heart.scale.set(3, 3, 1);
            heart.position.copy(position);
            heart.position.y = 4;
            scene.add(heart);
            gameState.encounter.heartEffect = heart;
        }

        function giveEncounterReward() {
            const enc = gameState.encounter;
            if (enc.rewardGiven) return;

            const type = enc.type;
            enc.rewardGiven = true;
            enc.cleanupTimer = 30 * 60; // 30 seconds at 60fps - auto cleanup after reward claimed

            // Grant the upgrade
            const upgrade = gameState.upgrades[type.reward];
            if (upgrade.level < upgrade.maxLevel) {
                upgrade.level++;
                
                // Apply upgrade effects
                if (type.reward === 'swords') {
                    updateSwordCount();
                } else if (type.reward === 'boom') {
                    updateBoomIndicator();
                    document.getElementById('boomCooldown').classList.add('active');
                }

                // Show reward notification
                showReward(type.rewardText);
                updateUpgradeMenu();
            } else {
                // Already maxed - give gold instead
                const goldReward = 200;
                gameState.player.gold += goldReward;
                document.getElementById('goldNum').textContent = gameState.player.gold;
                showReward(`üí∞ ${goldReward} GOLD (Upgrade already maxed!)`);
            }

            // Zoom camera back
            gameState.targetCameraZoom = 1;
        }

        function showDialogue(speaker, text) {
            document.getElementById('dialogueSpeaker').textContent = speaker;
            document.getElementById('dialogueText').textContent = text;
            document.getElementById('dialogueBox').classList.add('active');
            
            gameState.dialogueTimer = 99999; // Keep paused until button clicked
        }

        function hideDialogue() {
            document.getElementById('dialogueBox').classList.remove('active');
            gameState.dialogueTimer = 0;
        }

        function setupDialogueButton() {
            const btn = document.getElementById('dialogueContinue');
            btn.addEventListener('click', hideDialogue);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                hideDialogue();
            });
        }

        function showReward(text) {
            document.getElementById('rewardText').textContent = text;
            document.getElementById('rewardNotification').classList.add('active');
            
            setTimeout(() => {
                document.getElementById('rewardNotification').classList.remove('active');
            }, 3000);
        }

        function updateDialogue() {
            // Dialogue is now dismissed by button click
            // This function just keeps the timer active for mob pausing
        }

        function updateCompass() {
            let target = null;
            let targetType = null;

            // Priority: active encounter > boss
            if (gameState.encounter && !gameState.encounter.rewardGiven) {
                target = gameState.encounter.position;
                targetType = 'encounter';
            } else if (gameState.bosses.length > 0) {
                target = gameState.bosses[0].sprite.position;
                targetType = 'boss';
            }

            if (target) {
                compassLine.visible = true;
                
                // Calculate direction to target
                const dx = target.x - gameState.player.position.x;
                const dz = target.z - gameState.player.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist > 5) {
                    // Normalize and scale the line length
                    const lineLength = Math.min(8, dist * 0.15);
                    const dirX = (dx / dist) * lineLength;
                    const dirZ = (dz / dist) * lineLength;
                    
                    // Update line positions
                    const positions = compassLine.geometry.attributes.position.array;
                    // Start point (near player)
                    positions[0] = gameState.player.position.x + (dx / dist) * 2;
                    positions[1] = 0.2;
                    positions[2] = gameState.player.position.z + (dz / dist) * 2;
                    // End point (towards target)
                    positions[3] = gameState.player.position.x + (dx / dist) * (2 + lineLength);
                    positions[4] = 0.2;
                    positions[5] = gameState.player.position.z + (dz / dist) * (2 + lineLength);
                    
                    compassLine.geometry.attributes.position.needsUpdate = true;
                    
                    // Color based on target type
                    if (targetType === 'encounter') {
                        compassMaterial.color.setHex(0x2ecc71); // Green for positive
                    } else {
                        compassMaterial.color.setHex(0xe74c3c); // Red for boss
                    }
                    
                    // Pulse opacity
                    const pulse = 0.4 + Math.sin(Date.now() * 0.005) * 0.3;
                    compassMaterial.opacity = pulse;
                } else {
                    compassLine.visible = false;
                }
            } else {
                compassLine.visible = false;
            }
        }

        function cleanupEncounter() {
            const enc = gameState.encounter;
            if (!enc) return;

            scene.remove(enc.sprite);
            if (enc.npc) scene.remove(enc.npc);
            if (enc.heartEffect) scene.remove(enc.heartEffect);

            // Clean up remaining guards
            gameState.encounterGuards.forEach(g => scene.remove(g.sprite));
            gameState.encounterGuards = [];

            gameState.encounter = null;
            gameState.targetCameraZoom = 1;
            hideDialogue();
        }

        // Handle guard damage from player projectiles
        function damageEncounterGuard(guard, damage) {
            guard.health -= damage;
            guard.hitFlash = 10;

            if (guard.health <= 0) {
                // Drop XP and maybe gold
                spawnXPOrb(guard.sprite.position.clone(), 15);
                if (Math.random() < 0.3) {
                    spawnGoldOrb(guard.sprite.position.clone(), 8);
                }
                scene.remove(guard.sprite);
                const idx = gameState.encounterGuards.indexOf(guard);
                if (idx > -1) gameState.encounterGuards.splice(idx, 1);
                gameState.kills++;
                document.getElementById('kills').textContent = gameState.kills;
            }
        }

        // ============================================
        // TREASURE CHEST SYSTEM
        // ============================================
        function spawnTreasureChest() {
            const angle = Math.random() * Math.PI * 2;
            const dist = 15 + Math.random() * 25;
            
            const x = gameState.player.position.x + Math.cos(angle) * dist;
            const z = gameState.player.position.z + Math.sin(angle) * dist;

            const material = new THREE.SpriteMaterial({
                map: encounterTextures.treasureChest,
                transparent: true
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2.5, 2.2, 1);
            sprite.position.set(x, 1.1, z);
            scene.add(sprite);

            const chest = {
                sprite,
                position: new THREE.Vector3(x, 0, z),
                opened: false,
                goldAmount: 15 + Math.floor(Math.random() * 35), // 15-50 gold
                factIndex: Math.floor(Math.random() * funFacts.length)
            };

            gameState.treasureChests.push(chest);
        }

        function updateTreasureChests() {
            for (let i = gameState.treasureChests.length - 1; i >= 0; i--) {
                const chest = gameState.treasureChests[i];
                
                // Bob slightly
                chest.sprite.position.y = 1.1 + Math.sin(Date.now() * 0.002 + i) * 0.1;
                
                if (!chest.opened) {
                    // Check player collision
                    const dx = gameState.player.position.x - chest.position.x;
                    const dz = gameState.player.position.z - chest.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 2) {
                        openTreasureChest(chest);
                    }
                }
                
                // Remove if too far and already opened
                const dx = gameState.player.position.x - chest.position.x;
                const dz = gameState.player.position.z - chest.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist > CONFIG.renderDistance * 2) {
                    scene.remove(chest.sprite);
                    gameState.treasureChests.splice(i, 1);
                }
            }
        }

        function openTreasureChest(chest) {
            chest.opened = true;
            
            // Change to open chest texture
            chest.sprite.material.map = encounterTextures.openChest;
            chest.sprite.material.needsUpdate = true;
            chest.sprite.scale.set(2.5, 2.5, 1);
            
            // Give gold
            gameState.player.gold += chest.goldAmount;
            document.getElementById('goldNum').textContent = gameState.player.gold;
            
            // Show reward
            showReward(`üí∞ +${chest.goldAmount} GOLD`);
            
            // Show fun fact dialogue
            setTimeout(() => {
                showDialogue('üìú ANCIENT WISDOM', funFacts[chest.factIndex]);
            }, 500);
        }

        function shouldSpawnChest() {
            // Limit max chests
            if (gameState.treasureChests.length >= 5) return false;
            
            // Small chance each spawn cycle
            return Math.random() < 0.08;
        }

        function gainXP(amount) {
            gameState.player.xp += amount;
            const xpNeeded = CONFIG.baseXpToLevel * Math.pow(1.5, gameState.player.level - 1);
            
            if (gameState.player.xp >= xpNeeded) {
                gameState.player.xp -= xpNeeded;
                gameState.player.level++;
                gameState.player.maxHealth = 100 + gameState.player.level * 10;
                gameState.player.health = gameState.player.maxHealth;
                
                document.getElementById('levelNum').textContent = gameState.player.level;
                
                // Level up animation
                const levelUpEl = document.getElementById('levelUp');
                levelUpEl.style.animation = 'none';
                levelUpEl.offsetHeight; // Trigger reflow
                levelUpEl.style.animation = 'levelUpAnim 1.5s ease-out forwards';
            }

            updateUI();
        }

        // ============================================
        // PLAYER DAMAGE
        // ============================================
        function takeDamage(amount) {
            if (gameState.isGameOver) return;
            
            gameState.player.health -= amount;
            
            // Flash effect
            const flash = document.getElementById('damageFlash');
            flash.style.opacity = '1';
            setTimeout(() => flash.style.opacity = '0', 100);

            if (gameState.player.health <= 0) {
                gameOver();
            }

            updateUI();
        }

        function gameOver() {
            gameState.isGameOver = true;
            document.getElementById('finalLevel').textContent = gameState.player.level;
            document.getElementById('finalKills').textContent = gameState.kills;
            document.getElementById('finalGold').textContent = gameState.player.gold;
            document.getElementById('gameOver').style.display = 'flex';
        }

        function restartGame() {
            // Clear enemies
            gameState.enemies.forEach(e => scene.remove(e.sprite));
            gameState.enemies = [];

            // Clear projectiles
            gameState.projectiles.forEach(p => scene.remove(p.sprite));
            gameState.projectiles = [];

            // Clear XP orbs
            gameState.xpOrbs.forEach(o => scene.remove(o.sprite));
            gameState.xpOrbs = [];

            // Clear gold orbs
            gameState.goldOrbs.forEach(o => scene.remove(o.sprite));
            gameState.goldOrbs = [];

            // Clear swords
            gameState.swords.forEach(s => scene.remove(s.sprite));
            gameState.swords = [];

            // Clear boom projectiles
            gameState.boomProjectiles.forEach(p => scene.remove(p.sprite));
            gameState.boomProjectiles = [];

            // Clear bosses
            gameState.bosses.forEach(b => {
                scene.remove(b.sprite);
                if (b.club) scene.remove(b.club);
                b.projectiles.forEach(p => scene.remove(p.sprite));
            });
            gameState.bosses = [];

            // Clear encounters
            if (gameState.encounter) {
                cleanupEncounter();
            }
            gameState.encounterGuards.forEach(g => scene.remove(g.sprite));
            gameState.encounterGuards = [];

            // Clear treasure chests
            gameState.treasureChests.forEach(c => scene.remove(c.sprite));
            gameState.treasureChests = [];

            // Reset player
            gameState.player = {
                level: 1,
                xp: 0,
                health: 100,
                maxHealth: 100,
                position: new THREE.Vector3(0, 0, 0),
                rotation: 0,
                gold: 0
            };

            // Reset upgrades
            gameState.upgrades = {
                magnet: { level: 0, maxLevel: 8, baseCost: 10, costMult: 1.5 },
                swords: { level: 0, maxLevel: 8, baseCost: 50, costMult: 1.8 },
                boom: { level: 0, maxLevel: 30, baseCost: 30, costMult: 1.3 }
            };

            gameState.kills = 0;
            gameState.boomCooldown = 0;
            gameState.bossActive = false;
            gameState.cameraZoom = 1;
            gameState.targetCameraZoom = 1;
            gameState.encounter = null;
            gameState.encounterComplete = false;
            gameState.dialogue = null;
            gameState.dialogueTimer = 0;
            gameState.isGameOver = false;
            gameState.menuOpen = false;

            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('levelNum').textContent = '1';
            document.getElementById('kills').textContent = '0';
            document.getElementById('goldNum').textContent = '0';
            document.getElementById('boomIndicator').style.display = 'none';
            document.getElementById('boomCooldown').classList.remove('active');
            hideDialogue();
            
            updateUI();
            updateUpgradeMenu();
        }

        function updateUI() {
            const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';

            const xpNeeded = CONFIG.baseXpToLevel * Math.pow(1.5, gameState.player.level - 1);
            const xpPercent = (gameState.player.xp / xpNeeded) * 100;
            document.getElementById('xpFill').style.width = xpPercent + '%';
            
            document.getElementById('goldNum').textContent = gameState.player.gold;
        }

        // ============================================
        // UPGRADE MENU SYSTEM
        // ============================================
        function getUpgradeCost(upgradeKey) {
            const upgrade = gameState.upgrades[upgradeKey];
            return Math.floor(upgrade.baseCost * Math.pow(upgrade.costMult, upgrade.level));
        }

        function canAffordUpgrade(upgradeKey) {
            return gameState.player.gold >= getUpgradeCost(upgradeKey);
        }

        function isUpgradeMaxed(upgradeKey) {
            const upgrade = gameState.upgrades[upgradeKey];
            return upgrade.level >= upgrade.maxLevel;
        }

        function purchaseUpgrade(upgradeKey) {
            if (isUpgradeMaxed(upgradeKey) || !canAffordUpgrade(upgradeKey)) return;
            
            const cost = getUpgradeCost(upgradeKey);
            gameState.player.gold -= cost;
            gameState.upgrades[upgradeKey].level++;
            
            // Apply upgrade effects
            if (upgradeKey === 'swords') {
                updateSwordCount();
            } else if (upgradeKey === 'boom') {
                updateBoomIndicator();
                document.getElementById('boomCooldown').classList.add('active');
            }
            
            updateUI();
            updateUpgradeMenu();
        }

        function updateUpgradeMenu() {
            const upgrades = ['magnet', 'swords', 'boom'];
            
            upgrades.forEach(key => {
                const item = document.getElementById(`upgrade-${key}`);
                const btn = item.querySelector('.upgrade-btn');
                const lvlSpan = item.querySelector('.lvl');
                const costSpan = btn.querySelector('.cost');
                
                const upgrade = gameState.upgrades[key];
                lvlSpan.textContent = upgrade.level;
                
                if (isUpgradeMaxed(key)) {
                    item.classList.add('maxed');
                    btn.disabled = true;
                    costSpan.textContent = 'MAX';
                } else {
                    item.classList.remove('maxed');
                    const cost = getUpgradeCost(key);
                    costSpan.textContent = `üí∞ ${cost}`;
                    btn.disabled = !canAffordUpgrade(key);
                }
            });
            
            // Update boom cooldown display
            if (gameState.upgrades.boom.level > 0) {
                document.getElementById('boomCooldown').classList.add('active');
            }
        }

        function openMenu() {
            gameState.menuOpen = true;
            document.getElementById('upgradeMenu').style.display = 'flex';
            updateUpgradeMenu();
        }

        function closeMenu() {
            gameState.menuOpen = false;
            document.getElementById('upgradeMenu').style.display = 'none';
        }

        function setupMenuControls() {
            document.getElementById('menuBtn').addEventListener('click', openMenu);
            document.getElementById('menuBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                openMenu();
            });
            
            document.getElementById('closeMenu').addEventListener('click', closeMenu);
            document.getElementById('closeMenu').addEventListener('touchstart', (e) => {
                e.preventDefault();
                closeMenu();
            });
            
            // Upgrade buttons
            document.querySelectorAll('.upgrade-btn').forEach(btn => {
                const upgrade = btn.dataset.upgrade;
                btn.addEventListener('click', () => purchaseUpgrade(upgrade));
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    purchaseUpgrade(upgrade);
                });
            });
            
            // Boom indicator click
            document.getElementById('boomIndicator').addEventListener('click', fireBoom);
            document.getElementById('boomIndicator').addEventListener('touchstart', (e) => {
                e.preventDefault();
                fireBoom();
            });
        }

        // ============================================
        // CONTROLS
        // ============================================
        const controls = {
            up: false,
            down: false,
            left: false,
            right: false
        };

        let touchStartX = 0;
        let touchStartY = 0;
        let isDragging = false;

        // D-Pad controls
        function setupDPad() {
            const buttons = {
                'dpad-up': 'up',
                'dpad-down': 'down',
                'dpad-left': 'left',
                'dpad-right': 'right'
            };

            for (const [id, dir] of Object.entries(buttons)) {
                const btn = document.getElementById(id);
                
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    controls[dir] = true;
                    btn.classList.add('active');
                });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    controls[dir] = false;
                    btn.classList.remove('active');
                });

                btn.addEventListener('touchcancel', () => {
                    controls[dir] = false;
                    btn.classList.remove('active');
                });

                // Mouse support for desktop
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    controls[dir] = true;
                    btn.classList.add('active');
                });

                btn.addEventListener('mouseup', () => {
                    controls[dir] = false;
                    btn.classList.remove('active');
                });

                btn.addEventListener('mouseleave', () => {
                    controls[dir] = false;
                    btn.classList.remove('active');
                });
            }
        }

        // Magic button
        function setupMagicButton() {
            const btn = document.getElementById('magicBtn');
            let canShoot = true;

            function shoot() {
                if (canShoot && !gameState.isGameOver && gameState.dialogueTimer <= 0) {
                    shootProjectile();
                    canShoot = false;
                    setTimeout(() => canShoot = true, 250);
                }
            }

            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                shoot();
            });

            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                shoot();
            });
        }

        // View swipe control
        function setupViewControl() {
            const viewArea = document.getElementById('viewArea');

            viewArea.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    isDragging = true;
                }
            });

            viewArea.addEventListener('touchmove', (e) => {
                if (isDragging && e.touches.length === 1 && gameState.dialogueTimer <= 0) {
                    const dx = e.touches[0].clientX - touchStartX;
                    gameState.player.rotation += dx * 0.005;
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });

            viewArea.addEventListener('touchend', () => {
                isDragging = false;
            });

            // Mouse support
            viewArea.addEventListener('mousedown', (e) => {
                touchStartX = e.clientX;
                isDragging = true;
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging && gameState.dialogueTimer <= 0) {
                    const dx = e.clientX - touchStartX;
                    gameState.player.rotation += dx * 0.005;
                    touchStartX = e.clientX;
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // Keyboard support
        function setupKeyboard() {
            document.addEventListener('keydown', (e) => {
                if (gameState.menuOpen) {
                    if (e.key === 'Escape') closeMenu();
                    return;
                }
                if (gameState.dialogueTimer > 0) return; // Disable controls during dialogue
                switch(e.key.toLowerCase()) {
                    case 'w': case 'arrowup': controls.up = true; break;
                    case 's': case 'arrowdown': controls.down = true; break;
                    case 'a': case 'arrowleft': controls.left = true; break;
                    case 'd': case 'arrowright': controls.right = true; break;
                    case ' ': shootProjectile(); break;
                    case 'q': fireBoom(); break;
                    case 'e': case 'escape': 
                        if (gameState.menuOpen) closeMenu();
                        else openMenu();
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w': case 'arrowup': controls.up = false; break;
                    case 's': case 'arrowdown': controls.down = false; break;
                    case 'a': case 'arrowleft': controls.left = false; break;
                    case 'd': case 'arrowright': controls.right = false; break;
                }
            });
        }

        // Restart button
        document.getElementById('restartBtn').addEventListener('click', restartGame);
        document.getElementById('restartBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            restartGame();
        });

        // ============================================
        // GAME LOOP
        // ============================================
        let lastSpawnTime = 0;

        function updatePlayer() {
            if (gameState.isGameOver) return;
            if (gameState.dialogueTimer > 0) return; // Pause player during dialogue

            const moveSpeed = CONFIG.playerSpeed;
            let moved = false;

            if (controls.up) {
                gameState.player.position.x -= Math.sin(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z -= Math.cos(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.down) {
                gameState.player.position.x += Math.sin(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z += Math.cos(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.left) {
                gameState.player.position.x -= Math.cos(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z += Math.sin(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.right) {
                gameState.player.position.x += Math.cos(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z -= Math.sin(gameState.player.rotation) * moveSpeed;
                moved = true;
            }

            // Update player visual position
            playerGroup.position.copy(gameState.player.position);

            // Update camera with zoom
            const camDist = 12 * gameState.cameraZoom;
            const camHeight = 8 * gameState.cameraZoom;
            camera.position.x = gameState.player.position.x + Math.sin(gameState.player.rotation) * camDist;
            camera.position.z = gameState.player.position.z + Math.cos(gameState.player.rotation) * camDist;
            camera.position.y = camHeight;
            camera.lookAt(
                gameState.player.position.x,
                2,
                gameState.player.position.z
            );

            // Update ground position to follow player
            ground.position.x = gameState.player.position.x;
            ground.position.z = gameState.player.position.z;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!gameState.isGameOver && !gameState.menuOpen) {
                updatePlayer();
                updateChunks();
                updateEnemies();
                updateProjectiles();
                updateXPOrbs();
                updateGoldOrbs();
                updateSwords();
                updateBoomProjectiles();
                updateBoomCooldown();
                updateBosses();
                updateEncounter();
                updateTreasureChests();
                updateDialogue();
                updateCompass();
                updateCameraZoom();

                // Spawn enemies
                const now = Date.now();
                if (now - lastSpawnTime > CONFIG.enemySpawnInterval) {
                    spawnEnemy();
                    
                    // Maybe spawn a boss
                    if (shouldSpawnBoss()) {
                        spawnBoss();
                    }
                    // Maybe spawn an encounter
                    else if (shouldSpawnEncounter()) {
                        spawnEncounter();
                    }
                    
                    // Maybe spawn a treasure chest
                    if (shouldSpawnChest()) {
                        spawnTreasureChest();
                    }
                    
                    lastSpawnTime = now;
                }
            }

            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            setupDPad();
            setupMagicButton();
            setupViewControl();
            setupKeyboard();
            setupMenuControls();
            setupDialogueButton();

            // Generate initial chunks
            updateChunks();
            
            // Initialize UI
            updateUpgradeMenu();

            // Start animation
            animate();

            // Start spawning enemies
            setTimeout(() => {
                for (let i = 0; i < 3; i++) {
                    spawnEnemy();
                }
            }, 1000);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start game
        init();
    </script>
</body>
</html>
