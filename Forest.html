<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mystic Forest Walker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            overflow: hidden;
            background: #0a0a12;
            font-family: 'Press Start 2P', cursive;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 10px;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
            line-height: 1.8;
            z-index: 100;
        }
        
        #stats .level {
            color: #ffd700;
            font-size: 14px;
        }
        
        #healthBar {
            width: 150px;
            height: 16px;
            background: #333;
            border: 3px solid #222;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(180deg, #ff6b6b, #c0392b);
            transition: width 0.3s;
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3);
        }
        
        #xpBar {
            width: 150px;
            height: 10px;
            background: #333;
            border: 2px solid #222;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        #xpFill {
            height: 100%;
            background: linear-gradient(180deg, #9b59b6, #8e44ad);
            transition: width 0.3s;
        }
        
        #dpad {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }
        
        .dpad-btn {
            position: absolute;
            width: 46px;
            height: 46px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: rgba(255,255,255,0.7);
            transition: all 0.1s;
            backdrop-filter: blur(4px);
        }
        
        .dpad-btn:active, .dpad-btn.active {
            background: rgba(255,255,255,0.35);
            transform: scale(0.95);
            border-color: rgba(255,255,255,0.6);
        }
        
        #dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
        #dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
        #dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
        #dpad-right { right: 0; top: 50%; transform: translateY(-50%); }
        
        #magicBtn {
            position: absolute;
            bottom: 50px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #9b59b6, #6c3483);
            border: 4px solid #bb8fce;
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #9b59b6;
            box-shadow: 0 0 20px rgba(155,89,182,0.5), inset 0 -4px 10px rgba(0,0,0,0.3);
            transition: all 0.1s;
        }
        
        #magicBtn:active {
            transform: scale(0.9);
            box-shadow: 0 0 30px rgba(155,89,182,0.8), inset 0 -4px 10px rgba(0,0,0,0.3);
        }
        
        #viewArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            pointer-events: auto;
        }
        
        #damageFlash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,0,0,0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
        
        #levelUp {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 24px;
            text-shadow: 0 0 20px #ffd700, 0 0 40px #ff8c00;
            opacity: 0;
            pointer-events: none;
            animation: none;
        }
        
        @keyframes levelUpAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1) translateY(-50px); }
        }
        
        #killCount {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ff6b6b;
            font-size: 12px;
            text-shadow: 2px 2px 0 #000;
        }
        
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            z-index: 1000;
        }
        
        #gameOver h1 {
            color: #c0392b;
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #c0392b;
        }
        
        #gameOver p {
            font-size: 12px;
            margin: 10px 0;
        }
        
        #restartBtn {
            margin-top: 30px;
            padding: 15px 30px;
            background: #27ae60;
            border: none;
            border-radius: 8px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        #instructions {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 8px;
            text-align: center;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="stats">
            <div class="level">LVL <span id="levelNum">1</span></div>
            <div>HP</div>
            <div id="healthBar"><div id="healthFill" style="width: 100%"></div></div>
            <div>XP</div>
            <div id="xpBar"><div id="xpFill" style="width: 0%"></div></div>
        </div>
        
        <div id="killCount">☠ <span id="kills">0</span></div>
        
        <div id="viewArea"></div>
        
        <div id="dpad">
            <div class="dpad-btn" id="dpad-up">▲</div>
            <div class="dpad-btn" id="dpad-down">▼</div>
            <div class="dpad-btn" id="dpad-left">◄</div>
            <div class="dpad-btn" id="dpad-right">►</div>
        </div>
        
        <div id="magicBtn">✦</div>
        
        <div id="instructions">SWIPE TO LOOK • D-PAD TO MOVE • ✦ TO ATTACK</div>
    </div>
    
    <div id="damageFlash"></div>
    <div id="levelUp">LEVEL UP!</div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p>Level Reached: <span id="finalLevel">1</span></p>
        <p>Enemies Slain: <span id="finalKills">0</span></p>
        <button id="restartBtn">RESTART</button>
    </div>

    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            renderDistance: 40,
            fogNear: 15,
            fogFar: 45,
            chunkSize: 30,
            treeDensity: 0.009,
            playerSpeed: 0.12,
            enemyBaseHealth: 30,
            enemyBaseDamage: 5,
            baseXpToLevel: 50,
            projectileBaseSpeed: 0.5,
            projectileBaseDamage: 15,
            enemySpawnRadius: 35,
            enemyMaxCount: 12,
            enemySpawnInterval: 2000
        };

        // ============================================
        // PIXEL ART TEXTURE GENERATORS
        // ============================================
        function createPixelTexture(width, height, drawFunc) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            drawFunc(ctx, width, height);
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        function createTreeTexture(type = 0) {
            return createPixelTexture(32, 64, (ctx, w, h) => {
                const colors = [
                    { trunk: '#5d4037', leaves: ['#2e7d32', '#388e3c', '#43a047'] },
                    { trunk: '#4e342e', leaves: ['#1b5e20', '#2e7d32', '#388e3c'] },
                    { trunk: '#6d4c41', leaves: ['#558b2f', '#689f38', '#7cb342'] },
                    { trunk: '#3e2723', leaves: ['#4a148c', '#6a1b9a', '#7b1fa2'] } // Mystic purple tree
                ];
                const c = colors[type % colors.length];
                
                // Trunk
                ctx.fillStyle = c.trunk;
                ctx.fillRect(13, 30, 6, 34);
                ctx.fillStyle = '#3e2723';
                ctx.fillRect(14, 30, 2, 34);
                
                // Leaves layers
                const leafPatterns = [
                    { y: 5, w: 24, h: 14 },
                    { y: 15, w: 28, h: 12 },
                    { y: 24, w: 22, h: 10 }
                ];
                
                leafPatterns.forEach((p, i) => {
                    ctx.fillStyle = c.leaves[i % c.leaves.length];
                    ctx.fillRect((w - p.w) / 2, p.y, p.w, p.h);
                    
                    // Add pixel details
                    ctx.fillStyle = c.leaves[(i + 1) % c.leaves.length];
                    for (let j = 0; j < 6; j++) {
                        const px = (w - p.w) / 2 + Math.random() * p.w;
                        const py = p.y + Math.random() * p.h;
                        ctx.fillRect(Math.floor(px), Math.floor(py), 2, 2);
                    }
                });
                
                // Top
                ctx.fillStyle = c.leaves[0];
                ctx.fillRect(12, 0, 8, 6);
            });
        }

        function createGrassTexture() {
            return createPixelTexture(64, 64, (ctx, w, h) => {
                // Base
                ctx.fillStyle = '#1a472a';
                ctx.fillRect(0, 0, w, h);
                
                // Grass variation
                const colors = ['#2d5a3f', '#1e5631', '#174023', '#236b3f'];
                for (let i = 0; i < 100; i++) {
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    ctx.fillRect(
                        Math.floor(Math.random() * w),
                        Math.floor(Math.random() * h),
                        2, 2
                    );
                }
                
                // Small flowers
                const flowerColors = ['#e91e63', '#ffeb3b', '#03a9f4', '#ff9800'];
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                    ctx.fillRect(
                        Math.floor(Math.random() * w),
                        Math.floor(Math.random() * h),
                        2, 2
                    );
                }
            });
        }

        function createRockTexture() {
            return createPixelTexture(16, 16, (ctx, w, h) => {
                ctx.fillStyle = '#5d6d7e';
                ctx.beginPath();
                ctx.arc(8, 10, 7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#85929e';
                ctx.fillRect(4, 6, 4, 3);
                ctx.fillRect(9, 8, 3, 2);
                
                ctx.fillStyle = '#34495e';
                ctx.fillRect(6, 11, 5, 3);
            });
        }

        function createMushroomTexture() {
            return createPixelTexture(16, 24, (ctx, w, h) => {
                // Stem
                ctx.fillStyle = '#faf0e6';
                ctx.fillRect(6, 12, 4, 12);
                
                // Cap
                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.ellipse(8, 10, 7, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Spots
                ctx.fillStyle = '#fff';
                ctx.fillRect(4, 7, 3, 3);
                ctx.fillRect(9, 5, 2, 2);
                ctx.fillRect(10, 10, 2, 2);
            });
        }

        // Enemy sprite textures
        function createSlimeTexture() {
            return createPixelTexture(32, 32, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.ellipse(16, 20, 14, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Highlight
                ctx.fillStyle = '#2ecc71';
                ctx.beginPath();
                ctx.ellipse(16, 18, 10, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.fillRect(10, 16, 5, 5);
                ctx.fillRect(18, 16, 5, 5);
                ctx.fillStyle = '#000';
                ctx.fillRect(12, 18, 2, 2);
                ctx.fillRect(20, 18, 2, 2);
                
                // Shine
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillRect(8, 14, 3, 3);
            });
        }

        function createSkeletonTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Skull
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(10, 2, 12, 14);
                ctx.fillRect(8, 6, 16, 8);
                
                // Eyes
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(11, 7, 4, 4);
                ctx.fillRect(17, 7, 4, 4);
                ctx.fillStyle = '#000';
                ctx.fillRect(12, 8, 2, 2);
                ctx.fillRect(18, 8, 2, 2);
                
                // Nose
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(15, 11, 2, 3);
                
                // Teeth
                ctx.fillStyle = '#bdc3c7';
                ctx.fillRect(12, 14, 8, 2);
                
                // Spine
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(14, 16, 4, 20);
                
                // Ribs
                ctx.fillStyle = '#bdc3c7';
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(8, 18 + i * 4, 16, 2);
                }
                
                // Arms
                ctx.fillRect(4, 18, 4, 14);
                ctx.fillRect(24, 18, 4, 14);
                
                // Legs
                ctx.fillRect(10, 36, 4, 12);
                ctx.fillRect(18, 36, 4, 12);
            });
        }

        function createGoblinTexture() {
            return createPixelTexture(32, 40, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#6b8e23';
                ctx.fillRect(8, 16, 16, 16);
                
                // Head
                ctx.fillStyle = '#7cba3d';
                ctx.fillRect(6, 4, 20, 14);
                
                // Ears
                ctx.fillStyle = '#6b8e23';
                ctx.fillRect(2, 6, 6, 8);
                ctx.fillRect(24, 6, 6, 8);
                
                // Eyes
                ctx.fillStyle = '#ff0';
                ctx.fillRect(10, 8, 4, 4);
                ctx.fillRect(18, 8, 4, 4);
                ctx.fillStyle = '#000';
                ctx.fillRect(11, 9, 2, 2);
                ctx.fillRect(19, 9, 2, 2);
                
                // Nose
                ctx.fillStyle = '#5a7a1e';
                ctx.fillRect(14, 11, 4, 4);
                
                // Mouth
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(12, 15, 8, 2);
                
                // Legs
                ctx.fillStyle = '#6b8e23';
                ctx.fillRect(10, 32, 4, 8);
                ctx.fillRect(18, 32, 4, 8);
                
                // Arms
                ctx.fillRect(4, 18, 4, 10);
                ctx.fillRect(24, 18, 4, 10);
            });
        }

        function createGhostTexture() {
            return createPixelTexture(32, 40, (ctx, w, h) => {
                // Body
                ctx.fillStyle = 'rgba(200, 220, 255, 0.8)';
                ctx.beginPath();
                ctx.ellipse(16, 16, 12, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Tail
                ctx.fillRect(6, 24, 20, 10);
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(6 + i * 6, 34, 4, 6);
                }
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(9, 12, 5, 6);
                ctx.fillRect(18, 12, 5, 6);
                
                // Glow
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(10, 8, 4, 3);
                ctx.fillRect(19, 8, 4, 3);
            });
        }

        function createBatTexture() {
            return createPixelTexture(40, 24, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#2c2c54';
                ctx.beginPath();
                ctx.ellipse(20, 14, 8, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Wings
                ctx.fillStyle = '#40407a';
                // Left wing
                ctx.beginPath();
                ctx.moveTo(12, 14);
                ctx.lineTo(2, 6);
                ctx.lineTo(4, 16);
                ctx.lineTo(12, 18);
                ctx.fill();
                
                // Right wing
                ctx.beginPath();
                ctx.moveTo(28, 14);
                ctx.lineTo(38, 6);
                ctx.lineTo(36, 16);
                ctx.lineTo(28, 18);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(16, 11, 3, 3);
                ctx.fillRect(21, 11, 3, 3);
                
                // Ears
                ctx.fillStyle = '#2c2c54';
                ctx.fillRect(14, 4, 4, 6);
                ctx.fillRect(22, 4, 4, 6);
            });
        }

        function createWizardTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Robe
                ctx.fillStyle = '#4a235a';
                ctx.fillRect(8, 20, 16, 22);
                ctx.fillRect(6, 42, 20, 6);
                
                // Face
                ctx.fillStyle = '#fad7a0';
                ctx.fillRect(10, 14, 12, 10);
                
                // Hat
                ctx.fillStyle = '#6c3483';
                ctx.fillRect(6, 10, 20, 6);
                ctx.fillRect(10, 2, 12, 10);
                ctx.fillRect(14, 0, 4, 4);
                
                // Star on hat
                ctx.fillStyle = '#f1c40f';
                ctx.fillRect(14, 4, 4, 4);
                
                // Eyes
                ctx.fillStyle = '#9b59b6';
                ctx.fillRect(12, 16, 3, 3);
                ctx.fillRect(17, 16, 3, 3);
                
                // Beard
                ctx.fillStyle = '#bdc3c7';
                ctx.fillRect(10, 22, 12, 8);
                ctx.fillRect(12, 30, 8, 4);
                ctx.fillRect(14, 34, 4, 2);
                
                // Staff
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(26, 10, 3, 38);
                ctx.fillStyle = '#9b59b6';
                ctx.fillRect(24, 6, 7, 6);
            });
        }

        function createXPOrbTexture() {
            return createPixelTexture(16, 16, (ctx, w, h) => {
                // Outer glow
                ctx.fillStyle = '#9b59b6';
                ctx.beginPath();
                ctx.arc(8, 8, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner
                ctx.fillStyle = '#bb8fce';
                ctx.beginPath();
                ctx.arc(8, 8, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Shine
                ctx.fillStyle = '#fff';
                ctx.fillRect(5, 5, 3, 3);
            });
        }

        // ============================================
        // GAME STATE
        // ============================================
        let gameState = {
            player: {
                level: 1,
                xp: 0,
                health: 100,
                maxHealth: 100,
                position: new THREE.Vector3(0, 0, 0),
                rotation: 0
            },
            kills: 0,
            enemies: [],
            projectiles: [],
            xpOrbs: [],
            chunks: new Map(),
            isGameOver: false
        };

        // ============================================
        // THREE.JS SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x1a1a2e);

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x1a1a2e, CONFIG.fogNear, CONFIG.fogFar);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 8, 12);
        camera.lookAt(0, 0, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
        scene.add(ambientLight);

        const moonLight = new THREE.DirectionalLight(0x8888ff, 0.4);
        moonLight.position.set(10, 20, 10);
        scene.add(moonLight);

        // Ground
        const groundTexture = createGrassTexture();
        groundTexture.wrapS = THREE.RepeatWrapping;
        groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(50, 50);

        const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        scene.add(ground);

        // Player visual
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);

        // Player body (simple pixel character)
        function createPlayerTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Cloak
                ctx.fillStyle = '#2980b9';
                ctx.fillRect(8, 16, 16, 24);
                ctx.fillRect(6, 40, 20, 8);
                
                // Head
                ctx.fillStyle = '#fad7a0';
                ctx.fillRect(10, 6, 12, 12);
                
                // Hair
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(10, 4, 12, 6);
                ctx.fillRect(8, 6, 4, 4);
                
                // Eyes
                ctx.fillStyle = '#3498db';
                ctx.fillRect(12, 10, 3, 3);
                ctx.fillRect(17, 10, 3, 3);
                
                // Hood
                ctx.fillStyle = '#1a5276';
                ctx.fillRect(6, 2, 20, 6);
                ctx.fillRect(4, 6, 4, 12);
                ctx.fillRect(24, 6, 4, 12);
            });
        }

        const playerTexture = createPlayerTexture();
        const playerMaterial = new THREE.SpriteMaterial({ map: playerTexture });
        const playerSprite = new THREE.Sprite(playerMaterial);
        playerSprite.scale.set(3, 4.5, 1);
        playerSprite.position.y = 2;
        playerGroup.add(playerSprite);

        // ============================================
        // WORLD GENERATION
        // ============================================
        const treeTextures = [
            createTreeTexture(0),
            createTreeTexture(1),
            createTreeTexture(2),
            createTreeTexture(3)
        ];

        const rockTexture = createRockTexture();
        const mushroomTexture = createMushroomTexture();

        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function generateChunk(chunkX, chunkZ) {
            const key = `${chunkX},${chunkZ}`;
            if (gameState.chunks.has(key)) return;

            const chunkGroup = new THREE.Group();
            chunkGroup.userData = { chunkX, chunkZ };
            
            const baseX = chunkX * CONFIG.chunkSize;
            const baseZ = chunkZ * CONFIG.chunkSize;

            // Trees
            for (let i = 0; i < CONFIG.chunkSize * CONFIG.chunkSize * CONFIG.treeDensity; i++) {
                const seed = chunkX * 10000 + chunkZ * 100 + i;
                const rand1 = seededRandom(seed);
                const rand2 = seededRandom(seed + 1);
                const rand3 = seededRandom(seed + 2);
                
                const x = baseX + rand1 * CONFIG.chunkSize;
                const z = baseZ + rand2 * CONFIG.chunkSize;
                
                const treeType = Math.floor(rand3 * treeTextures.length);
                const treeMaterial = new THREE.SpriteMaterial({ 
                    map: treeTextures[treeType],
                    transparent: true
                });
                const tree = new THREE.Sprite(treeMaterial);
                tree.scale.set(4, 8, 1);
                tree.position.set(x, 3.5, z);
                chunkGroup.add(tree);
            }

            // Rocks
            for (let i = 0; i < 3; i++) {
                const seed = chunkX * 20000 + chunkZ * 200 + i;
                const rand1 = seededRandom(seed);
                const rand2 = seededRandom(seed + 1);
                
                const x = baseX + rand1 * CONFIG.chunkSize;
                const z = baseZ + rand2 * CONFIG.chunkSize;
                
                const rockMaterial = new THREE.SpriteMaterial({ 
                    map: rockTexture,
                    transparent: true
                });
                const rock = new THREE.Sprite(rockMaterial);
                rock.scale.set(1.5, 1.5, 1);
                rock.position.set(x, 0.3, z);
                chunkGroup.add(rock);
            }

            // Mushrooms
            for (let i = 0; i < 2; i++) {
                const seed = chunkX * 30000 + chunkZ * 300 + i;
                const rand1 = seededRandom(seed);
                const rand2 = seededRandom(seed + 1);
                
                const x = baseX + rand1 * CONFIG.chunkSize;
                const z = baseZ + rand2 * CONFIG.chunkSize;
                
                const mushMaterial = new THREE.SpriteMaterial({ 
                    map: mushroomTexture,
                    transparent: true
                });
                const mushroom = new THREE.Sprite(mushMaterial);
                mushroom.scale.set(1, 1.5, 1);
                mushroom.position.set(x, 0.5, z);
                chunkGroup.add(mushroom);
            }

            scene.add(chunkGroup);
            gameState.chunks.set(key, chunkGroup);
        }

        function updateChunks() {
            const playerChunkX = Math.floor(gameState.player.position.x / CONFIG.chunkSize);
            const playerChunkZ = Math.floor(gameState.player.position.z / CONFIG.chunkSize);
            const viewDist = Math.ceil(CONFIG.renderDistance / CONFIG.chunkSize);

            // Generate nearby chunks
            for (let x = -viewDist; x <= viewDist; x++) {
                for (let z = -viewDist; z <= viewDist; z++) {
                    generateChunk(playerChunkX + x, playerChunkZ + z);
                }
            }

            // Remove far chunks
            for (const [key, chunk] of gameState.chunks) {
                const [cx, cz] = key.split(',').map(Number);
                const dx = cx - playerChunkX;
                const dz = cz - playerChunkZ;
                if (Math.abs(dx) > viewDist + 1 || Math.abs(dz) > viewDist + 1) {
                    scene.remove(chunk);
                    gameState.chunks.delete(key);
                }
            }
        }

        // ============================================
        // ENEMY SYSTEM
        // ============================================
        const enemyTypes = [
            { name: 'slime', texture: createSlimeTexture, scale: [2.5, 2.5], speed: 0.03, healthMult: 0.8, damageMult: 0.7, xp: 10 },
            { name: 'goblin', texture: createGoblinTexture, scale: [2.5, 3.2], speed: 0.05, healthMult: 1, damageMult: 1, xp: 15 },
            { name: 'skeleton', texture: createSkeletonTexture, scale: [2.5, 4], speed: 0.04, healthMult: 1.2, damageMult: 1.1, xp: 20 },
            { name: 'ghost', texture: createGhostTexture, scale: [2.5, 3.2], speed: 0.045, healthMult: 0.9, damageMult: 1.3, xp: 25 },
            { name: 'bat', texture: createBatTexture, scale: [3, 2], speed: 0.06, healthMult: 0.6, damageMult: 0.8, xp: 12 },
            { name: 'wizard', texture: createWizardTexture, scale: [2.5, 4], speed: 0.03, healthMult: 1.5, damageMult: 1.5, xp: 35 }
        ];

        function spawnEnemy() {
            if (gameState.enemies.length >= CONFIG.enemyMaxCount || gameState.isGameOver) return;

            const angle = Math.random() * Math.PI * 2;
            const dist = CONFIG.enemySpawnRadius * (0.7 + Math.random() * 0.3);
            
            const x = gameState.player.position.x + Math.cos(angle) * dist;
            const z = gameState.player.position.z + Math.sin(angle) * dist;

            // Select enemy type based on level
            const maxTypeIndex = Math.min(Math.floor(gameState.player.level / 2), enemyTypes.length - 1);
            const typeIndex = Math.floor(Math.random() * (maxTypeIndex + 1));
            const type = enemyTypes[typeIndex];

            const texture = type.texture();
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(type.scale[0], type.scale[1], 1);
            sprite.position.set(x, type.scale[1] / 2, z);

            const enemy = {
                sprite,
                type,
                health: CONFIG.enemyBaseHealth * type.healthMult * (1 + gameState.player.level * 0.2),
                maxHealth: CONFIG.enemyBaseHealth * type.healthMult * (1 + gameState.player.level * 0.2),
                damage: CONFIG.enemyBaseDamage * type.damageMult * (1 + gameState.player.level * 0.15),
                attackCooldown: 0,
                hitFlash: 0
            };

            scene.add(sprite);
            gameState.enemies.push(enemy);
        }

        function updateEnemies(delta) {
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                // Move towards player
                const dx = gameState.player.position.x - enemy.sprite.position.x;
                const dz = gameState.player.position.z - enemy.sprite.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist > 1.5) {
                    enemy.sprite.position.x += (dx / dist) * enemy.type.speed;
                    enemy.sprite.position.z += (dz / dist) * enemy.type.speed;
                } else if (enemy.attackCooldown <= 0) {
                    // Attack player
                    takeDamage(enemy.damage);
                    enemy.attackCooldown = 60;
                }

                enemy.attackCooldown = Math.max(0, enemy.attackCooldown - 1);

                // Hit flash effect
                if (enemy.hitFlash > 0) {
                    enemy.hitFlash--;
                    enemy.sprite.material.color.setHex(enemy.hitFlash % 4 < 2 ? 0xffffff : 0xff0000);
                } else {
                    enemy.sprite.material.color.setHex(0xffffff);
                }

                // Remove if too far
                if (dist > CONFIG.renderDistance * 1.5) {
                    scene.remove(enemy.sprite);
                    gameState.enemies.splice(i, 1);
                }
            }
        }

        // ============================================
        // PROJECTILE SYSTEM
        // ============================================
        function getRainbowColor(level) {
            const hue = (level * 30) % 360;
            const color = new THREE.Color();
            color.setHSL(hue / 360, 1, 0.5);
            return color;
        }

        function createProjectileTexture(level) {
            const size = Math.min(16 + level * 2, 48);
            return createPixelTexture(size, size, (ctx, w, h) => {
                const color = getRainbowColor(level);
                const hex = '#' + color.getHexString();
                
                // Outer glow
                ctx.fillStyle = hex;
                ctx.beginPath();
                ctx.arc(w/2, h/2, w/2 - 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner bright
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(w/2, h/2, w/4, 0, Math.PI * 2);
                ctx.fill();
                
                // Sparkles
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const r = w/3;
                    const px = w/2 + Math.cos(angle) * r;
                    const py = h/2 + Math.sin(angle) * r;
                    ctx.fillRect(px - 1, py - 1, 2, 2);
                }
            });
        }

        function shootProjectile() {
            const level = gameState.player.level;
            const texture = createProjectileTexture(level);
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const size = 1 + level * 0.15;
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(size, size, 1);
            
            const startPos = gameState.player.position.clone();
            startPos.y = 1.5;
            sprite.position.copy(startPos);

            // Direction based on player rotation
            const direction = new THREE.Vector3(
                -Math.sin(gameState.player.rotation),
                0,
                -Math.cos(gameState.player.rotation)
            );

            const projectile = {
                sprite,
                direction,
                speed: CONFIG.projectileBaseSpeed + level * 0.02,
                damage: CONFIG.projectileBaseDamage * (1 + level * 0.25),
                life: 120
            };

            scene.add(sprite);
            gameState.projectiles.push(projectile);
        }

        function updateProjectiles() {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                
                proj.sprite.position.x += proj.direction.x * proj.speed;
                proj.sprite.position.z += proj.direction.z * proj.speed;
                proj.life--;

                // Rotate for effect
                proj.sprite.material.rotation += 0.1;

                // Check collision with enemies
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = proj.sprite.position.x - enemy.sprite.position.x;
                    const dz = proj.sprite.position.z - enemy.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < 1.5) {
                        enemy.health -= proj.damage;
                        enemy.hitFlash = 10;

                        if (enemy.health <= 0) {
                            // Drop XP
                            spawnXPOrb(enemy.sprite.position.clone(), enemy.type.xp);
                            scene.remove(enemy.sprite);
                            gameState.enemies.splice(j, 1);
                            gameState.kills++;
                            document.getElementById('kills').textContent = gameState.kills;
                        }

                        scene.remove(proj.sprite);
                        gameState.projectiles.splice(i, 1);
                        break;
                    }
                }

                if (proj.life <= 0) {
                    scene.remove(proj.sprite);
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        // ============================================
        // XP SYSTEM
        // ============================================
        const xpOrbTexture = createXPOrbTexture();

        function spawnXPOrb(position, amount) {
            const material = new THREE.SpriteMaterial({ 
                map: xpOrbTexture, 
                transparent: true 
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1, 1, 1);
            sprite.position.copy(position);
            sprite.position.y = 0.5;

            const orb = {
                sprite,
                amount,
                bobOffset: Math.random() * Math.PI * 2
            };

            scene.add(sprite);
            gameState.xpOrbs.push(orb);
        }

        function updateXPOrbs() {
            const time = Date.now() * 0.003;
            
            for (let i = gameState.xpOrbs.length - 1; i >= 0; i--) {
                const orb = gameState.xpOrbs[i];
                
                // Bob up and down
                orb.sprite.position.y = 0.5 + Math.sin(time + orb.bobOffset) * 0.2;

                // Check pickup
                const dx = gameState.player.position.x - orb.sprite.position.x;
                const dz = gameState.player.position.z - orb.sprite.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < 2) {
                    gainXP(orb.amount);
                    scene.remove(orb.sprite);
                    gameState.xpOrbs.splice(i, 1);
                }

                // Remove if too far
                if (dist > CONFIG.renderDistance * 2) {
                    scene.remove(orb.sprite);
                    gameState.xpOrbs.splice(i, 1);
                }
            }
        }

        function gainXP(amount) {
            gameState.player.xp += amount;
            const xpNeeded = CONFIG.baseXpToLevel * Math.pow(1.5, gameState.player.level - 1);
            
            if (gameState.player.xp >= xpNeeded) {
                gameState.player.xp -= xpNeeded;
                gameState.player.level++;
                gameState.player.maxHealth = 100 + gameState.player.level * 10;
                gameState.player.health = gameState.player.maxHealth;
                
                document.getElementById('levelNum').textContent = gameState.player.level;
                
                // Level up animation
                const levelUpEl = document.getElementById('levelUp');
                levelUpEl.style.animation = 'none';
                levelUpEl.offsetHeight; // Trigger reflow
                levelUpEl.style.animation = 'levelUpAnim 1.5s ease-out forwards';
            }

            updateUI();
        }

        // ============================================
        // PLAYER DAMAGE
        // ============================================
        function takeDamage(amount) {
            if (gameState.isGameOver) return;
            
            gameState.player.health -= amount;
            
            // Flash effect
            const flash = document.getElementById('damageFlash');
            flash.style.opacity = '1';
            setTimeout(() => flash.style.opacity = '0', 100);

            if (gameState.player.health <= 0) {
                gameOver();
            }

            updateUI();
        }

        function gameOver() {
            gameState.isGameOver = true;
            document.getElementById('finalLevel').textContent = gameState.player.level;
            document.getElementById('finalKills').textContent = gameState.kills;
            document.getElementById('gameOver').style.display = 'flex';
        }

        function restartGame() {
            // Clear enemies
            gameState.enemies.forEach(e => scene.remove(e.sprite));
            gameState.enemies = [];

            // Clear projectiles
            gameState.projectiles.forEach(p => scene.remove(p.sprite));
            gameState.projectiles = [];

            // Clear XP orbs
            gameState.xpOrbs.forEach(o => scene.remove(o.sprite));
            gameState.xpOrbs = [];

            // Reset player
            gameState.player = {
                level: 1,
                xp: 0,
                health: 100,
                maxHealth: 100,
                position: new THREE.Vector3(0, 0, 0),
                rotation: 0
            };
            gameState.kills = 0;
            gameState.isGameOver = false;

            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('levelNum').textContent = '1';
            document.getElementById('kills').textContent = '0';
            updateUI();
        }

        function updateUI() {
            const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';

            const xpNeeded = CONFIG.baseXpToLevel * Math.pow(1.5, gameState.player.level - 1);
            const xpPercent = (gameState.player.xp / xpNeeded) * 100;
            document.getElementById('xpFill').style.width = xpPercent + '%';
        }

        // ============================================
        // CONTROLS
        // ============================================
        const controls = {
            up: false,
            down: false,
            left: false,
            right: false
        };

        let touchStartX = 0;
        let touchStartY = 0;
        let isDragging = false;

        // D-Pad controls
        function setupDPad() {
            const buttons = {
                'dpad-up': 'up',
                'dpad-down': 'down',
                'dpad-left': 'left',
                'dpad-right': 'right'
            };

            for (const [id, dir] of Object.entries(buttons)) {
                const btn = document.getElementById(id);
                
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    controls[dir] = true;
                    btn.classList.add('active');
                });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    controls[dir] = false;
                    btn.classList.remove('active');
                });

                btn.addEventListener('touchcancel', () => {
                    controls[dir] = false;
                    btn.classList.remove('active');
                });

                // Mouse support for desktop
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    controls[dir] = true;
                    btn.classList.add('active');
                });

                btn.addEventListener('mouseup', () => {
                    controls[dir] = false;
                    btn.classList.remove('active');
                });

                btn.addEventListener('mouseleave', () => {
                    controls[dir] = false;
                    btn.classList.remove('active');
                });
            }
        }

        // Magic button
        function setupMagicButton() {
            const btn = document.getElementById('magicBtn');
            let canShoot = true;

            function shoot() {
                if (canShoot && !gameState.isGameOver) {
                    shootProjectile();
                    canShoot = false;
                    setTimeout(() => canShoot = true, 250);
                }
            }

            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                shoot();
            });

            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                shoot();
            });
        }

        // View swipe control
        function setupViewControl() {
            const viewArea = document.getElementById('viewArea');

            viewArea.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    isDragging = true;
                }
            });

            viewArea.addEventListener('touchmove', (e) => {
                if (isDragging && e.touches.length === 1) {
                    const dx = e.touches[0].clientX - touchStartX;
                    gameState.player.rotation += dx * 0.005;
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });

            viewArea.addEventListener('touchend', () => {
                isDragging = false;
            });

            // Mouse support
            viewArea.addEventListener('mousedown', (e) => {
                touchStartX = e.clientX;
                isDragging = true;
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - touchStartX;
                    gameState.player.rotation += dx * 0.005;
                    touchStartX = e.clientX;
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // Keyboard support
        function setupKeyboard() {
            document.addEventListener('keydown', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w': case 'arrowup': controls.up = true; break;
                    case 's': case 'arrowdown': controls.down = true; break;
                    case 'a': case 'arrowleft': controls.left = true; break;
                    case 'd': case 'arrowright': controls.right = true; break;
                    case ' ': shootProjectile(); break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w': case 'arrowup': controls.up = false; break;
                    case 's': case 'arrowdown': controls.down = false; break;
                    case 'a': case 'arrowleft': controls.left = false; break;
                    case 'd': case 'arrowright': controls.right = false; break;
                }
            });
        }

        // Restart button
        document.getElementById('restartBtn').addEventListener('click', restartGame);
        document.getElementById('restartBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            restartGame();
        });

        // ============================================
        // GAME LOOP
        // ============================================
        let lastSpawnTime = 0;

        function updatePlayer() {
            if (gameState.isGameOver) return;

            const moveSpeed = CONFIG.playerSpeed;
            let moved = false;

            if (controls.up) {
                gameState.player.position.x -= Math.sin(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z -= Math.cos(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.down) {
                gameState.player.position.x += Math.sin(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z += Math.cos(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.left) {
                gameState.player.position.x -= Math.cos(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z += Math.sin(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.right) {
                gameState.player.position.x += Math.cos(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z -= Math.sin(gameState.player.rotation) * moveSpeed;
                moved = true;
            }

            // Update player visual position
            playerGroup.position.copy(gameState.player.position);

            // Update camera
            const camDist = 12;
            const camHeight = 8;
            camera.position.x = gameState.player.position.x + Math.sin(gameState.player.rotation) * camDist;
            camera.position.z = gameState.player.position.z + Math.cos(gameState.player.rotation) * camDist;
            camera.position.y = camHeight;
            camera.lookAt(
                gameState.player.position.x,
                2,
                gameState.player.position.z
            );

            // Update ground position to follow player
            ground.position.x = gameState.player.position.x;
            ground.position.z = gameState.player.position.z;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!gameState.isGameOver) {
                updatePlayer();
                updateChunks();
                updateEnemies();
                updateProjectiles();
                updateXPOrbs();

                // Spawn enemies
                const now = Date.now();
                if (now - lastSpawnTime > CONFIG.enemySpawnInterval) {
                    spawnEnemy();
                    lastSpawnTime = now;
                }
            }

            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            setupDPad();
            setupMagicButton();
            setupViewControl();
            setupKeyboard();

            // Generate initial chunks
            updateChunks();

            // Start animation
            animate();

            // Start spawning enemies
            setTimeout(() => {
                for (let i = 0; i < 3; i++) {
                    spawnEnemy();
                }
            }, 1000);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start game
        init();
    </script>
</body>
</html>
