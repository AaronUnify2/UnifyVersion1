<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warren Buffett's Bubble Pop Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a, #1a1a2e, #16213e);
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 100vw;
            background: linear-gradient(135deg, #0a0a1a, #1a1a2e);
        }

        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: linear-gradient(90deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 40, 0.9));
            border-bottom: 2px solid #333;
            font-size: 14px;
            min-height: 45px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .books { color: #64b5f6; }
        .year { color: #ff9800; }
        .cash { color: #4caf50; }
        .portfolio { color: #9c27b0; }

        .game-area {
            flex: 1;
            position: relative;
            background: linear-gradient(180deg, #2a2a3e 0%, #1a1a2e 100%);
            overflow: hidden;
            border: 4px solid #444;
            border-radius: 8px;
            margin: 8px 12px;
            box-shadow: 
                inset 0 0 20px rgba(0, 0, 0, 0.5),
                0 4px 20px rgba(0, 0, 0, 0.3);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            border-radius: 4px;
        }

        .controls-area {
            background: linear-gradient(90deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 40, 0.9));
            padding: 10px 15px;
            border-top: 2px solid #333;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
        }

        .main-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .sugar-bar {
            width: 130px;
            height: 22px;
            background: linear-gradient(45deg, #333, #444);
            border-radius: 11px;
            overflow: hidden;
            position: relative;
            border: 2px solid #555;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .sugar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff5722, #ff9800, #ffc107);
            transition: width 0.3s ease;
            border-radius: 9px;
            box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.3);
        }

        .next-bubbles {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .next-bubble {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            border: 2px solid #666;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .shots-info {
            color: #ffa726;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .market-status {
            text-align: center;
            margin-bottom: 10px;
            font-size: 13px;
            color: #ccc;
        }

        .market-state {
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .market-normal { background: linear-gradient(45deg, #2196f3, #1976d2); color: white; }
        .market-bull { background: linear-gradient(45deg, #4caf50, #388e3c); color: white; }
        .market-bear { background: linear-gradient(45deg, #f44336, #d32f2f); color: white; }

        .powerups {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 10px;
        }

        .powerup-btn {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            border: 2px solid #666;
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            color: white;
            font-size: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .powerup-btn:hover {
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            border-color: #999;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .powerup-count {
            position: absolute;
            top: -6px;
            right: -6px;
            background: linear-gradient(45deg, #ff5722, #d84315);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #fff;
            font-weight: bold;
        }

        .quote-area {
            background: linear-gradient(90deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
            padding: 15px 20px;
            border-top: 2px solid #333;
            min-height: 90px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            border: 4px solid #444;
            border-radius: 8px;
            margin: 8px 12px 12px 12px;
            box-shadow: 
                inset 0 0 15px rgba(0, 0, 0, 0.5),
                0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .quote-text {
            font-style: italic;
            font-size: 15px;
            line-height: 1.5;
            margin-bottom: 8px;
            color: #e0e0e0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .quote-author {
            font-size: 12px;
            color: #ffa726;
            text-align: right;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        /* Store UI Styles */
        .store-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
            display: none;
        }

        .store-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .store-section {
            margin-bottom: 25px;
        }

        .store-item {
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 2px solid #333;
            border-radius: 10px;
            padding: 18px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .store-item:hover {
            border-color: #555;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .store-item.disabled {
            opacity: 0.5;
        }

        .buy-btn {
            background: linear-gradient(45deg, #4caf50, #388e3c);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .buy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
        }

        .buy-btn:disabled {
            background: linear-gradient(45deg, #666, #555);
            cursor: not-allowed;
            transform: none;
        }

        .continue-btn {
            background: linear-gradient(45deg, #ff9800, #f57c00);
            color: white;
            border: none;
            padding: 18px 35px;
            border-radius: 12px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            font-weight: bold;
            display: block;
            margin: 35px auto 0;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }

        .continue-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
        }

        /* Professional enhancements */
        .level-complete-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .level-complete-overlay.show {
            opacity: 1;
        }

        .completion-message {
            background: linear-gradient(45deg, #4caf50, #388e3c);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .completion-message.show {
            transform: scale(1);
        }

        /* Responsive improvements */
        @media (max-width: 480px) {
            .stats-header {
                padding: 8px 10px;
                font-size: 12px;
            }
            
            .quote-text {
                font-size: 13px;
            }
            
            .powerup-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Stats Header -->
        <div class="stats-header">
            <div class="stat-item books">📚 <span id="booksCount">5</span></div>
            <div class="stat-item year">YEAR: <span id="currentYear">1960</span></div>
            <div class="stat-item cash">$<span id="cashAmount">0</span></div>
            <div class="stat-item portfolio">$<span id="portfolioValue">0</span></div>
        </div>

        <!-- Game Area -->
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
        </div>

        <!-- Controls -->
        <div class="controls-area">
            <div class="main-controls">
                <div class="sugar-bar">
                    <div class="sugar-fill" id="sugarFill" style="width: 100%"></div>
                </div>
                
                <div class="next-bubbles">
                    <span style="font-size: 13px; margin-right: 10px; font-weight: bold;">Next:</span>
                    <div class="next-bubble" id="nextBubble1"></div>
                    <div class="next-bubble" id="nextBubble2"></div>
                    <div class="next-bubble" id="nextBubble3"></div>
                </div>
                
                <div class="shots-info">Shots: <span id="shotsRemaining">3</span></div>
            </div>

            <div class="market-status">
                Market: <span class="market-state market-normal" id="marketState">NORMAL</span>
            </div>

            <div class="powerups">
                <div class="powerup-btn" id="lollapalooza" title="Lollapalooza Effect">💥<span class="powerup-count">0</span></div>
                <div class="powerup-btn" id="grahamNets" title="Graham's Nets">📚<span class="powerup-count">0</span></div>
                <div class="powerup-btn" id="coke" title="Coke Refresher">🥤<span class="powerup-count">0</span></div>
            </div>
        </div>

        <!-- Quote Area -->
        <div class="quote-area">
            <div class="quote-text" id="quoteText">Welcome to 1960! Start building your capital for the journey ahead. Aim carefully - you only have 3 shots per round!</div>
            <div class="quote-author" id="quoteAuthor">- Warren Buffett</div>
        </div>
    </div>

    <!-- Store Overlay -->
    <div class="store-overlay" id="storeOverlay">
        <div class="store-header">
            <h2 style="color: #ff9800; margin: 0;">WARREN'S STORE</h2>
            <p style="margin: 5px 0; color: #ccc;" id="storeStats">Cash: $0 | Books: 📚5</p>
        </div>
        
        <div class="store-section">
            <h3 style="color: #f44336; margin: 0 0 10px 0;">💥 POWERUPS</h3>
            <div id="powerupsSection"></div>
        </div>
        
        <div class="store-section">
            <h3 style="color: #2196f3; margin: 0 0 10px 0;">📚 BOOKS</h3>
            <div id="booksSection"></div>
        </div>
        
        <div class="store-section">
            <h3 style="color: #4caf50; margin: 0 0 10px 0;">🏢 BUSINESS ACQUISITIONS</h3>
            <div id="subsidiariesSection"></div>
        </div>
        
        <button class="continue-btn" onclick="game.goToInvestments()">CONTINUE TO INVESTMENTS</button>
    </div>

    <!-- Investment Board Overlay -->
    <div class="store-overlay" id="investmentOverlay">
        <div class="store-header">
            <h2 style="color: #ff9800; margin: 0;">INVESTMENT BOARD</h2>
            <p style="margin: 5px 0; color: #ccc;" id="investmentStats">Cash: $0 | Portfolio: $0</p>
        </div>
        
        <div class="store-section">
            <h3 style="color: #4caf50; margin: 0 0 10px 0;">📈 AVAILABLE STOCKS</h3>
            <div id="stocksSection"></div>
        </div>
        
        <div class="store-section">
            <h3 style="color: #2196f3; margin: 0 0 10px 0;">💼 YOUR PORTFOLIO</h3>
            <div id="portfolioDisplay"></div>
        </div>
        
        <button class="continue-btn" onclick="game.closeInvestments()">START NEXT YEAR</button>
    </div>

    <script>
        class BubbleGame {
            constructor() {
                console.log('Initializing Bubble Game...');
                
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                if (!this.canvas || !this.ctx) {
                    console.error('Canvas not found or context failed');
                    return;
                }
                
                this.resizeCanvas();
                console.log('Canvas initialized:', this.canvas.width, 'x', this.canvas.height);
                
                // Game state
                this.year = 1960;
                this.sugar = 30;
                this.maxSugar = 30;
                this.cash = 0;
                this.books = 5;
                this.baseShots = 3; // Base shots before bonuses
                this.shots = 3;
                this.marketState = 'normal';
                this.gameState = 'playing';
                this.levelComplete = false;
                
                // Investment system
                this.portfolio = {};
                
                // Bubble colors based on year
                this.bubbleColors = ['#f44336', '#2196f3', '#4caf50'];
                this.currentColors = 3;
                
                // Game grid
                this.gridWidth = 25;
                this.maxRows = 6;
                this.bubbleRadius = 12;
                this.bubbleSpacing = this.bubbleRadius * 2 + 2;
                
                // Game objects
                this.bubbleGrid = [];
                this.cannonBubbles = [];
                this.collectibles = [];
                this.powerups = {
                    lollapalooza: 0,
                    grahamNets: 0,
                    coke: 0
                };
                this.activePowerup = null;
                
                // Store system
                this.ownedBooks = [];
                this.ownedSubsidiaries = [];
                this.initializeStoreData();
                this.initializeStockData();
                
                // Cannon
                this.cannonX = this.canvas.width / 2;
                this.cannonY = this.canvas.height - 100;
                this.cannonAngle = -Math.PI / 2;
                this.nextBubbles = this.generateNextBubbles();
                this.isDragging = false;
                
                // Drop rates
                this.dropRates = {
                    coin: 0.3,
                    sweet: 0.15,
                    book: 0.05
                };
                
                // Market data
                this.marketData = {
                    1960: 'normal', 1961: 'normal', 1962: 'normal', 1963: 'normal',
                    1974: 'bear', 1975: 'bull', 1983: 'bull', 1985: 'bull',
                    1986: 'bull', 1989: 'bull', 1991: 'bull', 1995: 'bull',
                    1996: 'bull', 1997: 'bull', 1999: 'bull', 2003: 'bull',
                    2008: 'bear', 2013: 'bull', 2017: 'bull', 2019: 'bull'
                };
                
                this.buffettQuotes = [
                    "Rule No. 1: Never lose money. Rule No. 2: Never forget rule No. 1.",
                    "It's far better to buy a wonderful company at a fair price than a fair company at a wonderful price.",
                    "Price is what you pay. Value is what you get.",
                    "Risk comes from not knowing what you're doing.",
                    "The stock market is designed to transfer money from the Active to the Patient.",
                    "Time is the friend of the wonderful company, the enemy of the mediocre.",
                    "Our favorite holding period is forever.",
                    "Be fearful when others are greedy and greedy when others are fearful.",
                    "Someone's sitting in the shade today because someone planted a tree a long time ago.",
                    "The most important investment you can make is in yourself.",
                    "Opportunities come infrequently. When it rains gold, put out the bucket, not the thimble."
                ];
                
                this.setupEventListeners();
                this.calculatePerkBonuses(); // Calculate initial bonuses
                this.initializeLevel();
                this.updateUI();
                
                console.log('Starting game loop...');
                this.gameLoop();
                console.log('Bubble Game initialized successfully!');
            }
            
            // New method to calculate all perk bonuses
            calculatePerkBonuses() {
                // Start with base values
                this.shots = this.baseShots;
                this.maxSugar = 30; // Reset to base
                
                // Apply book bonuses
                for (const book of this.storeData.books) {
                    if (book.owned) {
                        if (book.unlocks.includes('+1 starting bubble')) {
                            this.shots += 1;
                        }
                        if (book.unlocks.includes('+20 sugar capacity')) {
                            this.maxSugar += 20;
                        }
                    }
                }
                
                // Apply subsidiary bonuses
                for (const subsidiary of this.storeData.subsidiaries) {
                    if (subsidiary.owned) {
                        if (subsidiary.perk.includes('+1 starting bubble')) {
                            this.shots += 1;
                        }
                        if (subsidiary.perk.includes('+10 sugar capacity')) {
                            this.maxSugar += 10;
                        }
                    }
                }
                
                console.log('Total shots after bonuses:', this.shots);
                console.log('Max sugar after bonuses:', this.maxSugar);
            }
            
            initializeStockData() {
                this.stockData = {
                    'KO': {
                        name: 'Coca-Cola',
                        startYear: 1963,
                        prices: {
                            1963: 0.06, 1964: 0.08, 1965: 0.09, 1966: 0.10, 1967: 0.14, 1968: 0.16, 1969: 0.18, 1970: 0.19,
                            1971: 0.27, 1972: 0.34, 1973: 0.29, 1974: 0.13, 1975: 0.20, 1976: 0.20, 1977: 0.19, 1978: 0.24,
                            1979: 0.20, 1980: 0.20, 1981: 0.23, 1982: 0.36, 1983: 0.40, 1984: 0.48, 1985: 0.68, 1986: 0.94,
                            1987: 0.98, 1988: 1.18, 1989: 2.08, 1990: 2.56, 1991: 4.49, 1992: 4.74, 1993: 5.14, 1994: 6.03,
                            1995: 8.82, 1996: 12.64, 1997: 16.16, 1998: 16.37, 1999: 14.38, 2000: 15.24, 2001: 11.97, 2002: 11.31,
                            2003: 13.36, 2004: 11.21, 2005: 11.13, 2006: 13.70, 2007: 17.88, 2008: 13.57, 2009: 17.68, 2010: 21.04,
                            2011: 23.03, 2012: 24.54, 2013: 28.77, 2014: 30.28, 2015: 31.84, 2016: 31.72, 2017: 36.29, 2018: 38.74,
                            2019: 46.72, 2020: 47.88, 2021: 53.32, 2022: 58.98, 2023: 56.36, 2024: 61.37, 2025: 68.84
                        }
                    },
                    'DIS': {
                        name: 'Disney',
                        startYear: 1963,
                        prices: {
                            1963: 0.0667, 1964: 0.0768, 1965: 0.1000, 1966: 0.1338, 1967: 0.1866, 1968: 0.2870, 1969: 0.4525, 1970: 0.4774,
                            1971: 0.9287, 1972: 1.5990, 1973: 0.6382, 1974: 0.2887, 1975: 0.6737, 1976: 0.6382, 1977: 0.5403, 1978: 0.5420,
                            1979: 0.6062, 1980: 0.6923, 1981: 0.7057, 1982: 0.8725, 1983: 0.7416, 1984: 0.8596, 1985: 1.6429, 1986: 2.5311,
                            1987: 3.4902, 1988: 3.8974, 1989: 6.6733, 1990: 6.0778, 1991: 6.8976, 1992: 10.4214, 1993: 10.3906, 1994: 11.2914,
                            1995: 14.5687, 1996: 17.3528, 1997: 24.7930, 1998: 22.6800, 1999: 22.3554, 2000: 22.2690, 2001: 16.1144, 2002: 12.8429,
                            2003: 18.5453, 2004: 22.2960, 2005: 19.4287, 2006: 28.0288, 2007: 27.0516, 2008: 19.2999, 2009: 27.7479, 2010: 32.6266,
                            2011: 33.1657, 2012: 44.7114, 2013: 69.4541, 2014: 86.7151, 2015: 97.9273, 2016: 98.5853, 2017: 103.2780, 2018: 107.0040,
                            2019: 142.8650, 2020: 178.9690, 2021: 153.0000, 2022: 85.8198, 2023: 89.4789, 2024: 111.3500, 2025: 92.49
                        }
                    },
                    'AAPL': {
                        name: 'Apple',
                        startYear: 1981,
                        prices: {
                            1981: 0.0760, 1982: 0.1026, 1983: 0.0837, 1984: 0.1000, 1985: 0.0755, 1986: 0.1391, 1987: 0.2899, 1988: 0.2802,
                            1989: 0.2478, 1990: 0.3060, 1991: 0.4049, 1992: 0.4330, 1993: 0.2146, 1994: 0.2901, 1995: 0.2398, 1996: 0.1571,
                            1997: 0.0988, 1998: 0.3080, 1999: 0.7735, 2000: 0.2238, 2001: 0.3295, 2002: 0.2156, 2003: 0.3215, 2004: 0.9690,
                            2005: 2.1634, 2006: 2.5531, 2007: 5.9610, 2008: 2.5685, 2009: 6.3417, 2010: 9.7070, 2011: 12.1879, 2012: 16.1572,
                            2013: 17.4609, 2014: 24.5540, 2015: 23.8140, 2016: 26.7861, 2017: 39.7678, 2018: 37.6242, 2019: 71.0940, 2020: 129.6090,
                            2021: 174.5160, 2022: 128.4370, 2023: 191.3810, 2024: 250.1450, 2025: 202.52
                        }
                    },
                    'BRK.A': {
                        name: 'Berkshire Hathaway',
                        startYear: 1981,
                        prices: {
                            1981: 560.00, 1982: 775.00, 1983: 1310.00, 1984: 1275.00, 1985: 2470.00, 1986: 2820.00, 1987: 2950.00, 1988: 4700.00,
                            1989: 8675.00, 1990: 6675.00, 1991: 9050.00, 1992: 11750.00, 1993: 16325.00, 1994: 20400.00, 1995: 32100.00, 1996: 34100.00,
                            1997: 46000.00, 1998: 70000.00, 1999: 56100.00, 2000: 71000.00, 2001: 75600.00, 2002: 72750.00, 2003: 84250.00, 2004: 87900.00,
                            2005: 88620.00, 2006: 109990.00, 2007: 141600.00, 2008: 96600.00, 2009: 99200.00, 2010: 120450.00, 2011: 114755.00, 2012: 134060.00,
                            2013: 177900.00, 2014: 226000.00, 2015: 197800.00, 2016: 244121.00, 2017: 297600.00, 2018: 306000.00, 2019: 339590.00, 2020: 347815.00,
                            2021: 450662.00, 2022: 468711.00, 2023: 542625.00, 2024: 680920.00, 2025: 795000.00
                        }
                    },
                    'BAC': {
                        name: 'Bank of America',
                        startYear: 1985,
                        prices: {
                            1985: 1.8605, 1986: 1.8245, 1987: 1.5195, 1988: 2.4973, 1989: 4.3485, 1990: 2.2464, 1991: 4.1450, 1992: 5.4298,
                            1993: 5.3525, 1994: 5.1157, 1995: 8.1748, 1996: 11.8058, 1997: 15.0259, 1998: 15.2195, 1999: 13.0888, 2000: 12.5007,
                            2001: 17.8383, 2002: 20.4333, 2003: 24.5517, 2004: 29.8364, 2005: 30.5533, 2006: 36.8783, 2007: 29.9343, 2008: 11.0479,
                            2009: 11.8743, 2010: 10.5495, 2011: 4.4180, 2012: 9.2700, 2013: 12.4692, 2014: 14.4312, 2015: 13.7420, 2016: 18.3275,
                            2017: 24.8677, 2018: 21.1416, 2019: 30.9070, 2020: 27.3116, 2021: 40.8606, 2022: 31.1264, 2023: 32.6285, 2024: 43.6744,
                            2025: 43.20
                        }
                    }
                };
            }
            
            initializeStoreData() {
                this.storeData = {
                    powerups: [
                        { name: "Coke", effect: "Restore 30 sugar", price: 50, currency: "cash" },
                        { name: "Lollapalooza", effect: "Destroys 3x3 area", price: 200, currency: "cash" },
                        { name: "Grahams Nets", effect: "Turns bubbles silver", price: 300, currency: "cash" }
                    ],
                    books: [
                        { name: "The Intelligent Investor", price: 5, currency: "books", unlocks: "+1 starting bubble", owned: false },
                        { name: "Poor Charlies Almanack", price: 10, currency: "books", unlocks: "Sees Candies unlock", owned: false },
                        { name: "Common Stocks and Uncommon Profits", price: 15, currency: "books", unlocks: "+1 starting bubble", owned: false },
                        { name: "The Little Book of Common Sense Investing", price: 20, currency: "books", unlocks: "+1 starting bubble", owned: false },
                        { name: "Essays of Warren Buffett", price: 25, currency: "books", unlocks: "+1 starting bubble", owned: false },
                        { name: "Securities Analysis", price: 30, currency: "books", unlocks: "+1 starting bubble", owned: false },
                    ],
                    subsidiaries: [
                        { name: "Sees Candies", price: 2500, currency: "cash", income: 150, perk: "+10 sugar capacity", year: 1963, owned: false },
                        { name: "GEICO", price: 10000, currency: "cash", income: 1500, perk: "+1 starting bubble", year: 1968, owned: false },
                        { name: "Dairy Queen", price: 150000, currency: "cash", income: 30000, perk: "+50% trajectory line length", year: 1975, owned: false },
                        { name: "Nebraska Furniture Mart", price: 250000, currency: "cash", income: 45000, perk: "+1 starting bubble", year: 1980, owned: false },
                        { name: "Fruit of the Loom", price: 750000, currency: "cash", income: 50000, perk: "+1 starting bubble", year: 1987, owned: false },
                        { name: "Gillette", price: 1000000, currency: "cash", income: 65000, perk: "+10 sugar capacity", year: 1990, owned: false },
                        { name: "Duracell", price: 250000, currency: "cash", income: 150, perk: "+10 sugar capacity", year: 1995, owned: false },
                        { name: "BNSF Railway", price: 8000000, currency: "cash", income: 4000000, perk: "+1 starting bubble", year: 2005, owned: false }
                    ]
                };
            }

            
            resizeCanvas() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.cannonX = this.canvas.width / 2;
                this.cannonY = this.canvas.height - 100;
            }
            
            updateColorProgression() {
                if (this.year >= 2000 && this.currentColors < 5) {
                    this.bubbleColors = ['#f44336', '#2196f3', '#4caf50', '#ff9800', '#9c27b0'];
                    this.currentColors = 5;
                } else if (this.year >= 1980 && this.currentColors < 4) {
                    this.bubbleColors = ['#f44336', '#2196f3', '#4caf50', '#ff9800'];
                    this.currentColors = 4;
                }
            }
            
            updateMarketConditions() {
                const newState = this.marketData[this.year] || 'normal';
                if (newState !== this.marketState) {
                    this.marketState = newState;
                    this.updateMarketUI();
                    this.setRowsByMarket();
                }
            }
            
            setRowsByMarket() {
                switch(this.marketState) {
                    case 'bull':
                        this.maxRows = Math.floor(Math.random() * 2) + 7;
                        break;
                    case 'bear':
                        this.maxRows = Math.floor(Math.random() * 2) + 3;
                        break;
                    default:
                        this.maxRows = Math.floor(Math.random() * 2) + 5;
                }
            }
            
            updateMarketUI() {
                const stateElement = document.getElementById('marketState');
                stateElement.textContent = this.marketState.toUpperCase();
                stateElement.className = 'market-state market-' + this.marketState;
            }
            
            generateBubbleFormation() {
                this.bubbleGrid = [];
                
                for (let row = 0; row < this.maxRows; row++) {
                    this.bubbleGrid[row] = [];
                    const isEvenRow = row % 2 === 0;
                    const bubblesInRow = isEvenRow ? this.gridWidth : this.gridWidth - 1;
                    const clusterProbability = Math.max(0.1, 1 - (row / this.maxRows));
                    
                    for (let col = 0; col < bubblesInRow; col++) {
                        if (Math.random() < 0.85) {
                            let color;
                            
                            if (row < this.maxRows * 0.6 && Math.random() < clusterProbability) {
                                let adjacentColor = null;
                                if (col > 0 && this.bubbleGrid[row][col-1]) {
                                    adjacentColor = this.bubbleGrid[row][col-1].color;
                                } else if (row > 0 && this.bubbleGrid[row-1]) {
                                    const adjacentCol = isEvenRow ? col : col + 1;
                                    if (this.bubbleGrid[row-1][adjacentCol]) {
                                        adjacentColor = this.bubbleGrid[row-1][adjacentCol].color;
                                    }
                                }
                                color = adjacentColor || this.bubbleColors[Math.floor(Math.random() * this.currentColors)];
                            } else {
                                color = this.bubbleColors[Math.floor(Math.random() * this.currentColors)];
                            }
                            
                            this.bubbleGrid[row][col] = {
                                color: color,
                                x: this.getBubbleX(row, col),
                                y: this.getBubbleY(row)
                            };
                        }
                    }
                }
            }
            
            getBubbleX(row, col) {
                const isEvenRow = row % 2 === 0;
                const offset = isEvenRow ? 0 : this.bubbleSpacing / 2;
                const startX = (this.canvas.width - (this.gridWidth * this.bubbleSpacing)) / 2;
                return startX + offset + col * this.bubbleSpacing + this.bubbleRadius;
            }
            
            getBubbleY(row) {
                return 50 + row * (this.bubbleSpacing * 0.87);
            }
            
            generateNextBubbles() {
                const bubbles = [];
                for (let i = 0; i < 3; i++) {
                    bubbles.push(this.bubbleColors[Math.floor(Math.random() * this.currentColors)]);
                }
                return bubbles;
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                const lollapaloozaBtn = document.getElementById('lollapalooza');
                const grahamNetsBtn = document.getElementById('grahamNets');
                const cokeBtn = document.getElementById('coke');
                
                if (lollapaloozaBtn) lollapaloozaBtn.addEventListener('click', () => this.activatePowerup('lollapalooza'));
                if (grahamNetsBtn) grahamNetsBtn.addEventListener('click', () => this.activatePowerup('grahamNets'));
                if (cokeBtn) cokeBtn.addEventListener('click', () => this.activatePowerup('coke'));
                
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            activatePowerup(type) {
                if (this.powerups[type] > 0) {
                    if (type === 'coke') {
                        this.sugar = Math.min(this.maxSugar, this.sugar + 30);
                        this.powerups[type]--;
                        this.updateUI();
                    } else {
                        this.activePowerup = type;
                        this.powerups[type]--;
                        this.updateUI();
                    }
                }
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                this.startTouchX = touch.clientX - rect.left;
                this.startTouchY = touch.clientY - rect.top;
                this.isDragging = true;
            }
            
            handleTouchMove(e) {
                if (!this.isDragging) return;
                e.preventDefault();
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const currentX = touch.clientX - rect.left;
                const currentY = touch.clientY - rect.top;
                this.updateCannonAngle(currentX, currentY);
            }
            
            handleTouchEnd(e) {
                if (this.isDragging) {
                    e.preventDefault();
                    this.fireBubble();
                    this.isDragging = false;
                }
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.startTouchX = e.clientX - rect.left;
                this.startTouchY = e.clientY - rect.top;
                this.isDragging = true;
            }
            
            handleMouseMove(e) {
                if (!this.isDragging) return;
                const rect = this.canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                this.updateCannonAngle(currentX, currentY);
            }
            
            handleMouseUp(e) {
                if (this.isDragging) {
                    this.fireBubble();
                    this.isDragging = false;
                }
            }
            
            updateCannonAngle(x, y) {
                const dx = x - this.cannonX;
                const dy = y - this.cannonY;
                let angle = Math.atan2(dy, dx);
                
                const minAngle = -Math.PI + 0.02;
                const maxAngle = -0.02;
                angle = Math.max(minAngle, Math.min(maxAngle, angle));
                
                this.cannonAngle = angle;
            }
            
            fireBubble() {
                if (this.shots <= 0 || this.nextBubbles.length === 0) return;
                
                const color = this.nextBubbles.shift();
                this.nextBubbles.push(this.bubbleColors[Math.floor(Math.random() * this.currentColors)]);
                
                const speed = 8;
                const newBubble = {
                    x: this.cannonX,
                    y: this.cannonY,
                    vx: Math.cos(this.cannonAngle) * speed,
                    vy: Math.sin(this.cannonAngle) * speed,
                    color: color,
                    radius: this.bubbleRadius,
                    powerup: this.activePowerup
                };
                
                this.cannonBubbles.push(newBubble);
                this.activePowerup = null;
                this.shots--;
                this.updateUI();
            }
            
            update() {
                if (this.gameState !== 'playing') return;
                
                // Update cannon bubbles
                for (let i = this.cannonBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.cannonBubbles[i];
                    bubble.x += bubble.vx;
                    bubble.y += bubble.vy;
                    
                    if (bubble.x - bubble.radius <= 0 || bubble.x + bubble.radius >= this.canvas.width) {
                        bubble.vx = -bubble.vx;
                        bubble.x = Math.max(bubble.radius, Math.min(this.canvas.width - bubble.radius, bubble.x));
                    }
                    
                    if (this.checkBubbleCollision(bubble)) {
                        this.cannonBubbles.splice(i, 1);
                        continue;
                    }
                    
                    if (bubble.y < -50 || bubble.y > this.canvas.height + 50) {
                        this.cannonBubbles.splice(i, 1);
                    }
                }
                
                // Update collectibles
                for (let i = this.collectibles.length - 1; i >= 0; i--) {
                    const collectible = this.collectibles[i];
                    
                    collectible.x += collectible.vx;
                    collectible.y += collectible.vy;
                    collectible.vy += collectible.gravity;
                    
                    const dx = collectible.x - this.cannonX;
                    const dy = collectible.y - this.cannonY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 40) {
                        this.collectItem(collectible);
                        this.collectibles.splice(i, 1);
                        continue;
                    }
                    
                    if (collectible.y >= this.canvas.height - 20) {
                        this.collectItem(collectible);
                        this.collectibles.splice(i, 1);
                        continue;
                    }
                    
                    if (collectible.y > this.canvas.height + 100) {
                        this.collectibles.splice(i, 1);
                    }
                }
                
                this.sugar = Math.max(0, this.sugar - 0.02);
                
                // Updated end game logic
                const boardCleared = this.isBoardClear();
                const noAmmoAndNothingMoving = this.shots <= 0 && this.collectibles.length === 0 && this.cannonBubbles.length === 0;
                const outOfSugar = this.sugar <= 0;
                
                if (boardCleared && !this.levelComplete) {
                    this.levelComplete = true;
                    this.cash += 100;
                    setTimeout(() => this.endLevel(), 1000);
                } else if ((noAmmoAndNothingMoving || outOfSugar) && !this.levelComplete) {
                    this.endLevel();
                }
            }
            
            collectItem(collectible) {
                switch(collectible.type) {
                    case 'coin':
                        this.cash += 25;
                        break;
                    case 'sweet':
                        this.sugar = Math.min(this.maxSugar, this.sugar + 10);
                        break;
                    case 'book':
                        this.books += 1;
                        break;
                }
                this.updateUI();
            }
            
            isBoardClear() {
                for (let row = 0; row < this.bubbleGrid.length; row++) {
                    for (let col = 0; col < this.bubbleGrid[row].length; col++) {
                        if (this.bubbleGrid[row][col]) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            checkBubbleCollision(cannonBubble) {
                let closestCollision = null;
                let closestDistance = Infinity;
                
                for (let row = 0; row < this.bubbleGrid.length; row++) {
                    for (let col = 0; col < this.bubbleGrid[row].length; col++) {
                        if (this.bubbleGrid[row][col]) {
                            const bubble = this.bubbleGrid[row][col];
                            const dx = cannonBubble.x - bubble.x;
                            const dy = cannonBubble.y - bubble.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < this.bubbleRadius * 2) {
                                const trajectoryDistance = Math.sqrt(
                                    (cannonBubble.x - this.cannonX) * (cannonBubble.x - this.cannonX) + 
                                    (cannonBubble.y - this.cannonY) * (cannonBubble.y - this.cannonY)
                                );
                                
                                if (trajectoryDistance < closestDistance) {
                                    closestDistance = trajectoryDistance;
                                    closestCollision = { x: bubble.x, y: bubble.y };
                                }
                            }
                        }
                    }
                }
                
                if (closestCollision) {
                    return this.attachBubbleNearCollision(cannonBubble, closestCollision.x, closestCollision.y);
                }
                
                const topBubbleY = this.getBubbleY(0);
                if (cannonBubble.y <= topBubbleY - this.bubbleRadius) {
                    return this.attachBubbleToGrid(cannonBubble);
                }
                
                return false;
            }
            
            attachBubbleNearCollision(cannonBubble, collisionX, collisionY) {
                if (cannonBubble.powerup) {
                    if (cannonBubble.powerup === 'lollapalooza') {
                        this.explodeBubbles(collisionX, collisionY);
                        return true;
                    } else if (cannonBubble.powerup === 'grahamNets') {
                        this.convertBubbles(collisionX, collisionY);
                    }
                }
                
                let bestRow = -1, bestCol = -1;
                let minDistance = Infinity;
                
                for (let row = 0; row < this.maxRows; row++) {
                    const isEvenRow = row % 2 === 0;
                    const bubblesInRow = isEvenRow ? this.gridWidth : this.gridWidth - 1;
                    
                    for (let col = 0; col < bubblesInRow; col++) {
                        if (!this.bubbleGrid[row]) this.bubbleGrid[row] = [];
                        
                        if (!this.bubbleGrid[row][col]) {
                            const gridX = this.getBubbleX(row, col);
                            const gridY = this.getBubbleY(row);
                            
                            const dx = gridX - cannonBubble.x;
                            const dy = gridY - cannonBubble.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                                bestRow = row;
                                bestCol = col;
                            }
                        }
                    }
                }
                
                if (bestRow !== -1 && bestCol !== -1) {
                    this.bubbleGrid[bestRow][bestCol] = {
                        color: cannonBubble.powerup === 'grahamNets' ? '#c0c0c0' : cannonBubble.color,
                        x: this.getBubbleX(bestRow, bestCol),
                        y: this.getBubbleY(bestRow)
                    };
                    
                    this.processMatches(bestRow, bestCol);
                    return true;
                }
                
                return false;
            }
            
            attachBubbleToGrid(cannonBubble) {
                if (cannonBubble.powerup) {
                    if (cannonBubble.powerup === 'lollapalooza') {
                        this.explodeBubbles(cannonBubble.x, this.getBubbleY(0));
                        return true;
                    } else if (cannonBubble.powerup === 'grahamNets') {
                        this.convertBubbles(cannonBubble.x, this.getBubbleY(0));
                    }
                }
                
                let bestCol = Math.round((cannonBubble.x - this.getBubbleX(0, 0)) / this.bubbleSpacing);
                bestCol = Math.max(0, Math.min(this.gridWidth - 1, bestCol));
                
                for (let row = 0; row < this.maxRows; row++) {
                    if (!this.bubbleGrid[row]) this.bubbleGrid[row] = [];
                    if (!this.bubbleGrid[row][bestCol]) {
                        this.bubbleGrid[row][bestCol] = {
                            color: cannonBubble.powerup === 'grahamNets' ? '#c0c0c0' : cannonBubble.color,
                            x: this.getBubbleX(row, bestCol),
                            y: this.getBubbleY(row)
                        };
                        
                        this.processMatches(row, bestCol);
                        return true;
                    }
                }
                
                return false;
            }
            
            explodeBubbles(x, y) {
                const explosionRadius = this.bubbleRadius * 3;
                const toRemove = [];
                
                for (let row = 0; row < this.bubbleGrid.length; row++) {
                    for (let col = 0; col < this.bubbleGrid[row].length; col++) {
                        if (this.bubbleGrid[row][col]) {
                            const bubble = this.bubbleGrid[row][col];
                            const dx = bubble.x - x;
                            const dy = bubble.y - y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance <= explosionRadius) {
                                toRemove.push([row, col]);
                            }
                        }
                    }
                }
                
                if (toRemove.length > 0) {
                    this.removeBubbles(toRemove);
                    this.dropFloatingBubbles();
                }
            }
            
            convertBubbles(x, y) {
                const convertRadius = this.bubbleRadius * 2;
                
                for (let row = 0; row < this.bubbleGrid.length; row++) {
                    for (let col = 0; col < this.bubbleGrid[row].length; col++) {
                        if (this.bubbleGrid[row][col]) {
                            const bubble = this.bubbleGrid[row][col];
                            const dx = bubble.x - x;
                            const dy = bubble.y - y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance <= convertRadius) {
                                bubble.color = '#c0c0c0';
                            }
                        }
                    }
                }
            }
            
            processMatches(row, col) {
                const placedBubble = this.bubbleGrid[row][col];
                if (!placedBubble) return;
                
                let matchingBubbles = [];
                if (placedBubble.color === '#c0c0c0') {
                    matchingBubbles = this.findAdjacentBubbles(row, col);
                } else {
                    matchingBubbles = this.findConnectedBubbles(row, col, placedBubble.color, new Set());
                }
                
                if (matchingBubbles.length >= 3) {
                    const bubblesToRemove = matchingBubbles.map(pos => {
                        const [r, c] = pos.split(',').map(Number);
                        return [r, c];
                    });
                    
                    this.removeBubbles(bubblesToRemove);
                    this.dropFloatingBubbles();
                }
            }
            
            findConnectedBubbles(startRow, startCol, color, visited = new Set()) {
                const stack = [startRow + ',' + startCol];
                const cluster = [];
                
                while (stack.length > 0) {
                    const current = stack.pop();
                    if (visited.has(current)) continue;
                    
                    visited.add(current);
                    
                    const [row, col] = current.split(',').map(Number);
                    const currentBubble = this.bubbleGrid[row] && this.bubbleGrid[row][col];
                    
                    if (currentBubble && currentBubble.color === color) {
                        cluster.push(current);
                        
                        const neighbors = this.getNeighbors(row, col);
                        for (const [nRow, nCol] of neighbors) {
                            const key = nRow + ',' + nCol;
                            if (!visited.has(key) && 
                                this.bubbleGrid[nRow] && 
                                this.bubbleGrid[nRow][nCol] && 
                                this.bubbleGrid[nRow][nCol].color === color) {
                                stack.push(key);
                            }
                        }
                    }
                }
                
                return cluster;
            }
            
            findAdjacentBubbles(startRow, startCol) {
                const visited = new Set();
                const stack = [startRow + ',' + startCol];
                const cluster = [];
                
                while (stack.length > 0) {
                    const current = stack.pop();
                    if (visited.has(current)) continue;
                    
                    visited.add(current);
                    const [row, col] = current.split(',').map(Number);
                    
                    if (this.bubbleGrid[row] && this.bubbleGrid[row][col]) {
                        cluster.push(current);
                        
                        const neighbors = this.getNeighbors(row, col);
                        for (const [nRow, nCol] of neighbors) {
                            const key = nRow + ',' + nCol;
                            if (!visited.has(key) && this.bubbleGrid[nRow] && this.bubbleGrid[nRow][nCol]) {
                                stack.push(key);
                            }
                        }
                    }
                }
                
                return cluster;
            }
            
            getNeighbors(row, col) {
                const neighbors = [];
                const isEvenRow = row % 2 === 0;
                
                const directions = [
                    [-1, isEvenRow ? -1 : 0], [-1, isEvenRow ? 0 : 1],
                    [0, -1], [0, 1],
                    [1, isEvenRow ? -1 : 0], [1, isEvenRow ? 0 : 1]
                ];
                
                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow >= 0 && newRow < this.bubbleGrid.length && 
                        newCol >= 0 && newCol < (this.bubbleGrid[newRow]?.length || 0)) {
                        neighbors.push([newRow, newCol]);
                    }
                }
                
                return neighbors;
            }
            
            removeBubbles(positions) {
                for (const [row, col] of positions) {
                    if (this.bubbleGrid[row] && this.bubbleGrid[row][col]) {
                        const bubble = this.bubbleGrid[row][col];
                        this.createCollectible(bubble.x, bubble.y);
                        this.bubbleGrid[row][col] = null;
                        this.cash += 10;
                    }
                }
            }
            
            createCollectible(x, y) {
                const rand = Math.random();
                let type = null;
                
                if (rand < this.dropRates.book) {
                    type = 'book';
                } else if (rand < this.dropRates.book + this.dropRates.sweet) {
                    type = 'sweet';
                } else if (rand < this.dropRates.book + this.dropRates.sweet + this.dropRates.coin) {
                    type = 'coin';
                }
                
                if (type) {
                    this.collectibles.push({
                        type: type,
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: Math.random() * -3 - 2,
                        gravity: 0.3
                    });
                }
            }
            
            dropFloatingBubbles() {
                const connected = new Set();
                
                for (let col = 0; col < this.gridWidth; col++) {
                    if (this.bubbleGrid[0] && this.bubbleGrid[0][col]) {
                        this.markConnectedBubbles(0, col, connected);
                    }
                }
                
                for (let row = 0; row < this.bubbleGrid.length; row++) {
                    for (let col = 0; col < this.bubbleGrid[row].length; col++) {
                        if (this.bubbleGrid[row][col] && !connected.has(row + ',' + col)) {
                            this.bubbleGrid[row][col] = null;
                            this.cash += 5;
                        }
                    }
                }
            }
            
            markConnectedBubbles(row, col, connected) {
                const key = row + ',' + col;
                if (connected.has(key) || !this.bubbleGrid[row] || !this.bubbleGrid[row][col]) return;
                
                connected.add(key);
                const neighbors = this.getNeighbors(row, col);
                
                for (const [nRow, nCol] of neighbors) {
                    if (this.bubbleGrid[nRow] && this.bubbleGrid[nRow][nCol]) {
                        this.markConnectedBubbles(nRow, nCol, connected);
                    }
                }
            }
            
            initializeLevel() {
                this.updateColorProgression();
                this.updateMarketConditions();
                this.generateBubbleFormation();
                this.sugar = this.maxSugar;
                // Use calculated shots instead of hardcoded 3
                this.calculatePerkBonuses();
                this.nextBubbles = this.generateNextBubbles();
                this.collectibles = [];
                this.cannonBubbles = [];
                this.activePowerup = null;
                this.levelComplete = false;
                this.showRandomQuote();
            }
            
            endLevel() {
                const completionBonus = this.levelComplete ? 100 : 0;
                const yearBonus = Math.floor(this.sugar * 2);
                
                this.cash += yearBonus;
                
                for (const subsidiary of this.storeData.subsidiaries) {
                    if (subsidiary.owned) {
                        this.cash += subsidiary.income;
                    }
                }
                
                if (this.year % 5 === 0) {
                    this.powerups.coke += 1;
                }
                if (this.year % 10 === 0) {
                    this.powerups.lollapalooza += 1;
                    this.powerups.grahamNets += 1;
                }
                
                this.year++;
                if (this.year > 2025) {
                    this.year = 2025;
                }
                
                this.levelComplete = false;
                this.collectibles = [];
                this.cannonBubbles = [];
                this.activePowerup = null;
                
                this.showStore();
                
                const message = completionBonus > 0 ? 
                    'Year ' + (this.year - 1) + ' Complete! Board Cleared Bonus: $' + completionBonus : 
                    'Year ' + (this.year - 1) + ' Complete! Sugar/Time Bonus: $' + yearBonus;
                
                this.showQuoteTemporarily(message, '- Game System', 3000);
            }
            
            showStore() {
                this.gameState = 'store';
                document.getElementById('storeOverlay').style.display = 'block';
                this.populateStore();
            }
            
            populateStore() {
                document.getElementById('storeStats').textContent = 'Cash: $' + this.cash.toLocaleString() + ' | Books: 📚' + this.books;
                
                const powerupsSection = document.getElementById('powerupsSection');
                powerupsSection.innerHTML = '';
                
                for (const powerup of this.storeData.powerups) {
                    const canAfford = powerup.currency === 'cash' ? this.cash >= powerup.price : this.books >= powerup.price;
                    const currencySymbol = powerup.currency === 'cash' ? '$' : '📚';
                    
                    const div = document.createElement('div');
                    div.className = 'store-item' + (canAfford ? '' : ' disabled');
                    div.innerHTML = '<div><h4>' + powerup.name + '</h4><p>' + powerup.effect + '</p></div>' +
                                   '<button class="buy-btn" onclick="game.buyPowerup(\'' + powerup.name + '\')" ' + 
                                   (canAfford ? '' : 'disabled') + '>' + currencySymbol + powerup.price + '</button>';
                    powerupsSection.appendChild(div);
                }
                
                const booksSection = document.getElementById('booksSection');
                booksSection.innerHTML = '';
                
                const nextBook = this.storeData.books.find(book => !book.owned);
                if (nextBook) {
                    const canAfford = this.books >= nextBook.price;
                    
                    const div = document.createElement('div');
                    div.className = 'store-item' + (canAfford ? '' : ' disabled');
                    div.innerHTML = '<div><h4>' + nextBook.name + '</h4><p>' + nextBook.unlocks + '</p></div>' +
                                   '<button class="buy-btn" onclick="game.buyBook(\'' + nextBook.name.replace(/'/g, "\\'") + '\')" ' + 
                                   (canAfford ? '' : 'disabled') + '>📚' + nextBook.price + '</button>';
                    booksSection.appendChild(div);
                } else {
                    booksSection.innerHTML = '<p style="color: #666;">All books owned!</p>';
                }
                
                const subsidiariesSection = document.getElementById('subsidiariesSection');
                subsidiariesSection.innerHTML = '';
                
                const availableSubsidiary = this.storeData.subsidiaries.find(sub => 
                    !sub.owned && this.year >= sub.year
                );
                
                if (availableSubsidiary) {
                    const canAfford = this.cash >= availableSubsidiary.price;
                    
                    const div = document.createElement('div');
                    div.className = 'store-item' + (canAfford ? '' : ' disabled');
                    div.innerHTML = '<div><h4>' + availableSubsidiary.name + '</h4><p>' + availableSubsidiary.perk + '</p><p>Income: $' + availableSubsidiary.income + '/year</p></div>' +
                                   '<button class="buy-btn" onclick="game.buySubsidiary(\'' + availableSubsidiary.name + '\')" ' + 
                                   (canAfford ? '' : 'disabled') + '>$' + availableSubsidiary.price.toLocaleString() + '</button>';
                    subsidiariesSection.appendChild(div);
                } else {
                    subsidiariesSection.innerHTML = '<p style="color: #666;">No acquisitions available yet.</p>';
                }
            }
            
            buyPowerup(name) {
                const powerup = this.storeData.powerups.find(p => p.name === name);
                if (!powerup) return;
                
                const canAfford = powerup.currency === 'cash' ? this.cash >= powerup.price : this.books >= powerup.price;
                if (!canAfford) return;
                
                if (powerup.currency === 'cash') {
                    this.cash -= powerup.price;
                } else {
                    this.books -= powerup.price;
                }
                
                if (name === 'Coke') this.powerups.coke += 1;
                else if (name === 'Lollapalooza') this.powerups.lollapalooza += 1;
                else if (name === 'Grahams Nets') this.powerups.grahamNets += 1;
                
                this.populateStore();
                this.updateUI();
            }
            
            buyBook(name) {
                const book = this.storeData.books.find(b => b.name === name);
                if (!book || book.owned || this.books < book.price) return;
                
                this.books -= book.price;
                book.owned = true;
                this.ownedBooks.push(name);
                
                // Recalculate bonuses after purchase
                this.calculatePerkBonuses();
                
                this.populateStore();
                this.updateUI();
                
                this.showQuoteTemporarily(
                    'Purchased "' + book.name + '". ' + book.unlocks + ' applied!',
                    '- Learning System',
                    3000
                );
            }
            
            buySubsidiary(name) {
                const subsidiary = this.storeData.subsidiaries.find(s => s.name === name);
                if (!subsidiary || subsidiary.owned || this.cash < subsidiary.price) return;
                
                this.cash -= subsidiary.price;
                subsidiary.owned = true;
                this.ownedSubsidiaries.push(name);
                
                // Recalculate bonuses after purchase
                this.calculatePerkBonuses();
                
                this.populateStore();
                this.updateUI();
                
                this.showQuoteTemporarily(
                    'Acquired ' + subsidiary.name + '! ' + subsidiary.perk + ' applied!',
                    '- Business System',
                    3000
                );
            }
            
            goToInvestments() {
                document.getElementById('storeOverlay').style.display = 'none';
                this.showInvestmentBoard();
            }
            
            showInvestmentBoard() {
                this.gameState = 'investments';
                document.getElementById('investmentOverlay').style.display = 'block';
                this.populateInvestmentBoard();
            }
            
            populateInvestmentBoard() {
                const portfolioValue = this.calculatePortfolioValue();
                document.getElementById('investmentStats').textContent = 
                    'Cash: $' + this.cash.toLocaleString() + ' | Portfolio: $' + portfolioValue.toLocaleString();
                
                const stocksSection = document.getElementById('stocksSection');
                stocksSection.innerHTML = '';
                
                if (this.year >= 1963) {
                    for (const [symbol, stock] of Object.entries(this.stockData)) {
                        if (this.year >= stock.startYear && stock.prices[this.year]) {
                            const price = stock.prices[this.year];
                            const owned = this.portfolio[symbol] || 0;
                            
                            const div = document.createElement('div');
                            div.className = 'store-item';
                            div.innerHTML = 
                                '<div><h4>' + symbol + ' - ' + stock.name + '</h4><p>Price: $' + price.toFixed(2) + ' | Owned: ' + owned + ' shares</p></div>' +
                                '<div style="display: flex; gap: 5px;"><input type="number" id="shares_' + symbol + '" min="1" max="' + Math.floor(this.cash / price) + '" value="1" style="width: 60px; padding: 4px; font-size: 12px;"><button class="buy-btn" onclick="game.buyStock(\'' + symbol + '\')" style="margin-right: 5px;" ' + (this.cash < price ? 'disabled' : '') + '>BUY</button>' +
                                (owned > 0 ? '<button class="buy-btn" onclick="game.sellStock(\'' + symbol + '\')" style="background: #f44336;">SELL</button>' : '') + '</div>';
                            stocksSection.appendChild(div);
                        }
                    }
                } else {
                    stocksSection.innerHTML = '<p style="color: #666;">Stock market opens in 1963. Focus on building capital!</p>';
                }
                
                const portfolioDisplay = document.getElementById('portfolioDisplay');
                portfolioDisplay.innerHTML = '';
                
                let totalValue = 0;
                for (const [symbol, shares] of Object.entries(this.portfolio)) {
                    if (shares > 0 && this.stockData[symbol] && this.stockData[symbol].prices[this.year]) {
                        const stock = this.stockData[symbol];
                        const price = stock.prices[this.year];
                        const value = shares * price;
                        totalValue += value;
                        
                        const div = document.createElement('div');
                        div.className = 'store-item';
                        div.innerHTML = 
    '<div><h4>' + symbol + ' - ' + stock.name + '</h4><p>Price: $' + price.toFixed(2) + ' | Owned: ' + owned + ' shares</p></div>' +
    '<div style="display: flex; gap: 5px; align-items: center;"><input type="number" id="shares_' + symbol + '" min="1" max="' + Math.floor(this.cash / price) + '" value="1" style="width: 60px; padding: 4px; font-size: 12px;"><button class="buy-btn" onclick="game.buyStock(\'' + symbol + '\')" style="margin-right: 5px;" ' + (this.cash < price ? 'disabled' : '') + '>BUY</button>' +
    '<button class="buy-btn" onclick="game.buyMaxStock(\'' + symbol + '\')" style="margin-right: 5px; background: linear-gradient(45deg, #ff9800, #f57c00);" ' + (this.cash < price ? 'disabled' : '') + '>BUY MAX</button>' +
    (owned > 0 ? '<button class="buy-btn" onclick="game.sellStock(\'' + symbol + '\')" style="background: #f44336;">SELL</button>' : '') + '</div>';
                    }
                }
                
                if (totalValue === 0) {
                    portfolioDisplay.innerHTML = '<p style="color: #666;">No stocks owned yet.</p>';
                }
            }
            
            buyStock(symbol) {
                const sharesInput = document.getElementById('shares_' + symbol);
                const shares = parseInt(sharesInput.value) || 1;
                const stock = this.stockData[symbol];
                const price = stock.prices[this.year];
                const totalCost = shares * price;
                
                if (this.cash >= totalCost && shares > 0) {
                    this.cash -= totalCost;
                    this.portfolio[symbol] = (this.portfolio[symbol] || 0) + shares;
                    this.populateInvestmentBoard();
                    this.updateUI();
                    
                    this.showQuoteTemporarily(
                        'Purchased ' + shares + ' shares of ' + symbol + ' for $' + totalCost.toFixed(2),
                        '- Investment System',
                        2000
                    );
                }
            }

buyMaxStock(symbol) {
    const stock = this.stockData[symbol];
    const price = stock.prices[this.year];
    const maxShares = Math.floor(this.cash / price);
    
    if (maxShares > 0) {
        const totalCost = maxShares * price;
        this.cash -= totalCost;
        this.portfolio[symbol] = (this.portfolio[symbol] || 0) + maxShares;
        this.populateInvestmentBoard();
        this.updateUI();
        
        this.showQuoteTemporarily(
            'Invested all available funds: ' + maxShares + ' shares of ' + symbol + ' for $' + totalCost.toFixed(2),
            '- Investment System',
            2000
        );
    }
}
            
            sellStock(symbol) {
                const sellInput = document.getElementById('sell_' + symbol);
                const shares = parseInt(sellInput.value) || 1;
                const ownedShares = this.portfolio[symbol] || 0;
                
                if (ownedShares >= shares && shares > 0) {
                    const stock = this.stockData[symbol];
                    const price = stock.prices[this.year];
                    const totalValue = shares * price;
                    
                    this.cash += totalValue;
                    this.portfolio[symbol] -= shares;
                    
                    if (this.portfolio[symbol] <= 0) {
                        delete this.portfolio[symbol];
                    }
                    
                    this.populateInvestmentBoard();
                    this.updateUI();
                    
                    this.showQuoteTemporarily(
                        'Sold ' + shares + ' shares of ' + symbol + ' for $' + totalValue.toFixed(2),
                        '- Investment System',
                        2000
                    );
                }
            }
            
            calculatePortfolioValue() {
                let totalValue = 0;
                for (const [symbol, shares] of Object.entries(this.portfolio)) {
                    if (shares > 0 && this.stockData[symbol] && this.stockData[symbol].prices[this.year]) {
                        const price = this.stockData[symbol].prices[this.year];
                        totalValue += shares * price;
                    }
                }
                return totalValue;
            }
            
            closeInvestments() {
                document.getElementById('investmentOverlay').style.display = 'none';
                this.gameState = 'playing';
                this.initializeLevel();
                this.updateUI();
            }
            
            closeStore() {
                document.getElementById('storeOverlay').style.display = 'none';
                this.gameState = 'playing';
                this.initializeLevel();
                this.updateUI();
            }
            
            showQuoteTemporarily(text, author, duration = 3000) {
                const originalText = document.getElementById('quoteText').textContent;
                const originalAuthor = document.getElementById('quoteAuthor').textContent;
                
                document.getElementById('quoteText').textContent = text;
                document.getElementById('quoteAuthor').textContent = author;
                
                setTimeout(() => {
                    document.getElementById('quoteText').textContent = originalText;
                    document.getElementById('quoteAuthor').textContent = originalAuthor;
                }, duration);
            }
            
            showRandomQuote() {
                const quote = this.buffettQuotes[Math.floor(Math.random() * this.buffettQuotes.length)];
                document.getElementById('quoteText').textContent = quote;
                document.getElementById('quoteAuthor').textContent = '- Warren Buffett';
            }
            
            updateUI() {
                document.getElementById('currentYear').textContent = this.year;
                document.getElementById('cashAmount').textContent = this.cash.toLocaleString();
                document.getElementById('booksCount').textContent = this.books;
                
                const portfolioValue = this.calculatePortfolioValue();
                document.getElementById('portfolioValue').textContent = portfolioValue.toLocaleString();
                
                document.getElementById('shotsRemaining').textContent = this.shots;
                
                const sugarPercent = (this.sugar / this.maxSugar) * 100;
                document.getElementById('sugarFill').style.width = sugarPercent + '%';
                
                for (let i = 0; i < 3; i++) {
                    const element = document.getElementById('nextBubble' + (i + 1));
                    if (this.nextBubbles[i]) {
                        element.style.backgroundColor = this.nextBubbles[i];
                        element.style.borderColor = this.nextBubbles[i];
                    }
                }
                
                document.querySelector('#lollapalooza .powerup-count').textContent = this.powerups.lollapalooza;
                document.querySelector('#grahamNets .powerup-count').textContent = this.powerups.grahamNets;
                document.querySelector('#coke .powerup-count').textContent = this.powerups.coke;
                
                for (const powerup in this.powerups) {
                    const element = document.querySelector('#' + powerup + ' .powerup-count');
                    if (element) {
                        element.style.display = this.powerups[powerup] > 0 ? 'flex' : 'none';
                    }
                }
            }
            
            render() {
                if (this.gameState !== 'playing') return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let row = 0; row < this.bubbleGrid.length; row++) {
                    for (let col = 0; col < this.bubbleGrid[row].length; col++) {
                        if (this.bubbleGrid[row][col]) {
                            this.drawBubble(this.bubbleGrid[row][col]);
                        }
                    }
                }
                
                for (const bubble of this.cannonBubbles) {
                    this.drawBubble(bubble);
                }
                
                for (const collectible of this.collectibles) {
                    this.drawCollectible(collectible);
                }
                
                this.drawCannon();
                
                if (this.isDragging) {
                    this.drawTrajectory();
                }
                
                if (this.activePowerup) {
                    this.drawPowerupIndicator();
                }
            }
            
            drawBubble(bubble) {
                this.ctx.save();
                this.ctx.fillStyle = bubble.color;
                this.ctx.beginPath();
                this.ctx.arc(bubble.x, bubble.y, this.bubbleRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(bubble.x - 3, bubble.y - 3, this.bubbleRadius * 0.4, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.restore();
            }
            
            drawCollectible(collectible) {
                this.ctx.save();
                
                let symbol = '';
                let color = '';
                
                switch(collectible.type) {
                    case 'coin':
                        symbol = '$';
                        color = '#ffd700';
                        break;
                    case 'sweet':
                        symbol = '♥';
                        color = '#ff69b4';
                        break;
                    case 'book':
                        symbol = '📚';
                        color = '#64b5f6';
                        break;
                }
                
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(collectible.x, collectible.y, 8, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(symbol, collectible.x, collectible.y);
                
                this.ctx.restore();
            }
            
            drawPowerupIndicator() {
                this.ctx.save();
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.lineWidth = 2;
                const text = this.activePowerup.toUpperCase() + ' ACTIVE';
                this.ctx.strokeText(text, this.canvas.width / 2, 30);
                this.ctx.fillText(text, this.canvas.width / 2, 30);
                this.ctx.restore();
            }
            
            drawCannon() {
                this.ctx.save();
                this.ctx.translate(this.cannonX, this.cannonY);
                this.ctx.rotate(this.cannonAngle);
                
                this.ctx.fillStyle = '#666';
                this.ctx.fillRect(-5, -10, 40, 20);
                
                this.ctx.resetTransform();
                this.ctx.fillStyle = '#444';
                this.ctx.beginPath();
                this.ctx.arc(this.cannonX, this.cannonY, 15, 0, Math.PI * 2);
                this.ctx.fill();
                
                if (this.nextBubbles.length > 0) {
                    this.ctx.fillStyle = this.nextBubbles[0];
                    this.ctx.beginPath();
                    this.ctx.arc(this.cannonX, this.cannonY, this.bubbleRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Add highlight to cannon bubble
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.arc(this.cannonX - 3, this.cannonY - 3, this.bubbleRadius * 0.4, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            drawTrajectory() {
                this.ctx.save();
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                this.ctx.setLineDash([8, 8]);
                this.ctx.lineWidth = 3;
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                this.ctx.shadowBlur = 2;
                
                let x = this.cannonX;
                let y = this.cannonY;
                const vx = Math.cos(this.cannonAngle) * 8;
                const vy = Math.sin(this.cannonAngle) * 8;
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                
                for (let i = 0; i < 50; i++) {
                    x += vx;
                    y += vy;
                    
                    if (x <= this.bubbleRadius || x >= this.canvas.width - this.bubbleRadius) {
                        break;
                    }
                    
                    if (y <= 50) break;
                    
                    this.ctx.lineTo(x, y);
                }
                
                this.ctx.stroke();
                this.ctx.restore();
            }
            
            gameLoop() {
                try {
                    this.update();
                    this.render();
                } catch (error) {
                    console.error('Game loop error:', error);
                }
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        let game;
        
        window.addEventListener('load', () => {
            game = new BubbleGame();
            window.game = game;
        });
    </script>
</body>
</html>
