<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Warren Buffett's Bubble Pop Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background: #1a1a1a;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            z-index: 100;
            height: 50px;
        }

        #yearDisplay {
            font-size: 16px;
            font-weight: bold;
            color: #f39c12;
        }

        #sugarBar {
            width: 80px;
            height: 16px;
            background: #34495e;
            border: 2px solid #fff;
            border-radius: 8px;
            overflow: hidden;
        }

        #sugarFill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12);
            transition: width 0.3s ease;
            width: 100%;
        }

        #lives {
            display: flex;
            gap: 3px;
        }

        .life {
            width: 16px;
            height: 16px;
            background: #e74c3c;
            border-radius: 50%;
            border: 1px solid #fff;
        }

        #stats {
            display: flex;
            gap: 10px;
            font-size: 11px;
        }

        #gameCanvas {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            display: block;
            position: absolute;
            top: 50px;
            left: 0;
            touch-action: none;
            cursor: crosshair;
        }

        #quoteBox {
            position: absolute;
            bottom: 20px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #f39c12;
            padding: 8px;
            border-radius: 8px;
            font-size: 11px;
            text-align: center;
            display: none;
            z-index: 100;
        }

        #debugInfo {
            position: absolute;
            top: 60px;
            left: 10px;
            color: white;
            font-size: 10px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div id="yearDisplay">1951</div>
            <div id="sugarBar">
                <div id="sugarFill"></div>
            </div>
            <div id="lives">
                <div class="life"></div>
                <div class="life"></div>
                <div class="life"></div>
            </div>
            <div id="stats">
                <span>Coins: <span id="coinCount">0</span></span>
                <span>Bubbles: <span id="bubbleCount">20</span></span>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="quoteBox"></div>
        <div id="debugInfo"></div>
    </div>

    <script>
        // Debug function
        function debug(msg) {
            console.log(msg);
            const debugEl = document.getElementById('debugInfo');
            debugEl.style.display = 'block';
            debugEl.innerHTML += msg + '<br>';
        }

        class BubbleGame {
            constructor() {
                debug('Initializing game...');
                
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.setupCanvas();
                this.initGameState();
                this.setupEventListeners();
                this.generateInitialBubbles();
                
                debug('Game initialized, starting loop...');
                this.lastTime = 0;
                this.gameLoop();
            }
            
            setupCanvas() {
                const container = document.getElementById('gameContainer');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight - 50; // Account for UI
                
                debug(`Canvas size: ${this.canvas.width} x ${this.canvas.height}`);
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight - 50;
                    this.cannon.x = this.canvas.width / 2;
                    this.cannon.y = this.canvas.height - 30;
                });
            }
            
            initGameState() {
                this.year = 1951;
                this.sugar = 60;
                this.maxSugar = 60;
                this.lives = 3;
                this.coins = 0;
                this.bubblesRemaining = 20;
                this.gameRunning = true;
                
                // Bubble system
                this.bubbles = [];
                this.activeBubble = null;
                this.nextBubbles = [];
                this.collectibles = [];
                
                // Physics
                this.bubbleRadius = Math.min(18, this.canvas.width / 25);
                this.scrollSpeed = 30; // pixels per second
                this.spawnTimer = 0;
                this.spawnInterval = 0.8; // seconds between new columns
                
                // Cluster system (Buffett's patience mechanic)
                this.currentClusterSize = 0;
                this.clusterThreshold = 30; // Much larger clusters before reset
                this.clusterProbability = 0.25; // Only 25% chance - much rarer!
                this.isClusterMode = false;
                this.lastSpawnedColor = null;
                this.clusterCooldown = 0; // Prevent clusters from happening too frequently
                this.minClusterInterval = 45; // Minimum 45 seconds between cluster opportunities
                
                // Cannon
                this.cannon = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height - 30,
                    angle: -Math.PI / 2,
                    power: 300
                };
                
                // Colors
                this.colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'];
                
                // Input
                this.isAiming = false;
                this.trajectory = [];
                
                // Generate next bubbles
                for (let i = 0; i < 3; i++) {
                    this.nextBubbles.push(Math.floor(Math.random() * 3));
                }
                
                this.updateUI();
                this.showQuote("Welcome to 1951! Legendary clusters appear every ~60 seconds. Your sugar lasts 30 seconds. Choose wisely!");
            }
            
            setupEventListeners() {
                // Prevent context menu
                this.canvas.addEventListener('contextmenu', e => e.preventDefault());
                
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.startAiming(e));
                this.canvas.addEventListener('mousemove', (e) => this.updateAiming(e));
                this.canvas.addEventListener('mouseup', (e) => this.fire(e));
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startAiming(e.touches[0]);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.updateAiming(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.fire(e);
                });
            }
            
            getPointerPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            startAiming(e) {
                if (!this.gameRunning || this.activeBubble) return;
                
                this.isAiming = true;
                this.updateAiming(e);
            }
            
            updateAiming(e) {
                if (!this.isAiming) return;
                
                const pos = this.getPointerPos(e);
                const dx = pos.x - this.cannon.x;
                const dy = pos.y - this.cannon.y;
                
                let angle = Math.atan2(dy, dx);
                
                // Limit angle (roughly 160 degrees range)
                const maxAngle = Math.PI * 0.1;
                const minAngle = -Math.PI + maxAngle;
                angle = Math.max(minAngle, Math.min(maxAngle, angle));
                
                this.cannon.angle = angle;
                this.calculateTrajectory();
            }
            
            fire(e) {
                if (!this.isAiming || this.activeBubble || this.bubblesRemaining <= 0) return;
                
                this.isAiming = false;
                this.trajectory = [];
                
                this.activeBubble = {
                    x: this.cannon.x,
                    y: this.cannon.y,
                    vx: Math.cos(this.cannon.angle) * this.cannon.power,
                    vy: Math.sin(this.cannon.angle) * this.cannon.power,
                    color: this.nextBubbles.shift(),
                    radius: this.bubbleRadius
                };
                
                this.nextBubbles.push(Math.floor(Math.random() * 3));
                this.bubblesRemaining--;
                this.updateUI();
                
                debug(`Fired bubble! ${this.bubblesRemaining} remaining`);
            }
            
            calculateTrajectory() {
                this.trajectory = [];
                if (!this.isAiming) return;
                
                let x = this.cannon.x;
                let y = this.cannon.y;
                let vx = Math.cos(this.cannon.angle) * this.cannon.power / 60;
                let vy = Math.sin(this.cannon.angle) * this.cannon.power / 60;
                
                for (let i = 0; i < 30; i++) {
                    x += vx;
                    y += vy;
                    
                    // Bounce off walls
                    if (x <= this.bubbleRadius || x >= this.canvas.width - this.bubbleRadius) {
                        vx = -vx;
                        x = Math.max(this.bubbleRadius, Math.min(this.canvas.width - this.bubbleRadius, x));
                    }
                    
                    this.trajectory.push({ x, y });
                    
                    if (y <= 0) break;
                }
            }
            
            generateInitialBubbles() {
                this.bubbles = [];
                
                const cols = Math.floor(this.canvas.width / (this.bubbleRadius * 2)) + 5; // Extra columns off-screen
                const rows = 6;
                
                for (let col = 0; col < cols; col++) {
                    for (let row = 0; row < rows; row++) {
                        if (Math.random() < 0.7) { // 70% fill rate
                            const x = col * (this.bubbleRadius * 2) + this.bubbleRadius + (row % 2 ? this.bubbleRadius : 0);
                            const y = row * (this.bubbleRadius * 1.5) + this.bubbleRadius + 20;
                            
                            this.bubbles.push({
                                x: x,
                                y: y,
                                color: Math.floor(Math.random() * 3),
                                radius: this.bubbleRadius,
                                gridX: col,
                                gridY: row
                            });
                        }
                    }
                }
                
                debug(`Generated ${this.bubbles.length} bubbles`);
            }
            
            spawnNewColumn() {
                const rows = 6;
                const rightmostX = Math.max(...this.bubbles.map(b => b.x), this.canvas.width);
                const newCol = Math.floor((rightmostX + this.bubbleRadius * 2) / (this.bubbleRadius * 2));
                
                for (let row = 0; row < rows; row++) {
                    if (Math.random() < 0.7) { // 70% fill rate
                        const x = newCol * (this.bubbleRadius * 2) + this.bubbleRadius + (row % 2 ? this.bubbleRadius : 0);
                        const y = row * (this.bubbleRadius * 1.5) + this.bubbleRadius + 20;
                        
                        // Smart cluster color selection
                        const color = this.getClusterAwareColor(newCol, row);
                        
                        this.bubbles.push({
                            x: x,
                            y: y,
                            color: color,
                            radius: this.bubbleRadius,
                            gridX: newCol,
                            gridY: row
                        });
                    }
                }
            }
            
            getClusterAwareColor(col, row) {
                // Skip clustering if in cooldown period
                if (this.clusterCooldown > 0) {
                    return Math.floor(Math.random() * 3);
                }
                
                // Get neighboring bubbles
                const neighbors = this.getGridNeighbors(col, row);
                const neighborColors = neighbors.map(n => n.color);
                
                // Only attempt clustering if we have neighbors and haven't hit threshold
                if (neighborColors.length > 0 && this.currentClusterSize < this.clusterThreshold) {
                    // Find most common neighbor color
                    const colorCounts = {};
                    neighborColors.forEach(color => {
                        colorCounts[color] = (colorCounts[color] || 0) + 1;
                    });
                    
                    const mostCommonColor = Object.keys(colorCounts).reduce((a, b) => 
                        colorCounts[a] > colorCounts[b] ? a : b
                    );
                    
                    // Much lower probability - creates rarity!
                    if (Math.random() < this.clusterProbability) {
                        this.currentClusterSize++;
                        this.isClusterMode = true;
                        this.lastSpawnedColor = parseInt(mostCommonColor);
                        
                        // Only announce significant clusters
                        if (this.currentClusterSize === 8) {
                            debug('RARE CLUSTER OPPORTUNITY! This could be BIG - but can you wait?');
                        } else if (this.currentClusterSize === 15) {
                            debug('MASSIVE CLUSTER FORMING! Warren would wait... but time is running out!');
                        }
                        
                        return parseInt(mostCommonColor);
                    }
                }
                
                // Reset cluster if threshold reached + start cooldown
                if (this.currentClusterSize >= this.clusterThreshold) {
                    this.currentClusterSize = 0;
                    this.isClusterMode = false;
                    this.clusterCooldown = this.minClusterInterval; // Start cooldown period
                    debug('LEGENDARY CLUSTER COMPLETED! Next opportunity in ~45 seconds...');
                }
                
                // Random color (normal market conditions - most of the time)
                return Math.floor(Math.random() * 3);
            }
            
            getGridNeighbors(col, row) {
                const neighbors = [];
                const isEvenRow = row % 2 === 0;
                
                // Hexagonal grid neighbor offsets
                const offsets = isEvenRow ? 
                    [[-1, -1], [0, -1], [-1, 0], [1, 0], [-1, 1], [0, 1]] :
                    [[0, -1], [1, -1], [-1, 0], [1, 0], [0, 1], [1, 1]];
                
                for (let [dx, dy] of offsets) {
                    const neighborCol = col + dx;
                    const neighborRow = row + dy;
                    
                    const neighbor = this.bubbles.find(b => 
                        b.gridX === neighborCol && b.gridY === neighborRow
                    );
                    
                    if (neighbor) {
                        neighbors.push(neighbor);
                    }
                }
                
                return neighbors;
            }
            
            update(deltaTime) {
                if (!this.gameRunning) return;
                
                // Update sugar
                this.sugar -= deltaTime;
                if (this.sugar <= 0) {
                    this.endLevel(false);
                    return;
                }
                
                // Update cluster cooldown
                if (this.clusterCooldown > 0) {
                    this.clusterCooldown -= deltaTime;
                }
                
                // Scroll bubbles
                this.bubbles.forEach(bubble => {
                    bubble.x -= this.scrollSpeed * deltaTime;
                });
                
                // Remove off-screen bubbles
                this.bubbles = this.bubbles.filter(bubble => bubble.x > -this.bubbleRadius);
                
                // Spawn new columns continuously 
                this.spawnTimer += deltaTime;
                if (this.spawnTimer >= this.spawnInterval) {
                    this.spawnNewColumn();
                    this.spawnTimer = 0;
                }
                
                // Update active bubble
                if (this.activeBubble) {
                    this.activeBubble.x += this.activeBubble.vx * deltaTime;
                    this.activeBubble.y += this.activeBubble.vy * deltaTime;
                    
                    // Wall bouncing
                    if (this.activeBubble.x <= this.bubbleRadius || 
                        this.activeBubble.x >= this.canvas.width - this.bubbleRadius) {
                        this.activeBubble.vx = -this.activeBubble.vx;
                        this.activeBubble.x = Math.max(this.bubbleRadius, 
                            Math.min(this.canvas.width - this.bubbleRadius, this.activeBubble.x));
                    }
                    
                    // Check collisions
                    this.checkCollisions();
                    
                    // Remove if off screen top
                    if (this.activeBubble && this.activeBubble.y <= -this.bubbleRadius) {
                        this.activeBubble = null;
                    }
                }
                
                // Update collectibles
                this.collectibles.forEach(collectible => {
                    collectible.y += 100 * deltaTime;
                    
                    // Check collection
                    const dist = Math.sqrt(
                        Math.pow(collectible.x - this.cannon.x, 2) + 
                        Math.pow(collectible.y - this.cannon.y, 2)
                    );
                    
                    if (dist < 30) {
                        this.collectItem(collectible);
                        collectible.collected = true;
                    }
                });
                
                this.collectibles = this.collectibles.filter(c => !c.collected && c.y < this.canvas.height);
                
                // Check win/lose conditions
                if (this.bubbles.length === 0) {
                    this.endLevel(true);
                } else if (this.bubblesRemaining <= 0 && !this.activeBubble) {
                    this.endLevel(false);
                }
                
                this.updateUI();
            }
            
            checkCollisions() {
                if (!this.activeBubble) return;
                
                for (let bubble of this.bubbles) {
                    const dist = Math.sqrt(
                        Math.pow(this.activeBubble.x - bubble.x, 2) + 
                        Math.pow(this.activeBubble.y - bubble.y, 2)
                    );
                    
                    if (dist < this.bubbleRadius * 1.8) {
                        this.attachBubble(bubble);
                        return;
                    }
                }
            }
            
            attachBubble(nearBubble) {
                // Add active bubble to grid
                const newBubble = {
                    x: this.activeBubble.x,
                    y: this.activeBubble.y,
                    color: this.activeBubble.color,
                    radius: this.bubbleRadius,
                    gridX: nearBubble.gridX,
                    gridY: nearBubble.gridY
                };
                
                this.bubbles.push(newBubble);
                this.activeBubble = null;
                
                // Check for matches
                const matches = this.findMatches(newBubble);
                if (matches.length >= 3) {
                    this.popBubbles(matches);
                    debug(`Popped ${matches.length} bubbles!`);
                }
            }
            
            findMatches(startBubble) {
                const visited = new Set();
                const matches = [];
                const stack = [startBubble];
                
                while (stack.length > 0) {
                    const bubble = stack.pop();
                    const key = `${bubble.x},${bubble.y}`;
                    
                    if (visited.has(key)) continue;
                    visited.add(key);
                    
                    if (bubble.color === startBubble.color) {
                        matches.push(bubble);
                        
                        // Find neighbors
                        const neighbors = this.bubbles.filter(b => {
                            if (b === bubble) return false;
                            const dist = Math.sqrt(
                                Math.pow(b.x - bubble.x, 2) + 
                                Math.pow(b.y - bubble.y, 2)
                            );
                            return dist < this.bubbleRadius * 2.2;
                        });
                        
                        for (let neighbor of neighbors) {
                            const neighborKey = `${neighbor.x},${neighbor.y}`;
                            if (!visited.has(neighborKey) && neighbor.color === startBubble.color) {
                                stack.push(neighbor);
                            }
                        }
                    }
                }
                
                return matches;
            }
            
            popBubbles(matches) {
                // Remove matched bubbles
                for (let bubble of matches) {
                    const index = this.bubbles.indexOf(bubble);
                    if (index !== -1) {
                        this.bubbles.splice(index, 1);
                        
                        // Create collectibles
                        if (Math.random() < 0.4) {
                            this.collectibles.push({
                                x: bubble.x,
                                y: bubble.y,
                                type: Math.random() < 0.7 ? 'coin' : 'sweet',
                                collected: false
                            });
                        }
                    }
                }
                
                // Dramatic rewards for patience - much higher thresholds
                if (matches.length >= 20) {
                    this.showQuote('LEGENDARY PATIENCE! ' + matches.length + ' bubbles! Warren: "Our favorite holding period is forever." +' + (matches.length * 20) + ' coins!');
                    this.coins += matches.length * 20; // Massive bonus
                    this.sugar = Math.min(this.maxSugar, this.sugar + 15); // Big sugar bonus
                } else if (matches.length >= 15) {
                    this.showQuote('EXCEPTIONAL CLUSTER! ' + matches.length + ' bubbles! Warren: "The stock market rewards patience." +' + (matches.length * 10) + ' coins!');
                    this.coins += matches.length * 10; // Large bonus
                    this.sugar = Math.min(this.maxSugar, this.sugar + 10); // Sugar bonus
                } else if (matches.length >= 8) {
                    this.showQuote('GREAT PATIENCE! ' + matches.length + ' bubbles! Small clusters sustain you for the big opportunities.');
                    this.coins += matches.length * 5; // Good bonus
                    this.sugar = Math.min(this.maxSugar, this.sugar + 5); // Small sugar bonus
                } else if (matches.length >= 5) {
                    this.showQuote('Decent cluster! ' + matches.length + ' bubbles. Sometimes you need small wins to survive.');
                    this.coins += matches.length * 2; // Modest bonus
                }
                
                // Reset cluster tracking if we popped a significant cluster
                if (matches.length >= 8) {
                    this.currentClusterSize = Math.max(0, this.currentClusterSize - matches.length);
                }
            }
            
            collectItem(collectible) {
                switch (collectible.type) {
                    case 'coin':
                        this.coins += 10;
                        break;
                    case 'sweet':
                        this.sugar = Math.min(this.maxSugar, this.sugar + 10);
                        break;
                }
            }
            
            endLevel(won) {
                this.gameRunning = false;
                
                if (won) {
                    this.year++;
                    this.showQuote(`Year ${this.year - 1} completed! Moving to ${this.year}.`);
                    setTimeout(() => this.nextLevel(), 2000);
                } else {
                    this.lives--;
                    if (this.lives <= 0) {
                        this.showQuote("Game Over! Warren says: 'Time is the friend of the wonderful business.'");
                        setTimeout(() => this.restart(), 3000);
                    } else {
                        this.showQuote(`Life lost! ${this.lives} remaining.`);
                        setTimeout(() => this.retryLevel(), 2000);
                    }
                }
            }
            
            nextLevel() {
                this.sugar = this.maxSugar;
                this.bubblesRemaining = 20;
                this.scrollSpeed += 5; // Increase difficulty
                this.generateInitialBubbles();
                this.gameRunning = true;
            }
            
            retryLevel() {
                this.sugar = this.maxSugar;
                this.bubblesRemaining = 20;
                this.generateInitialBubbles();
                this.gameRunning = true;
            }
            
            restart() {
                this.initGameState();
                this.generateInitialBubbles();
            }
            
            showQuote(text) {
                const quoteBox = document.getElementById('quoteBox');
                quoteBox.textContent = text;
                quoteBox.style.display = 'block';
                
                setTimeout(() => {
                    quoteBox.style.display = 'none';
                }, 3000);
            }
            
            updateUI() {
                document.getElementById('yearDisplay').textContent = this.year;
                document.getElementById('sugarFill').style.width = `${(this.sugar / this.maxSugar) * 100}%`;
                document.getElementById('coinCount').textContent = this.coins;
                document.getElementById('bubbleCount').textContent = this.bubblesRemaining;
                
                const livesContainer = document.getElementById('lives');
                livesContainer.innerHTML = '';
                for (let i = 0; i < this.lives; i++) {
                    const life = document.createElement('div');
                    life.className = 'life';
                    livesContainer.appendChild(life);
                }
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw bubbles
                for (let bubble of this.bubbles) {
                    this.drawBubble(bubble);
                }
                
                // Draw active bubble
                if (this.activeBubble) {
                    this.drawBubble(this.activeBubble);
                }
                
                // Draw trajectory
                if (this.isAiming && this.trajectory.length > 0) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.cannon.x, this.cannon.y);
                    for (let point of this.trajectory) {
                        this.ctx.lineTo(point.x, point.y);
                    }
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                // Draw cannon
                this.ctx.save();
                this.ctx.translate(this.cannon.x, this.cannon.y);
                this.ctx.rotate(this.cannon.angle);
                this.ctx.fillStyle = '#34495e';
                this.ctx.fillRect(-5, -8, 25, 6);
                this.ctx.restore();
                
                // Draw cannon base
                this.ctx.beginPath();
                this.ctx.arc(this.cannon.x, this.cannon.y, 15, 0, Math.PI * 2);
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fill();
                
                // Draw next bubbles
                for (let i = 0; i < this.nextBubbles.length; i++) {
                    const x = this.canvas.width - 30;
                    const y = this.canvas.height - 100 + (i * 35);
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 10, 0, Math.PI * 2);
                    this.ctx.fillStyle = this.colors[this.nextBubbles[i]];
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
                
                // Draw collectibles
                for (let collectible of this.collectibles) {
                    this.ctx.beginPath();
                    this.ctx.arc(collectible.x, collectible.y, 8, 0, Math.PI * 2);
                    this.ctx.fillStyle = collectible.type === 'coin' ? '#f1c40f' : '#e74c3c';
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '10px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(collectible.type === 'coin' ? '
            }
            
            drawBubble(bubble) {
                // Main bubble
                this.ctx.beginPath();
                this.ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = this.colors[bubble.color];
                this.ctx.fill();
                
                // Highlight
                this.ctx.beginPath();
                this.ctx.arc(bubble.x - bubble.radius * 0.3, bubble.y - bubble.radius * 0.3, 
                    bubble.radius * 0.3, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.fill();
                
                // Border
                this.ctx.beginPath();
                this.ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            }
            
            gameLoop() {
                const now = performance.now();
                const deltaTime = this.lastTime ? (now - this.lastTime) / 1000 : 0;
                this.lastTime = now;
                
                this.update(Math.min(deltaTime, 0.016)); // Cap at 60fps
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Initialize game when page loads
        window.addEventListener('load', () => {
            debug('Page loaded, creating game...');
            try {
                new BubbleGame();
            } catch (error) {
                debug('Error creating game: ' + error.message);
                console.error(error);
            }
        });
        
        // Handle page visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Game paused
            } else {
                // Game resumed
            }
        });
    </script>
</body>
</html> : '♥', 
                        collectible.x, collectible.y + 3);
                }
                
                // Draw cluster indicator - only for significant clusters
                if (this.isClusterMode && this.currentClusterSize >= 8) {
                    let message, color;
                    if (this.currentClusterSize >= 20) {
                        message = 'LEGENDARY CLUSTER (' + this.currentClusterSize + ')';
                        color = 'rgba(231, 76, 60, 0.9)'; // Red for extreme opportunity
                    } else if (this.currentClusterSize >= 15) {
                        message = 'MASSIVE CLUSTER (' + this.currentClusterSize + ')';
                        color = 'rgba(155, 89, 182, 0.9)'; // Purple for large opportunity  
                    } else {
                        message = 'RARE CLUSTER (' + this.currentClusterSize + ')';
                        color = 'rgba(241, 196, 15, 0.9)'; // Gold for opportunity
                    }
                    
                    this.ctx.fillStyle = color;
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(message, this.canvas.width / 2, 50);
                    
                    // Calculate time pressure
                    const timeLeft = this.sugar;
                    const urgency = timeLeft < 10 ? 'TIME CRITICAL!' : timeLeft < 20 ? 'TIME PRESSURE' : 'PATIENCE PAYS';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.fillText(urgency, this.canvas.width / 2, 70);
                }
                
                // Show cooldown status
                if (this.clusterCooldown > 0) {
                    this.ctx.fillStyle = 'rgba(127, 140, 141, 0.7)';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Market Analysis: ' + Math.ceil(this.clusterCooldown) + 's until next opportunity', 
                        this.canvas.width / 2, this.canvas.height - 40);
                }
            }
            
            drawBubble(bubble) {
                // Main bubble
                this.ctx.beginPath();
                this.ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = this.colors[bubble.color];
                this.ctx.fill();
                
                // Highlight
                this.ctx.beginPath();
                this.ctx.arc(bubble.x - bubble.radius * 0.3, bubble.y - bubble.radius * 0.3, 
                    bubble.radius * 0.3, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.fill();
                
                // Border
                this.ctx.beginPath();
                this.ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            }
            
            gameLoop() {
                const now = performance.now();
                const deltaTime = this.lastTime ? (now - this.lastTime) / 1000 : 0;
                this.lastTime = now;
                
                this.update(Math.min(deltaTime, 0.016)); // Cap at 60fps
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Initialize game when page loads
        window.addEventListener('load', () => {
            debug('Page loaded, creating game...');
            try {
                new BubbleGame();
            } catch (error) {
                debug('Error creating game: ' + error.message);
                console.error(error);
            }
        });
        
        // Handle page visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Game paused
            } else {
                // Game resumed
            }
        });
    </script>
</body>
                    </html>
