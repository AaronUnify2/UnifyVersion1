<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Warren Buffett's Bubble Pop Investment Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
            touch-action: none;
        }
        
        #root {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }
        
        .game-container {
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 600px;
            margin: 0 auto;
            position: relative;
            background: #000;
        }
        
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            z-index: 10;
        }
        
        .menu-title {
            font-size: 2.5em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .menu-subtitle {
            font-size: 1.2em;
            margin-bottom: 40px;
            color: #ccc;
        }
        
        .menu-button {
            padding: 15px 40px;
            font-size: 1.2em;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .menu-button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }
        
        .menu-button:active {
            transform: translateY(0);
        }
        
        .game-screen {
            width: 100%;
            height: 100%;
            position: relative;
            display: none;
        }
        
        .game-screen.active {
            display: block;
        }
        
        .decade-border {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 20px solid #666;
            pointer-events: none;
        }
        
        .decade-1950s {
            border-color: #666;
            background: repeating-linear-gradient(45deg, #333, #333 10px, #444 10px, #444 20px);
        }
        
        .decade-1960s { 
            border-color: #ff6b6b;
            background: repeating-linear-gradient(45deg, #ff6b6b, #ff6b6b 10px, #feca57 10px, #feca57 20px);
        }
        
        .decade-1970s { 
            border-color: #8b4513;
            background: repeating-linear-gradient(45deg, #d2691e, #d2691e 10px, #ff8c00 10px, #ff8c00 20px);
        }
        
        .decade-1980s { 
            border-color: #ff00ff;
            background: repeating-linear-gradient(45deg, #ff00ff, #ff00ff 10px, #00ffff 10px, #00ffff 20px);
        }
        
        .decade-1990s { 
            border-color: #0066cc;
            background: repeating-linear-gradient(45deg, #0066cc, #0066cc 10px, #ffcc00 10px, #ffcc00 20px);
        }
        
        .decade-2000s { 
            border-color: #4285f4;
            background: linear-gradient(135deg, #4285f4 0%, #34a853 50%, #fbbc05 100%);
        }
        
        .decade-2010s { 
            border-color: #f0f0f0;
            background: #fff;
        }
        
        .decade-2020s { 
            border-color: #6366f1;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #ec4899 100%);
        }
        
        #gameCanvas {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            bottom: 120px;
            overflow: hidden;
            cursor: crosshair;
            background: rgba(0,0,0,0.1);
        }
        
        .game-ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 80px;
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
        }
        
        .stat-display {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-label {
            font-size: 0.8em;
            color: #ccc;
        }
        
        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .sugar-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #666;
        }
        
        .sugar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b 0%, #ff8e53 100%);
            transition: width 0.3s;
        }
        
        .quote-box {
            position: absolute;
            bottom: 110px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            border-radius: 5px;
            padding: 10px;
            font-size: 0.9em;
            color: #ffd700;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .shop-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
        }
        
        .shop-screen.active {
            display: flex;
        }
        
        .shop-header {
            font-size: 2em;
            color: #ffd700;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .shop-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .shop-item {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #444;
            transition: all 0.3s;
        }
        
        .shop-item:hover {
            border-color: #ffd700;
            transform: translateY(-2px);
        }
        
        .shop-item-name {
            font-size: 1.1em;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .shop-item-desc {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 10px;
        }
        
        .shop-item-price {
            font-size: 1em;
            color: #4CAF50;
            margin-bottom: 10px;
        }
        
        .shop-buy-button {
            width: 100%;
            padding: 8px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .shop-buy-button:hover:not(:disabled) {
            background: #45a049;
        }
        
        .shop-buy-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .investment-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
        }
        
        .investment-screen.active {
            display: flex;
        }
        
        .stock-board {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .stock-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #333;
        }
        
        .stock-info {
            flex: 1;
        }
        
        .stock-name {
            font-weight: bold;
            color: #ffd700;
        }
        
        .stock-price {
            color: #4CAF50;
        }
        
        .stock-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .stock-button {
            padding: 5px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .stock-button.sell {
            background: #f44336;
        }
        
        .continue-button {
            padding: 15px 40px;
            font-size: 1.2em;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 20px auto;
            display: block;
        }
        
        .cannon {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            background: #666;
            border-radius: 50%;
            border: 3px solid #888;
            z-index: 5;
            pointer-events: none;
        }
        
        .cannon-barrel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform-origin: bottom center;
            width: 6px;
            height: 30px;
            background: #888;
            margin-left: -3px;
            pointer-events: none;
        }
        
        .bubble {
            position: absolute;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .bubble.popping {
            animation: pop 0.3s ease-out forwards;
        }
        
        @keyframes pop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); }
            100% { transform: scale(0); opacity: 0; }
        }
        
        .bubble-queue {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            align-items: center;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 20px;
        }
        
        .queue-bubble {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            transition: all 0.3s;
        }
        
        .queue-bubble:first-child {
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
        }
        
        .collectable {
            position: absolute;
            width: 24px;
            height: 24px;
            animation: fall 2s linear;
        }
        
        @keyframes fall {
            from { transform: translateY(0); }
            to { transform: translateY(500px); }
        }
        
        .coin {
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
        }
        
        .sweet {
            background: #ff69b4;
            border-radius: 5px;
        }
        
        .book {
            background: #8b4513;
            border-radius: 3px;
        }
        
        .trajectory-line {
            position: absolute;
            height: 3px;
            background: repeating-linear-gradient(
                to right,
                #ffd700,
                #ffd700 10px,
                transparent 10px,
                transparent 15px
            );
            transform-origin: left center;
            pointer-events: none;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="root">
        <div style="text-align: center; padding: 50px;">
            <h2>Loading Game...</h2>
        </div>
    </div>
    
    <script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Game quotes
        const levelStartQuotes = [
            "The stock market is a device for transferring money from the impatient to the patient.",
            "Price is what you pay. Value is what you get.",
            "Our favorite holding period is forever.",
            "Risk comes from not knowing what you're doing.",
            "Someone's sitting in the shade today because someone planted a tree a long time ago.",
            "Be fearful when others are greedy and greedy when others are fearful.",
            "The best investment you can make is in yourself.",
            "It's far better to buy a wonderful company at a fair price than a fair company at a wonderful price.",
            "Time is the friend of the wonderful company, the enemy of the mediocre.",
            "Only buy something that you'd be perfectly happy to hold if the market shut down for 10 years.",
            "Rule No. 1: Never lose money. Rule No. 2: Never forget rule No. 1.",
            "In the business world, the rearview mirror is always clearer than the windshield."
        ];
        
        const bookFacts = [
            "Compound interest is the eighth wonder of the world.",
            "Risk comes from not knowing what you're doing.",
            "Diversification is protection against ignorance.",
            "The intelligent investor is a realist who sells to optimists and buys from pessimists.",
            "In the short run, the market is a voting machine but in the long run, it is a weighing machine."
        ];
        
        // Historical stock data (simplified)
        const stockData = {
            BRK: {
                name: "Berkshire Hathaway",
                startYear: 1965,
                prices: {
                    1965: 18, 1970: 42, 1975: 38, 1980: 340, 1985: 2400,
                    1990: 6675, 1995: 25000, 2000: 55000, 2005: 85000,
                    2010: 120000, 2015: 215000, 2020: 345000, 2025: 795000
                }
            },
            DIS: {
                name: "Disney",
                startYear: 1963,
                prices: {
                    1963: 0.067, 1970: 0.16, 1975: 0.054, 1980: 1.07,
                    1985: 3.37, 1990: 6.00, 1995: 13.88, 2000: 28.50,
                    2005: 24.20, 2010: 33.80, 2015: 114.00, 2020: 144.00, 2025: 92.49
                }
            },
            KO: {
                name: "Coca-Cola",
                startYear: 1963,
                prices: {
                    1963: 0.13, 1970: 0.38, 1975: 0.46, 1980: 0.75,
                    1985: 2.90, 1990: 5.63, 1995: 18.84, 2000: 28.38,
                    2005: 20.50, 2010: 28.30, 2015: 41.50, 2020: 55.00, 2025: 58.00
                }
            },
            AAPL: {
                name: "Apple",
                startYear: 1981,
                prices: {
                    1981: 0.076, 1985: 0.048, 1990: 1.19, 1995: 1.06,
                    2000: 0.95, 2005: 5.50, 2010: 35.90, 2015: 126.60,
                    2020: 91.00, 2025: 202.52
                }
            }
        };
        
        // Bubble colors
        const bubbleColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#ff6b9d'];
        
        // Game component
        function Game() {
            const [gameState, setGameState] = useState('menu');
            const [year, setYear] = useState(1953);
            const [lives, setLives] = useState(3);
            const [coins, setCoins] = useState(250);
            const [sugar, setSugar] = useState(60);
            const [maxSugar, setMaxSugar] = useState(60);
            const [books, setBooks] = useState(0);
            const [portfolio, setPortfolio] = useState({});
            const [upgrades, setUpgrades] = useState({
                startingBubbles: 5,
                seesCandyLevel: 0,
                mungerPartner: false,
                tedTodd: false
            });
            const [currentQuote, setCurrentQuote] = useState('Welcome to Warren Buffett\'s Bubble Pop Adventure!');
            const [bubbles, setBubbles] = useState([]);
            const [cannonAngle, setCannonAngle] = useState(0);
            const [bubbleQueue, setBubbleQueue] = useState([]);
            const [scrollSpeed, setScrollSpeed] = useState(0.5);
            const [collectables, setCollectables] = useState([]);
            
            const gameRef = useRef(null);
            const animationRef = useRef(null);
            const lastTimeRef = useRef(0);
            
            // Get decade from year
            const getDecade = (year) => {
                if (!year || typeof year !== 'number') return '1950s';
                if (year <= 1959) return '1950s';
                if (year <= 1969) return '1960s';
                if (year <= 1979) return '1970s';
                if (year <= 1989) return '1980s';
                if (year <= 1999) return '1990s';
                if (year <= 2009) return '2000s';
                if (year <= 2019) return '2010s';
                return '2020s';
            };
            
            // Get bubble count for year
            const getBubbleColorCount = (year) => {
                const decade = getDecade(year);
                const counts = {
                    '1950s': [3, 4, 5],
                    '1960s': [4, 5, 6],
                    '1970s': [5, 6, 7],
                    '1980s': [5, 6, 7],
                    '1990s': [3, 4, 5],
                    '2000s': [5, 6, 7],
                    '2010s': [3, 7, 8],
                    '2020s': [6, 8, 10]
                };
                const range = counts[decade] || [3, 4, 5];
                const decadeProgress = (year % 10) / 10;
                return Math.floor(range[0] + (range[2] - range[0]) * decadeProgress);
            };
            
            // Get scroll speed for year
            const getScrollSpeed = (year) => {
                const decade = getDecade(year);
                const speeds = {
                    '1950s': 0.5, '1960s': 0.5, '1970s': 0.5, '1980s': 0.5,
                    '1990s': 1.0, '2000s': 1.0, '2010s': 1.5, '2020s': 2.0
                };
                return speeds[decade] || 0.5;
            };
            
            // Initialize level
            const initLevel = () => {
                // Ensure arrays exist
                if (!levelStartQuotes || levelStartQuotes.length === 0) {
                    setCurrentQuote("Time to start investing!");
                } else {
                    setCurrentQuote(levelStartQuotes[year % levelStartQuotes.length]);
                }
                
                setScrollSpeed(getScrollSpeed(year));
                setSugar(maxSugar);
                
                // Create initial bubble field
                const colorCount = getBubbleColorCount(year);
                const colors = bubbleColors.slice(0, Math.min(colorCount, bubbleColors.length));
                const newBubbles = [];
                
                // Create 5 rows x 20 visible columns (fill the screen)
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 20; col++) {
                        newBubbles.push({
                            id: `init-${row}-${col}`,
                            x: col * 35 + 20,
                            y: row * 35 + 20,
                            color: colors[Math.floor(Math.random() * colors.length)],
                            popping: false
                        });
                    }
                }
                
                setBubbles(newBubbles);
                
                // Create bubble queue
                const queue = [];
                for (let i = 0; i < upgrades.startingBubbles; i++) {
                    queue.push(colors[Math.floor(Math.random() * colors.length)]);
                }
                setBubbleQueue(queue);
            };
            
            // Start game
            const startGame = () => {
                try {
                    setGameState('playing');
                    initLevel();
                } catch (error) {
                    alert('Error starting game: ' + error.message);
                }
            };
            
            // Pop bubble and create collectables
            const popBubble = (bubble) => {
                // Add popping animation class
                setBubbles(prev => prev.map(b => 
                    b.id === bubble.id ? { ...b, popping: true } : b
                ));
                
                // Remove after animation
                setTimeout(() => {
                    setBubbles(prev => prev.filter(b => b.id !== bubble.id));
                }, 300);
                
                // Drop collectables
                const drops = [];
                if (Math.random() < 0.3) {
                    drops.push({
                        type: 'coin',
                        x: bubble.x,
                        y: bubble.y,
                        id: Math.random()
                    });
                }
                if (Math.random() < 0.15) {
                    drops.push({
                        type: 'sweet',
                        x: bubble.x,
                        y: bubble.y,
                        id: Math.random()
                    });
                }
                if (Math.random() < 0.05) {
                    drops.push({
                        type: 'book',
                        x: bubble.x,
                        y: bubble.y,
                        id: Math.random()
                    });
                    setCurrentQuote(bookFacts[Math.floor(Math.random() * bookFacts.length)]);
                }
                
                setCollectables(prev => [...prev, ...drops]);
                
                // Auto-collect after fall
                setTimeout(() => {
                    drops.forEach(drop => {
                        if (drop.type === 'coin') setCoins(prev => prev + 10);
                        if (drop.type === 'sweet') setSugar(prev => Math.min(prev + 10, maxSugar));
                        if (drop.type === 'book') setBooks(prev => prev + 1);
                    });
                    setCollectables(prev => prev.filter(c => !drops.find(d => d.id === c.id)));
                }, 2000);
            };
            
            // End level
            const endLevel = () => {
                if (gameState !== 'playing') return;
                setGameState('shop');
                
                // Calculate dividends
                let dividends = 0;
                Object.entries(portfolio).forEach(([stock, data]) => {
                    if (stock === 'SEES') {
                        dividends += data.shares * 50; // Simplified dividend
                    }
                });
                setCoins(prev => prev + dividends);
            };
            
            // Handle mouse/touch movement
            const handlePointerMove = (e) => {
                if (gameState !== 'playing' || !gameRef.current) return;
                
                const rect = gameRef.current.getBoundingClientRect();
                const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
                const cannonX = rect.width / 2;
                const cannonY = rect.height - 60;
                
                const angle = Math.atan2(y - cannonY, x - cannonX);
                const degrees = angle * 180 / Math.PI - 90;
                const clamped = Math.max(-89, Math.min(89, degrees));
                
                setCannonAngle(clamped);
            };
            
            // Handle shooting - ultra simplified
            const handleShoot = (e) => {
                if (gameState !== 'playing' || bubbleQueue.length === 0) return;
                
                e.preventDefault();
                
                const color = bubbleQueue[0];
                setBubbleQueue(prev => prev.slice(1));
                
                // For now, just find any matching bubble
                const matchingBubble = bubbles.find(b => b.color === color && !b.popping);
                
                if (matchingBubble) {
                    // Pop the bubble and connected ones
                    const connected = [matchingBubble];
                    const checked = new Set();
                    
                    while (connected.length > 0) {
                        const current = connected.pop();
                        if (checked.has(current.id)) continue;
                        
                        popBubble(current);
                        checked.add(current.id);
                        
                        // Find adjacent same color
                        bubbles.forEach(b => {
                            if (!checked.has(b.id) && !b.popping && b.color === color) {
                                const dx = Math.abs(b.x - current.x);
                                const dy = Math.abs(b.y - current.y);
                                if (dx <= 36 && dy <= 36) {
                                    connected.push(b);
                                }
                            }
                        });
                    }
                }
                
                // Check if level should end
                if (bubbleQueue.length === 0) {
                    setTimeout(() => endLevel(), 1500);
                }
            };
            
            // Game loop
            useEffect(() => {
                if (gameState !== 'playing') return;
                
                const gameLoop = (timestamp) => {
                    const deltaTime = timestamp - lastTimeRef.current;
                    lastTimeRef.current = timestamp;
                    
                    // Update sugar
                    if (deltaTime > 0) {
                        setSugar(prev => {
                            const newSugar = Math.max(0, prev - deltaTime / 1000);
                            if (newSugar === 0) {
                                endLevel();
                            }
                            return newSugar;
                        });
                    }
                    
                    // Scroll bubbles
                    setBubbles(prev => {
                        const colorCount = getBubbleColorCount(year);
                        const colors = bubbleColors.slice(0, colorCount);
                        
                        let updated = prev.map(bubble => ({
                            ...bubble,
                            x: bubble.x + scrollSpeed
                        }));
                        
                        // Remove bubbles that have scrolled off screen
                        updated = updated.filter(bubble => bubble.x < 800);
                        
                        // Check if we need to add new bubbles
                        const rowNeedsBubble = new Array(5).fill(false);
                        
                        // Find rightmost bubble in each row
                        for (let row = 0; row < 5; row++) {
                            const rowBubbles = updated.filter(b => Math.round((b.y - 20) / 35) === row);
                            if (rowBubbles.length === 0) {
                                rowNeedsBubble[row] = true;
                            } else {
                                const rightmost = Math.max(...rowBubbles.map(b => b.x));
                                // Add new bubble if there's enough gap from the rightmost
                                if (rightmost < 500) {
                                    rowNeedsBubble[row] = true;
                                }
                            }
                        }
                        
                        // Add new bubbles with staggered timing
                        rowNeedsBubble.forEach((needsBubble, row) => {
                            if (needsBubble) {
                                // Stagger bubble creation by row
                                const staggerOffset = row * 10;
                                updated.push({
                                    id: `${row}-new-${Date.now()}-${Math.random()}`,
                                    x: -35 - staggerOffset,
                                    y: row * 35 + 20,
                                    color: colors[Math.floor(Math.random() * colors.length)],
                                    popping: false
                                });
                            }
                        });
                        
                        return updated;
                    });
                    
                    animationRef.current = requestAnimationFrame(gameLoop);
                };
                
                animationRef.current = requestAnimationFrame(gameLoop);
                
                return () => {
                    if (animationRef.current) {
                        cancelAnimationFrame(animationRef.current);
                    }
                };
            }, [gameState, scrollSpeed, year]);
            
            // Add keyboard controls for testing
            useEffect(() => {
                const handleKeyPress = (e) => {
                    if (gameState !== 'playing') return;
                    
                    // Space bar for simple shoot
                    if (e.code === 'Space' && bubbleQueue.length > 0) {
                        e.preventDefault();
                        
                        const color = bubbleQueue[0];
                        setBubbleQueue(prev => prev.slice(1));
                        
                        // Find any matching bubble that's not already popping
                        const matches = bubbles.filter(b => b.color === color && !b.popping);
                        if (matches.length > 0) {
                            popBubble(matches[0]);
                        }
                        
                        if (bubbleQueue.length === 0) {
                            setTimeout(() => endLevel(), 1500);
                        }
                    }
                };
                
                window.addEventListener('keydown', handleKeyPress);
                return () => window.removeEventListener('keydown', handleKeyPress);
            }, [gameState, bubbleQueue, bubbles]);
            
            // Shop items
            const shopItems = [
                {
                    id: 'sees-candy',
                    name: "See's Candy",
                    desc: "Permanently increases sugar bar by 20",
                    price: 100 * Math.pow(1.5, upgrades.seesCandyLevel),
                    requires: upgrades.mungerPartner,
                    action: () => {
                        setMaxSugar(prev => prev + 20);
                        setUpgrades(prev => ({ ...prev, seesCandyLevel: prev.seesCandyLevel + 1 }));
                    }
                },
                {
                    id: 'coke',
                    name: "Coca-Cola",
                    desc: "Restores 20% sugar (consumable)",
                    price: 50,
                    action: () => {
                        setSugar(prev => Math.min(prev + maxSugar * 0.2, maxSugar));
                    }
                },
                {
                    id: 'munger-partner',
                    name: "Partner with Charlie",
                    desc: "+1 starting bubble",
                    price: 500,
                    purchased: upgrades.mungerPartner,
                    action: () => {
                        setUpgrades(prev => ({ ...prev, mungerPartner: true, startingBubbles: prev.startingBubbles + 1 }));
                    }
                },
                {
                    id: 'ted-todd',
                    name: "Ted and Todd Recruited",
                    desc: "+1 starting bubble, unlocks Apple stock",
                    price: 5000,
                    purchased: upgrades.tedTodd,
                    action: () => {
                        setUpgrades(prev => ({ ...prev, tedTodd: true, startingBubbles: prev.startingBubbles + 1 }));
                    }
                }
            ];
            
            // Buy item
            const buyItem = (item) => {
                if (coins >= item.price && !item.purchased) {
                    setCoins(prev => prev - item.price);
                    item.action();
                }
            };
            
            // Continue to investment
            const continueToInvestment = () => {
                setGameState('investment');
            };
            
            // Buy/sell stock
            const buyStock = (stockSymbol, amount = 1) => {
                const stock = stockData[stockSymbol];
                const price = stock.prices[year] || stock.prices[Math.max(...Object.keys(stock.prices).filter(y => y <= year))];
                const cost = price * amount;
                
                if (coins >= cost) {
                    setCoins(prev => prev - cost);
                    setPortfolio(prev => ({
                        ...prev,
                        [stockSymbol]: {
                            shares: (prev[stockSymbol]?.shares || 0) + amount,
                            totalInvested: (prev[stockSymbol]?.totalInvested || 0) + cost
                        }
                    }));
                }
            };
            
            const sellStock = (stockSymbol, amount = 1) => {
                const stock = stockData[stockSymbol];
                const price = stock.prices[year] || stock.prices[Math.max(...Object.keys(stock.prices).filter(y => y <= year))];
                const proceeds = price * amount;
                
                if (portfolio[stockSymbol]?.shares >= amount) {
                    setCoins(prev => prev + proceeds);
                    setPortfolio(prev => ({
                        ...prev,
                        [stockSymbol]: {
                            shares: prev[stockSymbol].shares - amount,
                            totalInvested: prev[stockSymbol].totalInvested
                        }
                    }));
                }
            };
            
            // Continue to next year
            const continueToNextYear = () => {
                const nextYear = year + 1;
                if (nextYear > 2025) {
                    // End game
                    setGameState('gameOver');
                } else {
                    setYear(nextYear);
                    if (nextYear % 10 === 0) {
                        setLives(prev => prev + 1); // Bonus life per decade
                    }
                    setGameState('playing');
                    initLevel();
                }
            };
            
            return (
                <div className="game-container">
                    {/* Main Menu */}
                    {gameState === 'menu' && (
                        <div className="menu-screen">
                            <h1 className="menu-title">Warren Buffett's<br/>Bubble Pop Adventure</h1>
                            <p className="menu-subtitle">An Investment Journey: 1951-2025</p>
                            <button className="menu-button" onClick={startGame}>Start Game</button>
                            <p style={{ marginTop: '20px', fontSize: '0.9em', opacity: 0.7 }}>
                                Click Start Game to begin your journey!
                            </p>
                        </div>
                    )}
                    
                    {/* Game Screen */}
                    <div 
                        className={`game-screen ${gameState === 'playing' ? 'active' : ''}`} 
                        ref={gameRef}
                        onMouseMove={handlePointerMove}
                        onTouchMove={handlePointerMove}
                        onClick={handleShoot}
                        onTouchStart={handleShoot}
                    >
                        <div className={`decade-border decade-${getDecade(year)}`}></div>
                        
                        <div id="gameCanvas">
                            {/* Bubbles */}
                            {bubbles.map(bubble => (
                                <div
                                    key={bubble.id}
                                    className={`bubble ${bubble.popping ? 'popping' : ''}`}
                                    style={{
                                        left: bubble.x + 'px',
                                        top: bubble.y + 'px',
                                        backgroundColor: bubble.color
                                    }}
                                />
                            ))}
                            
                            {/* Collectables */}
                            {collectables.map(item => (
                                <div
                                    key={item.id}
                                    className={`collectable ${item.type}`}
                                    style={{
                                        left: item.x + 'px',
                                        top: item.y + 'px'
                                    }}
                                />
                            ))}
                            
                            {/* Trajectory Line */}
                            {gameState === 'playing' && bubbleQueue.length > 0 && (
                                <div 
                                    className="trajectory-line"
                                    style={{
                                        bottom: '60px',
                                        left: '50%',
                                        width: '250px',
                                        transform: `translateX(-3px) rotate(${cannonAngle}deg)`,
                                        transformOrigin: '3px center'
                                    }}
                                />
                            )}
                            
                            {/* Cannon */}
                            <div className="cannon">
                                <div 
                                    className="cannon-barrel" 
                                    style={{ transform: `rotate(${cannonAngle}deg)` }}
                                />
                            </div>
                            
                            {/* Bubble queue */}
                            <div className="bubble-queue">
                                {bubbleQueue.slice(0, 5).map((color, i) => (
                                    <div
                                        key={i}
                                        className="queue-bubble"
                                        style={{ 
                                            backgroundColor: color,
                                            opacity: i === 0 ? 1 : 0.6,
                                            transform: i === 0 ? 'scale(1.2)' : 'scale(1)'
                                        }}
                                    />
                                ))}
                                {bubbleQueue.length > 5 && (
                                    <div style={{ color: '#ffd700', marginLeft: '10px' }}>+{bubbleQueue.length - 5}</div>
                                )}
                            </div>
                        </div>
                        
                        <div className="quote-box">
                            {currentQuote}
                            {gameState === 'playing' && bubbleQueue.length > 0 && (
                                <div style={{ fontSize: '0.8em', marginTop: '5px', opacity: 0.7 }}>
                                    Click to shoot â€¢ Space for quick shot
                                </div>
                            )}
                        </div>
                        
                        <div className="game-ui">
                            <div className="stat-display">
                                <span className="stat-label">Year</span>
                                <span className="stat-value">{year}</span>
                            </div>
                            
                            <div className="stat-display">
                                <span className="stat-label">Sugar</span>
                                <div className="sugar-bar">
                                    <div className="sugar-fill" style={{ width: `${(sugar / maxSugar) * 100}%` }} />
                                </div>
                            </div>
                            
                            <div className="stat-display">
                                <span className="stat-label">Bubbles</span>
                                <span className="stat-value">{bubbleQueue.length}</span>
                            </div>
                            
                            <div className="stat-display">
                                <span className="stat-label">Lives</span>
                                <span className="stat-value">{lives}</span>
                            </div>
                            
                            <div className="stat-display">
                                <span className="stat-label">Coins</span>
                                <span className="stat-value">${coins}</span>
                            </div>
                            
                            <div className="stat-display">
                                <span className="stat-label">Books</span>
                                <span className="stat-value">{books}</span>
                            </div>
                        </div>
                    </div>
                    
                    {/* Shop Screen */}
                    <div className={`shop-screen ${gameState === 'shop' ? 'active' : ''}`}>
                        <h2 className="shop-header">The Value Shop - Year {year}</h2>
                        <p style={{ textAlign: 'center', fontSize: '1.2em', color: '#ffd700', marginBottom: '20px' }}>
                            Your Coins: ${coins}
                        </p>
                        
                        <div className="shop-items">
                            {shopItems.map(item => (
                                <div key={item.id} className="shop-item">
                                    <h3 className="shop-item-name">{item.name}</h3>
                                    <p className="shop-item-desc">{item.desc}</p>
                                    <p className="shop-item-price">Price: ${Math.floor(item.price)}</p>
                                    <button
                                        className="shop-buy-button"
                                        onClick={() => buyItem(item)}
                                        disabled={coins < item.price || item.purchased || (item.requires !== undefined && !item.requires)}
                                    >
                                        {item.purchased ? 'Purchased' : 'Buy'}
                                    </button>
                                </div>
                            ))}
                        </div>
                        
                        <button className="continue-button" onClick={continueToInvestment}>
                            Continue to Investments
                        </button>
                    </div>
                    
                    {/* Investment Screen */}
                    <div className={`investment-screen ${gameState === 'investment' ? 'active' : ''}`}>
                        <h2 className="shop-header">Investment Board - {year}</h2>
                        <p style={{ textAlign: 'center', fontSize: '1.2em', color: '#ffd700', marginBottom: '20px' }}>
                            Your Coins: ${coins}
                        </p>
                        
                        <div className="stock-board">
                            {(() => {
                                const availableStocks = Object.entries(stockData).filter(([symbol, stock]) => {
                                    if (stock.startYear > year) return false;
                                    if (symbol === 'AAPL' && !upgrades.tedTodd) return false;
                                    return true;
                                });
                                
                                if (availableStocks.length === 0) {
                                    return (
                                        <div style={{ textAlign: 'center', padding: '40px', color: '#ccc' }}>
                                            <h3 style={{ color: '#ffd700', marginBottom: '20px' }}>Investment Market Closed</h3>
                                            <p>No public companies available for investment yet.</p>
                                            <p>Keep playing to unlock investment opportunities!</p>
                                            <p style={{ marginTop: '20px', fontSize: '0.9em' }}>
                                                First investments available in the 1960s.
                                            </p>
                                        </div>
                                    );
                                }
                                
                                return availableStocks.map(([symbol, stock]) => {
                                    const price = stock.prices[year] || stock.prices[Math.max(...Object.keys(stock.prices).filter(y => y <= year))];
                                    const owned = portfolio[symbol]?.shares || 0;
                                    
                                    return (
                                        <div key={symbol} className="stock-item">
                                            <div className="stock-info">
                                                <div className="stock-name">{stock.name}</div>
                                                <div className="stock-price">Price: ${price}</div>
                                                <div>Owned: {owned} shares</div>
                                            </div>
                                            <div className="stock-controls">
                                                <button 
                                                    className="stock-button"
                                                    onClick={() => buyStock(symbol)}
                                                    disabled={coins < price}
                                                >
                                                    Buy
                                                </button>
                                                <button 
                                                    className="stock-button sell"
                                                    onClick={() => sellStock(symbol)}
                                                    disabled={owned === 0}
                                                >
                                                    Sell
                                                </button>
                                            </div>
                                        </div>
                                    );
                                });
                            })()}
                        </div>
                        
                        <button className="continue-button" onClick={continueToNextYear}>
                            Continue to {year + 1}
                        </button>
                    </div>
                    
                    {/* Game Over */}
                    {gameState === 'gameOver' && (
                        <div className="menu-screen">
                            <h1 className="menu-title">Congratulations!</h1>
                            <p className="menu-subtitle">You've completed Buffett's journey!</p>
                            <div style={{ marginTop: '20px', fontSize: '1.2em' }}>
                                <p>Final Portfolio Value: ${
                                    Object.entries(portfolio).reduce((total, [symbol, data]) => {
                                        const stock = stockData[symbol];
                                        const price = stock.prices[2025] || stock.prices[Math.max(...Object.keys(stock.prices))];
                                        return total + (data.shares * price);
                                    }, 0).toFixed(0)
                                }</p>
                                <p>Total Coins: ${coins}</p>
                            </div>
                            <button className="menu-button" onClick={() => window.location.reload()}>
                                Play Again
                            </button>
                        </div>
                    )}
                </div>
            );
        }
        
        // Simple error boundary
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            
            static getDerivedStateFromError(error) {
                return { hasError: true, error: error.toString() };
            }
            
            componentDidCatch(error, errorInfo) {
                console.error('Game error:', error, errorInfo);
            }
            
            render() {
                if (this.state.hasError) {
                    return (
                        <div style={{ padding: '20px', color: 'red', textAlign: 'center' }}>
                            <h2>Something went wrong!</h2>
                            <p>{this.state.error}</p>
                            <button onClick={() => window.location.reload()}>Reload</button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }
        
        // Render the game
        ReactDOM.render(
            <ErrorBoundary>
                <Game />
            </ErrorBoundary>, 
            document.getElementById('root')
        );
    </script>
</body>
</html>
