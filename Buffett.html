<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Warren Buffett's Bubble Pop Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background: #1a1a1a;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #gameCanvas {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            display: block;
            flex: 1;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        #yearDisplay {
            font-size: 18px;
            font-weight: bold;
            color: #f39c12;
        }

        #sugarBar {
            width: 120px;
            height: 20px;
            background: #34495e;
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
        }

        #sugarFill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12);
            transition: width 0.3s ease;
        }

        #lives {
            display: flex;
            gap: 5px;
        }

        .life {
            width: 20px;
            height: 20px;
            background: #e74c3c;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        #stats {
            display: flex;
            gap: 15px;
            font-size: 12px;
        }

        #quoteBox {
            position: absolute;
            bottom: 80px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #f39c12;
            padding: 10px;
            border-radius: 10px;
            font-size: 12px;
            text-align: center;
            display: none;
        }

        #trajectoryLine {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        @media (max-width: 480px) {
            #ui {
                font-size: 12px;
                padding: 5px;
            }
            #yearDisplay {
                font-size: 16px;
            }
            #sugarBar {
                width: 80px;
                height: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div id="yearDisplay">1951</div>
            <div id="sugarBar">
                <div id="sugarFill" style="width: 100%"></div>
            </div>
            <div id="lives">
                <div class="life"></div>
                <div class="life"></div>
                <div class="life"></div>
            </div>
            <div id="stats">
                <span>Coins: <span id="coinCount">0</span></span>
                <span>Bubbles: <span id="bubbleCount">20</span></span>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="quoteBox"></div>
    </div>

    <script>
        class BubbleBuffettGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                // Game state
                this.year = 1951;
                this.sugar = 60;
                this.maxSugar = 60;
                this.lives = 3;
                this.coins = 0;
                this.bubblesRemaining = 20;
                this.gameRunning = false;
                this.isPaused = false;
                
                // Bubble system
                this.bubbles = [];
                this.activeBubble = null;
                this.nextBubbles = [];
                this.collectibles = [];
                
                // Physics
                this.bubbleRadius = 16;
                this.gridOffsetX = 0;
                this.scrollSpeed = this.getScrollSpeed();
                
                // Cannon
                this.cannon = {
                    x: 0,
                    y: 0,
                    angle: -Math.PI / 2,
                    power: 400
                };
                
                // Colors for current decade
                this.bubbleColors = this.getBubbleColors();
                this.colorPalette = [
                    '#e74c3c', '#3498db', '#2ecc71', '#f39c12', 
                    '#9b59b6', '#1abc9c', '#e67e22', '#34495e',
                    '#f1c40f', '#e91e63'
                ];
                
                // Input
                this.mousePos = { x: 0, y: 0 };
                this.isAiming = false;
                this.trajectory = [];
                
                this.setupEventListeners();
                this.initializeLevel();
                this.gameLoop();
            }
            
            setupCanvas() {
                const resize = () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight - 50; // Account for UI
                    this.cannon.x = this.canvas.width / 2;
                    this.cannon.y = this.canvas.height - 40;
                };
                
                resize();
                window.addEventListener('resize', resize);
            }
            
            getScrollSpeed() {
                const speeds = {
                    1951: 0.5, 1961: 0.5, 1971: 0.5, 1991: 1.0,
                    2001: 1.0, 2011: 1.5, 2021: 2.0
                };
                
                for (let year of Object.keys(speeds).reverse()) {
                    if (this.year >= parseInt(year)) {
                        return speeds[year];
                    }
                }
                return 0.5;
            }
            
            getBubbleColors() {
                const colorCounts = {
                    1951: [3, 4, 5], 1961: [4, 5, 6], 1971: [5, 6, 7],
                    1991: [3, 4, 5], 2001: [5, 6, 7], 2011: [3, 7, 8],
                    2021: [6, 8, 10]
                };
                
                for (let year of Object.keys(colorCounts).reverse()) {
                    if (this.year >= parseInt(year)) {
                        return colorCounts[year];
                    }
                }
                return [3, 4, 5];
            }
            
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handlePointerStart(e));
                this.canvas.addEventListener('mousemove', (e) => this.handlePointerMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handlePointerEnd(e));
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handlePointerStart(e.touches[0]);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handlePointerMove(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handlePointerEnd(e);
                });
            }
            
            getPointerPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            handlePointerStart(e) {
                if (!this.gameRunning || this.activeBubble) return;
                
                this.mousePos = this.getPointerPos(e);
                this.isAiming = true;
                this.updateCannon();
            }
            
            handlePointerMove(e) {
                if (!this.isAiming) return;
                
                this.mousePos = this.getPointerPos(e);
                this.updateCannon();
                this.calculateTrajectory();
            }
            
            handlePointerEnd(e) {
                if (!this.isAiming || this.activeBubble) return;
                
                this.isAiming = false;
                this.trajectory = [];
                this.fireBubble();
            }
            
            updateCannon() {
                const dx = this.mousePos.x - this.cannon.x;
                const dy = this.mousePos.y - this.cannon.y;
                let angle = Math.atan2(dy, dx);
                
                // Limit angle to 178 degrees (approximately -Ï€ to 0)
                const maxAngle = Math.PI * 0.1; // 18 degrees from horizontal
                const minAngle = -Math.PI + maxAngle;
                
                angle = Math.max(minAngle, Math.min(maxAngle, angle));
                this.cannon.angle = angle;
            }
            
            calculateTrajectory() {
                this.trajectory = [];
                if (!this.isAiming) return;
                
                let x = this.cannon.x;
                let y = this.cannon.y;
                let vx = Math.cos(this.cannon.angle) * this.cannon.power / 60;
                let vy = Math.sin(this.cannon.angle) * this.cannon.power / 60;
                
                for (let i = 0; i < 60; i++) {
                    x += vx;
                    y += vy;
                    
                    // Bounce off walls
                    if (x <= this.bubbleRadius || x >= this.canvas.width - this.bubbleRadius) {
                        vx = -vx;
                        x = Math.max(this.bubbleRadius, Math.min(this.canvas.width - this.bubbleRadius, x));
                    }
                    
                    this.trajectory.push({ x, y });
                    
                    if (y <= 0) break;
                }
            }
            
            initializeLevel() {
                this.bubbles = [];
                this.collectibles = [];
                this.gridOffsetX = 0;
                this.gameRunning = true;
                
                // Generate initial bubble grid
                this.generateBubbleGrid();
                
                // Prepare next bubbles
                this.nextBubbles = [];
                for (let i = 0; i < 5; i++) {
                    this.nextBubbles.push(this.getRandomBubbleColor());
                }
                
                this.showQuote("The stock market is a device for transferring money from the impatient to the patient.");
            }
            
            generateBubbleGrid() {
                const cols = 20;
                const rows = 6 + Math.floor((this.year - 1951) / 10); // Add rows as years progress
                
                for (let row = 0; row < rows; row++) {
                    const fillRate = row === 0 ? 1.0 : Math.max(0.4, 1.0 - (row * 0.1));
                    
                    for (let col = 0; col < cols; col++) {
                        if (Math.random() < fillRate) {
                            const x = col * (this.bubbleRadius * 2) + (row % 2 ? this.bubbleRadius : 0);
                            const y = row * (this.bubbleRadius * 1.7) + this.bubbleRadius;
                            
                            this.bubbles.push({
                                x: x + this.canvas.width, // Start off-screen right
                                y: y,
                                gridX: col,
                                gridY: row,
                                color: this.getRandomBubbleColor(),
                                radius: this.bubbleRadius
                            });
                        }
                    }
                }
            }
            
            getRandomBubbleColor() {
                const [min, , max] = this.bubbleColors;
                const range = max - min + 1;
                return min + Math.floor(Math.random() * range);
            }
            
            fireBubble() {
                if (this.bubblesRemaining <= 0 || this.activeBubble) return;
                
                this.activeBubble = {
                    x: this.cannon.x,
                    y: this.cannon.y,
                    vx: Math.cos(this.cannon.angle) * this.cannon.power / 60,
                    vy: Math.sin(this.cannon.angle) * this.cannon.power / 60,
                    color: this.nextBubbles.shift() || this.getRandomBubbleColor(),
                    radius: this.bubbleRadius
                };
                
                this.nextBubbles.push(this.getRandomBubbleColor());
                this.bubblesRemaining--;
                this.updateUI();
            }
            
            updateBubbles(deltaTime) {
                // Scroll existing bubbles
                this.gridOffsetX += this.scrollSpeed * deltaTime;
                
                this.bubbles.forEach(bubble => {
                    bubble.x -= this.scrollSpeed * deltaTime;
                });
                
                // Remove bubbles that have scrolled off screen
                this.bubbles = this.bubbles.filter(bubble => bubble.x > -this.bubbleRadius);
                
                // Generate new bubbles on the right side
                if (Math.random() < 0.01) { // 1% chance per frame
                    this.generateNewColumn();
                }
                
                // Update active bubble
                if (this.activeBubble) {
                    this.activeBubble.x += this.activeBubble.vx * deltaTime;
                    this.activeBubble.y += this.activeBubble.vy * deltaTime;
                    
                    // Wall bouncing
                    if (this.activeBubble.x <= this.bubbleRadius || 
                        this.activeBubble.x >= this.canvas.width - this.bubbleRadius) {
                        this.activeBubble.vx = -this.activeBubble.vx;
                        this.activeBubble.x = Math.max(this.bubbleRadius, 
                            Math.min(this.canvas.width - this.bubbleRadius, this.activeBubble.x));
                    }
                    
                    // Check collisions
                    this.checkBubbleCollisions();
                    
                    // Remove if off screen
                    if (this.activeBubble.y <= -this.bubbleRadius) {
                        this.activeBubble = null;
                    }
                }
                
                // Update collectibles
                this.collectibles.forEach(collectible => {
                    collectible.y += 100 * deltaTime; // Fall down
                    
                    // Check collection
                    if (this.distance(collectible, { x: this.cannon.x, y: this.cannon.y }) < 30) {
                        this.collectItem(collectible);
                        collectible.collected = true;
                    }
                });
                
                this.collectibles = this.collectibles.filter(c => !c.collected && c.y < this.canvas.height);
            }
            
            generateNewColumn() {
                const rows = 6 + Math.floor((this.year - 1951) / 10);
                const baseX = this.canvas.width + this.bubbleRadius;
                
                for (let row = 0; row < rows; row++) {
                    const fillRate = row === 0 ? 1.0 : Math.max(0.4, 1.0 - (row * 0.1));
                    
                    if (Math.random() < fillRate) {
                        this.bubbles.push({
                            x: baseX,
                            y: row * (this.bubbleRadius * 1.7) + this.bubbleRadius,
                            gridX: Math.floor(baseX / (this.bubbleRadius * 2)),
                            gridY: row,
                            color: this.getRandomBubbleColor(),
                            radius: this.bubbleRadius
                        });
                    }
                }
            }
            
            checkBubbleCollisions() {
                if (!this.activeBubble) return;
                
                for (let bubble of this.bubbles) {
                    if (this.distance(this.activeBubble, bubble) < this.bubbleRadius * 1.8) {
                        this.attachBubble(bubble);
                        return;
                    }
                }
            }
            
            attachBubble(nearestBubble) {
                // Find grid position for the active bubble
                const gridX = Math.round((this.activeBubble.x - (nearestBubble.gridY % 2 ? this.bubbleRadius : 0)) / (this.bubbleRadius * 2));
                const gridY = Math.round((this.activeBubble.y - this.bubbleRadius) / (this.bubbleRadius * 1.7));
                
                // Add the bubble to the grid
                const newBubble = {
                    x: gridX * (this.bubbleRadius * 2) + (gridY % 2 ? this.bubbleRadius : 0),
                    y: gridY * (this.bubbleRadius * 1.7) + this.bubbleRadius,
                    gridX: gridX,
                    gridY: Math.max(0, gridY),
                    color: this.activeBubble.color,
                    radius: this.bubbleRadius
                };
                
                this.bubbles.push(newBubble);
                this.activeBubble = null;
                
                // Check for matches
                const matches = this.findMatches(newBubble);
                if (matches.length >= 3) {
                    this.popBubbles(matches);
                }
            }
            
            findMatches(startBubble) {
                const visited = new Set();
                const matches = [];
                const stack = [startBubble];
                
                while (stack.length > 0) {
                    const bubble = stack.pop();
                    const key = `${bubble.gridX},${bubble.gridY}`;
                    
                    if (visited.has(key)) continue;
                    visited.add(key);
                    
                    if (bubble.color === startBubble.color) {
                        matches.push(bubble);
                        
                        // Check neighbors
                        const neighbors = this.getNeighbors(bubble);
                        for (let neighbor of neighbors) {
                            const neighborKey = `${neighbor.gridX},${neighbor.gridY}`;
                            if (!visited.has(neighborKey) && neighbor.color === startBubble.color) {
                                stack.push(neighbor);
                            }
                        }
                    }
                }
                
                return matches;
            }
            
            getNeighbors(bubble) {
                const neighbors = [];
                const { gridX, gridY } = bubble;
                const isEvenRow = gridY % 2 === 0;
                
                // Define neighbor offsets for hexagonal grid
                const offsets = isEvenRow ? 
                    [[-1, -1], [0, -1], [-1, 0], [1, 0], [-1, 1], [0, 1]] :
                    [[0, -1], [1, -1], [-1, 0], [1, 0], [0, 1], [1, 1]];
                
                for (let [dx, dy] of offsets) {
                    const neighborX = gridX + dx;
                    const neighborY = gridY + dy;
                    
                    const neighbor = this.bubbles.find(b => b.gridX === neighborX && b.gridY === neighborY);
                    if (neighbor) {
                        neighbors.push(neighbor);
                    }
                }
                
                return neighbors;
            }
            
            popBubbles(bubbles) {
                // Remove bubbles from array
                for (let bubble of bubbles) {
                    const index = this.bubbles.indexOf(bubble);
                    if (index !== -1) {
                        this.bubbles.splice(index, 1);
                        
                        // Create collectibles
                        if (Math.random() < 0.3) { // 30% chance for coin
                            this.createCollectible(bubble.x, bubble.y, 'coin');
                        } else if (Math.random() < 0.15) { // 15% chance for sweet
                            this.createCollectible(bubble.x, bubble.y, 'sweet');
                        } else if (Math.random() < 0.05) { // 5% chance for book
                            this.createCollectible(bubble.x, bubble.y, 'book');
                        }
                    }
                }
                
                // Check for floating bubbles and remove them
                this.removeFloatingBubbles();
            }
            
            removeFloatingBubbles() {
                const connected = new Set();
                const stack = [];
                
                // Find all bubbles connected to the top row
                for (let bubble of this.bubbles) {
                    if (bubble.gridY === 0) {
                        stack.push(bubble);
                    }
                }
                
                while (stack.length > 0) {
                    const bubble = stack.pop();
                    const key = `${bubble.gridX},${bubble.gridY}`;
                    
                    if (connected.has(key)) continue;
                    connected.add(key);
                    
                    const neighbors = this.getNeighbors(bubble);
                    for (let neighbor of neighbors) {
                        const neighborKey = `${neighbor.gridX},${neighbor.gridY}`;
                        if (!connected.has(neighborKey)) {
                            stack.push(neighbor);
                        }
                    }
                }
                
                // Remove floating bubbles
                const floating = this.bubbles.filter(bubble => 
                    !connected.has(`${bubble.gridX},${bubble.gridY}`)
                );
                
                for (let bubble of floating) {
                    const index = this.bubbles.indexOf(bubble);
                    if (index !== -1) {
                        this.bubbles.splice(index, 1);
                        this.createCollectible(bubble.x, bubble.y, 'coin');
                    }
                }
            }
            
            createCollectible(x, y, type) {
                this.collectibles.push({
                    x, y, type,
                    vx: (Math.random() - 0.5) * 100,
                    vy: -50,
                    collected: false
                });
            }
            
            collectItem(collectible) {
                switch (collectible.type) {
                    case 'coin':
                        this.coins += 10;
                        break;
                    case 'sweet':
                        this.sugar = Math.min(this.maxSugar, this.sugar + 10);
                        break;
                    case 'book':
                        this.coins += 50;
                        this.showQuote("Knowledge compounds faster than money.");
                        break;
                }
                this.updateUI();
            }
            
            distance(a, b) {
                const dx = a.x - b.x;
                const dy = a.y - b.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            updateGameState(deltaTime) {
                // Deplete sugar
                this.sugar -= deltaTime;
                if (this.sugar <= 0) {
                    this.endLevel(false);
                    return;
                }
                
                // Check win condition (all bubbles cleared or reached end)
                if (this.bubbles.length === 0) {
                    this.endLevel(true);
                    return;
                }
                
                // Check lose condition (no bubbles remaining)
                if (this.bubblesRemaining <= 0 && !this.activeBubble) {
                    this.endLevel(false);
                    return;
                }
                
                this.updateUI();
            }
            
            endLevel(won) {
                this.gameRunning = false;
                
                if (won) {
                    this.year++;
                    this.showQuote(`Year ${this.year - 1} completed! Moving to ${this.year}.`);
                    
                    // Reset for next level
                    setTimeout(() => {
                        this.sugar = this.maxSugar;
                        this.bubblesRemaining = 20 + Math.floor((this.year - 1951) / 5);
                        this.bubbleColors = this.getBubbleColors();
                        this.scrollSpeed = this.getScrollSpeed();
                        this.initializeLevel();
                    }, 2000);
                } else {
                    this.lives--;
                    if (this.lives <= 0) {
                        this.showQuote("Game Over! Warren says: 'It's only when the tide goes out that you learn who's been swimming naked.'");
                        setTimeout(() => this.restartGame(), 3000);
                    } else {
                        this.showQuote("Life lost! Try again.");
                        setTimeout(() => {
                            this.sugar = this.maxSugar;
                            this.bubblesRemaining = 20;
                            this.initializeLevel();
                        }, 2000);
                    }
                }
                
                this.updateUI();
            }
            
            restartGame() {
                this.year = 1951;
                this.sugar = 60;
                this.lives = 3;
                this.coins = 0;
                this.bubblesRemaining = 20;
                this.bubbleColors = this.getBubbleColors();
                this.scrollSpeed = this.getScrollSpeed();
                this.initializeLevel();
            }
            
            showQuote(text) {
                const quoteBox = document.getElementById('quoteBox');
                quoteBox.textContent = text;
                quoteBox.style.display = 'block';
                
                setTimeout(() => {
                    quoteBox.style.display = 'none';
                }, 3000);
            }
            
            updateUI() {
                document.getElementById('yearDisplay').textContent = this.year;
                document.getElementById('sugarFill').style.width = `${(this.sugar / this.maxSugar) * 100}%`;
                document.getElementById('coinCount').textContent = this.coins;
                document.getElementById('bubbleCount').textContent = this.bubblesRemaining;
                
                // Update lives display
                const livesContainer = document.getElementById('lives');
                livesContainer.innerHTML = '';
                for (let i = 0; i < this.lives; i++) {
                    const life = document.createElement('div');
                    life.className = 'life';
                    livesContainer.appendChild(life);
                }
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = 'rgba(44, 62, 80, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid bubbles
                for (let bubble of this.bubbles) {
                    this.drawBubble(bubble.x, bubble.y, bubble.radius, bubble.color);
                }
                
                // Draw active bubble
                if (this.activeBubble) {
                    this.drawBubble(this.activeBubble.x, this.activeBubble.y, 
                        this.activeBubble.radius, this.activeBubble.color);
                }
                
                // Draw trajectory
                if (this.isAiming && this.trajectory.length > 0) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.cannon.x, this.cannon.y);
                    for (let point of this.trajectory) {
                        this.ctx.lineTo(point.x, point.y);
                    }
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                // Draw cannon
                this.drawCannon();
                
                // Draw next bubbles queue
                this.drawNextBubbles();
                
                // Draw collectibles
                for (let collectible of this.collectibles) {
                    this.drawCollectible(collectible);
                }
            }
            
            drawBubble(x, y, radius, colorIndex) {
                const color = this.colorPalette[colorIndex % this.colorPalette.length];
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.fillStyle = color;
                this.ctx.fill();
                
                // Add highlight
                this.ctx.beginPath();
                this.ctx.arc(x - radius * 0.3, y - radius * 0.3, radius * 0.3, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.fill();
                
                this.ctx.strokeStyle = '#2c3e50';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }
            
            drawCannon() {
                this.ctx.save();
                this.ctx.translate(this.cannon.x, this.cannon.y);
                this.ctx.rotate(this.cannon.angle);
                
                // Cannon body
                this.ctx.fillStyle = '#34495e';
                this.ctx.fillRect(-5, -15, 30, 10);
                
                // Cannon base
                this.ctx.beginPath();
                this.ctx.arc(0, 0, 20, 0, Math.PI * 2);
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fill();
                
                this.ctx.restore();
            }
            
            drawNextBubbles() {
                for (let i = 0; i < Math.min(3, this.nextBubbles.length); i++) {
                    const x = this.canvas.width - 40;
                    const y = this.canvas.height - 120 + (i * 35);
                    this.drawBubble(x, y, 12, this.nextBubbles[i]);
                }
            }
            
            drawCollectible(collectible) {
                let color, symbol;
                switch (collectible.type) {
                    case 'coin':
                        color = '#f1c40f';
                        symbol = '$';
                        break;
                    case 'sweet':
                        color = '#e74c3c';
                        symbol = 'â™¥';
                        break;
                    case 'book':
                        color = '#3498db';
                        symbol = 'ðŸ“–';
                        break;
                }
                
                this.ctx.beginPath();
                this.ctx.arc(collectible.x, collectible.y, 8, 0, Math.PI * 2);
                this.ctx.fillStyle = color;
                this.ctx.fill();
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(symbol, collectible.x, collectible.y + 4);
            }
            
            gameLoop() {
                const now = Date.now();
                const deltaTime = this.lastTime ? (now - this.lastTime) / 1000 : 0;
                this.lastTime = now;
                
                if (this.gameRunning && !this.isPaused) {
                    this.updateBubbles(deltaTime);
                    this.updateGameState(deltaTime);
                }
                
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            new BubbleBuffettGame();
        });
    </script>
</body>
</html>
