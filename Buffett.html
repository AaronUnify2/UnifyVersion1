<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Warren Buffett's Bubble Pop Investment Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            max-width: 414px;
            margin: 0 auto;
            background: #111;
            position: relative;
        }
        
        #game-canvas {
            flex: 1;
            touch-action: none;
            position: relative;
            min-height: 400px;
        }
        
        .ui-header {
            background: linear-gradient(to bottom, #1a1a1a, #0a0a0a);
            padding: 8px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 12px;
            border-bottom: 2px solid #333;
        }
        
        .ui-header-item {
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #333;
            text-align: center;
        }
        
        .ui-header-item span {
            display: block;
            font-weight: bold;
            margin-top: 2px;
        }
        
        .books { color: #5DADE2; }
        .year { color: #F39C12; }
        .cash { color: #52BE80; }
        .portfolio { color: #AF7AC5; }
        
        .ui-footer {
            background: linear-gradient(to top, #1a1a1a, #0a0a0a);
            padding: 8px;
            border-top: 2px solid #333;
        }
        
        .sugar-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .sugar-bar-container {
            flex: 1;
            height: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            border: 1px solid #333;
            overflow: hidden;
            position: relative;
        }
        
        .sugar-bar-fill {
            height: 100%;
            background: linear-gradient(to right, #E74C3C, #F39C12);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }
        
        .game-stats {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }
        
        .game-stat {
            background: rgba(0, 0, 0, 0.6);
            padding: 4px 12px;
            border-radius: 4px;
            border: 1px solid #333;
        }
        
        .quote-box {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            padding: 12px;
            margin: 8px;
            border-radius: 4px;
            font-size: 13px;
            font-style: italic;
            text-align: center;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .quote-author {
            position: absolute;
            bottom: 4px;
            right: 8px;
            font-size: 11px;
            color: #888;
            font-style: normal;
        }
        
        .trajectory-debug {
            position: absolute;
            top: 50%;
            left: 10px;
            font-size: 10px;
            color: #666;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Game constants
        const GAME_WIDTH = window.innerWidth > 414 ? 414 : window.innerWidth;
        const GAME_HEIGHT = window.innerHeight * 0.6;
        const BUBBLE_RADIUS = 0.5;
        const CANNON_BASE_Y = -8;
        const MR_MARKET_X = 18;
        const BUBBLE_COLORS = {
            red: 0xff4444,
            blue: 0x4444ff,
            green: 0x44ff44,
            yellow: 0xffff44,
            purple: 0xff44ff,
            orange: 0xff8844
        };
        
        // Market data from doc
        const MARKET_DATA = {
            1960: 'Normal', 1961: 'Normal', 1962: 'Normal', 1963: 'Normal', 1964: 'Normal',
            1965: 'Normal', 1966: 'Normal', 1967: 'Normal', 1968: 'Normal', 1969: 'Normal',
            1970: 'Normal', 1971: 'Normal', 1972: 'Normal', 1973: 'Normal', 1974: 'Bear',
            1975: 'Bull', 1976: 'Normal', 1977: 'Normal', 1978: 'Normal', 1979: 'Normal',
            1980: 'Normal', 1981: 'Normal', 1982: 'Normal', 1983: 'Bull', 1984: 'Normal',
            1985: 'Bull', 1986: 'Bull', 1987: 'Normal', 1988: 'Normal', 1989: 'Bull',
            1990: 'Normal', 1991: 'Bull', 1992: 'Normal', 1993: 'Normal', 1994: 'Normal',
            1995: 'Bull', 1996: 'Bull', 1997: 'Bull', 1998: 'Normal', 1999: 'Bull',
            2000: 'Normal', 2001: 'Normal', 2002: 'Normal', 2003: 'Bull', 2004: 'Normal',
            2005: 'Normal', 2006: 'Normal', 2007: 'Normal', 2008: 'Bear', 2009: 'Normal',
            2010: 'Normal', 2011: 'Normal', 2012: 'Normal', 2013: 'Bull', 2014: 'Normal',
            2015: 'Normal', 2016: 'Normal', 2017: 'Bull', 2018: 'Normal', 2019: 'Bull',
            2020: 'Normal', 2021: 'Normal', 2022: 'Normal', 2023: 'Normal', 2024: 'Normal'
        };
        
        // Buffett quotes
        const BUFFETT_QUOTES = [
            "Rule No. 1: Never lose money. Rule No. 2: Never forget rule No. 1.",
            "It's far better to buy a wonderful company at a fair price than a fair company at a wonderful price.",
            "Price is what you pay. Value is what you get.",
            "Risk comes from not knowing what you're doing.",
            "Our favorite holding period is forever."
        ];
        
        class BubbleGame {
            constructor(container) {
                this.container = container;
                this.year = 1960;
                this.sugar = 30;
                this.cash = 0;
                this.books = 5;
                this.shots = 3;
                this.marketState = MARKET_DATA[this.year];
                this.bubbles = [];
                this.trajectoryPoints = [];
                this.cannonAngle = 0;
                this.nextBubbleColors = ['red', 'blue', 'green'];
                this.currentBubbleColor = 'red';
                this.isAiming = false;
                this.aimStart = { x: 0, y: 0 };
                
                this.init();
            }
            
            init() {
                // Setup Three.js scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);
                
                // Camera setup
                const aspect = GAME_WIDTH / GAME_HEIGHT;
                this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 100);
                this.camera.position.set(0, 0, 30);
                this.camera.lookAt(0, 0, 0);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true 
                });
                this.renderer.setSize(GAME_WIDTH, GAME_HEIGHT);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.container.appendChild(this.renderer.domElement);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                const pointLight = new THREE.PointLight(0xffffff, 0.5);
                pointLight.position.set(-10, 5, 10);
                this.scene.add(pointLight);
                
                // Create glass bubble material
                this.bubbleMaterial = new THREE.MeshPhysicalMaterial({
                    roughness: 0.1,
                    metalness: 0.1,
                    transmission: 0.9,
                    thickness: 0.5,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.0,
                    ior: 1.5,
                    envMapIntensity: 1,
                });
                
                // Create cannon
                this.createCannon();
                
                // Create Mr. Market building
                this.createMrMarket();
                
                // Create trajectory line
                this.createTrajectoryLine();
                
                // Setup controls
                this.setupControls();
                
                // Start game loop
                this.animate();
            }
            
            createCannon() {
                const cannonGroup = new THREE.Group();
                
                // Base
                const baseGeometry = new THREE.CylinderGeometry(1.5, 2, 1, 8);
                const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = CANNON_BASE_Y;
                base.castShadow = true;
                cannonGroup.add(base);
                
                // Barrel
                const barrelGeometry = new THREE.CylinderGeometry(0.6, 0.8, 3, 8);
                const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
                this.barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                this.barrel.position.y = CANNON_BASE_Y + 1;
                this.barrel.castShadow = true;
                cannonGroup.add(this.barrel);
                
                // Current bubble preview
                const bubbleGeometry = new THREE.SphereGeometry(BUBBLE_RADIUS, 32, 16);
                this.currentBubble = new THREE.Mesh(bubbleGeometry, this.bubbleMaterial.clone());
                this.currentBubble.material.color = new THREE.Color(BUBBLE_COLORS[this.currentBubbleColor]);
                this.currentBubble.position.y = CANNON_BASE_Y + 2.5;
                cannonGroup.add(this.currentBubble);
                
                this.cannonGroup = cannonGroup;
                this.scene.add(cannonGroup);
            }
            
            createMrMarket() {
                const buildingGroup = new THREE.Group();
                
                // Simple pixel art style building
                const buildingGeometry = new THREE.BoxGeometry(4, 8, 3);
                const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0x333366 });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(MR_MARKET_X, 0, 0);
                building.castShadow = true;
                building.receiveShadow = true;
                buildingGroup.add(building);
                
                // Windows
                const windowGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.1);
                const windowMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffaa,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.3
                });
                
                for (let y = -2; y <= 2; y += 2) {
                    for (let x = -1; x <= 1; x += 2) {
                        const window = new THREE.Mesh(windowGeometry, windowMaterial);
                        window.position.set(MR_MARKET_X - 2.05, y, x);
                        buildingGroup.add(window);
                    }
                }
                
                // Market state indicator
                const indicatorGeometry = new THREE.BoxGeometry(3, 1, 0.1);
                const indicatorMaterial = new THREE.MeshStandardMaterial({ 
                    color: this.getMarketColor(),
                    emissive: this.getMarketColor(),
                    emissiveIntensity: 0.5
                });
                this.marketIndicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                this.marketIndicator.position.set(MR_MARKET_X - 2.05, 4.5, 0);
                buildingGroup.add(this.marketIndicator);
                
                this.mrMarketGroup = buildingGroup;
                this.scene.add(buildingGroup);
            }
            
            createTrajectoryLine() {
                const points = [];
                for (let i = 0; i < 20; i++) {
                    points.push(new THREE.Vector3(0, 0, 0));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    opacity: 0.3,
                    transparent: true
                });
                
                this.trajectoryLine = new THREE.Line(geometry, material);
                this.scene.add(this.trajectoryLine);
            }
            
            updateTrajectory() {
                if (!this.isAiming) {
                    this.trajectoryLine.visible = false;
                    return;
                }
                
                this.trajectoryLine.visible = true;
                const positions = this.trajectoryLine.geometry.attributes.position;
                
                // Calculate trajectory
                const startPos = new THREE.Vector3(0, CANNON_BASE_Y + 2.5, 0);
                const angle = this.cannonAngle;
                const speed = 15;
                const gravity = -9.8;
                
                for (let i = 0; i < 20; i++) {
                    const t = i * 0.05;
                    const x = Math.sin(angle) * speed * t;
                    const y = startPos.y + Math.cos(angle) * speed * t + 0.5 * gravity * t * t;
                    
                    positions.setXYZ(i, x, y, 0);
                    
                    // Stop if we hit the top
                    if (y > 8) break;
                }
                
                positions.needsUpdate = true;
            }
            
            setupControls() {
                const canvas = this.renderer.domElement;
                
                // Touch/Mouse controls
                canvas.addEventListener('touchstart', this.handleStart.bind(this), { passive: false });
                canvas.addEventListener('touchmove', this.handleMove.bind(this), { passive: false });
                canvas.addEventListener('touchend', this.handleEnd.bind(this), { passive: false });
                
                canvas.addEventListener('mousedown', this.handleStart.bind(this));
                canvas.addEventListener('mousemove', this.handleMove.bind(this));
                canvas.addEventListener('mouseup', this.handleEnd.bind(this));
            }
            
            handleStart(e) {
                e.preventDefault();
                this.isAiming = true;
                const point = e.touches ? e.touches[0] : e;
                this.aimStart = { x: point.clientX, y: point.clientY };
            }
            
            handleMove(e) {
                if (!this.isAiming) return;
                e.preventDefault();
                
                const point = e.touches ? e.touches[0] : e;
                const deltaX = point.clientX - this.aimStart.x;
                
                // Convert to angle (-89 to 89 degrees)
                this.cannonAngle = Math.max(-1.55, Math.min(1.55, deltaX * 0.01));
                
                // Update barrel rotation
                this.barrel.rotation.z = -this.cannonAngle;
                this.currentBubble.position.x = Math.sin(this.cannonAngle) * 2;
                this.currentBubble.position.y = CANNON_BASE_Y + 2.5 + Math.cos(this.cannonAngle) * 2;
                
                this.updateTrajectory();
            }
            
            handleEnd(e) {
                if (!this.isAiming) return;
                e.preventDefault();
                
                this.isAiming = false;
                this.fireBubble();
            }
            
            fireBubble() {
                if (this.shots <= 0) return;
                
                this.shots--;
                
                // Create new bubble
                const bubbleGeometry = new THREE.SphereGeometry(BUBBLE_RADIUS, 32, 16);
                const bubbleMaterial = this.bubbleMaterial.clone();
                bubbleMaterial.color = new THREE.Color(BUBBLE_COLORS[this.currentBubbleColor]);
                
                const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                bubble.position.copy(this.currentBubble.position);
                bubble.userData = {
                    color: this.currentBubbleColor,
                    velocity: new THREE.Vector3(
                        Math.sin(this.cannonAngle) * 15,
                        Math.cos(this.cannonAngle) * 15,
                        0
                    ),
                    active: true
                };
                
                this.bubbles.push(bubble);
                this.scene.add(bubble);
                
                // Update next bubble
                this.currentBubbleColor = this.nextBubbleColors.shift();
                this.nextBubbleColors.push(this.getRandomColor());
                this.currentBubble.material.color = new THREE.Color(BUBBLE_COLORS[this.currentBubbleColor]);
                
                // Reset cannon
                this.cannonAngle = 0;
                this.barrel.rotation.z = 0;
                this.currentBubble.position.x = 0;
                
                // Notify UI update
                if (this.onUpdate) this.onUpdate();
            }
            
            getRandomColor() {
                const colors = Object.keys(BUBBLE_COLORS);
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            getMarketColor() {
                switch (this.marketState) {
                    case 'Bull': return 0x00ff00;
                    case 'Bear': return 0xff0000;
                    default: return 0x0088ff;
                }
            }
            
            spawnBubbleFromMarket() {
                const geometry = new THREE.SphereGeometry(BUBBLE_RADIUS, 32, 16);
                const material = this.bubbleMaterial.clone();
                const color = this.getRandomColor();
                material.color = new THREE.Color(BUBBLE_COLORS[color]);
                
                const bubble = new THREE.Mesh(geometry, material);
                bubble.position.set(
                    MR_MARKET_X - 2,
                    Math.random() * 6 - 3,
                    Math.random() * 2 - 1
                );
                bubble.userData = {
                    color: color,
                    velocity: new THREE.Vector3(-2, 0, 0),
                    fromMarket: true,
                    active: false
                };
                
                this.bubbles.push(bubble);
                this.scene.add(bubble);
            }
            
            updateBubbles(deltaTime) {
                const gravity = -9.8;
                
                for (let i = this.bubbles.length - 1; i >= 0; i--) {
                    const bubble = this.bubbles[i];
                    const data = bubble.userData;
                    
                    if (data.active) {
                        // Apply physics to fired bubbles
                        data.velocity.y += gravity * deltaTime;
                        bubble.position.add(data.velocity.clone().multiplyScalar(deltaTime));
                        
                        // Wall bouncing
                        if (Math.abs(bubble.position.x) > 20) {
                            data.velocity.x *= -0.8;
                            bubble.position.x = Math.sign(bubble.position.x) * 20;
                        }
                        
                        // Check if bubble reached top or fell too far
                        if (bubble.position.y > 10 || bubble.position.y < -15) {
                            this.scene.remove(bubble);
                            this.bubbles.splice(i, 1);
                        }
                    } else if (data.fromMarket) {
                        // Market bubbles flow left
                        bubble.position.add(data.velocity.clone().multiplyScalar(deltaTime));
                        
                        // Remove if off screen
                        if (bubble.position.x < -25) {
                            this.scene.remove(bubble);
                            this.bubbles.splice(i, 1);
                        }
                    }
                }
            }
            
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                const deltaTime = 0.016; // 60fps
                
                // Update sugar
                this.sugar = Math.max(0, this.sugar - deltaTime);
                
                // Update bubbles
                this.updateBubbles(deltaTime);
                
                // Spawn new bubbles from market
                if (Math.random() < this.getSpawnRate() * deltaTime) {
                    this.spawnBubbleFromMarket();
                }
                
                // Update UI
                if (this.onUpdate) this.onUpdate();
                
                // Render
                this.renderer.render(this.scene, this.camera);
            }
            
            getSpawnRate() {
                switch (this.marketState) {
                    case 'Bull': return 1.0;
                    case 'Bear': return 0.2;
                    default: return 0.33;
                }
            }
        }
        
        // React UI Component
        const GameUI = () => {
            const [gameState, setGameState] = useState({
                year: 1960,
                sugar: 30,
                cash: 0,
                books: 5,
                shots: 3,
                portfolio: 0,
                quote: BUFFETT_QUOTES[0],
                quoteAuthor: "Warren Buffett"
            });
            
            const canvasRef = useRef(null);
            const gameRef = useRef(null);
            
            useEffect(() => {
                if (canvasRef.current && !gameRef.current) {
                    // Ensure container has proper dimensions
                    const rect = canvasRef.current.getBoundingClientRect();
                    console.log('Initializing game with dimensions:', rect.width, rect.height);
                    
                    gameRef.current = new BubbleGame(canvasRef.current);
                    
                    // Update callback
                    gameRef.current.onUpdate = () => {
                        setGameState({
                            year: gameRef.current.year,
                            sugar: gameRef.current.sugar,
                            cash: gameRef.current.cash,
                            books: gameRef.current.books,
                            shots: gameRef.current.shots,
                            portfolio: 0,
                            quote: BUFFETT_QUOTES[Math.floor(Math.random() * BUFFETT_QUOTES.length)],
                            quoteAuthor: "Warren Buffett"
                        });
                    };
                }
                
                return () => {
                    if (gameRef.current && gameRef.current.renderer) {
                        gameRef.current.renderer.dispose();
                    }
                };
            }, []);
            
            const sugarPercentage = (gameState.sugar / 30) * 100;
            
            return (
                <div id="game-container">
                    <div className="ui-header">
                        <div className="ui-header-item">
                            <span className="books">📚 {gameState.books}</span>
                            BOOKS
                        </div>
                        <div className="ui-header-item">
                            <span className="year">{gameState.year}</span>
                            YEAR
                        </div>
                        <div className="ui-header-item">
                            <span className="cash">${gameState.cash.toFixed(2)}</span>
                            CASH
                        </div>
                        <div className="ui-header-item">
                            <span className="portfolio">${gameState.portfolio.toFixed(2)}</span>
                            PORTFOLIO
                        </div>
                    </div>
                    
                    <div ref={canvasRef} id="game-canvas"></div>
                    
                    <div className="ui-footer">
                        <div className="sugar-bar">
                            <span>Sugar:</span>
                            <div className="sugar-bar-container">
                                <div 
                                    className="sugar-bar-fill" 
                                    style={{ width: `${sugarPercentage}%` }}
                                />
                            </div>
                        </div>
                        
                        <div className="game-stats">
                            <div className="game-stat">
                                Next: <span style={{color: '#5DADE2'}}>●●●</span>
                            </div>
                            <div className="game-stat">
                                Shots: {gameState.shots}
                            </div>
                        </div>
                    </div>
                    
                    <div className="quote-box">
                        "{gameState.quote}"
                        <span className="quote-author">- {gameState.quoteAuthor}</span>
                    </div>
                </div>
            );
        };
        
        // Render the game when DOM is ready
        window.addEventListener('DOMContentLoaded', () => {
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<GameUI />);
        });
    </script>
</body>
</html>
