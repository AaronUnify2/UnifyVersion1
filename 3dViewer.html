<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Terrain Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
        }

        .main-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #2a2a2a;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .header-title {
            color: white;
            font-size: 20px;
            font-weight: 600;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .header-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .header-btn:hover {
            background: #66BB6A;
        }

        .header-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .header-btn.secondary {
            background: #2196F3;
        }

        .header-btn.secondary:hover {
            background: #42A5F5;
        }

        #viewer3d {
            flex: 1;
            width: 100%;
            position: relative;
        }

        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #888;
        }

        .empty-state h2 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #aaa;
        }

        .empty-state p {
            font-size: 16px;
            margin-bottom: 20px;
        }

        .empty-state button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
        }

        .empty-state button:hover {
            background: #66BB6A;
        }

        /* Toast notification */
        .toast {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 2000;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
        }

        .loading-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 8px;
            z-index: 10001;
            display: none;
            text-align: center;
        }

        .loading-overlay.show {
            display: block;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2196F3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .viewer-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 10002;
            display: none;
        }

        /* View controls panel */
        .view-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 10003;
            max-width: 250px;
            display: none;
        }

        .view-controls h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }

        .control-item {
            margin: 8px 0;
        }

        .control-item label {
            display: inline-block;
            width: 100px;
        }

        .control-item input[type="range"] {
            width: 120px;
        }

        .control-item button {
            margin: 3px 3px 3px 0;
            padding: 6px 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .control-item button:hover {
            background: #45a049;
        }

        .control-item button:active {
            background: #3d8b40;
        }

        /* Touch controls */
        #touchControls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none;
            z-index: 10004;
        }

        #dpad {
            position: relative;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .dpad-btn {
            position: absolute;
            width: 45px;
            height: 45px;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            transition: all 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .dpad-btn:active {
            background: rgba(76, 175, 80, 0.9);
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        #dpad-up { top: 5px; left: 52.5px; }
        #dpad-down { bottom: 5px; left: 52.5px; }
        #dpad-left { left: 5px; top: 52.5px; }
        #dpad-right { right: 5px; top: 52.5px; }
        #dpad-center { 
            left: 52.5px; 
            top: 52.5px; 
            background: rgba(100, 150, 255, 0.8); 
            font-size: 16px; 
        }
        #dpad-center:active { 
            background: rgba(100, 150, 255, 1); 
        }

        /* Show touch controls on mobile */
        @media (hover: none) and (pointer: coarse) {
            #touchControls {
                display: block !important;
            }
            .viewer-controls {
                font-size: 10px;
                padding: 8px 12px;
            }
            .view-controls {
                font-size: 11px;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <div class="header-title">üóª 3D Terrain Viewer</div>
            <div class="header-buttons">
                <button id="loadDataBtn" class="header-btn">üìÇ Load Terrain Data</button>
                <button id="saveDataBtn" class="header-btn secondary" style="display: none;">üíæ Save Data</button>
            </div>
        </div>
        
        <div id="viewer3d">
            <div id="emptyState" class="empty-state">
                <h2>No Terrain Loaded</h2>
                <p>Upload a terrain JSON file to view it in 3D</p>
                <button onclick="document.getElementById('fileInput').click()">üìÇ Load Terrain Data</button>
            </div>
            
            <div class="viewer-controls">
                üñ±Ô∏è Mouse: Rotate/Pan/Zoom | ‚å®Ô∏è Arrows/WASD: Move | Space: Reset
            </div>
            
            <!-- View Controls Panel -->
            <div class="view-controls" id="viewControls">
                <h4>View Settings</h4>
                <div class="control-item">
                    <label>Vertical Scale:</label>
                    <input type="range" id="verticalScale" min="0.1" max="5" step="0.1" value="0.1">
                    <span id="scaleValue">0.1</span>
                </div>
                <div class="control-item">
                    <label>Wireframe:</label>
                    <input type="checkbox" id="wireframeToggle">
                </div>
                <div class="control-item">
                    <button id="resetViewBtn">Reset View</button>
                    <button id="topViewBtn">Top View</button>
                </div>
                <div class="control-item">
                    <button id="autoRotateBtn">Auto Rotate</button>
                    <button id="touchUIBtn">Touch UI</button>
                </div>
            </div>

            <!-- Touch Controls -->
            <div id="touchControls">
                <div id="dpad">
                    <div class="dpad-btn" id="dpad-up">‚Üë</div>
                    <div class="dpad-btn" id="dpad-down">‚Üì</div>
                    <div class="dpad-btn" id="dpad-left">‚Üê</div>
                    <div class="dpad-btn" id="dpad-right">‚Üí</div>
                    <div class="dpad-btn" id="dpad-center">‚óè</div>
                </div>
            </div>
        </div>

        <input type="file" id="fileInput" accept=".json" style="display: none;">
    </div>

    <div id="toast" class="toast"></div>

    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner"></div>
        <div>Loading terrain data...</div>
    </div>

    <script>
        // Store current terrain data for saving
        let currentTerrainData = null;
        let currentScene = null;

        // Toast notification function
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        // Save terrain data to JSON file
        function saveTerrainData() {
            if (!currentTerrainData) {
                showToast('No terrain data to save');
                return;
            }
            
            const dataStr = JSON.stringify(currentTerrainData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `terrain-data-${new Date().getTime()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Terrain data saved!');
        }

        // Load terrain data from JSON file
        function loadTerrainData(file) {
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.classList.add('show');
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (!data.elevationData || !data.width || !data.height || !data.bottomLeft || !data.topRight) {
                        showToast('Invalid terrain data file');
                        loadingOverlay.classList.remove('show');
                        return;
                    }
                    
                    // Convert back to Float32Array
                    const elevationData = new Float32Array(data.elevationData);
                    
                    // Create 3D visualization
                    create3DTerrain(elevationData, data.width, data.height, data.bottomLeft, data.topRight);
                    
                    // Store as current data
                    currentTerrainData = data;
                    
                    // Show save button
                    document.getElementById('saveDataBtn').style.display = 'inline-block';
                    
                    // Hide empty state
                    document.getElementById('emptyState').style.display = 'none';
                    
                    showToast('Terrain data loaded!');
                } catch (error) {
                    showToast('Error loading terrain data file');
                } finally {
                    loadingOverlay.classList.remove('show');
                }
            };
            
            reader.readAsText(file);
        }

        // Create 3D terrain visualization
        function create3DTerrain(elevationData, width, height, bottomLeft, topRight) {
            const container = document.getElementById('viewer3d');
            
            // Clear previous 3D content if exists
            if (currentScene) {
                const canvas = container.querySelector('canvas');
                if (canvas) {
                    canvas.remove();
                }
            }
            
            // Movement and camera state
            const movement = { 
                forward: false, backward: false, 
                left: false, right: false, 
                up: false, down: false 
            };
            let autoRotate = false;
            let cameraRotation = { theta: 0, phi: Math.PI / 4 };
            let cameraDistance = 0;
            let cameraTarget = new THREE.Vector3(0, 0, 0);
            let originalHeightData = [];
            
            // Setup Three.js scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            currentScene = scene;
            
            const camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                10000
            );
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Find elevation range for scaling
            let minElev = Infinity;
            let maxElev = -Infinity;
            for (let i = 0; i < elevationData.length; i++) {
                if (elevationData[i] > -9999 && elevationData[i] !== 0) {
                    minElev = Math.min(minElev, elevationData[i]);
                    maxElev = Math.max(maxElev, elevationData[i]);
                }
            }
            
            // If all values are zero or invalid, create a test terrain
            if (minElev === Infinity || maxElev === -Infinity || minElev === maxElev) {
                minElev = 0;
                maxElev = 100;
                for (let i = 0; i < elevationData.length; i++) {
                    elevationData[i] = Math.sin(i / 10) * 50 + 50;
                }
            }
            
            const elevRange = maxElev - minElev;
            const scale = Math.max(width, height) / 100;
            const verticalExaggeration = 0.1;
            
            // Create geometry
            const geometry = new THREE.PlaneGeometry(
                width * scale,
                height * scale,
                width - 1,
                height - 1
            );
            
            const vertices = geometry.attributes.position.array;
            
            // Apply elevation data and store original heights
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const idx = i * width + j;
                    const vertIdx = (i * width + j) * 3;
                    
                    let elevation = elevationData[idx];
                    if (elevation < -9999) elevation = minElev;
                    
                    const normalizedHeight = ((elevation - minElev) / elevRange) * verticalExaggeration * scale * 50;
                    vertices[vertIdx + 2] = normalizedHeight;
                    originalHeightData.push(normalizedHeight);
                }
            }
            
            geometry.computeVertexNormals();
            
            // Create material with vertex colors based on elevation
            const colors = new Float32Array(vertices.length);
            for (let i = 0; i < vertices.length; i += 3) {
                const height = vertices[i + 2];
                const normalized = height / (verticalExaggeration * scale * 50);
                
                let r, g, b;
                if (normalized < 0.25) {
                    r = 0.2;
                    g = 0.5 + normalized * 2;
                    b = 0.3;
                } else if (normalized < 0.5) {
                    r = 0.3 + (normalized - 0.25) * 2;
                    g = 0.7;
                    b = 0.2;
                } else if (normalized < 0.75) {
                    r = 0.7 + (normalized - 0.5) * 0.8;
                    g = 0.7 - (normalized - 0.5) * 1.2;
                    b = 0.2;
                } else {
                    r = 0.5 + (normalized - 0.75) * 0.8;
                    g = 0.4 - (normalized - 0.75) * 0.8;
                    b = 0.2;
                }
                
                colors[i] = r;
                colors[i + 1] = g;
                colors[i + 2] = b;
            }
            
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                flatShading: false,
                shininess: 10,
                side: THREE.DoubleSide
            });
            
            const terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            scene.add(terrain);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Setup camera
            const maxDim = Math.max(width * scale, height * scale);
            const cameraStartDistance = maxDim * 1.5;
            cameraDistance = cameraStartDistance;
            
            function updateCameraFromState() {
                const distance = cameraDistance;
                const x = cameraTarget.x + distance * Math.sin(cameraRotation.phi) * Math.cos(cameraRotation.theta);
                const y = cameraTarget.y + distance * Math.cos(cameraRotation.phi);
                const z = cameraTarget.z + distance * Math.sin(cameraRotation.phi) * Math.sin(cameraRotation.theta);
                
                camera.position.set(x, y, z);
                camera.lookAt(cameraTarget);
            }
            
            updateCameraFromState();
            
            // Mouse controls
            let isDragging = false;
            let isPanning = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    isDragging = true;
                } else if (e.button === 2) {
                    isPanning = true;
                }
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                e.preventDefault();
            });
            
            renderer.domElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
                isPanning = false;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!isDragging && !isPanning) return;
                
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                
                if (isDragging) {
                    cameraRotation.theta -= dx * 0.005;
                    cameraRotation.phi -= dy * 0.005;
                    cameraRotation.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraRotation.phi));
                    updateCameraFromState();
                } else if (isPanning) {
                    const panSpeed = 0.5;
                    const dir = new THREE.Vector3();
                    const right = new THREE.Vector3();
                    
                    camera.getWorldDirection(dir);
                    dir.y = 0;
                    dir.normalize();
                    right.crossVectors(dir, new THREE.Vector3(0, 1, 0)).normalize();
                    
                    cameraTarget.sub(right.multiplyScalar(dx * panSpeed));
                    cameraTarget.add(dir.multiplyScalar(dy * panSpeed));
                    updateCameraFromState();
                }
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.5;
                cameraDistance = Math.max(scale * 50, Math.min(scale * 500, cameraDistance));
                updateCameraFromState();
            });
            
            // Touch controls
            let lastTouch = { x: 0, y: 0, dist: 0 };
            
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouch.dist = Math.sqrt(dx * dx + dy * dy);
                }
            });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const dx = e.touches[0].clientX - lastTouch.x;
                    const dy = e.touches[0].clientY - lastTouch.y;
                    cameraRotation.theta -= dx * 0.01;
                    cameraRotation.phi -= dy * 0.01;
                    cameraRotation.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraRotation.phi));
                    updateCameraFromState();
                    lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    cameraDistance += (lastTouch.dist - dist) * 0.5;
                    cameraDistance = Math.max(scale * 50, Math.min(scale * 500, cameraDistance));
                    updateCameraFromState();
                    lastTouch.dist = dist;
                }
            });
            
            // Keyboard controls
            function onKeyDown(e) {
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') movement.forward = true;
                if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') movement.backward = true;
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') movement.left = true;
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') movement.right = true;
                if (e.key === 'q' || e.key === 'Q') movement.up = true;
                if (e.key === 'e' || e.key === 'E') movement.down = true;
                if (e.key === ' ') {
                    e.preventDefault();
                    resetView();
                }
            }

            function onKeyUp(e) {
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') movement.forward = false;
                if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') movement.backward = false;
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') movement.left = false;
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') movement.right = false;
                if (e.key === 'q' || e.key === 'Q') movement.up = false;
                if (e.key === 'e' || e.key === 'E') movement.down = false;
            }
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Store cleanup function
            window.cleanup3DViewer = function() {
                document.removeEventListener('keydown', onKeyDown);
                document.removeEventListener('keyup', onKeyUp);
            };
            
            // Movement update function
            function updateMovement() {
                const moveSpeed = 0.5;
                const dir = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                camera.getWorldDirection(dir);
                dir.y = 0;
                dir.normalize();
                right.crossVectors(dir, new THREE.Vector3(0, 1, 0)).normalize();
                
                if (movement.forward) cameraTarget.add(dir.multiplyScalar(moveSpeed));
                if (movement.backward) cameraTarget.sub(dir.multiplyScalar(moveSpeed));
                if (movement.left) cameraTarget.sub(right.multiplyScalar(moveSpeed));
                if (movement.right) cameraTarget.add(right.multiplyScalar(moveSpeed));
                if (movement.up) cameraTarget.y += moveSpeed;
                if (movement.down) cameraTarget.y -= moveSpeed;
                
                if (Object.values(movement).some(v => v)) {
                    updateCameraFromState();
                }
            }
            
            // Touch D-pad controls
            function setupDPad() {
                const dpadControls = {
                    'dpad-up': 'forward',
                    'dpad-down': 'backward',
                    'dpad-left': 'left',
                    'dpad-right': 'right',
                    'dpad-center': 'up'
                };
                
                Object.entries(dpadControls).forEach(([id, dir]) => {
                    const btn = document.getElementById(id);
                    if (btn) {
                        const start = () => { movement[dir] = true; };
                        const stop = () => { movement[dir] = false; };
                        
                        btn.addEventListener('touchstart', (e) => { e.preventDefault(); start(); });
                        btn.addEventListener('touchend', (e) => { e.preventDefault(); stop(); });
                        btn.addEventListener('mousedown', (e) => { e.preventDefault(); start(); });
                        btn.addEventListener('mouseup', (e) => { e.preventDefault(); stop(); });
                    }
                });
            }
            
            setupDPad();
            
            // Ensure touch controls are visible on mobile devices
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                const tc = document.getElementById('touchControls');
                if (window.getComputedStyle(tc).display === 'none') {
                    tc.style.display = 'block';
                }
            }
            
            // View control functions
            function resetView() {
                cameraRotation = { theta: 0, phi: Math.PI / 4 };
                cameraDistance = cameraStartDistance;
                cameraTarget.set(0, 0, 0);
                updateCameraFromState();
            }
            
            function topView() {
                cameraRotation = { theta: 0, phi: 0.01 };
                cameraDistance = cameraStartDistance * 1.5;
                cameraTarget.set(0, 0, 0);
                updateCameraFromState();
            }
            
            function toggleAutoRotate() {
                autoRotate = !autoRotate;
            }
            
            function toggleTouchUI() {
                const tc = document.getElementById('touchControls');
                const computedDisplay = window.getComputedStyle(tc).display;
                
                if (computedDisplay === 'none') {
                    tc.style.display = 'block';
                } else {
                    tc.style.display = 'none';
                }
            }
            
            // Vertical scale control
            function updateVerticalScale(value) {
                const newScale = parseFloat(value);
                document.getElementById('scaleValue').textContent = newScale.toFixed(1);
                
                const vertices = geometry.attributes.position.array;
                for (let i = 0; i < originalHeightData.length; i++) {
                    vertices[i * 3 + 2] = originalHeightData[i] * (newScale / verticalExaggeration);
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
            }
            
            // Wireframe toggle
            function toggleWireframe(checked) {
                material.wireframe = checked;
            }
            
            // Add event listeners for controls
            const resetBtn = document.getElementById('resetViewBtn');
            const topBtn = document.getElementById('topViewBtn');
            const autoBtn = document.getElementById('autoRotateBtn');
            const touchBtn = document.getElementById('touchUIBtn');
            const scaleSlider = document.getElementById('verticalScale');
            const wireframeCheck = document.getElementById('wireframeToggle');
            
            if (resetBtn) resetBtn.addEventListener('click', resetView);
            if (topBtn) topBtn.addEventListener('click', topView);
            if (autoBtn) autoBtn.addEventListener('click', toggleAutoRotate);
            if (touchBtn) touchBtn.addEventListener('click', toggleTouchUI);
            if (scaleSlider) scaleSlider.addEventListener('input', (e) => updateVerticalScale(e.target.value));
            if (wireframeCheck) wireframeCheck.addEventListener('change', (e) => toggleWireframe(e.target.checked));
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                updateMovement();
                
                if (autoRotate && !Object.values(movement).some(v => v)) {
                    cameraRotation.theta += 0.002;
                    updateCameraFromState();
                }
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Show controls
            document.querySelector('.viewer-controls').style.display = 'block';
            document.getElementById('viewControls').style.display = 'block';
            
            // Handle window resize
            const resizeHandler = () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            };
            window.addEventListener('resize', resizeHandler);
        }

        // Event listeners
        document.getElementById('loadDataBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        
        document.getElementById('saveDataBtn').addEventListener('click', saveTerrainData);
        
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadTerrainData(e.target.files[0]);
            }
        });
    </script>
</body>
</html>
