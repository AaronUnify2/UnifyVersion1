<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unify V2</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            /* Dark Theme Variables (Default) */
            --bg-color: #0a0d16;
            --section-bg: #151826;
            --form-bg: #1f2336;
            --border-color: #303545;
            --input-bg: #2a2f45;
            --input-border: #3a4057;
            --text-color: #ffffff;
            --text-secondary: #c0c7db;
            --btn-bg: #4CAF50;
            --btn-delete-bg: #e24136;
            --btn-secondary-bg: #32374a;
            --btn-help-bg: #3a75c4;
            --header-bg: #151826;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        /* Light Theme Variables */
        .light-theme {
            --bg-color: #f0e6d2;
            --section-bg: #e6d9bc;
            --form-bg: #d9ccb0;
            --border-color: #b3a68c;
            --input-bg: #f5eee0;
            --input-border: #c7b798;
            --text-color: #472d0f;
            --text-secondary: #664518;
            --btn-bg: #4a7746;
            --btn-delete-bg: #a83232;
            --btn-secondary-bg: #947c58;
            --btn-help-bg: #2d5986;
            --header-bg: #daccae;
            --box-shadow: 0 4px 8px rgba(71, 45, 15, 0.2);
        }

        * {
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .fixed-header {
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
            background-color: var(--header-bg);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--box-shadow);
        }

        .app-title {
            font-size: 1.5rem;
            margin: 0;
        }

        .header-controls {
            display: flex;
            gap: 15px;
        }

        .main-container {
            max-width: 800px;
            margin: 70px auto 20px;
            padding: 0 20px;
            width: 100%;
        }

        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .section {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 20px;
            background-color: var(--section-bg);
            box-shadow: var(--box-shadow);
            overflow: hidden;
            backdrop-filter: blur(5px);
            background: rgba(21, 24, 38, 0.85);
        }

        .section-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            font-weight: bold;
        }

        .section-title-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-content {
            display: none;
            padding: 20px;
        }

        .section-content.active {
            display: block;
        }

        .form-container, .list-container {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            background-color: var(--form-bg);
            margin-bottom: 15px;
            backdrop-filter: blur(5px);
            background: rgba(31, 35, 54, 0.9);
        }

        label {
            display: block;
            margin-bottom: 12px;
        }

        input[type="text"], select, textarea {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            border-radius: 4px;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
        }

        input[type="radio"] {
            margin-right: 5px;
        }

        .difficulty-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 5px;
        }

        .difficulty-option {
            display: flex;
            align-items: center;
        }

        button {
            padding: 10px 15px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
        }

        button:hover {
            opacity: 0.9;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: scale(0.98);
        }

        .btn-add {
            background-color: var(--btn-bg);
            margin-top: 15px;
            width: 100%;
        }

        .btn-delete {
            background-color: var(--btn-delete-bg);
        }

        .btn-secondary {
            background-color: var(--btn-secondary-bg);
        }

        .btn-help {
            background-color: var(--btn-help-bg);
            padding: 5px 10px;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-toggle {
            background-color: rgba(42, 47, 69, 0.7);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 5px;
            backdrop-filter: blur(5px);
        }

        .btn-quick-nav {
            background-color: var(--btn-bg);
            color: white;
            padding: 8px 10px;
            font-size: 14px;
        }

        .description {
            margin-top: 10px;
            color: var(--text-secondary);
            font-style: italic;
        }

        .help-content {
            display: none;
            padding: 15px;
            margin-top: 15px;
            border-radius: 6px;
            background-color: var(--form-bg);
            border: 1px solid var(--border-color);
            backdrop-filter: blur(5px);
            background: rgba(31, 35, 54, 0.9);
        }

        .help-content.active {
            display: block;
        }

        .list-item {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: var(--form-bg);
            backdrop-filter: blur(8px);
            background: rgba(31, 35, 54, 0.85);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .list-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        .list-item-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            font-weight: bold;
        }

        .list-item-content {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }

        .list-item-content.active {
            display: block;
        }

        .list-item-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 10px 0;
            font-size: 0.9rem;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .meta-item i {
            width: 20px;
            text-align: center;
        }

        .sort-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .sort-controls button {
            flex: 1;
            min-width: 80px;
            padding: 8px 10px;
            font-size: 0.9rem;
        }

        .sort-controls button.active {
            background-color: var(--btn-help-bg);
        }

        .chart-container {
            height: 250px;
            margin-bottom: 20px;
        }

        .stats-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-box {
            flex: 1;
            min-width: 160px;
            padding: 15px;
            border-radius: 6px;
            background-color: var(--form-bg);
            border: 1px solid var(--border-color);
            text-align: center;
            backdrop-filter: blur(8px);
            background: rgba(31, 35, 54, 0.85);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .stat-box:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin: 10px 0;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .btn-calendar {
            background-color: #4285F4;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .count-badge {
            background-color: var(--btn-bg);
            color: white;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.75rem;
            margin-left: 10px;
        }

        /* Responsive styles */
        @media (max-width: 600px) {
            .stats-row {
                flex-direction: column;
            }
            
            .stat-box {
                width: 100%;
            }
            
            .difficulty-options {
                flex-direction: column;
                gap: 8px;
            }
        }

        #theme-toggle-icon {
            margin-right: 5px;
        }

        .toggle-arrow {
            transition: transform 0.3s;
        }

        .toggle-arrow.open {
            transform: rotate(180deg);
        }

        .item-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-btn {
            flex: 1;
        }

        #jump-to-input {
            margin-right: 10px;
        }

        /* Enhanced visual styles */
        .glow-effect {
            position: relative;
        }

        .glow-effect::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 10px;
            background: linear-gradient(45deg, #4CAF50, transparent, #3a75c4);
            z-index: -1;
            filter: blur(8px);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .glow-effect:hover::after {
            opacity: 0.7;
        }

        .cosmic-dust {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><rect width="200" height="200" fill="none"/><circle cx="50" cy="50" r="0.5" fill="rgba(255,255,255,0.3)"/><circle cx="100" cy="25" r="0.5" fill="rgba(255,255,255,0.3)"/><circle cx="150" cy="90" r="0.5" fill="rgba(255,255,255,0.3)"/><circle cx="70" cy="120" r="0.5" fill="rgba(255,255,255,0.3)"/><circle cx="180" cy="160" r="0.5" fill="rgba(255,255,255,0.3)"/><circle cx="30" cy="180" r="0.5" fill="rgba(255,255,255,0.3)"/><circle cx="120" cy="60" r="0.5" fill="rgba(255,255,255,0.3)"/></svg>');
            z-index: -1;
            opacity: 0.3;
        }

        /* Loading animation */
        .cosmic-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 1;
            transition: opacity 1s ease-out;
        }

        .cosmic-loader.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader-planet {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(45deg, #3a75c4, #4CAF50);
            position: relative;
            animation: pulse 2s infinite;
        }

        .loader-orbit {
            position: absolute;
            top: -25px;
            left: -25px;
            width: 100px;
            height: 100px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            animation: rotate 4s linear infinite;
        }

        .loader-moon {
            position: absolute;
            top: -5px;
            left: 45px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #e0e0e0;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 10px rgba(58, 117, 196, 0.5); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(58, 117, 196, 0.8); }
            100% { transform: scale(1); box-shadow: 0 0 10px rgba(58, 117, 196, 0.5); }
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading animation -->
    <div class="cosmic-loader" id="cosmic-loader">
        <div class="loader-container">
            <div class="loader-planet"></div>
            <div class="loader-orbit">
                <div class="loader-moon"></div>
            </div>
        </div>
    </div>

    <!-- Cosmic dust overlay -->
    <div class="cosmic-dust"></div>

    <!-- Fixed Header -->
    <div class="fixed-header">
        <h1 class="app-title">Unify</h1>
        <div class="header-controls">
            <button id="jump-to-input" class="btn-quick-nav glow-effect" title="Jump to problem input">
                <i class="fas fa-arrow-down"></i> Input Problem
            </button>
            <button id="theme-toggle" class="btn-toggle">
                <i id="theme-toggle-icon" class="fas fa-moon"></i>
                <span id="theme-toggle-text">Dark Mode</span>
            </button>
            <button id="help-button" class="btn-help">?</button>
        </div>
    </div>

    <!-- Help Content -->
    <div id="help-content" class="help-content">
        <h2 style="text-align: center;">Unify: Your Path to Targeted Self-Improvement</h2>
        <p>How Unify Works:</p>
        <ol>
            <li><strong>Input Problems:</strong> Identify and rate problems causing negative emotions in different life areas.</li>
            <li><strong>Problems List:</strong> Review your problems and set achievable goals to address them.</li>
            <li><strong>Goals List:</strong> Create goals and identify tasks needed to accomplish them.</li>
            <li><strong>Tasks List:</strong> Break down goals into specific actionable tasks with required resources.</li>
            <li><strong>Dashboard:</strong> Track your progress and gain insights on your journey to self-improvement.</li>
        </ol>
        <hr>
        <p>The core concept of Unify is transforming negative emotions associated with problems into motivation and positive change. The process naturally guides you to solutions that actually work, to solve your self-defined problems, in a way you are motivated to implement.</p>
    </div>

    <!-- Background Canvas for Animations -->
    <canvas id="background-canvas"></canvas>

    <!-- Main Container -->
    <div class="main-container">
        <!-- SECTION 1: Dashboard & Insights -->
        <div class="section" id="section-dashboard">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-chart-line"></i>
                    <span>Dashboard & Insights</span>
                </div>
                <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <!-- Stats Summary -->
                <div class="stats-row">
                    <div class="stat-box glow-effect">
                        <div class="stat-label">Problems</div>
                        <div class="stat-value" id="stats-problems">0</div>
                    </div>
                    <div class="stat-box glow-effect">
                        <div class="stat-label">Goals</div>
                        <div class="stat-value" id="stats-goals">0</div>
                    </div>
                    <div class="stat-box glow-effect">
                        <div class="stat-label">Tasks</div>
                        <div class="stat-value" id="stats-tasks">0</div>
                    </div>
                    <div class="stat-box glow-effect">
                        <div class="stat-label">Completed Tasks</div>
                        <div class="stat-value" id="stats-completed">0</div>
                    </div>
                </div>

                <!-- Problem Analysis -->
                <h3>Problem Analysis</h3>
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-label">Problems by Area</div>
                        <div class="chart-container">
                            <canvas id="chart-problems-area"></canvas>
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Problem Difficulty by Area</div>
                        <div class="chart-container">
                            <canvas id="chart-difficulty-area"></canvas>
                        </div>
                    </div>
                </div>
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-label">Problems by Emotion</div>
                        <div class="chart-container">
                            <canvas id="chart-problems-emotion"></canvas>
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Problem Difficulty by Emotion</div>
                        <div class="chart-container">
                            <canvas id="chart-difficulty-emotion"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Goal Analysis -->
                <h3>Goal Analysis</h3>
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-label">Goals by Area</div>
                        <div class="chart-container">
                            <canvas id="chart-goals-area"></canvas>
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Goal Difficulty by Area</div>
                        <div class="chart-container">
                            <canvas id="chart-goals-difficulty-area"></canvas>
                        </div>
                    </div>
                </div>
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-label">Goals by Emotion</div>
                        <div class="chart-container">
                            <canvas id="chart-goals-emotion"></canvas>
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Goal Difficulty by Emotion</div>
                        <div class="chart-container">
                            <canvas id="chart-goals-difficulty-emotion"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SECTION 2: Tasks List -->
        <div class="section" id="section-tasks">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-tasks"></i>
                    <span>Tasks</span>
                    <span class="count-badge" id="tasks-count">0</span>
                </div>
                <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <div id="tasks-list" class="list-container">
                    <!-- Tasks will be loaded here dynamically -->
                </div>
            </div>
        </div>

        <!-- SECTION 3: Completed Tasks -->
        <div class="section" id="section-completed">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-check-circle"></i>
                    <span>Completed Tasks</span>
                    <span class="count-badge" id="completed-count">0</span>
                </div>
                <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <div id="completed-list" class="list-container">
                    <!-- Completed tasks will be loaded here dynamically -->
                </div>
            </div>
        </div>

        <!-- SECTION 4: Goals List -->
        <div class="section" id="section-goals">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-bullseye"></i>
                    <span>Goals</span>
                    <span class="count-badge" id="goals-count">0</span>
                </div>
                <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <div class="sort-controls">
                    <button class="btn-secondary active" onclick="sortGoals('recent')">Recent</button>
                    <button class="btn-secondary" onclick="sortGoals('area')">Area</button>
                    <button class="btn-secondary" onclick="sortGoals('emotion')">Emotion</button>
                    <button class="btn-secondary" onclick="sortGoals('difficulty')">Difficulty</button>
                </div>
                <div id="goals-list" class="list-container">
                    <!-- Goals will be loaded here dynamically -->
                </div>
            </div>
        </div>

        <!-- SECTION 5: Problems List -->
        <div class="section" id="section-problems">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-exclamation-circle"></i>
                    <span>Problems</span>
                    <span class="count-badge" id="problems-count">0</span>
                </div>
                <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <div class="sort-controls">
                    <button class="btn-secondary active" onclick="sortProblems('recent')">Recent</button>
                    <button class="btn-secondary" onclick="sortProblems('area')">Area</button>
                    <button class="btn-secondary" onclick="sortProblems('emotion')">Emotion</button>
                    <button class="btn-secondary" onclick="sortProblems('difficulty')">Difficulty</button>
                </div>
                <div id="problems-list" class="list-container">
                    <!-- Problems will be loaded here dynamically -->
                </div>
            </div>
        </div>

        <!-- SECTION 6: Input Problem -->
        <div class="section" id="section-input">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-plus-circle"></i>
                    <span>Input Problem</span>
                </div>
                <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <div class="form-container">
                    <form id="problem-form">
                        <label>
                            Problem:
                            <input type="text" id="problem-input" placeholder="Describe your problem">
                        </label>
                        <label>
                            Area:
                            <select id="problem-area">
                                <option value="Diet">Diet</option>
                                <option value="Family">Family</option>
                                <option value="Fitness">Fitness</option>
                                <option value="Health">Health</option>
                                <option value="Home">Home</option>
                                <option value="Parenting">Parenting</option>
                                <option value="Personal">Personal</option>
                                <option value="Relationship">Relationship</option>
                                <option value="Sleep">Sleep</option>
                                <option value="Social Life">Social Life</option>
                                <option value="Study">Study</option>
                                <option value="Work">Work</option>
                            </select>
                        </label>
                        <label>
                            Emotion:
                            <select id="problem-emotion">
                                <option value="Annoyed">Annoyed</option>
                                <option value="Anxious">Anxious</option>
                                <option value="Bored">Bored</option>
                                <option value="Depressed">Depressed</option>
                                <option value="Distracted">Distracted</option>
                                <option value="Disapproving">Disapproving</option>
                                <option value="Disassociated">Disassociated</option>
                                <option value="Embarrassed">Embarrassed</option>
                                <option value="Envy">Envy</option>
                                <option value="Guilty">Guilty</option>
                                <option value="Impatient">Impatient</option>
                                <option value="Insecure">Insecure</option>
                                <option value="Let Down">Let Down</option>
                                <option value="Lonely">Lonely</option>
                                <option value="Offended">Offended</option>
                                <option value="Physical Pain">Physical Pain</option>
                                <option value="Stressed">Stressed</option>
                                <option value="Tired">Tired</option>
                                <option value="Vulnerable">Vulnerable</option>
                            </select>
                        </label>
        

                <label>
                           <label> Difficulty: <div class="difficulty-options"> <div class="difficulty-option"> <input type="radio" name="problem-difficulty" id="difficulty-1" value="1"> <label for="difficulty-1">1 - Fixable now</label> </div> <div class="difficulty-option"> <input type="radio" name="problem-difficulty" id="difficulty-2" value="2"> <label for="difficulty-2">2 - Fixable soon</label> </div> <div class="difficulty-option"> <input type="radio" name="problem-difficulty" id="difficulty-3" value="3"> <label for="difficulty-3">3 - Fixable with resources</label> </div>
                                <div class="difficulty-option">
                                    <input type="radio" name="problem-difficulty" id="difficulty-4" value="4">
                                    <label for="difficulty-4">4 - Fixable with resources and skills</label>
                                </div>
                                <div class="difficulty-option">
                                    <input type="radio" name="problem-difficulty" id="difficulty-5" value="5">
                                    <label for="difficulty-5">5 - Requires resources, skills, and cooperation</label>
                                </div>
                            </div>
                        </label>
                        <div id="problem-description" class="description"></div>
                        <button type="button" id="add-problem-btn" class="btn-add glow-effect">Add Problem</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let isDarkTheme = true;
        let renderer, scene, camera, composer;
        let particles, goalObjects, problemObjects, taskObjects;
        let animationId;
        let stars = [];
        let nebulas = [];
        let shootingStars = [];
        let galaxyCenter;
        let clock = new THREE.Clock();
        
        // Celestial objects for new Enhanced Background
        let starField, nebulae, centralSun, dustParticles;
        let galaxyRotation = 0;
        let lastShootingStarTime = 0;
        
        const problemDescriptions = {
            1: "Fixable now",
            2: "Fixable soon",
            3: "Fixable with the right resources",
            4: "Fixable with the right resources and skills",
            5: "Fixable with the right resources, skills, and cooperation from other people"
        };
        const goalDescriptions = {
            1: "Achievable now",
            2: "Achievable soon",
            3: "Achievable with the right resources",
            4: "Achievable with the right resources and skills",
            5: "Achievable with the right resources, skills, and cooperation from other people"
        };

        // Emotion colors mapping for visualization
        const emotionColors = {
            'Annoyed': 0xffa500,     // Orange
            'Anxious': 0x9370db,      // Purple
            'Bored': 0xa9a9a9,        // Gray
            'Depressed': 0x4b0082,    // Indigo
            'Distracted': 0xadd8e6,   // Light Blue
            'Disapproving': 0x8b0000, // Dark Red
            'Disassociated': 0xf5f5f5, // White
            'Embarrassed': 0xff69b4,  // Pink
            'Envy': 0x32cd32,         // Lime Green
            'Guilty': 0x8b4513,       // Brown
            'Impatient': 0xffa07a,    // Light Salmon
            'Insecure': 0xff6347,     // Tomato
            'Let Down': 0x6a5acd,     // Slate Blue
            'Lonely': 0x87ceeb,       // Sky Blue
            'Offended': 0xcd5c5c,     // Indian Red
            'Physical Pain': 0xff0000, // Red
            'Stressed': 0xffd700,     // Gold
            'Tired': 0x2f4f4f,        // Dark Slate Gray
            'Vulnerable': 0x98fb98    // Pale Green
        };
        
        // Goal emotion colors
        const goalEmotionColors = {
            'Meaningful': 0x4CAF50, // Green
            'Neutral': 0x2196F3,    // Blue
            'Difficult': 0xF44336   // Red
        };

        // DOM Ready Event
        document.addEventListener('DOMContentLoaded', function() {
            // Hide loader after 1.5 seconds
            setTimeout(() => {
                document.getElementById('cosmic-loader').classList.add('hidden');
            }, 1500);
            
            // Initialize UI event listeners
            initEventListeners();
            
            // Initialize Three.js visualization
            initThreeJS();
            
            // Load data from localStorage
            loadData();
            
            // Add sample items if empty
            addSampleItems();
            
            // Update stats and counters
            updateStats();
            updateCounts();
            
            // Initialize difficulty description display
            document.querySelectorAll('input[name="problem-difficulty"]').forEach(radio => {
                radio.addEventListener('change', updateProblemDescription);
            });
            
            // Focus problem input
            document.getElementById('problem-input').focus();
        });

        // Initialize event listeners
        function initEventListeners() {
            // Toggle sections
            document.querySelectorAll('.section-title').forEach(title => {
                title.addEventListener('click', toggleSection);
            });
            
            // Help button
            document.getElementById('help-button').addEventListener('click', toggleHelp);
            
            // Theme toggle
            document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
            
            // Jump to input button
            document.getElementById('jump-to-input').addEventListener('click', jumpToInput);
            
            // Add problem button
            document.getElementById('add-problem-btn').addEventListener('click', addProblem);
        }

        // Toggle section visibility
        function toggleSection(e) {
            if (e.target.classList.contains('btn-secondary')) return;
            
            const section = this.closest('.section');
            const content = section.querySelector('.section-content');
            const arrow = this.querySelector('.toggle-arrow');
            
            content.classList.toggle('active');
            arrow.classList.toggle('open');
            
            if (content.classList.contains('active')) {
                arrow.classList.add('fa-chevron-up');
                arrow.classList.remove('fa-chevron-down');
            } else {
                arrow.classList.add('fa-chevron-down');
                arrow.classList.remove('fa-chevron-up');
            }
        }

        // Toggle help content
        function toggleHelp() {
            const helpContent = document.getElementById('help-content');
            helpContent.classList.toggle('active');
        }

        // Toggle theme (Dark/Light)
        function toggleTheme() {
            isDarkTheme = !isDarkTheme;
            
            if (isDarkTheme) {
                document.body.classList.remove('light-theme');
                document.getElementById('theme-toggle-icon').className = 'fas fa-moon';
                document.getElementById('theme-toggle-text').textContent = 'Dark Mode';
            } else {
                document.body.classList.add('light-theme');
                document.getElementById('theme-toggle-icon').className = 'fas fa-sun';
                document.getElementById('theme-toggle-text').textContent = 'Light Mode';
            }
            
            // Reinitialize Three.js scene based on new theme
            resetThreeJS();
        }

        // Jump to problem input section
        function jumpToInput() {
            const inputSection = document.getElementById('section-input');
            const content = inputSection.querySelector('.section-content');
            const arrow = inputSection.querySelector('.toggle-arrow');
            
            // Open the section if closed
            if (!content.classList.contains('active')) {
                content.classList.add('active');
                arrow.classList.add('open');
                arrow.classList.add('fa-chevron-up');
                arrow.classList.remove('fa-chevron-down');
            }
            
            // Scroll to the section
            inputSection.scrollIntoView({ behavior: 'smooth' });
            
            // Focus the input field
            setTimeout(() => {
                document.getElementById('problem-input').focus();
            }, 500);
        }

        // Update problem description based on selected difficulty
        function updateProblemDescription() {
            const selectedDifficulty = document.querySelector('input[name="problem-difficulty"]:checked')?.value;
            const descriptionElement = document.getElementById('problem-description');
            
            if (selectedDifficulty) {
                descriptionElement.textContent = problemDescriptions[selectedDifficulty];
            } else {
                descriptionElement.textContent = '';
            }
        }

        // Add a new problem
        function addProblem() {
            const problemInput = document.getElementById('problem-input').value.trim();
            const problemArea = document.getElementById('problem-area').value;
            const problemEmotion = document.getElementById('problem-emotion').value;
            const problemDifficulty = document.querySelector('input[name="problem-difficulty"]:checked')?.value;
            
            if (!problemInput) {
                alert('Please enter a problem description.');
                return;
            }
            
            if (!problemDifficulty) {
                alert('Please select a difficulty level.');
                return;
            }
            
            const problem = {
                id: Date.now().toString(),
                problemInput,
                problemArea,
                problemEmotion,
                problemDifficulty,
                timestamp: Date.now()
            };
            
            // Save to localStorage
            let problems = JSON.parse(localStorage.getItem('problems')) || [];
            problems.push(problem);
            localStorage.setItem('problems', JSON.stringify(problems));
            
            // Reset form
            document.getElementById('problem-form').reset();
            document.getElementById('problem-description').textContent = '';
            
            // Update UI
            renderProblems();
            updateStats();
            updateCounts();
            
            // Add object to 3D scene
            addProblemObject(problem);
            
            // Show success message
            alert('Problem added successfully!');
        }

        // Render problems list
        function renderProblems() {
            const problems = JSON.parse(localStorage.getItem('problems')) || [];
            const problemsList = document.getElementById('problems-list');
            
            problemsList.innerHTML = '';
            
            if (problems.length === 0) {
                problemsList.innerHTML = '<p>No problems added yet. Use the Input Problem section to add problems.</p>';
                return;
            }
            
            problems.forEach(problem => {
                const listItem = document.createElement('div');
                listItem.className = 'list-item';
                listItem.innerHTML = `
                    <div class="list-item-title">
                        <span>${problem.problemInput}</span>
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="list-item-meta">
                        <div class="meta-item"><i class="fas fa-folder"></i> ${problem.problemArea}</div>
                        <div class="meta-item"><i class="fas fa-heart-broken"></i> ${problem.problemEmotion}</div>
                        <div class="meta-item"><i class="fas fa-star"></i> Difficulty: ${problem.problemDifficulty}</div>
                    </div>
                    <div class="list-item-content">
                        <form id="goal-form-${problem.id}">
                            <label>
                                Goal:
                                <input type="text" id="goal-input-${problem.id}" placeholder="Create a goal to address this problem">
                            </label>
                            <label>
                                Area:
                                <select id="goal-area-${problem.id}">
                                    <option value="Diet">Diet</option>
                                    <option value="Family">Family</option>
                                    <option value="Fitness">Fitness</option>
                                    <option value="Health">Health</option>
                                    <option value="Home">Home</option>
                                    <option value="Parenting">Parenting</option>
                                    <option value="Personal">Personal</option>
                                    <option value="Relationship">Relationship</option>
                                    <option value="Sleep">Sleep</option>
                                    <option value="Social Life">Social Life</option>
                                    <option value="Study">Study</option>
                                    <option value="Work">Work</option>
                                </select>
                            </label>
                            <label>
                                Emotion:
                                <select id="goal-emotion-${problem.id}">
                                    <option value="Meaningful">Meaningful</option>
                                    <option value="Neutral">Neutral</option>
                                    <option value="Difficult">Difficult</option>
                                </select>
                            </label>
                            <label>
                                Difficulty:
                                <div class="difficulty-options">
                                    <div class="difficulty-option">
                                        <input type="radio" name="goal-difficulty-${problem.id}" id="goal-difficulty-1-${problem.id}" value="1">
                                        <label for="goal-difficulty-1-${problem.id}">1</label>
                                    </div>
                                    <div class="difficulty-option">
                                        <input type="radio" name="goal-difficulty-${problem.id}" id="goal-difficulty-2-${problem.id}" value="2">
                                        <label for="goal-difficulty-2-${problem.id}">2</label>
                                    </div>
                                    <div class="difficulty-option">
                                        <input type="radio" name="goal-difficulty-${problem.id}" id="goal-difficulty-3-${problem.id}" value="3">
                                        <label for="goal-difficulty-3-${problem.id}">3</label>
                                    </div>
                                    <div class="difficulty-option">
                                        <input type="radio" name="goal-difficulty-${problem.id}" id="goal-difficulty-4-${problem.id}" value="4">
                                        <label for="goal-difficulty-4-${problem.id}">4</label>
                                    </div>
                                    <div class="difficulty-option">
                                        <input type="radio" name="goal-difficulty-${problem.id}" id="goal-difficulty-5-${problem.id}" value="5">
                                        <label for="goal-difficulty-5-${problem.id}">5</label>
                                    </div>
                                </div>
                            </label>
                            <div id="goal-description-${problem.id}" class="description"></div>
                            <div class="item-actions">
                                <button type="button" class="btn-add action-btn" onclick="addGoal('${problem.id}')">Add Goal</button>
                                <button type="button" class="btn-delete action-btn" onclick="deleteProblem('${problem.id}')">Delete Problem</button>
                            </div>
                        </form>
                    </div>
                `;
                
                // Set selected area to match problem area
                setTimeout(() => {
                    const areaSelect = listItem.querySelector(`#goal-area-${problem.id}`);
                    if (areaSelect) areaSelect.value = problem.problemArea;
                    
                    // Add event listeners for goal difficulty description
                    listItem.querySelectorAll(`input[name="goal-difficulty-${problem.id}"]`).forEach(radio => {
                        radio.addEventListener('change', function() {
                            const descriptionElement = document.getElementById(`goal-description-${problem.id}`);
                            descriptionElement.textContent = goalDescriptions[this.value];
                        });
                    });
                }, 0);
                
                // Toggle content visibility
                const title = listItem.querySelector('.list-item-title');
                title.addEventListener('click', function() {
                    const content = this.parentElement.querySelector('.list-item-content');
                    const arrow = this.querySelector('i');
                    content.classList.toggle('active');
                    
                    if (content.classList.contains('active')) {
                        arrow.classList.remove('fa-chevron-down');
                        arrow.classList.add('fa-chevron-up');
                    } else {
                        arrow.classList.remove('fa-chevron-up');
                        arrow.classList.add('fa-chevron-down');
                    }
                });
                
                problemsList.appendChild(listItem);
            });
        }

        // Add a new goal
        function addGoal(problemId) {
            const goalInput = document.getElementById(`goal-input-${problemId}`).value.trim();
            const goalArea = document.getElementById(`goal-area-${problemId}`).value;
            const goalEmotion = document.getElementById(`goal-emotion-${problemId}`).value;
            const goalDifficulty = document.querySelector(`input[name="goal-difficulty-${problemId}"]:checked`)?.value;
            
            if (!goalInput) {
                alert('Please enter a goal description.');
                return;
            }
            
            if (!goalDifficulty) {
                alert('Please select a difficulty level.');
                return;
            }
            
            // Get the problem details
            const problems = JSON.parse(localStorage.getItem('problems')) || [];
            const problem = problems.find(p => p.id === problemId);
            
            if (!problem) {
                alert('Problem not found. Please try again.');
                return;
            }
            
            const goal = {
                id: Date.now().toString(),
                goalInput,
                goalArea,
                goalEmotion,
                goalDifficulty,
                relatedProblemId: problemId,
                relatedProblem: problem.problemInput,
                timestamp: Date.now(),
                completed: false
            };
            
            // Save to localStorage
            let goals = JSON.parse(localStorage.getItem('goals')) || [];
            goals.push(goal);
            localStorage.setItem('goals', JSON.stringify(goals));
            
            // Reset form
            document.getElementById(`goal-form-${problemId}`).reset();
            document.getElementById(`goal-description-${problemId}`).textContent = '';
            
            // Update UI
            renderGoals();
            updateStats();
            updateCounts();
            
            // Add object to 3D scene
            addGoalObject(goal);
            
            // Show success message
            alert('Goal added successfully!');
        }

        // Render goals list
        function renderGoals() {
            const goals = JSON.parse(localStorage.getItem('goals')) || [];
            const goalsList = document.getElementById('goals-list');
            
            goalsList.innerHTML = '';
            
            if (goals.length === 0) {
                goalsList.innerHTML = '<p>No goals added yet. Create goals from your problems list.</p>';
                return;
            }
            
            goals.forEach(goal => {
                const listItem = document.createElement('div');
                listItem.className = 'list-item';
                listItem.innerHTML = `
                    <div class="list-item-title">
                        <span>${goal.goalInput}</span>
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="list-item-meta">
                        <div class="meta-item"><i class="fas fa-folder"></i> ${goal.goalArea}</div>
                        <div class="meta-item"><i class="fas fa-heart"></i> ${goal.goalEmotion}</div>
                        <div class="meta-item"><i class="fas fa-star"></i> Difficulty: ${goal.goalDifficulty}</div>
                    </div>
                    <div class="list-item-content">
                        <p><strong>Related Problem:</strong> ${goal.relatedProblem}</p>
                        <form id="task-form-${goal.id}">
                            <label>
                                Task:
                                <input type="text" id="task-input-${goal.id}" placeholder="Create a task to achieve this goal">
                            </label>
                            <div class="item-actions">
                // When rendering goal items, ensure this code is included:
<button type="button" class="btn-add action-btn" onclick="addTask('${goal.id}')">Add Task</button>
                                <button type="button" class="btn-delete action-btn" onclick="deleteGoal('${goal.id}')">Delete Goal</button>
                            </div>
                        </form>
                    </div>
                `;
                
                // Toggle content visibility
                const title = listItem.querySelector('.list-item-title');
                title.addEventListener('click', function() {
                    const content = this.parentElement.querySelector('.list-item-content');
                    const arrow = this.querySelector('i');
                    content.classList.toggle('active');
                    
                    if (content.classList.contains('active')) {
                        arrow.classList.remove('fa-chevron-down');
                        arrow.classList.add('fa-chevron-up');
                    } else {
                        arrow.classList.remove('fa-chevron-up');
                        arrow.classList.add('fa-chevron-down');
                    }
                });
                
                goalsList.appendChild(listItem);
            });
        }

        // Add a new task
        function addTask(goalId) {
    const taskInput = document.getElementById(`task-input-${goalId}`).value.trim();
    
    if (!taskInput) {
        alert('Please enter a task description.');
        return;
    }
    
    // Get the goal details
    const goals = JSON.parse(localStorage.getItem('goals')) || [];
    const goal = goals.find(g => g.id === goalId);
    
    if (!goal) {
        alert('Goal not found. Please try again.');
        return;
    }
    
    const task = {
        id: Date.now().toString(),
        taskInput,
        relatedGoalId: goalId,
        relatedGoal: goal.goalInput,
        goalArea: goal.goalArea,
        materialsInput: '',
        cooperationInput: '',
        knowledgeInput: '',
        timestamp: Date.now(),
        completed: false
    };
    
    // Save to localStorage
    let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    tasks.push(task);
    localStorage.setItem('tasks', JSON.stringify(tasks));
    
    // Reset form
    document.getElementById(`task-input-${goalId}`).value = '';
    
    // Update UI
    renderTasks();
    updateStats();
    updateCounts();
    
    // Add object to 3D scene
    addTaskObject(task, goal);
    
    // Show success message
    alert('Task added successfully!');
}

        // Render active tasks list
        function renderActiveTasksList(activeTasks) {
            const tasksList = document.getElementById('tasks-list');
            
            tasksList.innerHTML = '';
            
            if (activeTasks.length === 0) {
                tasksList.innerHTML = '<p>No active tasks. Create tasks from your goals list.</p>';
                return;
            }
            
            activeTasks.forEach(task => {
                const listItem = document.createElement('div');
                listItem.className = 'list-item';
                listItem.innerHTML = `
                    <div class="list-item-title">
                        <span>${task.taskInput}</span>
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="list-item-meta">
                        <div class="meta-item"><i class="fas fa-folder"></i> ${task.goalArea}</div>
                        <div class="meta-item"><i class="fas fa-bullseye"></i> ${task.relatedGoal}</div>
                    </div>
                    <div class="list-item-content">
                        <form id="task-details-form-${task.id}">
                            <label>
                                Materials Needed:
                                <textarea id="materials-input-${task.id}" placeholder="List materials needed for this task">${task.materialsInput}</textarea>
                            </label>
                            <label>
                                Cooperation Needed:
                                <textarea id="cooperation-input-${task.id}" placeholder="List people or organizations whose cooperation you need">${task.cooperationInput}</textarea>
                            </label>
                            <label>
                                Knowledge Required:
                                <textarea id="knowledge-input-${task.id}" placeholder="List skills or knowledge you need to acquire">${task.knowledgeInput}</textarea>
                            </label>
                            <div class="item-actions">
                                <button type="button" class="btn-add action-btn" onclick="saveTask('${task.id}')">Save Details</button>
                                <button type="button" class="btn-calendar action-btn" onclick="addToCalendar('${task.id}')">
                                    <i class="fas fa-calendar"></i> Add to Calendar
                                </button>
                            </div>
                            <div class="item-actions" style="margin-top: 10px;">
                                <button type="button" class="btn-add action-btn" onclick="completeTask('${task.id}')">Mark Complete</button>
                                <button type="button" class="btn-delete action-btn" onclick="deleteTask('${task.id}')">Delete Task</button>
                            </div>
                        </form>
                    </div>
                `;
                
                // Toggle content visibility
                const title = listItem.querySelector('.list-item-title');
                title.addEventListener('click', function() {
                    const content = this.parentElement.querySelector('.list-item-content');
                    const arrow = this.querySelector('i');
                    content.classList.toggle('active');
                    
                    if (content.classList.contains('active')) {
                        arrow.classList.remove('fa-chevron-down');
                        arrow.classList.add('fa-chevron-up');
                    } else {
                        arrow.classList.remove('fa-chevron-up');
                        arrow.classList.add('fa-chevron-down');
                    }
                });
                
                tasksList.appendChild(listItem);
            });
        }

        // Render completed tasks list
        function renderCompletedTasksList(completedTasks) {
            const completedList = document.getElementById('completed-list');
            
            completedList.innerHTML = '';
            
            if (completedTasks.length === 0) {
                completedList.innerHTML = '<p>No completed tasks yet.</p>';
                return;
            }
            
            completedTasks.forEach(task => {
                const listItem = document.createElement('div');
                listItem.className = 'list-item';
                listItem.innerHTML = `
                    <div class="list-item-title">
                        <span><i class="fas fa-check"></i> ${task.taskInput}</span>
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="list-item-meta">
                        <div class="meta-item"><i class="fas fa-folder"></i> ${task.goalArea}</div>
                        <div class="meta-item"><i class="fas fa-bullseye"></i> ${task.relatedGoal}</div>
                    </div>
                    <div class="list-item-content">
                        <p><strong>Materials:</strong> ${task.materialsInput || 'None specified'}</p>
                        <p><strong>Cooperation:</strong> ${task.cooperationInput || 'None specified'}</p>
                        <p><strong>Knowledge:</strong> ${task.knowledgeInput || 'None specified'}</p>
                        <div class="item-actions">
                            <button type="button" class="btn-add action-btn" onclick="uncompleteTask('${task.id}')">Mark Incomplete</button>
                            <button type="button" class="btn-delete action-btn" onclick="deleteTask('${task.id}')">Delete Task</button>
                        </div>
                    </div>
                `;
                
                // Toggle content visibility
                const title = listItem.querySelector('.list-item-title');
                title.addEventListener('click', function() {
                    const content = this.parentElement.querySelector('.list-item-content');
                    const arrow = this.querySelector('i');
                    content.classList.toggle('active');
                    
                    if (content.classList.contains('active')) {
                        arrow.classList.remove('fa-chevron-down');
                        arrow.classList.add('fa-chevron-up');
                    } else {
                        arrow.classList.remove('fa-chevron-up');
                        arrow.classList.add('fa-chevron-down');
                    }
                });
                
                completedList.appendChild(listItem);
            });
        }

        // Save task details
        function saveTask(taskId) {
            const materialsInput = document.getElementById(`materials-input-${taskId}`).value;
            const cooperationInput = document.getElementById(`cooperation-input-${taskId}`).value;
            const knowledgeInput = document.getElementById(`knowledge-input-${taskId}`).value;
            
            // Update task in localStorage
            let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            
            if (taskIndex !== -1) {
                tasks[taskIndex].materialsInput = materialsInput;
                tasks[taskIndex].cooperationInput = cooperationInput;
                tasks[taskIndex].knowledgeInput = knowledgeInput;
                
                localStorage.setItem('tasks', JSON.stringify(tasks));
                
                // Show success message
                alert('Task details saved successfully!');
            }
        }

        // Mark task as complete
        function completeTask(taskId) {
            // Update task in localStorage
            let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            
            if (taskIndex !== -1) {
                tasks[taskIndex].completed = true;
                localStorage.setItem('tasks', JSON.stringify(tasks));
                
                // Update UI
                renderTasks();
                updateStats();
                updateCounts();
                
                // Update 3D visualization
                updateTaskObject(tasks[taskIndex]);
                
                // Create a shooting star celebration
                createShootingStar();
                
                // Show success message
                alert('Task marked as complete!');
            }
        }

        // Mark task as incomplete
        function uncompleteTask(taskId) {
            // Update task in localStorage
            let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            
            if (taskIndex !== -1) {
                tasks[taskIndex].completed = false;
                localStorage.setItem('tasks', JSON.stringify(tasks));
                
                // Update UI
                renderTasks();
                updateStats();
                updateCounts();
                
                // Update 3D visualization
                updateTaskObject(tasks[taskIndex]);
                
                // Show success message
                alert('Task marked as incomplete!');
            }
        }

        // Delete task
        function deleteTask(taskId) {
            if (confirm('Are you sure you want to delete this task?')) {
                // Remove task from localStorage
                let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
                const taskToDelete = tasks.find(t => t.id === taskId);
                tasks = tasks.filter(t => t.id !== taskId);
                localStorage.setItem('tasks', JSON.stringify(tasks));
                
                // Update UI
                renderTasks();
                updateStats();
                updateCounts();

// Remove object from 3D scene
                removeTaskObject(taskToDelete);
            }
        }

        // Delete goal
        function deleteGoal(goalId) {
            if (confirm('Are you sure you want to delete this goal? Any tasks associated with this goal will also be deleted.')) {
                // Remove goal from localStorage
                let goals = JSON.parse(localStorage.getItem('goals')) || [];
                const goalToDelete = goals.find(g => g.id === goalId);
                goals = goals.filter(g => g.id !== goalId);
                localStorage.setItem('goals', JSON.stringify(goals));
                
                // Remove associated tasks
                let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
                const tasksToDelete = tasks.filter(t => t.relatedGoalId === goalId);
                tasks = tasks.filter(t => t.relatedGoalId !== goalId);
                localStorage.setItem('tasks', JSON.stringify(tasks));
                
                // Update UI
                renderGoals();
                renderTasks();
                updateStats();
                updateCounts();
                
                // Remove objects from 3D scene
                removeGoalObject(goalToDelete);
                tasksToDelete.forEach(task => removeTaskObject(task));
            }
        }

        // Delete problem
        function deleteProblem(problemId) {
            if (confirm('Are you sure you want to delete this problem? This will not delete any goals or tasks you\'ve created from this problem.')) {
                // Remove problem from localStorage
                let problems = JSON.parse(localStorage.getItem('problems')) || [];
                const problemToDelete = problems.find(p => p.id === problemId);
                problems = problems.filter(p => p.id !== problemId);
                localStorage.setItem('problems', JSON.stringify(problems));
                
                // Update UI
                renderProblems();
                updateStats();
                updateCounts();
                
                // Remove object from 3D scene
                removeProblemObject(problemToDelete);
            }
        }

        // Add to Google Calendar
        function addToCalendar(taskId) {
            // Get the task details
            const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            const task = tasks.find(t => t.id === taskId);
            
            if (!task) {
                alert('Task not found. Please try again.');
                return;
            }
            
            const taskName = encodeURIComponent(task.taskInput);
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(today.getDate() + 1);
            
            // Format dates for Google Calendar
            const startDate = formatDateForCalendar(tomorrow);
            const endDate = formatDateForCalendar(tomorrow, 1); // 1 hour later
            
            // Build Google Calendar URL
            const calendarUrl = `https://www.google.com/calendar/render?action=TEMPLATE&text=${taskName}&dates=${startDate}/${endDate}`;
            
            // Open calendar in new tab
            window.open(calendarUrl, '_blank');
        }

        // Format date for Google Calendar (YYYYMMDDTHHMMSSZ)
        function formatDateForCalendar(date, hoursToAdd = 0) {
            const d = new Date(date);
            if (hoursToAdd) d.setHours(d.getHours() + hoursToAdd);
            
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            const hours = String(d.getHours()).padStart(2, '0');
            const minutes = String(d.getMinutes()).padStart(2, '0');
            
            return `${year}${month}${day}T${hours}${minutes}00`;
        }

        // Sort problems
        function sortProblems(criteria) {
            let problems = JSON.parse(localStorage.getItem('problems')) || [];
            
            switch(criteria) {
                case 'recent':
                    problems.sort((a, b) => b.timestamp - a.timestamp);
                    break;
                case 'area':
                    problems.sort((a, b) => a.problemArea.localeCompare(b.problemArea));
                    break;
                case 'emotion':
                    problems.sort((a, b) => a.problemEmotion.localeCompare(b.problemEmotion));
                    break;
                case 'difficulty':
                    problems.sort((a, b) => Number(a.problemDifficulty) - Number(b.problemDifficulty));
                    break;
            }
            
            localStorage.setItem('problems', JSON.stringify(problems));
            renderProblems();
            
            // Update active button
            document.querySelectorAll('#section-problems .sort-controls button').forEach(button => {
                button.classList.remove('active');
            });
            document.querySelector(`#section-problems .sort-controls button[onclick="sortProblems('${criteria}')"]`).classList.add('active');
        }

        // Sort goals
        function sortGoals(criteria) {
            let goals = JSON.parse(localStorage.getItem('goals')) || [];
            
            switch(criteria) {
                case 'recent':
                    goals.sort((a, b) => b.timestamp - a.timestamp);
                    break;
                case 'area':
                    goals.sort((a, b) => a.goalArea.localeCompare(b.goalArea));
                    break;
                case 'emotion':
                    goals.sort((a, b) => a.goalEmotion.localeCompare(b.goalEmotion));
                    break;
                case 'difficulty':
                    goals.sort((a, b) => Number(a.goalDifficulty) - Number(b.goalDifficulty));
                    break;
            }
            
            localStorage.setItem('goals', JSON.stringify(goals));
            renderGoals();
            
            // Update active button
            document.querySelectorAll('#section-goals .sort-controls button').forEach(button => {
                button.classList.remove('active');
            });
            document.querySelector(`#section-goals .sort-controls button[onclick="sortGoals('${criteria}')"]`).classList.add('active');
        }

        // Update statistics and charts
        function updateStats() {
            const problems = JSON.parse(localStorage.getItem('problems')) || [];
            const goals = JSON.parse(localStorage.getItem('goals')) || [];
            const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            const completedTasks = tasks.filter(task => task.completed);
            
            // Update counters
            document.getElementById('stats-problems').textContent = problems.length;
            document.getElementById('stats-goals').textContent = goals.length;
            document.getElementById('stats-tasks').textContent = tasks.length;
            document.getElementById('stats-completed').textContent = completedTasks.length;
            
            // Update charts
            updateProblemAreaChart(problems);
            updateProblemDifficultyAreaChart(problems);
            updateProblemEmotionChart(problems);
            updateProblemDifficultyEmotionChart(problems);
            updateGoalAreaChart(goals);
            updateGoalDifficultyAreaChart(goals);
            updateGoalEmotionChart(goals);
            updateGoalDifficultyEmotionChart(goals);
        }

        // Update count badges
        function updateCounts() {
    const problems = JSON.parse(localStorage.getItem('problems')) || [];
    const goals = JSON.parse(localStorage.getItem('goals')) || [];
    const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    const completedTasks = tasks.filter(task => task.completed);
    const activeTasks = tasks.filter(task => !task.completed);
    
    document.getElementById('problems-count').textContent = problems.length;
    document.getElementById('goals-count').textContent = goals.length;
    document.getElementById('tasks-count').textContent = activeTasks.length;
    document.getElementById('completed-count').textContent = completedTasks.length;
}

        // Chart update functions
        function updateProblemAreaChart(problems) {
            const ctx = document.getElementById('chart-problems-area').getContext('2d');
            const areaData = countByProperty(problems, 'problemArea');
            
            new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(areaData),
                    datasets: [{
                        data: Object.values(areaData),
                        backgroundColor: getRandomColors(Object.keys(areaData).length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: getTextColorForTheme()
                            }
                        }
                    }
                }
            });
        }

        function updateProblemDifficultyAreaChart(problems) {
            const ctx = document.getElementById('chart-difficulty-area').getContext('2d');
            const areas = [...new Set(problems.map(p => p.problemArea))];
            const datasets = [];
            
            for (let i = 1; i <= 5; i++) {
                const data = areas.map(area => {
                    const filtered = problems.filter(p => p.problemArea === area && p.problemDifficulty === i.toString());
                    return filtered.length;
                });
                
                datasets.push({
                    label: `Difficulty ${i}`,
                    data: data,
                    backgroundColor: getColorWithOpacity(i, 0.7)
                });
            }
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: areas,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                color: getTextColorForTheme()
                            }
                        },
                        y: {
                            stacked: true,
                            ticks: {
                                color: getTextColorForTheme()
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: getTextColorForTheme()
                            }
                        }
                    }
                }
            });
        }

        function updateProblemEmotionChart(problems) {
            const ctx = document.getElementById('chart-problems-emotion').getContext('2d');
            const emotionData = countByProperty(problems, 'problemEmotion');
            
            new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(emotionData),
                    datasets: [{
                        data: Object.values(emotionData),
                        backgroundColor: Object.keys(emotionData).map(emotion => {
                            const color = emotionColors[emotion] || getRandomColor();
                            return colorToRgba(color, 0.8);
                        })
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: getTextColorForTheme()
                            }
                        }
                    }
                }
            });
        }

        function updateProblemDifficultyEmotionChart(problems) {
            const ctx = document.getElementById('chart-difficulty-emotion').getContext('2d');
            const emotions = [...new Set(problems.map(p => p.problemEmotion))];
            const datasets = [];
            
            for (let i = 1; i <= 5; i++) {
                const data = emotions.map(emotion => {
                    const filtered = problems.filter(p => p.problemEmotion === emotion && p.problemDifficulty === i.toString());
                    return filtered.length;
                });
                
                datasets.push({
                    label: `Difficulty ${i}`,
                    data: data,
                    backgroundColor: getColorWithOpacity(i, 0.7)
                });
            }
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: emotions,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                color: getTextColorForTheme()
                            }
                        },
                        y: {
                            stacked: true,
                            ticks: {
                                color: getTextColorForTheme()
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: getTextColorForTheme()
                            }
                        }
                    }
                }
            });
        }

        function updateGoalAreaChart(goals) {
            const ctx = document.getElementById('chart-goals-area').getContext('2d');
            const areaData = countByProperty(goals, 'goalArea');
            
            new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(areaData),
                    datasets: [{
                        data: Object.values(areaData),
                        backgroundColor: getRandomColors(Object.keys(areaData).length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: getTextColorForTheme()
                            }
                        }
                    }
                }
            });
        }

        function updateGoalDifficultyAreaChart(goals) {
            const ctx = document.getElementById('chart-goals-difficulty-area').getContext('2d');
            const areas = [...new Set(goals.map(g => g.goalArea))];
            const datasets = [];
            
            for (let i = 1; i <= 5; i++) {
                const data = areas.map(area => {
                    const filtered = goals.filter(g => g.goalArea === area && g.goalDifficulty === i.toString());
                    return filtered.length;
                });
                
                datasets.push({
                    label: `Difficulty ${i}`,
                    data: data,
                    backgroundColor: getColorWithOpacity(i, 0.7)
                });
            }
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: areas,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                color: getTextColorForTheme()
                            }
                        },
                        y: {
                            stacked: true,
                            ticks: {
                                color: getTextColorForTheme()
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: getTextColorForTheme()
                            }
                        }
                    }
                }
            });
        }

        function updateGoalEmotionChart(goals) {
            const ctx = document.getElementById('chart-goals-emotion').getContext('2d');
            const emotionData = countByProperty(goals, 'goalEmotion');
            
            new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(emotionData),
                    datasets: [{
                        data: Object.values(emotionData),
                        backgroundColor: Object.keys(emotionData).map(emotion => {
                            const color = goalEmotionColors[emotion] || getRandomColor();
                            return colorToRgba(color, 0.8);
                        })
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: getTextColorForTheme()
                            }
                        }
                    }
                }
            });
        }

        function updateGoalDifficultyEmotionChart(goals) {
            const ctx = document.getElementById('chart-goals-difficulty-emotion').getContext('2d');
            const emotions = [...new Set(goals.map(g => g.goalEmotion))];
            const datasets = [];
            
            for (let i = 1; i <= 5; i++) {
                const data = emotions.map(emotion => {
                    const filtered = goals.filter(g => g.goalEmotion === emotion && g.goalDifficulty === i.toString());
                    return filtered.length;
                });
                
                datasets.push({
                    label: `Difficulty ${i}`,
                    data: data,
                    backgroundColor: getColorWithOpacity(i, 0.7)
                });
            }
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: emotions,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                color: getTextColorForTheme()
                            }
                        },
                        y: {
                            stacked: true,
                            ticks: {
                                color: getTextColorForTheme()
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: getTextColorForTheme()
                            }
                        }
                    }
                }
            });
        }

        // Helper function to count items by property
        function countByProperty(array, property) {
            return array.reduce((acc, item) => {
                const key = item[property];
                if (!acc[key]) {
                    acc[key] = 0;
                }
                acc[key]++;
                return acc;
            }, {});
        }

        // Helper functions for colors
        function getRandomColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                colors.push(getRandomColor(0.8));
            }
            return colors;
        }

        function getRandomColor(alpha = 0.8) {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getColorWithOpacity(index, alpha = 0.8) {
            const colors = [
                `rgba(92, 198, 97, ${alpha})`,   // Green
                `rgba(79, 129, 189, ${alpha})`,  // Blue
                `rgba(192, 80, 77, ${alpha})`,   // Red
                `rgba(155, 87, 188, ${alpha})`,  // Purple
                `rgba(247, 150, 70, ${alpha})`   // Orange
            ];
            return colors[(index - 1) % colors.length];
        }

        function colorToRgba(hex, alpha = 1) {
            // Convert hex color to rgb
            let r, g, b;
            if (typeof hex === 'number') {
                r = (hex >> 16) & 255;
                g = (hex >> 8) & 255;
                b = hex & 255;
            } else {
                // If hex is a string like "#ff0000"
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                if (result) {
                    r = parseInt(result[1], 16);
                    g = parseInt(result[2], 16);
                    b = parseInt(result[3], 16);
                } else {
                    // Default to white if invalid hex
                    r = g = b = 255;
                }
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Helper function to get text color based on theme
        function getTextColorForTheme() {
            return isDarkTheme ? '#ffffff' : '#472d0f';
        }

        // Enhanced Three.js visualization
        function initThreeJS() {
            const canvas = document.getElementById('background-canvas');
            
            // Create renderer with antialias
            renderer = new THREE.WebGLRenderer({
                canvas,
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
            
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera with better positioning
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 20;
            camera.position.y = 5;
            
            // Initialize object containers
            goalObjects = {};
            problemObjects = {};
            taskObjects = {};
            
            // Add visualization elements based on theme
            if (isDarkTheme) {
                initEnhancedDarkTheme();
            } else {
                initLightTheme();
            }
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
        }

        function resetThreeJS() {
            // Cancel animation frame
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Clear scene
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }
            
            // Reset object containers
            goalObjects = {};
            problemObjects = {};
            taskObjects = {};
            
            // Add visualization elements based on theme
            if (isDarkTheme) {
                initEnhancedDarkTheme();
            } else {
                initLightTheme();
            }
            
            // Load all objects from localStorage
            loadVisualizationObjects();
            
            // Restart animation loop
            animate();
        }

        // Enhanced dark theme with improved space visualization
        function initEnhancedDarkTheme() {
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x111133, 0.3);
            scene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xccddff, 0.8);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);
            
            // Add point light (sun effect)
            const sunLight = new THREE.PointLight(0xe0c8a0, 1, 100);
            sunLight.position.set(-10, 5, -10);
            scene.add(sunLight);
            
            // Add galaxy center with glow
            createGalaxyCenter();
            
            // Add star field
            createStarField();
            
            // Add nebula clouds
            createNebulaClouds();
            
            // Add distant stars
            addDistantStars();
        }

        // Create galaxy center with glow effect
        function createGalaxyCenter() {
            // Central bright core
            const coreGeometry = new THREE.SphereGeometry(2, 32, 32);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffeecc,
                transparent: true,
                opacity: 0.7
            });
            galaxyCenter = new THREE.Mesh(coreGeometry, coreMaterial);
            galaxyCenter.position.set(-30, 5, -50);
            scene.add(galaxyCenter);
            
            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(3, 32, 32);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    glowColor: { value: new THREE.Color(0xffbb77) },
                    viewVector: { value: camera.position }
                },
                vertexShader: `
                    uniform vec3 viewVector;
                    varying float intensity;
                    void main() {
                        vec3 vNormal = normalize(normalMatrix * normal);
                        vec3 vNormel = normalize(normalMatrix * viewVector);
                        intensity = pow(0.6 - dot(vNormal, vNormel), 2.0);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying float intensity;
                    void main() {
                        vec3 glow = glowColor * intensity;
                        gl_FragColor = vec4(glow, 1.0);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            glowMesh.position.copy(galaxyCenter.position);
            glowMesh.scale.multiplyScalar(1.5);
            scene.add(glowMesh);
            
            // Add surrounding dust
            const particleCount = 2000;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            const galaxyRadius = 10;
            const galaxyThickness = 3;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Position in polar coordinates for galaxy disc
                const radius = Math.random() * galaxyRadius;
                const theta = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * galaxyThickness * (1 - radius / galaxyRadius);
                
                // Convert to cartesian
                positions[i3] = galaxyCenter.position.x + radius * Math.cos(theta);
                positions[i3 + 1] = galaxyCenter.position.y + height;
                positions[i3 + 2] = galaxyCenter.position.z + radius * Math.sin(theta);
                
                // Color based on distance from center (yellowish near center, bluish far away)
                const distanceRatio = radius / galaxyRadius;
                colors[i3] = 0.9 - (distanceRatio * 0.5);      // R: more near center
                colors[i3 + 1] = 0.6 - (distanceRatio * 0.3);  // G: more near center
                colors[i3 + 2] = 0.3 + (distanceRatio * 0.7);  // B: more at edges
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const galaxyParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(galaxyParticles);
        }

        // Create star field of tiny bright points
        function createStarField() {
            const starCount = 3000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            const colors = new Float32Array(starCount * 3);
            
            // Star positions in a spherical volume around camera
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                
                // Random position in a sphere
                const radius = 100 + Math.random() * 900; // Stars between 100 and 1000 units away
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
                
                // Random size
                sizes[i] = 0.5 + Math.random() * 1.5;
                
                // Slightly random color (white with tint)
                colors[i3] = 0.8 + Math.random() * 0.2;           // R
                colors[i3 + 1] = 0.8 + Math.random() * 0.2;       // G
                colors[i3 + 2] = 0.8 + Math.random() * 0.2;       // B
                
                // Some stars with color tint
                if (Math.random() < 0.1) {
                    // Blue tint
                    colors[i3] *= 0.5;
                    colors[i3 + 1] *= 0.7;
                } else if (Math.random() < 0.1) {
                    // Red/orange tint
                    colors[i3 + 1] *= 0.7;
                    colors[i3 + 2] *= 0.5;
                }
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const starTexture = createStarTexture();
            
            const material = new THREE.PointsMaterial({
                size: 0.1,
                map: starTexture,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            starField = new THREE.Points(geometry, material);
            scene.add(starField);
            
            // Save info for animation
            stars = Array(starCount).fill().map((_, i) => ({
                index: i,
                twinkleSpeed: 0.001 + Math.random() * 0.02,
                twinkleAmount: Math.random() * 0.3
            }));
        }
        
        // Create a texture for star points
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 32;
            canvas.height = 32;
            
            // Draw a simple radial gradient for the star
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
        
        // Create colorful nebula clouds
        function createNebulaClouds() {
            // Create 3-5 nebula clouds
            const nebulaCount = 3 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < nebulaCount; i++) {
                createNebula(i);
            }
        }
        
        // Create a single nebula cloud
        function createNebula(index) {
            // Nebula colors
            const nebulaColors = [
                [0xff9999, 0x9999ff], // Red-Blue
                [0x99ffcc, 0x9999ff], // Teal-Blue
                [0xffcc99, 0xff99cc], // Orange-Pink
                [0xff99ff, 0x9999ff], // Pink-Purple
                [0x99ccff, 0x99ffff]  // Blue-Cyan
            ];
            
            // Select a color pair for this nebula
            const colorPair = nebulaColors[index % nebulaColors.length];
            
            // Create particle geometry
            const particleCount = 300 + Math.floor(Math.random() * 200);
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            // Position this nebula randomly in space
            const nebulaCenter = new THREE.Vector3(
                -50 + Math.random() * 100,
                -30 + Math.random() * 60,
                -100 - Math.random() * 100
            );
            
            // Make sure the nebula isn't too close to the galaxy center
            if (galaxyCenter && nebulaCenter.distanceTo(galaxyCenter.position) < 40) {
                nebulaCenter.x += 60 * (Math.random() < 0.5 ? -1 : 1);
                nebulaCenter.z -= 50;
            }
            
            const nebulaSize = 20 + Math.random() * 30;
            
            // Generate particles in a cloud shape
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Use a spherical distribution with random variations
                const radius = (0.2 + Math.random() * 0.8) * nebulaSize;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                // Basic spherical position
                let x = radius * Math.sin(phi) * Math.cos(theta);
                let y = radius * Math.sin(phi) * Math.sin(theta);
                let z = radius * Math.cos(phi);
                
                // Add some distortion for a cloud-like appearance
                x += (Math.random() - 0.5) * nebulaSize * 0.3;
                y += (Math.random() - 0.5) * nebulaSize * 0.3;
                z += (Math.random() - 0.5) * nebulaSize * 0.3;
                
                // Set position relative to nebula center
                positions[i3] = nebulaCenter.x + x;
                positions[i3 + 1] = nebulaCenter.y + y;
                positions[i3 + 2] = nebulaCenter.z + z;
                
                // Interpolate between the two colors based on position
                const distanceRatio = Math.sqrt(x*x + y*y + z*z) / nebulaSize;
                const color1 = new THREE.Color(colorPair[0]);
                const color2 = new THREE.Color(colorPair[1]);
                const finalColor = new THREE.Color().lerpColors(color1, color2, distanceRatio);
                
                colors[i3] = finalColor.r;
                colors[i3 + 1] = finalColor.g;
                colors[i3 + 2] = finalColor.b;
                
                // Random size for each particle
                sizes[i] = 2 + Math.random() * 3;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Create a soft, glowing particle texture
            const particleTexture = createNebulaParticleTexture();
            
            const material = new THREE.PointsMaterial({
                size: 1.5,
                map: particleTexture,
                transparent: true,
                vertexColors: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            const nebula = new THREE.Points(geometry, material);
            scene.add(nebula);
            
            // Store for animation
            nebulas.push({
                mesh: nebula,
                center: nebulaCenter,
                rotationSpeed: (Math.random() - 0.5) * 0.0005,
                pulseSpeed: 0.0005 + Math.random() * 0.001,
                originalPositions: positions.slice()
            });
        }
        
        // Create a texture for nebula particles
        function createNebulaParticleTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            
            // Draw a soft circular gradient for each particle
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
        
        // Add distant stars as a backdrop
        function addDistantStars() {
            // Create a large sphere with stars on the inside
            const geometry = new THREE.SphereGeometry(1500, 64, 64);
            const material = new THREE.MeshBasicMaterial({
                map: createDistantStarTexture(),
                side: THREE.BackSide,
                transparent: true,
                opacity: 0.7
            });
            
            const starSphere = new THREE.Mesh(geometry, material);
            scene.add(starSphere);
        }
        
        // Create a texture with tiny stars for the background
        function createDistantStarTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 2048;
            canvas.height = 2048;
            
            // Fill with dark blue-black
            ctx.fillStyle = '#020209';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add tiny white dots for stars
            const starCount = 10000;
            for (let i = 0; i < starCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() < 0.9 ? 1 : 1 + Math.random() * 2; // Most stars are dim
                
                const brightness = 0.5 + Math.random() * 0.5;
                const r = Math.floor(255 * brightness);
                const g = Math.floor(255 * brightness);
                const b = Math.floor(255 * brightness);
                
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.2 + Math.random() * 0.8})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
        
        // Create a shooting star effect
        function createShootingStar() {
            // Don't create too many shooting stars at once
            const now = Date.now();
            if (now - lastShootingStarTime < 5000) return;
            lastShootingStarTime = now;
            
            // Choose a random direction in the hemisphere facing the camera
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI / 2; // Keep in the upper hemisphere
            
            const startPoint = new THREE.Vector3(
                Math.sin(phi) * Math.cos(theta),
                Math.sin(phi) * Math.sin(theta),
                Math.cos(phi)
            ).multiplyScalar(100); // Start far away
            
            // End point is in same direction but closer
            const endPoint = startPoint.clone().multiplyScalar(0.5);
            
            // Create a line between these points
            const points = [startPoint, endPoint];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            // White line with glow
            const material = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                linewidth: 3 // Note: linewidth not supported on WebGL renderer
            });
            
            const shootingStar = new THREE.Line(geometry, material);
            scene.add(shootingStar);
            
            // Add a point light that travels with the shooting star
            const light = new THREE.PointLight(0xffffff, 2, 50);
            light.position.copy(startPoint);
            scene.add(light);
            
            // Add to array for animation
            shootingStars.push({
                line: shootingStar,
                light: light,
                start: startPoint.clone(),
                end: endPoint.clone(),
                startTime: now,
                duration: 1000 + Math.random() * 1000,
                spawnsParticles: Math.random() < 0.5 // Sometimes spawn particles
            });
        }
        
        // Update shooting star animation
        function updateShootingStars() {
            const now = Date.now();
            
            shootingStars = shootingStars.filter(star => {
                const elapsed = now - star.startTime;
                const progress = Math.min(elapsed / star.duration, 1);
                
                // Move the shooting star and its light
                if (progress < 1) {
                    const pos = new THREE.Vector3().lerpVectors(star.start, star.end, progress);
                    
                    // Update the line
                    const positions = star.line.geometry.attributes.position.array;
                    positions[0] = pos.x;
                    positions[1] = pos.y;
                    positions[2] = pos.z;
                    
                    // Add some trail effect by extending the line backwards
                    const trailLength = (1 - progress) * 10; // Trail gets shorter as shooting star progresses
                    const trailDirection = star.start.clone().sub(star.end).normalize();
                    const trailEnd = pos.clone().add(trailDirection.multiplyScalar(trailLength));
                    
                    positions[3] = trailEnd.x;
                    positions[4] = trailEnd.y;
                    positions[5] = trailEnd.z;
                    
                    star.line.geometry.attributes.position.needsUpdate = true;
                    
                    // Update light position
                    star.light.position.copy(pos);
                    
                    return true;
                } else {
                    // Remove the shooting star and its light when done
                    scene.remove(star.line);
                    scene.remove(star.light);
                    
                    // Create particle effects at the final position
                    if (star.spawnsParticles) {
                        createShootingStarParticles(star.end);
                    }
                    
                    return false;
                }
            });
        }
        
        // Create particle effect when shooting star ends
        function createShootingStarParticles(position) {
            const particleCount = 20 + Math.floor(Math.random() * 10);
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            // Random colors from white to blue/yellow
            const baseColor = Math.random() < 0.5 ? 
                new THREE.Color(0xffcc44) : // Yellow/orange
                new THREE.Color(0x77bbff); // Blue
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const speed = 0.2 + Math.random() * 0.3;
                const direction = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ).normalize();
                
                // Position at center of burst
                positions[i3] = position.x;
                positions[i3 + 1] = position.y;
                positions[i3 + 2] = position.z;
                
                // Color variation from base
                const color = baseColor.clone().lerp(new THREE.Color(0xffffff), Math.random() * 0.5);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
                
                // Random size
                sizes[i] = 0.5 + Math.random() * 1.5;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Glowing particle material
            const material = new THREE.PointsMaterial({
                size: 0.5,
                map: createStarTexture(),
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // Animate the particles expanding and fading
            const startTime = Date.now();
            const duration = 1000; // 1 second animation
            
            function animateParticles() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                if (progress < 1) {
                    const positions = particles.geometry.attributes.position.array;
                    
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        
                        // Get original position
                        const origX = position.x;
                        const origY = position.y;
                        const origZ = position.z;
                        
                        // Direction for this particle
                        const dir = new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        ).normalize();
                        
                        // Move outward based on progress
                        positions[i3] = origX + dir.x * progress * 5;
                        positions[i3 + 1] = origY + dir.y * progress * 5;
                        positions[i3 + 2] = origZ + dir.z * progress * 5;
                    }
                    
                    particles.geometry.attributes.position.needsUpdate = true;
                    
                    // Fade out
                    particles.material.opacity = 1 - progress;
                    
                    requestAnimationFrame(animateParticles);
                } else {
                    // Remove particles when done
                    scene.remove(particles);
                }
            }
            
            animateParticles();
        }

        // Initialize light theme with stained glass window design
        function initLightTheme() {
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x777777);
            scene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Add stained glass background
            addStainedGlassBackground();
        }

        function addStainedGlassBackground() {
            // Create a simple colored background
            const geometry = new THREE.PlaneGeometry(50, 50);
            const material = new THREE.MeshBasicMaterial({
                color: 0xf0e6d2,
                transparent: true,
                opacity: 0.8
            });
            
            const background = new THREE.Mesh(geometry, material);
            background.position.z = -10;
            scene.add(background);
            
            // Add simple stained glass patterns
            for (let i = 0; i < 20; i++) {
                const size = 1 + Math.random() * 3;
                const patternGeometry = new THREE.PlaneGeometry(size, size);
                
                // Random color for each panel
                const hue = Math.random();
                const saturation = 0.5 + Math.random() * 0.5;
                const lightness = 0.4 + Math.random() * 0.4;
                
                const color = new THREE.Color();
                color.setHSL(hue, saturation, lightness);
                
                const patternMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.5 + Math.random() * 0.3
                });
                
                const pattern = new THREE.Mesh(patternGeometry, patternMaterial);
                
                // Random position
                pattern.position.x = -15 + Math.random() * 30;
                pattern.position.y = -15 + Math.random() * 30;
                pattern.position.z = -9.9 + Math.random() * 0.2;
                
                // Random rotation
                pattern.rotation.z = Math.random() * Math.PI * 2;
                
                scene.add(pattern);
            }
            
            // Add ivy vine trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.05, 0.1, 20, 8);
            const trunkMaterial = new THREE.MeshBasicMaterial({ color: 0x2d4a00 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            
            trunk.position.x = -5;
            trunk.position.y = 0;
            trunk.position.z = -9;
            trunk.rotation.z = Math.PI * 0.05;
            
            scene.add(trunk);
            
            // Add vine branches
            addVineBranch(trunk.position, 5, 8, 3);
            addVineBranch(trunk.position, -3, 5, 2);
            addVineBranch(trunk.position, 2, -4, 4);
        }

        function addVineBranch(startPos, offsetX, offsetY, segments) {
            const points = [];
            points.push(new THREE.Vector3(startPos.x, startPos.y, startPos.z));
            
            // Create curve points
            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                const x = startPos.x + offsetX * t + (Math.random() - 0.5) * 2 * t;
                const y = startPos.y + offsetY * t + (Math.random() - 0.5) * 2 * t;
                const z = startPos.z + (Math.random() - 0.5) * 0.5;
                
                points.push(new THREE.Vector3(x, y, z));
            }
            
            // Create a curve path
            const curve = new THREE.CatmullRomCurve3(points);
            
            // Create geometry from curve
            const branchGeometry = new THREE.TubeGeometry(curve, segments * 4, 0.05 - (segments * 0.01), 8, false);
            const branchMaterial = new THREE.MeshBasicMaterial({ color: 0x3a6100 });
            const branch = new THREE.Mesh(branchGeometry, branchMaterial);
            
            scene.add(branch);
        }

        function onWindowResize() {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            
            const elapsedTime = clock.getElapsedTime();
            
            // Slowly rotate camera for both themes
            if (isDarkTheme) {
                // Celestial motion - smooth orbital movement
                camera.position.x = 20 * Math.sin(elapsedTime * 0.1);
                camera.position.y = 5 + 2 * Math.sin(elapsedTime * 0.05);
                camera.position.z = 20 * Math.cos(elapsedTime * 0.1);
                camera.lookAt(0, 0, 0);
                
                // Update galaxy center rotation
                if (galaxyCenter) {
                    galaxyRotation += 0.001;
                    galaxyCenter.rotation.y = galaxyRotation;
                }
                
                // Update nebula clouds - subtle pulsing and rotation
                nebulas.forEach(nebula => {
                    nebula.mesh.rotation.y += nebula.rotationSpeed;
                    
                    // Subtle pulsing effect
                    const scale = 1 + 0.05 * Math.sin(elapsedTime * nebula.pulseSpeed * 2);
                    nebula.mesh.scale.set(scale, scale, scale);
                    
                    // Subtle distortion of particles
                    const positions = nebula.mesh.geometry.attributes.position.array;
                    const originalPositions = nebula.originalPositions;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        const offset = Math.sin(elapsedTime * 0.5 + i * 0.01) * 0.2;
                        positions[i] = originalPositions[i] + offset;
                        positions[i + 1] = originalPositions[i + 1] + offset;
                        positions[i + 2] = originalPositions[i + 2] + offset;
                    }
                    
                    nebula.mesh.geometry.attributes.position.needsUpdate = true;
                });
                
                // Animate star twinkle effect
                if (starField && starField.geometry.attributes.size) {
                    const sizes = starField.geometry.attributes.size.array;
                    
                    stars.forEach(star => {
                        // Simple sine wave based twinkle
                        const twinkle = Math.sin(elapsedTime * star.twinkleSpeed * 10) * star.twinkleAmount;
                        sizes[star.index] = (1 + twinkle) * (0.5 + Math.random() * 1.5);
                    });
                    
                    starField.geometry.attributes.size.needsUpdate = true;
                }
                
                // Update shooting stars
                updateShootingStars();
                
                // Occasionally create a new shooting star
                if (Math.random() < 0.003) {
                    createShootingStar();
                }
                
                // Animate problems (Saturn-like rings)
                Object.values(problemObjects).forEach(obj => {
                    if (obj && obj.group) {
                        obj.group.rotation.x += 0.002;
                        obj.group.rotation.y += 0.001;
                    }
                });
                
                // Animate goals (planets)
                Object.values(goalObjects).forEach(obj => {
                    if (obj && obj.mesh) {
                        // Rotate around its axis
                        obj.mesh.rotation.y += 0.01;
                        
                        // Orbit around center
                        if (obj.orbit) {
                            obj.orbit.rotation.y += 0.003;
                        }
                    }
                });
                
                // Animate tasks (moons)
                Object.values(taskObjects).forEach(obj => {
                    if (obj && obj.mesh) {
                        // Self-rotation
                        obj.mesh.rotation.y += 0.02;
                        
                        // Orbit around its parent goal
                        if (obj.orbit) {
                            obj.orbit.rotation.y += 0.01;
                            obj.orbit.rotation.x += 0.005;
                        }
                    }
                });
            } else {
                // Light theme animations
                // Simulate gentle wind movement on leaves and flowers
                Object.values(goalObjects).forEach(obj => {
                    if (obj && obj.mesh) {
                        // Gentle swaying
                        obj.mesh.rotation.z = Math.sin(Date.now() * 0.001 + obj.offset) * 0.05;
                    }
                });
                
                Object.values(taskObjects).forEach(obj => {
                    if (obj && obj.mesh) {
                        // Gentle swaying
                        obj.mesh.rotation.z = Math.sin(Date.now() * 0.002 + obj.offset) * 0.1;
                    }
                });
                
                Object.values(problemObjects).forEach(obj => {
                    if (obj && obj.mesh) {
                        // Subtle movement
                        obj.mesh.rotation.z = Math.sin(Date.now() * 0.0005 + obj.offset) * 0.03;
                    }
                });
            }
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Load all visualization objects from localStorage
        function loadVisualizationObjects() {
            const problems = JSON.parse(localStorage.getItem('problems')) || [];
            const goals = JSON.parse(localStorage.getItem('goals')) || [];
            const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            
            // Add problems
            problems.forEach(problem => {
                addProblemObject(problem);
            });
            
            // Add goals
            goals.forEach(goal => {
                addGoalObject(goal);
            });
            
            // Add tasks (after goals are added)
            tasks.forEach(task => {
                const relatedGoal = goals.find(g => g.id === task.relatedGoalId);
                if (relatedGoal) {
                    addTaskObject(task, relatedGoal);
                }
            });
        }

        // Add problem object to 3D scene
        function addProblemObject(problem) {
            if (isDarkTheme) {
                // Create Saturn-like ring for dark theme
                addProblemRing(problem);
            } else {
                // Create brown leaf for light theme
                addProblemLeaf(problem);
            }
        }

        function addProblemRing(problem) {
            // Create a group to hold rings
            const group = new THREE.Group();
            
            // Determine ring color based on emotion
            const color = emotionColors[problem.problemEmotion] || 0xffffff;
            
            // Create multiple rings with different sizes
            const difficulty = parseInt(problem.problemDifficulty);
            const ringCount = difficulty;
            
            for (let i = 0; i < ringCount; i++) {
                const innerRadius = 1 + (i * 0.2);
                const outerRadius = innerRadius + 0.15;
                
                const ringGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7 - (i * 0.1)
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                
                // Tilt rings
                ring.rotation.x = Math.PI / 2;
                
                // Add some particles along the ring for additional detail
                addRingParticles(ring, innerRadius, outerRadius, color);
                
                group.add(ring);
            }
            
            // Random position in the scene (avoiding the center)
            const distance = 10 + Math.random() * 15;
            const angle = Math.random() * Math.PI * 2;
            
            group.position.x = Math.cos(angle) * distance;
            group.position.y = (Math.random() - 0.5) * 10;
            group.position.z = Math.sin(angle) * distance;
            
            // Random rotation
            group.rotation.x = Math.random() * Math.PI;
            group.rotation.y = Math.random() * Math.PI;
            
            scene.add(group);
            
            // Store reference to the object
            problemObjects[problem.id] = { group };
        }
        
        // Add particles to make rings more interesting
        function addRingParticles(ring,  innerRadius, outerRadius, color) {
            const particleCount = 50 + Math.floor(Math.random() * 30);
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            
            // Create particles positioned along the ring
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const angle = Math.random() * Math.PI * 2;
                // Position between inner and outer radius
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                
                particlePositions[i3] = Math.cos(angle) * radius;
                particlePositions[i3 + 1] = 0; // Along the plane of the ring
                particlePositions[i3 + 2] = Math.sin(angle) * radius;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            // Create a brighter version of the ring color for particles
            const particleColor = new THREE.Color(color);
            particleColor.multiplyScalar(1.5); // Brighter
            
            const particleMaterial = new THREE.PointsMaterial({
                color: particleColor,
                size: 0.1,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            ring.add(particles);
        }

        function addProblemLeaf(problem) {
            // Create a brown leaf shape
            const shape = new THREE.Shape();
            
            // Define a leaf shape
            shape.moveTo(0, 0);
            shape.bezierCurveTo(0.5, 0.5, 1, -0.5, 2, 0);
            shape.bezierCurveTo(1, 0.2, 0.5, 0.5, 0, 0);
            
            const geometry = new THREE.ShapeGeometry(shape);
            
            // Brown color with variation based on difficulty
            const difficulty = parseInt(problem.problemDifficulty);
            const color = new THREE.Color(0.4 - difficulty * 0.05, 0.2 - difficulty * 0.02, 0);
            
            const material = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide
            });

            const leaf = new THREE.Mesh(geometry, material);

            // Size based on difficulty
            const scale = 0.3 + (difficulty * 0.1);
            leaf.scale.set(scale, scale, scale);

            // Random position on the vine
            const x = -5 + (Math.random() - 0.5) * 6;
            const y = (Math.random() - 0.5) * 15;
            const z = -9 + (Math.random() - 0.5) * 0.5;

            leaf.position.set(x, y, z);

            // Random rotation
            leaf.rotation.z = Math.random() * Math.PI * 2;

            // Store random offset for animation
            const offset = Math.random() * Math.PI * 2;

            scene.add(leaf);

            // Store reference to the object
            problemObjects[problem.id] = { mesh: leaf, offset };
        }

        // Add goal object to 3D scene
        function addGoalObject(goal) {
            if (isDarkTheme) {
                // Create planet for dark theme
                addGoalPlanet(goal);
            } else {
                // Create flower for light theme
                addGoalFlower(goal);
            }
        }

        function addGoalPlanet(goal) {
            // Determine planet color based on emotion
            let color = goalEmotionColors[goal.goalEmotion] || 0xE91E63;
            
            // Create an orbit container
            const orbitGroup = new THREE.Group();
            scene.add(orbitGroup);
            
            // Planet size based on difficulty
            const difficulty = parseInt(goal.goalDifficulty);
            const radius = 0.3 + (difficulty * 0.1);
            
            // Create planet geometry
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            
            // Create more detailed planet material based on goal type
            const material = createPlanetMaterial(goal, color);
            
            const planet = new THREE.Mesh(geometry, material);
            
            // Position the planet in orbit
            const orbitRadius = 5 + (Math.random() * 3);
            const orbitAngle = Math.random() * Math.PI * 2;
            const orbitHeight = (Math.random() - 0.5) * 2;
            
            planet.position.x = Math.cos(orbitAngle) * orbitRadius;
            planet.position.y = orbitHeight;
            planet.position.z = Math.sin(orbitAngle) * orbitRadius;
            
            // Add an atmosphere glow effect for planets
            addPlanetAtmosphere(planet, color, radius, goal.goalEmotion);
            
            orbitGroup.add(planet);
            
            // Store reference to objects
            goalObjects[goal.id] = {
                mesh: planet,
                orbit: orbitGroup
            };
        }
        
        // Create appropriate material for the planet based on goal type
        function createPlanetMaterial(goal, color) {
            // We'll create different planet styles based on goal area
            const areaToStyleMap = {
                'Diet': 'gasGiant',
                'Family': 'earth',
                'Fitness': 'desert',
                'Health': 'water',
                'Home': 'rocky',
                'Parenting': 'earth',
                'Personal': 'rocky',
                'Relationship': 'gas',
                'Sleep': 'ice',
                'Social Life': 'desert',
                'Study': 'rocky',
                'Work': 'gas'
            };
            
            const planetStyle = areaToStyleMap[goal.goalArea] || 'rocky';
            
            switch (planetStyle) {
                case 'earth': {
                    // Earth-like planet with land and water
                    const texture = createPlanetTexture(color, 0x1a3faa, 'continents');
                    return new THREE.MeshPhongMaterial({
                        map: texture,
                        shininess: 10,
                        bumpScale: 0.02
                    });
                }
                case 'gasGiant': {
                    // Gas giant with stripes
                    const texture = createPlanetTexture(color, new THREE.Color(color).multiplyScalar(0.7), 'stripes');
                    return new THREE.MeshPhongMaterial({
                        map: texture,
                        shininess: 30,
                        specular: 0x666666
                    });
                }
                case 'water': {
                    // Water planet
                    const texture = createPlanetTexture(0x2244aa, 0x1a3faa, 'waves');
                    return new THREE.MeshPhongMaterial({
                        map: texture,
                        shininess: 90,
                        specular: 0xaaaaaa
                    });
                }
                case 'desert': {
                    // Desert planet
                    const texture = createPlanetTexture(0xd2b48c, 0xc19a6b, 'sand');
                    return new THREE.MeshPhongMaterial({
                        map: texture,
                        shininess: 5,
                        bumpScale: 0.05
                    });
                }
                case 'ice': {
                    // Ice planet
                    const texture = createPlanetTexture(0xccddff, 0x99aadd, 'cracks');
                    return new THREE.MeshPhongMaterial({
                        map: texture,
                        shininess: 70,
                        specular: 0xffffff
                    });
                }
                case 'gas': {
                    // Gas planet with swirls
                    const texture = createPlanetTexture(color, new THREE.Color(color).multiplyScalar(0.6), 'swirls');
                    return new THREE.MeshPhongMaterial({
                        map: texture,
                        shininess: 20,
                        specular: 0x333333
                    });
                }
                default: {
                    // Rocky planet
                    const texture = createPlanetTexture(color, new THREE.Color(color).multiplyScalar(0.5), 'craters');
                    return new THREE.MeshPhongMaterial({
                        map: texture,
                        shininess: 10,
                        bumpScale: 0.05
                    });
                }
            }
        }
        
        // Create a texture for the planet
        function createPlanetTexture(primaryColor, secondaryColor, type) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.height = 256;
            
            // Convert THREE.Color to CSS string
            let primary, secondary;
            if (typeof primaryColor === 'number') {
                primary = '#' + new THREE.Color(primaryColor).getHexString();
            } else {
                primary = '#' + primaryColor.getHexString();
            }
            
            if (typeof secondaryColor === 'number') {
                secondary = '#' + new THREE.Color(secondaryColor).getHexString();
            } else {
                secondary = '#' + secondaryColor.getHexString();
            }
            
            // Fill background with primary color
            ctx.fillStyle = primary;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            switch (type) {
                case 'continents': 
                    // Earth-like with continents
                    drawContinents(ctx, canvas.width, canvas.height, secondary);
                    break;
                case 'stripes':
                    // Gas giant with stripes
                    drawStripes(ctx, canvas.width, canvas.height, secondary);
                    break;
                case 'waves':
                    // Water planet with wave patterns
                    drawWaves(ctx, canvas.width, canvas.height, secondary);
                    break;
                case 'sand':
                    // Desert planet with dunes
                    drawNoise(ctx, canvas.width, canvas.height, secondary, 0.3);
                    break;
                case 'cracks':
                    // Ice planet with cracks
                    drawCracks(ctx, canvas.width, canvas.height, secondary);
                    break;
                case 'swirls':
                    // Gas planet with swirls
                    drawSwirls(ctx, canvas.width, canvas.height, secondary);
                    break;
                case 'craters':
                default:
                    // Rocky planet with craters
                    drawCraters(ctx, canvas.width, canvas.height, secondary);
                    break;
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
        
        // Planet texture functions
        function drawContinents(ctx, width, height, color) {
            ctx.fillStyle = color;
            
            // Generate some random "continents"
            const continentCount = 3 + Math.floor(Math.random() * 4);
            
            for (let i = 0; i < continentCount; i++) {
                const centerX = Math.random() * width;
                const centerY = Math.random() * height;
                const size = 30 + Math.random() * 50;
                
                // Draw irregular shapes for continents
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                
                const points = 6 + Math.floor(Math.random() * 6);
                
                for (let j = 0; j < points; j++) {
                    const angle = (j / points) * Math.PI * 2;
                    const radius = size * (0.5 + Math.random() * 0.5);
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.lineTo(x, y);
                }
                
                ctx.closePath();
                ctx.fill();
            }
        }
        
        function drawStripes(ctx, width, height, color) {
            ctx.fillStyle = color;
            
            const stripeCount = 5 + Math.floor(Math.random() * 5);
            const stripeHeight = height / (stripeCount * 2);
            
            for (let i = 0; i < stripeCount; i++) {
                const y = i * stripeHeight * 2;
                ctx.fillRect(0, y, width, stripeHeight);
            }
        }
        
        function drawWaves(ctx, width, height, color) {
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.5;
            
            const waveCount = 10;
            const waveHeight = 5;
            
            for (let i = 0; i < height; i += 10) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                
                for (let x = 0; x < width; x += 5) {
                    const y = i + Math.sin(x * 0.05) * waveHeight;
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(width, i);
                ctx.lineTo(width, i + 5);
                ctx.lineTo(0, i + 5);
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        function drawNoise(ctx, width, height, color, density = 0.3) {
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.4;
            
            const pixelSize = 2;
            
            for (let y = 0; y < height; y += pixelSize) {
                for (let x = 0; x < width; x += pixelSize) {
                    if (Math.random() < density) {
                        ctx.fillRect(x, y, pixelSize, pixelSize);
                    }
                }
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        function drawCracks(ctx, width, height, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            
            const crackCount = 10 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < crackCount; i++) {
                const startX = Math.random() * width;
                const startY = Math.random() * height;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                let x = startX;
                let y = startY;
                const segments = 5 + Math.floor(Math.random() * 10);
                
                for (let j = 0; j < segments; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const length = 10 + Math.random() * 30;
                    
                    x += Math.cos(angle) * length;
                    y += Math.sin(angle) * length;
                    
                    ctx.lineTo(x, y);
                }
                
                ctx.stroke();
            }
        }
        
        function drawSwirls(ctx, width, height, color) {
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.5;
            
            const swirlCount = 3 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < swirlCount; i++) {
                const centerX = Math.random() * width;
                const centerY = Math.random() * height;
                const maxRadius = 30 + Math.random() * 50;
                
                for (let radius = maxRadius; radius > 0; radius -= 2) {
                    const startAngle = Math.random() * Math.PI * 2;
                    const endAngle = startAngle + Math.PI * (1 + Math.random());
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    ctx.arc(centerX, centerY, radius - 2, endAngle, startAngle, true);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        function drawCraters(ctx, width, height, color) {
            ctx.fillStyle = color;
            
            const craterCount = 20 + Math.floor(Math.random() * 30);
            
            for (let i = 0; i < craterCount; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const radius = 2 + Math.random() * 8;
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Add atmosphere glow to planets
        function addPlanetAtmosphere(planet, color, radius, emotion) {
            // Create a larger, transparent sphere around the planet
            const atmosphereRadius = radius * 1.2;
            const atmosphereGeometry = new THREE.SphereGeometry(atmosphereRadius, 32, 32);
            
            // Create a glowing material based on emotion
            let atmosphereColor;
            if (emotion === 'Meaningful') {
                atmosphereColor = new THREE.Color(0x88ff88); // Green glow for meaningful
            } else if (emotion === 'Difficult') {
                atmosphereColor = new THREE.Color(0xff8888); // Red glow for difficult
            } else {
                atmosphereColor = new THREE.Color(0x8888ff); // Blue glow for neutral
            }
            
            const atmosphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    glowColor: { value: atmosphereColor },
                    planetRadius: { value: radius },
                    atmosphereRadius: { value: atmosphereRadius },
                    viewVector: { value: new THREE.Vector3() }
                },
                vertexShader: `
                    uniform vec3 viewVector;
                    varying float intensity;
                    void main() {
                        vec3 vNormal = normalize(normalMatrix * normal);
                        vec3 vNormel = normalize(normalMatrix * viewVector);
                        intensity = pow(1.0 - dot(vNormal, vNormel), 2.0);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying float intensity;
                    void main() {
                        vec3 glow = glowColor * intensity;
                        gl_FragColor = vec4(glow, intensity * 0.5);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            planet.add(atmosphere);
            
            // Update the view vector in the animation loop
            planet.userData.updateAtmosphere = function(camera) {
                atmosphere.material.uniforms.viewVector.value = camera.position.clone().sub(planet.position);
            };
        }

        function addGoalFlower(goal) {
            // Determine flower color based on emotion
            let color;
            switch (goal.goalEmotion) {
                case 'Meaningful':
                    color = 0x4CAF50; // Green
                    break;
                case 'Neutral':
                    color = 0x2196F3; // Blue
                    break;
                case 'Difficult':
                    color = 0xF44336; // Red
                    break;
                default:
                    color = 0xE91E63; // Pink
            }
            
            // Create flower group
            const flowerGroup = new THREE.Group();
            
            // Create stem
            const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
            const stemMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = -0.25;
            flowerGroup.add(stem);
            
            // Create petals
            const difficulty = parseInt(goal.goalDifficulty);
            const petalCount = 5 + difficulty;
            const petalSize = 0.1 + (difficulty * 0.02);
            
            for (let i = 0; i < petalCount; i++) {
                const angle = (i / petalCount) * Math.PI * 2;
                
                const petalGeometry = new THREE.CircleGeometry(petalSize, 8);
                const petalMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide
                });
                
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                
                petal.position.x = Math.cos(angle) * petalSize;
                petal.position.z = Math.sin(angle) * petalSize;
                
                // Tilt petals outward
                petal.lookAt(petal.position.clone().multiplyScalar(2));
                
                flowerGroup.add(petal);
            }
            
            // Create center of flower
            const centerGeometry = new THREE.CircleGeometry(petalSize * 0.6, 16);
            const centerMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00, // Yellow center
                side: THREE.DoubleSide
            });
            
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.rotation.x = -Math.PI / 2;
            flowerGroup.add(center);
            
            // Random position on the vine
            const x = -5 + (Math.random() - 0.5) * 6;
            const y = (Math.random() - 0.5) * 15;
            const z = -9 + (Math.random() - 0.5) * 0.5;
            
            flowerGroup.position.set(x, y, z);
            
            // Random rotation
            flowerGroup.rotation.z = Math.random() * Math.PI * 0.2;
            
            // Store random offset for animation
            const offset = Math.random() * Math.PI * 2;
            
            scene.add(flowerGroup);
            
            // Store reference to the object
            goalObjects[goal.id] = { mesh: flowerGroup, offset };
        }

        // Add task object to 3D scene
        function addTaskObject(task, goal) {
            if (isDarkTheme) {
                // Create moon for dark theme
                addTaskMoon(task, goal);
            } else {
                // Create green leaf for light theme
                addTaskLeaf(task, goal);
            }
        }

        function addTaskMoon(task, goal) {
            // Get parent goal object
            const goalObject = goalObjects[goal.id];
            
            if (!goalObject || !goalObject.mesh) return;
            
            // Create an orbit container for the moon
            const moonOrbit = new THREE.Group();
            
            // Position the orbit at the same position as the planet
            moonOrbit.position.copy(goalObject.mesh.position);
            
            // Add the orbit to the goal's orbit group
            if (goalObject.orbit) {
                goalObject.orbit.add(moonOrbit);
            } else {
                scene.add(moonOrbit);
            }
            
            // Create moon geometry (smaller than planets)
            const radius = 0.1 + Math.random() * 0.1;
            const geometry = new THREE.SphereGeometry(radius, 16, 16);
            
            // Color based on completion status
            const material = new THREE.MeshPhongMaterial({
                color: task.completed ? 0x00FF00 : 0xCCCCCC,
                shininess: 30
            });
            
            // Add some texture to the moon
            const texture = createMoonTexture(task.completed);
            material.map = texture;
            
            const moon = new THREE.Mesh(geometry, material);
            
            // Position the moon in orbit around the planet
            const orbitRadius = 0.8 + Math.random() * 0.5;
            const orbitAngle = Math.random() * Math.PI * 2;
            const orbitTilt = Math.random() * Math.PI * 0.1;
            
            moon.position.x = Math.cos(orbitAngle) * orbitRadius;
            moon.position.y = Math.sin(orbitTilt) * orbitRadius;
            moon.position.z = Math.sin(orbitAngle) * orbitRadius;
            
            // Add a soft glow if the task is completed
            if (task.completed) {
                addCompletionGlow(moon, radius);
            }
            
            moonOrbit.add(moon);
            
            // Store reference to objects
            taskObjects[task.id] = {
                mesh: moon,
                orbit: moonOrbit,
                parentGoalId: goal.id
            };
        }
        
        // Create a texture for moons
        function createMoonTexture(isCompleted) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.height = 128;
            
            // Moon color
            const baseColor = isCompleted ? '#44ff44' : '#cccccc';
            
            // Fill background with base color
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add some craters
            ctx.fillStyle = isCompleted ? '#22dd22' : '#999999';
            
            const craterCount = 5 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < craterCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 1 + Math.random() * 5;
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // If completed, add a check mark or symbol
            if (isCompleted) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(40, 64);
                ctx.lineTo(55, 80);
                ctx.lineTo(88, 40);
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
        
        // Add a glow effect to completed tasks
        function addCompletionGlow(moon, radius) {
            const glowGeometry = new THREE.SphereGeometry(radius * 1.3, 16, 16);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    glowColor: { value: new THREE.Color(0x44ff44) },
                    viewVector: { value: new THREE.Vector3() }
                },
                vertexShader: `
                    uniform vec3 viewVector;
                    varying float intensity;
                    void main() {
                        vec3 vNormal = normalize(normalMatrix * normal);
                        vec3 vNormel = normalize(normalMatrix * viewVector);
                        intensity = pow(1.0 - dot(vNormal, vNormel), 1.5);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying float intensity;
                    void main() {
                        vec3 glow = glowColor * intensity;
                        gl_FragColor = vec4(glow, intensity * 0.6);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            moon.add(glow);
            
            // Add update function to object
            moon.userData.updateGlow = function(camera) {
                glow.material.uniforms.viewVector.value = camera.position.clone().sub(moon.position);
            };
        }

        function addTaskLeaf(task, goal) {
            // Get parent goal object
            const goalObject = goalObjects[goal.id];
            
            if (!goalObject || !goalObject.mesh) return;
            
            // Create a leaf shape
            const shape = new THREE.Shape();
            
            // Define a leaf shape
            shape.moveTo(0, 0);
            shape.bezierCurveTo(0.25, 0.25, 0.5, -0.25, 1, 0);
            shape.bezierCurveTo(0.5, 0.1, 0.25, 0.25, 0, 0);
            
            const geometry = new THREE.ShapeGeometry(shape);
            
            // Green color, brighter if completed
            const color = task.completed ? 0x00FF00 : 0x228B22;
            
            const material = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide
            });
            
            const leaf = new THREE.Mesh(geometry, material);
            
            // Size for leaf
            const scale = 0.2;
            leaf.scale.set(scale, scale, scale);
            
            // Position near the parent flower/goal
            const parentPos = goalObject.mesh.position.clone();
            const offsetX = (Math.random() - 0.5) * 0.5;
            const offsetY = -0.3 + (Math.random() - 0.5) * 0.2;
            const offsetZ = (Math.random() - 0.5) * 0.5;
            
            leaf.position.set(
                parentPos.x + offsetX,
                parentPos.y + offsetY,
                parentPos.z + offsetZ
            );
            
            // Random rotation
            leaf.rotation.z = Math.random() * Math.PI * 2;
            
            // Store random offset for animation
            const offset = Math.random() * Math.PI * 2;
            
            scene.add(leaf);
            
            // Store reference to the object
            taskObjects[task.id] = {
                mesh: leaf,
                parentGoalId: goal.id,
                offset
            };
        }

        // Update task object when completion status changes
        function updateTaskObject(task) {
            const taskObject = taskObjects[task.id];
            
            if (!taskObject || !taskObject.mesh) return;
            
            if (isDarkTheme) {
                // Update moon color and texture
                taskObject.mesh.material.color.set(task.completed ? 0x00FF00 : 0xCCCCCC);
                taskObject.mesh.material.map = createMoonTexture(task.completed);
                taskObject.mesh.material.needsUpdate = true;
                
                // Add or remove glow effect
                if (task.completed && !taskObject.mesh.userData.updateGlow) {
                    const radius = taskObject.mesh.geometry.parameters.radius;
                    addCompletionGlow(taskObject.mesh, radius);
                } else if (!task.completed && taskObject.mesh.userData.updateGlow) {
                    // Remove glow
                    for (let i = taskObject.mesh.children.length - 1; i >= 0; i--) {
                        taskObject.mesh.remove(taskObject.mesh.children[i]);
                    }
                    delete taskObject.mesh.userData.updateGlow;
                }
                
                // Create a shooting star effect on completion
                if (task.completed) {
                    createShootingStar();
                }
            } else {
                // Update leaf color
                taskObject.mesh.material.color.set(task.completed ? 0x00FF00 : 0x228B22);
            }
        }

        // Remove problem object from scene
        function removeProblemObject(problem) {
            const problemObject = problemObjects[problem.id];
            
            if (!problemObject) return;
            
            if (isDarkTheme && problemObject.group) {
                scene.remove(problemObject.group);
            } else if (!isDarkTheme && problemObject.mesh) {
                scene.remove(problemObject.mesh);
            }
            
            delete problemObjects[problem.id];
        }

        // Remove goal object from scene
        function removeGoalObject(goal) {
            const goalObject = goalObjects[goal.id];
            
            if (!goalObject) return;
            
            if (isDarkTheme && goalObject.orbit) {
                scene.remove(goalObject.orbit);
            } else if (!isDarkTheme && goalObject.mesh) {
                scene.remove(goalObject.mesh);
            }
            
            delete goalObjects[goal.id];
        }

        // Remove task object from scene
        function removeTaskObject(task) {
            const taskObject = taskObjects[task.id];
            
            if (!taskObject) return;
            
            if (isDarkTheme && taskObject.orbit) {
                const goalObject = goalObjects[taskObject.parentGoalId];
                if (goalObject && goalObject.orbit) {
                    goalObject.orbit.remove(taskObject.orbit);
                }
            } else if (!isDarkTheme && taskObject.mesh) {
                scene.remove(taskObject.mesh);
            }
            
            delete taskObjects[task.id];
        }

        // Load data from localStorage
        function loadData() {
            renderProblems();
            renderGoals();
            renderTasks();
        }

        // Add sample items if data is empty
        function addSampleItems() {
            const problems = JSON.parse(localStorage.getItem('problems')) || [];
            const goals = JSON.parse(localStorage.getItem('goals')) || [];
            const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            
            // Only add sample items if all lists are empty
            if (problems.length === 0 && goals.length === 0 && tasks.length === 0) {
                // Add sample problem
                const sampleProblem = {
                    id: 'sample-problem-1',
                    problemInput: 'Getting started with Unify - Use the Input Problem section below to add your own problems',
                    problemArea: 'Personal',
                    problemEmotion: 'Anxious',
                    problemDifficulty: '2',
                    timestamp: Date.now()
                };
                
                problems.push(sampleProblem);
                localStorage.setItem('problems', JSON.stringify(problems));
                
                // Add sample goal
                const sampleGoal = {
                    id: 'sample-goal-1',
                    goalInput: 'Identify motivating goals rather than sacrifices - Choose goals that feel meaningful to increase your chances of success',
                    goalArea: 'Personal',
                    goalEmotion: 'Meaningful',
                    goalDifficulty: '2',
                    relatedProblemId: 'sample-problem-1',
                    relatedProblem: sampleProblem.problemInput,
                    timestamp: Date.now()
                };
                
                goals.push(sampleGoal);
                localStorage.setItem('goals', JSON.stringify(goals));
                
                // Add sample task
                const sampleTask = {
                    id: 'sample-task-1',
                    taskInput: 'Fill in task details - Include required knowledge, cooperation, and materials to help you accomplish tasks',
                    relatedGoalId: 'sample-goal-1',
                    relatedGoal: sampleGoal.goalInput,
                    goalArea: sampleGoal.goalArea,
                    materialsInput: 'Example: List any physical materials needed for this task',
                    cooperationInput: 'Example: List any people whose help you will need',
                    knowledgeInput: 'Example: List any skills or information you need to learn',
                    timestamp: Date.now(),
                    completed: false
                };
                
                tasks.push(sampleTask);
                localStorage.setItem('tasks', JSON.stringify(tasks));
                
                // Re-render lists
                renderProblems();
                renderGoals();
                renderTasks();
            }
        }
    </script>
</body>
</html>