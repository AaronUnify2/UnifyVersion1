<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Warren Buffett's Bubble Pop Investment Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
            touch-action: none;
        }
        
        #root {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }
        
        .game-container {
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 600px;
            margin: 0 auto;
            position: relative;
            background: #000;
        }
        
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            z-index: 10;
        }
        
        .menu-title {
            font-size: 2.5em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .menu-subtitle {
            font-size: 1.2em;
            margin-bottom: 40px;
            color: #ccc;
        }
        
        .menu-button {
            padding: 15px 40px;
            font-size: 1.2em;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .menu-button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }
        
        .menu-button:active {
            transform: translateY(0);
        }
        
        .game-screen {
            width: 100%;
            /* Updated to 3:2 aspect ratio per devdoc */
            aspect-ratio: 3 / 2;
            position: relative;
            display: none;
        }
        
        .game-screen.active {
            display: block;
        }
        
        /* Decade-specific visual themes */
        .decade-border {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 20px solid #666;
            pointer-events: none;
        }
        
        .decade-1950s {
            border-color: #666;
            background: repeating-linear-gradient(45deg, #333, #333 10px, #444 10px, #444 20px);
            font-family: 'Courier New', Courier, monospace; /* Serif typewriter style */
        }
        
        .decade-1960s { 
            border-color: #ff6b6b;
            background: repeating-linear-gradient(45deg, #ff6b6b, #ff6b6b 10px, #feca57 10px, #feca57 20px);
            font-family: 'Bubblegum Sans', cursive; /* Groovy rounded style */
        }
        
        .decade-1970s { 
            border-color: #8b4513;
            background: repeating-linear-gradient(45deg, #d2691e, #d2691e 10px, #ff8c00 10px, #ff8c00 20px);
            font-family: 'Disco', sans-serif; /* Bold disco style */
        }
        
        .decade-1980s { 
            border-color: #ff00ff;
            background: repeating-linear-gradient(45deg, #ff00ff, #ff00ff 10px, #00ffff 10px, #00ffff 20px);
            font-family: 'OCR-A', monospace; /* Digital clock style */
        }
        
        .decade-1990s { 
            border-color: #0066cc;
            background: repeating-linear-gradient(45deg, #0066cc, #0066cc 10px, #ffcc00 10px, #ffcc00 20px);
            font-family: 'Comic Sans MS', cursive; /* Comic Sans style */
        }
        
        .decade-2000s { 
            border-color: #4285f4;
            background: linear-gradient(135deg, #4285f4 0%, #34a853 50%, #fbbc05 100%);
            font-family: 'Helvetica', Arial, sans-serif; /* Helvetica-inspired */
        }
        
        .decade-2010s { 
            border-color: #f0f0f0;
            background: #fff;
            font-family: 'Roboto', sans-serif; /* Modern sans-serif */
        }
        
        .decade-2020s { 
            border-color: #6366f1;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #ec4899 100%);
            font-family: 'Inter', sans-serif; /* Variable weight modern */
        }
        
        #gameCanvas {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            bottom: 120px;
            overflow: hidden;
            cursor: crosshair;
            background: rgba(0,0,0,0.1);
        }
        
        .game-ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 80px;
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
        }
        
        .stat-display {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-label {
            font-size: 0.8em;
            color: #ccc;
        }
        
        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .sugar-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #666;
        }
        
        .sugar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b 0%, #ff8e53 100%);
            transition: width 0.3s;
        }
        
        .quote-box {
            position: absolute;
            bottom: 110px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            border-radius: 5px;
            padding: 10px;
            font-size: 0.9em;
            color: #ffd700;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .shop-screen, .investment-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
        }
        
        .shop-screen.active, .investment-screen.active {
            display: flex;
        }
        
        .shop-header, .investment-header {
            font-size: 2em;
            color: #ffd700;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .shop-items, .investment-tabs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .shop-item, .stock-item, .subsidiary-item {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #444;
            transition: all 0.3s;
        }
        
        .shop-item:hover, .stock-item:hover, .subsidiary-item:hover {
            border-color: #ffd700;
            transform: translateY(-2px);
        }
        
        .shop-item-name, .stock-name, .subsidiary-name {
            font-size: 1.1em;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .shop-item-desc, .stock-info, .subsidiary-info {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 10px;
        }
        
        .shop-item-price, .stock-price, .subsidiary-price {
            font-size: 1em;
            color: #4CAF50;
            margin-bottom: 10px;
        }
        
        .shop-buy-button, .stock-button, .subsidiary-buy-button {
            width: 100%;
            padding: 8px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .shop-buy-button:hover:not(:disabled), .stock-button:hover:not(:disabled), .subsidiary-buy-button:hover:not(:disabled) {
            background: #45a049;
        }
        
        .shop-buy-button:disabled, .stock-button:disabled, .subsidiary-buy-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .stock-button.sell {
            background: #f44336;
        }
        
        .stock-button.sell:hover:not(:disabled) {
            background: #d32f2f;
        }
        
        .continue-button {
            padding: 15px 40px;
            font-size: 1.2em;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 20px auto;
            display: block;
        }
        
        .powerup-selector {
            position: absolute;
            bottom: 110px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        
        .powerup-button {
            padding: 5px 10px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .cannon {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 24px; /* Per devdoc: 24x24px */
            height: 24px;
            background: #666;
            border-radius: 50%;
            border: 3px solid #888;
            z-index: 5;
            pointer-events: none;
        }
        
        .cannon-barrel {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform-origin: bottom center;
            width: 6px;
            height: 18px;
            background: #888;
            margin-left: -3px;
            pointer-events: none;
        }
        
        .bubble {
            position: absolute;
            width: 16px; /* Per devdoc: 16x16px */
            height: 16px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.3); /* 1px highlight */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: left 0.1s, top 0.1s;
        }
        
        .bubble.popping {
            animation: pop 0.3s ease-out forwards;
        }
        
        @keyframes pop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); }
            100% { transform: scale(0); opacity: 0; }
        }
        
        .bubble-queue {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            align-items: center;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 20px;
        }
        
        .queue-bubble {
            width: 16px; /* Adjusted to match bubble size */
            height: 16px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.3);
            transition: all 0.3s;
        }
        
        .queue-bubble:first-child {
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
        }
        
        .collectable {
            position: absolute;
            width: 12px; /* Per devdoc: 12x12px */
            height: 12px;
            animation: fall 2s linear;
        }
        
        @keyframes fall {
            from { transform: translateY(0); }
            to { transform: translateY(500px); }
        }
        
        .coin {
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
        }
        
        .sweet {
            background: #ff69b4;
            border-radius: 5px;
        }
        
        .book {
            background: #8b4513;
            border-radius: 3px;
        }
        
        .trajectory-line {
            position: absolute;
            height: 3px;
            background: repeating-linear-gradient(
                to right,
                #ffd700,
                #ffd700 10px,
                transparent 10px,
                transparent 15px
            );
            transform-origin: left center;
            pointer-events: none;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="root">
        <div style="text-align: center; padding: 50px;">
            <h2>Loading Game...</h2>
        </div>
    </div>
    
    <script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Game quotes (from InvestmentQuotes.txt)
        const levelStartQuotes = [
            "The stock market is a device for transferring money from the impatient to the patient.",
            "Price is what you pay. Value is what you get.",
            "Our favorite holding period is forever.",
            "Risk comes from not knowing what you're doing.",
            "Someone's sitting in the shade today because someone planted a tree a long time ago.",
            "Be fearful when others are greedy and greedy when others are fearful.",
            "The most important investment you can make is in yourself.",
            "It's far better to buy a wonderful company at a fair price than a fair company at a wonderful price.",
            "Time is the friend of the wonderful company, the enemy of the mediocre.",
            "Rule No. 1: Never lose money. Rule No. 2: Never forget rule No. 1.",
            // ... (abridged for brevity, full list in InvestmentQuotes.txt)
        ];
        
        const powerupQuotes = {
            munger: [
                "Invert, always invert.",
                "Show me the incentive and I will show you the outcome."
            ],
            graham: [
                "In the short run, the market is a voting machine...",
                "The investor's chief problem is likely to be himself."
            ]
        };
        
        const bookFacts = [
            "Compound interest is the eighth wonder of the world.",
            "Risk comes from not knowing what you're doing.",
            "Diversification is protection against ignorance.",
            "The intelligent investor is a realist who sells to optimists and buys from pessimists.",
            "In the short run, the market is a voting machine but in the long run, it is a weighing machine.",
            // ... (abridged for brevity, full list in InvestmentQuotes.txt)
        ];
        
        // Sound effects (placeholders, to be replaced with base64 WAV files)
        const sounds = {
            pop: "data:audio/wav;base64,...", // 0.1s bubble pop
            shoot: "data:audio/wav;base64,...", // 0.2s cannon fire
            bomb: "data:audio/wav;base64,...", // 0.3s explosion
            bounce: "data:audio/wav;base64,...", // 0.1s wall bounce
            shimmer: "data:audio/wav;base64,...", // 0.5s Graham effect
            collect: "data:audio/wav;base64,...", // 0.2s item pickup
            levelComplete: "data:audio/wav;base64,..." // 1s fanfare
        };
        
        // Historical stock data (from InvestmentReturns.txt)
        const stockData = {
            BRK: {
                name: "Berkshire Hathaway",
                startYear: 1965,
                bookCost: 20,
                prices: {
                    1965: 18, 1970: 42, 1975: 38, 1980: 340, 1981: 560, 1985: 2400, 1990: 6675,
                    1995: 32100, 2000: 71000, 2005: 88620, 2010: 120450, 2015: 197800,
                    2020: 347815, 2025: 795000
                }
            },
            DIS: {
                name: "Disney",
                startYear: 1957,
                bookCost: 30,
                prices: {
                    1963: 0.067, 1970: 0.4774, 1975: 0.6737, 1980: 0.6923, 1985: 1.6429,
                    1990: 6.0778, 1995: 14.5687, 2000: 22.2690, 2005: 19.4287,
                    2010: 32.6266, 2015: 97.9273, 2020: 178.9690, 2025: 92.49
                }
            },
            KO: {
                name: "Coca-Cola",
                startYear: 1919,
                bookCost: 40,
                unlockedBy: "Buy 5 Cokes from store",
                prices: {
                    1963: 0.0667, 1970: 0.4774, 1975: 0.6737, 1980: 0.6923, 1985: 1.6429,
                    1990: 6.0778, 1995: 14.5687, 2000: 22.2690, 2005: 19.4287,
                    2010: 32.6266, 2015: 97.9273, 2020: 178.9690, 2025: 92.49
                }
            },
            AXP: {
                name: "American Express",
                startYear: 1958,
                bookCost: 60,
                prices: {
                    1972: 10, 1980: 20, 1985: 30, 1990: 40, 1995: 50, 2000: 60,
                    2005: 70, 2010: 80, 2015: 90, 2020: 100, 2025: 110
                }
            },
            BAC: {
                name: "Bank of America",
                startYear: 1956,
                bookCost: 80,
                prices: {
                    1985: 1.8605, 1990: 2.2464, 1995: 8.1748, 2000: 12.5007,
                    2005: 30.5533, 2010: 10.5495, 2015: 13.7420, 2020: 27.3116, 2025: 43.20
                }
            },
            AAPL: {
                name: "Apple",
                startYear: 1980,
                bookCost: 150,
                unlockedBy: "Ted and Todd Recruited",
                prices: {
                    1981: 0.076, 1985: 0.0755, 1990: 0.3060, 1995: 0.2398, 2000: 0.2238,
                    2005: 2.1634, 2010: 9.7070, 2015: 23.8140, 2020: 129.6090, 2025: 202.52
                }
            }
        };
        
        // Subsidiary data (from previous answer)
        const subsidiaryData = {
            SEES: {
                name: "See's Candy",
                bookCost: 25,
                cashReturn: 100,
                unlockedBy: "Charlie Munger Partnership"
            },
            GEICO: {
                name: "GEICO",
                bookCost: 50,
                cashReturn: 200,
                unlockedBy: "The Intelligent Investor"
            },
            BNSF: {
                name: "BNSF Railway",
                bookCost: 100,
                cashReturn: 300,
                unlockedBy: "Poor Charlie's Almanack"
            },
            DURACELL: {
                name: "Duracell",
                bookCost: 80,
                cashReturn: 250,
                unlockedBy: "Essays of Warren Buffett"
            },
            DAIRYQUEEN: {
                name: "Dairy Queen",
                bookCost: 40,
                cashReturn: 150,
                unlockedBy: "Common Stocks and Uncommon Profits"
            },
            FRUIT: {
                name: "Fruit of the Loom",
                bookCost: 60,
                cashReturn: 180,
                unlockedBy: "The Little Book of Common Sense Investing"
            },
            GILLETTE: {
                name: "Gillette",
                bookCost: 70,
                cashReturn: 220,
                unlockedBy: "The Intelligent Investor"
            },
            NFM: {
                name: "Nebraska Furniture Mart",
                bookCost: 30,
                cashReturn: 120,
                unlockedBy: null
            }
        };
        
        // Bubble colors per devdoc
        const bubbleColors = {
            '1951-1960': ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#ff6b9d'],
            '1961-1970': ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#a29bfe'],
            '1971-1990': ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#a29bfe', '#55efc4'],
            '1991-2000': ['#ff6b6b', '#4ecdc4', '#45b7d1'],
            '2001-2010': ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#a29bfe'],
            '2011-2020': ['#ff6b6b', '#45b7d1', '#f9ca24', '#a29bfe', '#55efc4', '#fd79a8'],
            '2021-2025': ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#a29bfe', '#55efc4', '#fd79a8', '#00b894']
        };
        
        // Game component
        function Game() {
            const [gameState, setGameState] = useState('menu');
            const [year, setYear] = useState(1951);
            const [lives, setLives] = useState(3);
            const [coins, setCoins] = useState(0);
            const [sugar, setSugar] = useState(30); // Per devdoc: starting sugar 30
            const [maxSugar, setMaxSugar] = useState(30);
            const [books, setBooks] = useState(0);
            const [portfolio, setPortfolio] = useState({
                stocks: {},
                subsidiaries: {}
            });
            const [upgrades, setUpgrades] = useState({
                sugarMax: 30,
                startingBubbles: 10,
                seesCandyLevel: 0,
                mungerPartner: false,
                ditchCigar: false,
                removeBankers: false,
                tedTodd: false,
                mungerDietCoke: 0
            });
            const [unlocks, setUnlocks] = useState({
                stocks: ['BRK'],
                items: []
            });
            const [statistics, setStatistics] = useState({
                totalBubblesPopped: 0,
                totalCoinsEarned: 0,
                totalInvestmentGains: 0,
                bestYear: { year: 1951, score: 0 }
            });
            const [currentQuote, setCurrentQuote] = useState('Welcome to Warren Buffett\'s Bubble Pop Adventure!');
            const [bubbles, setBubbles] = useState([]);
            const [cannonAngle, setCannonAngle] = useState(0);
            const [bubbleQueue, setBubbleQueue] = useState([]);
            const [scrollSpeed, setScrollSpeed] = useState(0.5);
            const [collectables, setCollectables] = useState([]);
            const [activePowerup, setActivePowerup] = useState(null);
            const [cokePurchases, setCokePurchases] = useState(0);
            
            const gameRef = useRef(null);
            const animationRef = useRef(null);
            const lastTimeRef = useRef(0);
            
            // Grid constants for hexagonal layout
            const GRID_WIDTH = 16; // Matches bubble size
            const GRID_HEIGHT = 16 * Math.sqrt(3) / 2;
            const ROW_OFFSET = GRID_WIDTH / 2;
            const MAX_ROWS = 6; // Per devdoc: 6 rows
            const MAX_COLS = 20; // Per devdoc: 20 columns
            
            // Save system
            const saveGame = useCallback(() => {
                const saveData = {
                    version: "1.0",
                    currentYear: year,
                    lives,
                    coins,
                    portfolio,
                    upgrades,
                    unlocks,
                    statistics
                };
                localStorage.setItem('bubbleBuffettSave', JSON.stringify(saveData));
            }, [year, lives, coins, portfolio, upgrades, unlocks, statistics]);
            
            const loadGame = useCallback(() => {
                const saved = localStorage.getItem('bubbleBuffettSave');
                if (saved) {
                    const data = JSON.parse(saved);
                    if (data.version === "1.0") {
                        setYear(data.currentYear);
                        setLives(data.lives);
                        setCoins(data.coins);
                        setPortfolio(data.portfolio);
                        setUpgrades(data.upgrades);
                        setUnlocks(data.unlocks);
                        setStatistics(data.statistics);
                        setMaxSugar(data.upgrades.sugarMax);
                        setSugar(Math.min(data.upgrades.sugarMax, 30));
                    }
                }
            }, []);
            
            useEffect(() => {
                loadGame();
            }, [loadGame]);
            
            // Get decade from year
            const getDecade = (year) => {
                if (year <= 1959) return '1950s';
                if (year <= 1969) return '1960s';
                if (year <= 1979) return '1970s';
                if (year <= 1989) return '1980s';
                if (year <= 1999) return '1990s';
                if (year <= 2009) return '2000s';
                if (year <= 2019) return '2010s';
                return '2020s';
            };
            
            // Get bubble color count for year
            const getBubbleColorCount = (year) => {
                const periods = {
                    '1951-1960': [3, 4, 5],
                    '1961-1970': [4, 5, 6],
                    '1971-1990': [5, 6, 7],
                    '1991-2000': [3, 4, 5],
                    '2001-2010': [5, 6, 7],
                    '2011-2020': [3, 7, 8],
                    '2021-2025': [6, 8, 10]
                };
                const period = Object.keys(periods).find(p => {
                    const [start, end] = p.split('-').map(Number);
                    return year >= start && year <= end;
                });
                const range = periods[period] || [3, 4, 5];
                const decadeProgress = (year % 10) / 10;
                return Math.floor(range[0] + (range[2] - range[0]) * decadeProgress);
            };
            
            // Get scroll speed for year
            const getScrollSpeed = (year) => {
                const speeds = {
                    '1951-1960': 0.5,
                    '1961-1970': 0.5,
                    '1971-1990': 0.5,
                    '1991-2000': 1.0,
                    '2001-2010': 1.0,
                    '2011-2020': 1.5,
                    '2021-2025': 2.0
                };
                const period = Object.keys(speeds).find(p => {
                    const [start, end] = p.split('-').map(Number);
                    return year >= start && year <= end;
                });
                return speeds[period] || 0.5;
            };
            
            // Snap bubble to hexagonal grid
            const snapToGrid = (x, y) => {
                const row = Math.round((y - 20) / GRID_HEIGHT);
                const isEvenRow = row % 2 === 0;
                const col = Math.round((x - 20 - (isEvenRow ? 0 : ROW_OFFSET)) / GRID_WIDTH);
                return {
                    x: col * GRID_WIDTH + 20 + (isEvenRow ? 0 : ROW_OFFSET),
                    y: row * GRID_HEIGHT + 20,
                    row,
                    col
                };
            };
            
            // Check collision with bubbles or walls
            const checkCollision = (x, y, bubbles) => {
                if (y <= 20) return true; // Top wall
                return bubbles.some(b => !b.popping && !b.moving && 
                    Math.hypot(x - b.x, y - b.y) < GRID_WIDTH - 2);
            };
            
            // Find connected bubbles for cluster popping
            const findConnectedBubbles = (startBubble, bubbles, color) => {
                const connected = [startBubble];
                const checked = new Set([startBubble.id]);
                
                while (connected.length > 0) {
                    const current = connected.shift();
                    bubbles.forEach(b => {
                        if (!checked.has(b.id) && !b.popping && b.color === color) {
                            const dx = Math.abs(b.x - current.x);
                            const dy = Math.abs(b.y - current.y);
                            if (dx <= GRID_WIDTH + 2 && dy <= GRID_HEIGHT + 2 &&
                                Math.hypot(b.x - current.x, b.y - current.y) < GRID_WIDTH + 2) {
                                connected.push(b);
                                checked.add(b.id);
                            }
                        }
                    });
                }
                
                return checked.size >= 3 ? Array.from(checked).map(id => bubbles.find(b => b.id === id)) : [];
            };
            
            // Initialize level
            const initLevel = () => {
                setCurrentQuote(levelStartQuotes[Math.floor(Math.random() * levelStartQuotes.length)] || "Time to start investing!");
                setScrollSpeed(getScrollSpeed(year));
                setSugar(maxSugar);
                
                const colorCount = getBubbleColorCount(year);
                const period = Object.keys(bubbleColors).find(p => {
                    const [start, end] = p.split('-').map(Number);
                    return year >= start && year <= end;
                });
                const colors = bubbleColors[period].slice(0, colorCount);
                
                const newBubbles = [];
                for (let row = 0; row < MAX_ROWS; row++) {
                    const fillPercentage = row === 0 ? 1.0 : row === MAX_ROWS - 1 ? 0.4 : 1.0 - (row / (MAX_ROWS - 1)) * 0.6;
                    const isEvenRow = row % 2 === 0;
                    for (let col = 0; col < MAX_COLS; col++) {
                        if (Math.random() < fillPercentage) {
                            newBubbles.push({
                                id: `init-${row}-${col}`,
                                x: col * GRID_WIDTH + 20 + (isEvenRow ? 0 : ROW_OFFSET),
                                y: row * GRID_HEIGHT + 20,
                                row,
                                col,
                                color: colors[Math.floor(Math.random() * colors.length)],
                                popping: false
                            });
                        }
                    }
                }
                
                setBubbles(newBubbles);
                
                const queue = [];
                for (let i = 0; i < upgrades.startingBubbles; i++) {
                    queue.push(colors[Math.floor(Math.random() * colors.length)]);
                }
                setBubbleQueue(queue);
                
                // Add subsidiary cash returns
                let subsidiaryIncome = 0;
                Object.entries(portfolio.subsidiaries).forEach(([id, data]) => {
                    if (data.owned) {
                        subsidiaryIncome += subsidiaryData[id].cashReturn;
                    }
                });
                setCoins(prev => prev + subsidiaryIncome);
                
                saveGame();
            };
            
            // Start game
            const startGame = () => {
                try {
                    setGameState('playing');
                    initLevel();
                } catch (error) {
                    alert('Error starting game: ' + error.message);
                }
            };
            
            // Pop bubble and create collectables
            const popBubble = (bubble, popCount = 1) => {
                setBubbles(prev => prev.map(b => 
                    b.id === bubble.id ? { ...b, popping: true } : b
                ));
                
                setTimeout(() => {
                    setBubbles(prev => prev.filter(b => b.id !== bubble.id));
                    setStatistics(prev => ({
                        ...prev,
                        totalBubblesPopped: prev.totalBubblesPopped + 1
                    }));
                }, 300);
                
                const dropChance = Math.min(1, 0.3 + (popCount - 1) * 0.1); // Multi-pop bonus
                const drops = [];
                if (Math.random() < dropChance) {
                    drops.push({
                        type: 'coin',
                        x: bubble.x,
                        y: bubble.y,
                        id: Math.random()
                    });
                }
                if (Math.random() < 0.15) {
                    drops.push({
                        type: 'sweet',
                        x: bubble.x,
                        y: bubble.y,
                        id: Math.random()
                    });
                }
                if (Math.random() < 0.05) {
                    drops.push({
                        type: 'book',
                        x: bubble.x,
                        y: bubble.y,
                        id: Math.random()
                    });
                    setCurrentQuote(bookFacts[Math.floor(Math.random() * bookFacts.length)]);
                }
                
                setCollectables(prev => [...prev, ...drops]);
                
                setTimeout(() => {
                    drops.forEach(drop => {
                        if (drop.type === 'coin') {
                            const coinValue = Math.ceil(year / 10); // Scales with difficulty
                            setCoins(prev => prev + coinValue);
                            setStatistics(prev => ({
                                ...prev,
                                totalCoinsEarned: prev.totalCoinsEarned + coinValue
                            }));
                        }
                        if (drop.type === 'sweet') setSugar(prev => Math.min(prev + 10, maxSugar));
                        if (drop.type === 'book') setBooks(prev => prev + 1);
                    });
                    setCollectables(prev => prev.filter(c => !drops.find(d => d.id === c.id)));
                }, 2000);
            };
            
            // End level
            const endLevel = () => {
                if (gameState !== 'playing') return;
                setGameState('shop');
                saveGame();
            };
            
            // Handle mouse/touch movement
            const handlePointerMove = (e) => {
                if (gameState !== 'playing' || !gameRef.current) return;
                
                const rect = gameRef.current.getBoundingClientRect();
                const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
                const cannonX = rect.width / 2;
                const cannonY = rect.height - 60;
                
                const angle = Math.atan2(y - cannonY, x - cannonX);
                const degrees = angle * 180 / Math.PI - 90;
                const clamped = Math.max(-89, Math.min(89, degrees)); // 178° firing angle
                
                setCannonAngle(clamped);
            };
            
            // Handle shooting
            const handleShoot = (e) => {
                if (gameState !== 'playing' || bubbleQueue.length === 0) return;
                
                e.preventDefault();
                
                const color = bubbleQueue[0];
                let effect = null;
                if (activePowerup) {
                    effect = activePowerup;
                    setActivePowerup(null);
                    setCurrentQuote(powerupQuotes[effect.type][Math.floor(Math.random() * powerupQuotes[effect.type].length)]);
                }
                
                setBubbleQueue(prev => {
                    const newQueue = prev.slice(1);
                    if (newQueue.length < upgrades.startingBubbles) {
                        const colorCount = getBubbleColorCount(year);
                        const period = Object.keys(bubbleColors).find(p => {
                            const [start, end] = p.split('-').map(Number);
                            return year >= start && year <= end;
                        });
                        const colors = bubbleColors[period].slice(0, colorCount);
                        newQueue.push(colors[Math.floor(Math.random() * colors.length)]);
                    }
                    return newQueue;
                });
                
                const rect = gameRef.current.getBoundingClientRect();
                const angleRad = (cannonAngle + 90) * Math.PI / 180;
                const speed = 10;
                
                const newBubble = {
                    id: `shot-${Date.now()}-${Math.random()}`,
                    x: rect.width / 2,
                    y: rect.height - 60,
                    vx: Math.cos(angleRad) * speed,
                    vy: Math.sin(angleRad) * speed,
                    color,
                    moving: true,
                    effect
                };
                
                setBubbles(prev => [...prev, newBubble]);
                
                // Play shoot sound
                new Audio(sounds.shoot).play();
            };
            
            // Game loop
            useEffect(() => {
                if (gameState !== 'playing') return;
                
                const gameLoop = (timestamp) => {
                    const deltaTime = timestamp - lastTimeRef.current;
                    lastTimeRef.current = timestamp;
                    
                    if (deltaTime > 0) {
                        setSugar(prev => {
                            const newSugar = Math.max(0, prev - deltaTime / 1000); // 1 point/second
                            if (newSugar === 0 || bubbleQueue.length === 0) {
                                endLevel();
                            }
                            return newSugar;
                        });
                    }
                    
                    setBubbles(prev => {
                        const colorCount = getBubbleColorCount(year);
                        const period = Object.keys(bubbleColors).find(p => {
                            const [start, end] = p.split('-').map(Number);
                            return year >= start && year <= end;
                        });
                        const colors = bubbleColors[period].slice(0, colorCount);
                        const rect = gameRef.current.getBoundingClientRect();
                        
                        let updated = prev.map(bubble => {
                            if (bubble.moving) {
                                let newX = bubble.x + bubble.vx * (deltaTime / 16);
                                let newY = bubble.y + bubble.vy * (deltaTime / 16);
                                
                                if (newX <= 20 || newX >= rect.width - 20) {
                                    bubble.vx = -bubble.vx;
                                    newX = Math.max(20, Math.min(rect.width - 20, newX));
                                    new Audio(sounds.bounce).play();
                                }
                                
                                if (checkCollision(newX, newY, prev)) {
                                    const snapped = snapToGrid(newX, newY);
                                    let connected = [];
                                    if (bubble.effect?.type === 'explosive') {
                                        connected = prev.filter(b => 
                                            !b.popping && 
                                            Math.abs(b.row - snapped.row) <= 1 &&
                                            Math.abs(b.col - snapped.col) <= 1
                                        );
                                        new Audio(sounds.bomb).play();
                                    } else if (bubble.effect?.type === 'converter') {
                                        connected = prev.filter(b => 
                                            !b.popping && 
                                            Math.hypot(b.x - snapped.x, b.y - snapped.y) < GRID_WIDTH + 2
                                        ).map(b => ({ ...b, color: '#999' }));
                                        new Audio(sounds.shimmer).play();
                                    } else {
                                        connected = findConnectedBubbles(
                                            { ...bubble, x: snapped.x, y: snapped.y, id: bubble.id, row: snapped.row, col: snapped.col },
                                            prev,
                                            bubble.color
                                        );
                                    }
                                    
                                    if (connected.length >= 3 || bubble.effect) {
                                        const popCount = connected.length;
                                        connected.forEach(b => popBubble(b, popCount));
                                        return null;
                                    }
                                    return { ...bubble, x: snapped.x, y: snapped.y, row: snapped.row, col: snapped.col, moving: false, effect: null };
                                }
                                
                                return { ...bubble, x: newX, y: newY };
                            }
                            
                            return { ...bubble, x: bubble.x + scrollSpeed * (deltaTime / 16) };
                        }).filter(Boolean);
                        
                        updated = updated.filter(bubble => bubble.x < rect.width - 20);
                        
                        // Add new bubbles to top row if needed
                        const topRowBubbles = updated.filter(b => b.row === 0);
                        if (topRowBubbles.length < MAX_COLS) {
                            const isEvenRow = 0 % 2 === 0;
                            const spawnX = (topRowBubbles.length * GRID_WIDTH) + 20 + (isEvenRow ? 0 : ROW_OFFSET);
                            updated.push({
                                id: `top-new-${Date.now()}-${Math.random()}`,
                                x: spawnX,
                                y: 20,
                                row: 0,
                                col: topRowBubbles.length,
                                color: colors[Math.floor(Math.random() * colors.length)],
                                popping: false
                            });
                        }
                        
                        return updated;
                    });
                    
                    animationRef.current = requestAnimationFrame(gameLoop);
                };
                
                animationRef.current = requestAnimationFrame(gameLoop);
                
                return () => {
                    if (animationRef.current) {
                        cancelAnimationFrame(animationRef.current);
                    }
                };
            }, [gameState, scrollSpeed, year]);
            
            // Keyboard controls
            useEffect(() => {
                const handleKeyPress = (e) => {
                    if (gameState !== 'playing') return;
                    
                    if (e.code === 'Space' && bubbleQueue.length > 0) {
                        e.preventDefault();
                        handleShoot(e);
                    }
                };
                
                window.addEventListener('keydown', handleKeyPress);
                return () => window.removeEventListener('keydown', handleKeyPress);
            }, [gameState, bubbleQueue]);
            
            // Shop items
            const shopItems = [
                {
                    id: 'sees-candy',
                    name: "See's Candy",
                    desc: "Increase max sugar by 20",
                    basePrice: 100,
                    priceMultiplier: 1.5,
                    requires: upgrades.mungerPartner,
                    action: () => {
                        setMaxSugar(prev => prev + 20);
                        setUpgrades(prev => ({ ...prev, seesCandyLevel: prev.seesCandyLevel + 1 }));
                        saveGame();
                    }
                },
                {
                    id: 'coke',
                    name: "Coke",
                    desc: "Restore 20% sugar (consumable)",
                    basePrice: 50,
                    priceMultiplier: 1.2,
                    maxPurchases: 99,
                    action: () => {
                        setSugar(prev => Math.min(prev + maxSugar * 0.2, maxSugar));
                        setCokePurchases(prev => prev + 1);
                        if (cokePurchases + 1 >= 5) {
                            setUnlocks(prev => ({ ...prev, stocks: [...prev.stocks, 'KO'] }));
                        }
                        saveGame();
                    }
                },
                {
                    id: 'mungers-lollapaloozas',
                    name: "Munger's Lollapaloozas",
                    desc: "Next shot destroys 3x3 area",
                    price: 200,
                    requires: upgrades.mungerPartner,
                    action: () => {
                        setActivePowerup({ type: 'munger', effect: 'explosive' });
                    }
                },
                {
                    id: 'grahams-nets',
                    name: "Graham's Nets",
                    desc: "Next shot turns hit bubbles grey for chain pops",
                    price: 300,
                    requires: unlocks.items.includes('The Intelligent Investor'),
                    action: () => {
                        setActivePowerup({ type: 'graham', effect: 'converter' });
                    }
                },
                {
                    id: 'munger-partner',
                    name: "Partner with Charlie",
                    desc: "+1 starting bubble",
                    price: 500,
                    purchased: upgrades.mungerPartner,
                    action: () => {
                        setUpgrades(prev => ({ ...prev, mungerPartner: true, startingBubbles: prev.startingBubbles + 1 }));
                        setPortfolio(prev => ({
                            ...prev,
                            subsidiaries: {
                                ...prev.subsidiaries,
                                SEES: { owned: true, booksSpent: 0 }
                            }
                        }));
                        saveGame();
                    }
                },
                {
                    id: 'ditch-cigar',
                    name: "Ditch the Cigar Butts",
                    desc: "Better bubble colors distribution",
                    price: 1000,
                    purchased: upgrades.ditchCigar,
                    requires: unlocks.items.includes('Poor Charlie\'s Almanack'),
                    action: () => {
                        setUpgrades(prev => ({ ...prev, ditchCigar: true }));
                        saveGame();
                    }
                },
                {
                    id: 'remove-bankers',
                    name: "Remove Investment Bankers",
                    desc: "+5 explosive bubbles per level",
                    price: 2000,
                    purchased: upgrades.removeBankers,
                    action: () => {
                        setUpgrades(prev => ({ ...prev, removeBankers: true }));
                        saveGame();
                    }
                },
                {
                    id: 'ted-todd',
                    name: "Ted and Todd Recruited",
                    desc: "+1 starting bubble, unlocks Apple stock",
                    price: 5000,
                    purchased: upgrades.tedTodd,
                    action: () => {
                        setUpgrades(prev => ({ ...prev, tedTodd: true, startingBubbles: prev.startingBubbles + 1 }));
                        setUnlocks(prev => ({ ...prev, stocks: [...prev.stocks, 'AAPL'] }));
                        saveGame();
                    }
                },
                {
                    id: 'mungers-diet-coke',
                    name: "Munger's Diet Coke",
                    desc: "+1 life",
                    basePrice: 1000,
                    priceMultiplier: 2.0,
                    action: () => {
                        setLives(prev => prev + 1);
                        setUpgrades(prev => ({ ...prev, mungerDietCoke: prev.mungerDietCoke + 1 }));
                        saveGame();
                    }
                },
                {
                    id: 'intelligent-investor',
                    name: "The Intelligent Investor",
                    desc: "Unlocks investment opportunities (50 book points)",
                    price: 1000,
                    bookValue: 50,
                    purchased: unlocks.items.includes('The Intelligent Investor'),
                    action: () => {
                        setBooks(prev => prev + 50);
                        setUnlocks(prev => ({ ...prev, items: [...prev.items, 'The Intelligent Investor'] }));
                        saveGame();
                    }
                },
                {
                    id: 'common-stocks',
                    name: "Common Stocks and Uncommon Profits",
                    desc: "Unlocks investment opportunities (75 book points)",
                    price: 1500,
                    bookValue: 75,
                    purchased: unlocks.items.includes('Common Stocks and Uncommon Profits'),
                    action: () => {
                        setBooks(prev => prev + 75);
                        setUnlocks(prev => ({ ...prev, items: [...prev.items, 'Common Stocks and Uncommon Profits'] }));
                        saveGame();
                    }
                },
                {
                    id: 'poor-charlies',
                    name: "Poor Charlie's Almanack",
                    desc: "Unlocks investment opportunities (100 book points)",
                    price: 2000,
                    bookValue: 100,
                    purchased: unlocks.items.includes('Poor Charlie\'s Almanack'),
                    action: () => {
                        setBooks(prev => prev + 100);
                        setUnlocks(prev => ({ ...prev, items: [...prev.items, 'Poor Charlie\'s Almanack'] }));
                        saveGame();
                    }
                },
                {
                    id: 'common-sense',
                    name: "The Little Book of Common Sense Investing",
                    desc: "Unlocks investment opportunities (40 book points)",
                    price: 800,
                    bookValue: 40,
                    purchased: unlocks.items.includes('The Little Book of Common Sense Investing'),
                    action: () => {
                        setBooks(prev => prev + 40);
                        setUnlocks(prev => ({ ...prev, items: [...prev.items, 'The Little Book of Common Sense Investing'] }));
                        saveGame();
                    }
                },
                {
                    id: 'essays-buffett',
                    name: "Essays of Warren Buffett",
                    desc: "Unlocks investment opportunities (100 book points)",
                    price: 2500,
                    bookValue: 100,
                    purchased: unlocks.items.includes('Essays of Warren Buffett'),
                    action: () => {
                        setBooks(prev => prev + 100);
                        setUnlocks(prev => ({ ...prev, items: [...prev.items, 'Essays of Warren Buffett'] }));
                        saveGame();
                    }
                }
            ];
            
            // Buy item
            const buyItem = (item) => {
                const price = item.basePrice ? Math.floor(item.basePrice * Math.pow(item.priceMultiplier, upgrades[item.id]?.level || 0)) : item.price;
                if (coins >= price && (!item.purchased || item.maxPurchases) && (item.requires === undefined || item.requires)) {
                    setCoins(prev => prev - price);
                    item.action();
                    new Audio(sounds.collect).play();
                    saveGame();
                }
            };
            
            // Continue to investment
            const continueToInvestment = () => {
                setGameState(year >= 1960 ? 'investment' : 'playing');
                if (year < 1960) {
                    continueToNextYear();
                }
            };
            
            // Buy/sell stock
            const buyStock = (stockSymbol, percentage = 1) => {
                const stock = stockData[stockSymbol];
                const priceYears = Object.keys(stock.prices).map(Number).filter(y => y <= year);
                const price = stock.prices[year] || stock.prices[Math.max(...priceYears)];
                const amount = percentage === 'max' ? Math.floor(coins / price) : Math.floor((coins * percentage) / price);
                
                if (amount > 0 && coins >= price * amount) {
                    const cost = price * amount;
                    setCoins(prev => prev - cost);
                    setPortfolio(prev => ({
                        ...prev,
                        stocks: {
                            ...prev.stocks,
                            [stockSymbol]: {
                                shares: (prev.stocks[stockSymbol]?.shares || 0) + amount,
                                totalInvested: (prev.stocks[stockSymbol]?.totalInvested || 0) + cost
                            }
                        }
                    }));
                    setStatistics(prev => ({
                        ...prev,
                        totalInvestmentGains: prev.totalInvestmentGains + cost
                    }));
                    saveGame();
                }
            };
            
            const sellStock = (stockSymbol, percentage = 1) => {
                const stock = stockData[stockSymbol];
                const priceYears = Object.keys(stock.prices).map(Number).filter(y => y <= year);
                const price = stock.prices[year] || stock.prices[Math.max(...priceYears)];
                const owned = portfolio.stocks[stockSymbol]?.shares || 0;
                const amount = percentage === 'max' ? owned : Math.floor(owned * percentage);
                
                if (amount > 0 && owned >= amount) {
                    const proceeds = price * amount;
                    setCoins(prev => prev + proceeds);
                    setPortfolio(prev => ({
                        ...prev,
                        stocks: {
                            ...prev.stocks,
                            [stockSymbol]: {
                                shares: prev.stocks[stockSymbol].shares - amount,
                                totalInvested: prev.stocks[stockSymbol].totalInvested
                            }
                        }
                    }));
                    setStatistics(prev => ({
                        ...prev,
                        totalInvestmentGains: prev.totalInvestmentGains + proceeds
                    }));
                    saveGame();
                }
            };
            
            // Buy subsidiary
            const buySubsidiary = (subId) => {
                const sub = subsidiaryData[subId];
                if (books >= sub.bookCost && !portfolio.subsidiaries[subId]?.owned && (!sub.unlockedBy || unlocks.items.includes(sub.unlockedBy))) {
                    setBooks(prev => prev - sub.bookCost);
                    setPortfolio(prev => ({
                        ...prev,
                        subsidiaries: {
                            ...prev.subsidiaries,
                            [subId]: { owned: true, booksSpent: sub.bookCost }
                        }
                    }));
                    saveGame();
                }
            };
            
            // Continue to next year
            const continueToNextYear = () => {
                const nextYear = year + 1;
                if (nextYear > 2025) {
                    setGameState('gameOver');
                } else {
                    setYear(nextYear);
                    setStatistics(prev => ({
                        ...prev,
                        bestYear: prev.bestYear.score < coins ? { year: nextYear, score: coins } : prev.bestYear
                    }));
                    setGameState('playing');
                    initLevel();
                }
            };
            
            return (
                <div className="game-container">
                    {/* Main Menu */}
                    {gameState === 'menu' && (
                        <div className="menu-screen">
                            <h1 className="menu-title">Warren Buffett's<br/>Bubble Pop Adventure</h1>
                            <p className="menu-subtitle">An Investment Journey: 1951-2025</p>
                            <button className="menu-button" onClick={startGame}>Start Game</button>
                            <p style={{ marginTop: '20px', fontSize: '0.9em', opacity: 0.7 }}>
                                Click Start Game to begin your journey!
                            </p>
                        </div>
                    )}
                    
                    {/* Game Screen */}
                    <div 
                        className={`game-screen ${gameState === 'playing' ? 'active' : ''}`} 
                        ref={gameRef}
                        onMouseMove={handlePointerMove}
                        onTouchMove={handlePointerMove}
                        onClick={handleShoot}
                        onTouchStart={handleShoot}
                    >
                        <div className={`decade-border decade-${getDecade(year)}`}>
                            <div style={{ position: 'absolute', top: '10px', left: '50%', transform: 'translateX(-50%)', fontSize: '1.5em', color: '#ffd700' }}>
                                {year}
                            </div>
                        </div>
                        
                        <div id="gameCanvas">
                            {bubbles.map(bubble => (
                                <div
                                    key={bubble.id}
                                    className={`bubble ${bubble.popping ? 'popping' : ''}`}
                                    style={{
                                        left: bubble.x + 'px',
                                        top: bubble.y + 'px',
                                        backgroundColor: bubble.color
                                    }}
                                />
                            ))}
                            
                            {collectables.map(item => (
                                <div
                                    key={item.id}
                                    className={`collectable ${item.type}`}
                                    style={{
                                        left: item.x + 'px',
                                        top: item.y + 'px'
                                    }}
                                />
                            ))}
                            
                            {gameState === 'playing' && bubbleQueue.length > 0 && (
                                <div 
                                    className="trajectory-line"
                                    style={{
                                        bottom: '60px',
                                        left: '50%',
                                        width: '250px',
                                        transform: `translateX(-3px) rotate(${cannonAngle}deg)`,
                                        transformOrigin: '3px center'
                                    }}
                                />
                            )}
                            
                            <div className="cannon">
                                <div 
                                    className="cannon-barrel" 
                                    style={{ transform: `rotate(${cannonAngle}deg)` }}
                                />
                            </div>
                            
                            <div className="bubble-queue">
                                {bubbleQueue.slice(0, 5).map((color, i) => (
                                    <div
                                        key={i}
                                        className="queue-bubble"
                                        style={{ 
                                            backgroundColor: color,
                                            opacity: i === 0 ? 1 : 0.6,
                                            transform: i === 0 ? 'scale(1.2)' : 'scale(1)'
                                        }}
                                    />
                                ))}
                                {bubbleQueue.length > 5 && (
                                    <div style={{ color: '#ffd700', marginLeft: '10px' }}>+{bubbleQueue.length - 5}</div>
                                )}
                            </div>
                        </div>
                        
                        <div className="quote-box">
                            {currentQuote}
                            {gameState === 'playing' && bubbleQueue.length > 0 && (
                                <div style={{ fontSize: '0.8em', marginTop: '5px', opacity: 0.7 }}>
                                    Click to shoot • Space for quick shot
                                </div>
                            )}
                        </div>
                        
                        <div className="powerup-selector">
                            {shopItems.filter(item => item.desc.includes('Next shot')).map(item => (
                                <button
                                    key={item.id}
                                    className="powerup-button"
                                    onClick={() => buyItem(item)}
                                    disabled={coins < item.price || (item.requires !== undefined && !item.requires)}
                                >
                                    {item.name}
                                </button>
                            ))}
                        </div>
                        
                        <div className="game-ui">
                            <div className="stat-display">
                                <span className="stat-label">Year</span>
                                <span className="stat-value">{year}</span>
                            </div>
                            
                            <div className="stat-display">
                                <span className="stat-label">Sugar</span>
                                <div className="sugar-bar">
                                    <div className="sugar-fill" style={{ width: `${(sugar / maxSugar) * 100}%` }} />
                                </div>
                            </div>
                            
                            <div className="stat-display">
                                <span className="stat-label">Bubbles</span>
                                <span className="stat-value">{bubbleQueue.length}</span>
                            </div>
                            
                            <div className="stat-display">
                                <span className="stat-label">Lives</span>
                                <span className="stat-value">{lives}</span>
                            </div>
                            
                            <div className="stat-display">
                                <span className="stat-label">Coins</span>
                                <span className="stat-value">${coins}</span>
                            </div>
                            
                            <div className="stat-display">
                                <span className="stat-label">Books</span>
                                <span className="stat-value">{books}</span>
                            </div>
                        </div>
                    </div>
                    
                    {/* Shop Screen */}
                    <div className={`shop-screen ${gameState === 'shop' ? 'active' : ''}`}>
                        <h2 className="shop-header">The Value Shop - Year {year}</h2>
                        <p style={{ textAlign: 'center', fontSize: '1.2em', color: '#ffd700', marginBottom: '20px' }}>
                            Your Coins: ${coins} | Your Books: {books}
                        </p>
                        
                        <div className="shop-items">
                            {shopItems.map(item => (
                                <div key={item.id} className="shop-item">
                                    <h3 className="shop-item-name">{item.name}</h3>
                                    <p className="shop-item-desc">{item.desc}</p>
                                    <p className="shop-item-price">Price: ${Math.floor(item.basePrice ? item.basePrice * Math.pow(item.priceMultiplier, upgrades[item.id]?.level || 0) : item.price)}</p>
                                    <button
                                        className="shop-buy-button"
                                        onClick={() => buyItem(item)}
                                        disabled={coins < (item.basePrice ? Math.floor(item.basePrice * Math.pow(item.priceMultiplier, upgrades[item.id]?.level || 0)) : item.price) || item.purchased || (item.requires !== undefined && !item.requires) || (item.maxPurchases && (upgrades[item.id]?.level || 0) >= item.maxPurchases)}
                                    >
                                        {item.purchased ? 'Purchased' : 'Buy'}
                                    </button>
                                </div>
                            ))}
                        </div>
                        
                        <button className="continue-button" onClick={continueToInvestment}>
                            Continue to Investments
                        </button>
                    </div>
                    
                    {/* Investment Screen */}
                    <div className={`investment-screen ${gameState === 'investment' ? 'active' : ''}`}>
                        <h2 className="investment-header">Investment Board - {year}</h2>
                        <p style={{ textAlign: 'center', fontSize: '1.2em', color: '#ffd700', marginBottom: '20px' }}>
                            Your Coins: ${coins} | Your Books: {books}
                        </p>
                        
                        <h3 style={{ color: '#ffd700', marginBottom: '10px' }}>Stocks</h3>
                        <div className="investment-tabs">
                            {(() => {
                                const availableStocks = Object.entries(stockData).filter(([symbol, stock]) => {
                                    if (stock.startYear > year) return false;
                                    if (symbol === 'AAPL' && !upgrades.tedTodd) return false;
                                    if (symbol === 'KO' && cokePurchases < 5) return false;
                                    return true;
                                });
                                
                                if (availableStocks.length === 0) {
                                    return (
                                        <div style={{ textAlign: 'center', padding: '40px', color: '#ccc' }}>
                                            <h3 style={{ color: '#ffd700', marginBottom: '20px' }}>Investment Market Closed</h3>
                                            <p>No public companies available for investment yet.</p>
                                            <p>Keep playing to unlock investment opportunities!</p>
                                            <p style={{ marginTop: '20px', fontSize: '0.9em' }}>
                                                First investments available in the 1960s.
                                            </p>
                                        </div>
                                    );
                                }
                                
                                return availableStocks.map(([symbol, stock]) => {
                                    const priceYears = Object.keys(stock.prices).map(Number).filter(y => y <= year);
                                    const price = stock.prices[year] || stock.prices[Math.max(...priceYears)];
                                    const prevPrice = stock.prices[year - 1] || stock.prices[Math.max(...priceYears.filter(y => y < year))];
                                    const priceChange = prevPrice ? ((price - prevPrice) / prevPrice * 100).toFixed(2) : 0;
                                    const owned = portfolio.stocks[symbol]?.shares || 0;
                                    
                                    return (
                                        <div key={symbol} className="stock-item">
                                            <div className="stock-info">
                                                <div className="stock-name">{stock.name}</div>
                                                <div className="stock-price">Price: ${price} ({priceChange > 0 ? '+' : ''}{priceChange}%)</div>
                                                <div>Owned: {owned} shares</div>
                                                <div>Book Cost: {stock.bookCost}</div>
                                            </div>
                                            <div className="stock-controls">
                                                <button 
                                                    className="stock-button"
                                                    onClick={() => buyStock(symbol, 1)}
                                                    disabled={coins < price || books < stock.bookCost}
                                                >
                                                    Buy 1
                                                </button>
                                                <button 
                                                    className="stock-button"
                                                    onClick={() => buyStock(symbol, 0.1)}
                                                    disabled={coins < price * 0.1 || books < stock.bookCost}
                                                >
                                                    Buy 10%
                                                </button>
                                                <button 
                                                    className="stock-button"
                                                    onClick={() => buyStock(symbol, 0.25)}
                                                    disabled={coins < price * 0.25 || books < stock.bookCost}
                                                >
                                                    Buy 25%
                                                </button>
                                                <button 
                                                    className="stock-button"
                                                    onClick={() => buyStock(symbol, 'max')}
                                                    disabled={coins < price || books < stock.bookCost}
                                                >
                                                    Buy Max
                                                </button>
                                                <button 
                                                    className="stock-button sell"
                                                    onClick={() => sellStock(symbol, 'max')}
                                                    disabled={owned === 0}
                                                >
                                                    Sell All
                                                </button>
                                            </div>
                                        </div>
                                    );
                                });
                            })()}
                        </div>
                        
                        <h3 style={{ color: '#ffd700', marginBottom: '10px', marginTop: '20px' }}>Subsidiaries</h3>
                        <div className="investment-tabs">
                            {Object.entries(subsidiaryData).map(([subId, sub]) => {
                                const owned = portfolio.subsidiaries[subId]?.owned || false;
                                return (
                                    <div key={subId} className="subsidiary-item">
                                        <div className="subsidiary-info">
                                            <div className="subsidiary-name">{sub.name}</div>
                                            <div className="subsidiary-price">Book Cost: {sub.bookCost}</div>
                                            <div>Cash Return: ${sub.cashReturn}/year</div>
                                            <div>{owned ? 'Owned' : sub.unlockedBy ? `Requires: ${sub.unlockedBy}` : ''}</div>
                                        </div>
                                        <button
                                            className="subsidiary-buy-button"
                                            onClick={() => buySubsidiary(subId)}
                                            disabled={owned || books < sub.bookCost || (sub.unlockedBy && !unlocks.items.includes(sub.unlockedBy))}
                                        >
                                            {owned ? 'Owned' : 'Buy'}
                                        </button>
                                    </div>
                                );
                            })}
                        </div>
                        
                        <div style={{ textAlign: 'center', fontSize: '1.2em', color: '#ffd700', marginTop: '20px' }}>
                            Portfolio Value: ${
                                Object.entries(portfolio.stocks).reduce((total, [symbol, data]) => {
                                    const stock = stockData[symbol];
                                    const priceYears = Object.keys(stock.prices).map(Number).filter(y => y <= year);
                                    const price = stock.prices[year] || stock.prices[Math.max(...priceYears)];
                                    return total + (data.shares * price);
                                }, 0).toFixed(0)
                            }
                        </div>
                        
                        <button className="continue-button" onClick={continueToNextYear}>
                            Continue to {year + 1}
                        </button>
                    </div>
                    
                    {/* Game Over */}
                    {gameState === 'gameOver' && (
                        <div className="menu-screen">
                            <h1 className="menu-title">Congratulations!</h1>
                            <p className="menu-subtitle">You've completed Buffett's journey!</p>
                            <div style={{ marginTop: '20px', fontSize: '1.2em' }}>
                                <p>Final Portfolio Value: ${
                                    Object.entries(portfolio.stocks).reduce((total, [symbol, data]) => {
                                        const stock = stockData[symbol];
                                        const price = stock.prices[2025] || stock.prices[Math.max(...Object.keys(stock.prices))];
                                        return total + (data.shares * price);
                                    }, 0).toFixed(0)
                                }</p>
                                <p>Total Coins: ${coins}</p>
                                <p>Total Bubbles Popped: {statistics.totalBubblesPopped}</p>
                                <p>Best Year: {statistics.bestYear.year} (${statistics.bestYear.score})</p>
                            </div>
                            <button className="menu-button" onClick={() => window.location.reload()}>
                                Play Again
                            </button>
                        </div>
                    )}
                </div>
            );
        }
        
        // Simple error boundary
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            
            static getDerivedStateFromError(error) {
                return { hasError: true, error: error.toString() };
            }
            
            componentDidCatch(error, errorInfo) {
                console.error('Game error:', error, errorInfo);
            }
            
            render() {
                if (this.state.hasError) {
                    return (
                        <div style={{ padding: '20px', color: 'red', textAlign: 'center' }}>
                            <h2>Something went wrong!</h2>
                            <p>{this.state.error}</p>
                            <button onClick={() => window.location.reload()}>Reload</button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }
        
        // Render the game
        ReactDOM.render(
            <ErrorBoundary>
                <Game />
            </ErrorBoundary>, 
            document.getElementById('root')
        );
    </script>
</body>
</html>
