<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QLD Bushfire Monitor</title>
    
    <!-- OpenLayers CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
        }

        #map {
            width: 100vw;
            height: 100vh;
        }

        #map.placement-mode {
            cursor: crosshair;
        }

        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 300px;
        }

        .info-panel h2 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }

        .info-panel .stats {
            font-size: 13px;
            color: #666;
        }

        .info-panel .stat-item {
            margin: 5px 0;
        }

        .info-panel .stat-label {
            font-weight: 600;
        }

        .weather-info {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e0e0e0;
            font-size: 12px;
        }

        .weather-info .weather-item {
            margin: 4px 0;
            display: flex;
            align-items: center;
        }

        .wind-arrow {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 5px;
            font-size: 16px;
        }

        .control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-btn {
            background: white;
            border: 2px solid #ddd;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .control-btn:hover {
            background: #f0f0f0;
            border-color: #999;
        }

        .control-btn.active {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 10px;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .legend h3 {
            font-size: 13px;
            margin-bottom: 8px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
            font-size: 11px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 6px;
            border: 2px solid rgba(0,0,0,0.3);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 2000;
            font-size: 14px;
            text-align: center;
            max-width: 400px;
        }

        .error {
            background: #fee;
            color: #c00;
        }

        .alert-emergency {
            background-color: #d32f2f;
        }

        .alert-watch {
            background-color: #f57c00;
        }

        .alert-advice {
            background-color: #ffd700;
        }

        .alert-not-applicable {
            background-color: #90caf9;
        }

        .ol-popup {
            position: absolute;
            background-color: white;
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #cccccc;
            bottom: 12px;
            left: -50px;
            min-width: 320px;
            max-width: 400px;
        }

        .ol-popup:after, .ol-popup:before {
            top: 100%;
            border: solid transparent;
            content: " ";
            height: 0;
            width: 0;
            position: absolute;
            pointer-events: none;
        }

        .ol-popup:after {
            border-top-color: white;
            border-width: 10px;
            left: 48px;
            margin-left: -10px;
        }

        .ol-popup:before {
            border-top-color: #cccccc;
            border-width: 11px;
            left: 48px;
            margin-left: -11px;
        }

        .ol-popup-closer {
            text-decoration: none;
            position: absolute;
            top: 2px;
            right: 8px;
            font-size: 20px;
            color: #999;
        }

        .ol-popup-closer:after {
            content: "‚úñ";
        }

        .popup-content h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
        }

        .popup-content .detail {
            margin: 5px 0;
            font-size: 12px;
            line-height: 1.4;
        }

        .popup-content .detail strong {
            color: #555;
        }

        .popup-weather {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e0e0e0;
        }

        .popup-weather h4 {
            font-size: 12px;
            margin-bottom: 8px;
            color: #555;
        }

        .watchtower-panel {
            position: absolute;
            bottom: 20px;
            right: 10px;
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 12px;
            min-width: 200px;
        }

        .watchtower-panel h3 {
            font-size: 13px;
            margin-bottom: 8px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .watchtower-panel .status {
            margin: 4px 0;
        }

        .watchtower-panel .status strong {
            color: #555;
        }

        .watchtower-panel button {
            margin-top: 8px;
            padding: 6px 12px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            width: 100%;
        }

        .watchtower-panel button:hover {
            background: #d32f2f;
        }

        .distance-label {
            background: rgba(255, 255, 255, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            border: 1px solid #666;
            white-space: nowrap;
        }

        .placement-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(76, 175, 80, 0.95);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 1500;
            pointer-events: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="info-panel">
        <h2>üî• QLD Bushfire Monitor</h2>
        <div class="stats">
            <div class="stat-item">
                <span class="stat-label">Active Incidents:</span> <span id="incident-count">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Last Update:</span> <span id="last-update">--:--</span>
            </div>
        </div>
    </div>

    <div class="control-panel">
        <button class="control-btn" onclick="loadBushfireData()">
            üîÑ Refresh Data
        </button>
        <button class="control-btn" id="watchtower-btn" onclick="toggleWatchtowerPlacement()">
            üóº Set Watchtower
        </button>
        <button class="control-btn" id="measure-btn" onclick="toggleMeasure()">
            üìè Show Distances
        </button>
        <button class="control-btn" id="wind-btn" onclick="toggleWind()">
            üå¨Ô∏è Toggle Wind
        </button>
    </div>

    <div class="legend">
        <h3>Alert Levels</h3>
        <div class="legend-item">
            <div class="legend-color alert-emergency"></div>
            <span>Emergency Warning</span>
        </div>
        <div class="legend-item">
            <div class="legend-color alert-watch"></div>
            <span>Watch & Act</span>
        </div>
        <div class="legend-item">
            <div class="legend-color alert-advice"></div>
            <span>Advice</span>
        </div>
        <div class="legend-item">
            <div class="legend-color alert-not-applicable"></div>
            <span>Not Applicable</span>
        </div>
    </div>

    <div id="loading" class="loading" style="display: none;">
        Loading data...
    </div>

    <!-- OpenLayers JS -->
    <script src="https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js"></script>
    
    <script>
        var map;
        var vectorSource;
        var vectorLayer;
        var distanceSource;
        var distanceLayer;
        var measureActive = false;
        var windEnabled = false;
        var watchtowerLocation = null;
        var watchtowerMarker = null;
        var watchtowerPlacementMode = false;

        // Cache for fire weather data
        var fireWeatherCache = {};

        function initMap() {
            vectorSource = new ol.source.Vector();
            vectorLayer = new ol.layer.Vector({
                source: vectorSource,
                zIndex: 100
            });

            distanceSource = new ol.source.Vector();
            distanceLayer = new ol.layer.Vector({
                source: distanceSource,
                zIndex: 50
            });

            map = new ol.Map({
                target: 'map',
                layers: [
                    new ol.layer.Tile({
                        source: new ol.source.OSM()
                    }),
                    distanceLayer,
                    vectorLayer
                ],
                view: new ol.View({
                    center: ol.proj.fromLonLat([145.0, -23.0]),
                    zoom: 6
                })
            });

            var popup = document.createElement('div');
            popup.className = 'ol-popup';
            popup.innerHTML = '<a href="#" class="ol-popup-closer"></a><div class="popup-content"></div>';
            
            var overlay = new ol.Overlay({
                element: popup,
                autoPan: true,
                autoPanAnimation: {
                    duration: 250
                }
            });
            
            map.addOverlay(overlay);

            popup.querySelector('.ol-popup-closer').onclick = function(e) {
                e.preventDefault();
                overlay.setPosition(undefined);
                return false;
            };

            map.on('click', function(evt) {
                // If in watchtower placement mode, place the watchtower
                if (watchtowerPlacementMode) {
                    var lonLat = ol.proj.toLonLat(evt.coordinate);
                    setWatchtower(lonLat[0], lonLat[1]);
                    return;
                }

                // Otherwise, handle fire feature clicks
                var feature = map.forEachFeatureAtPixel(evt.pixel, function(feature) {
                    return feature;
                });

                if (feature && feature.get('properties')) {
                    var props = feature.get('properties');
                    var coords = evt.coordinate;
                    
                    var lonLat = ol.proj.toLonLat(coords);
                    
                    fetchWeatherForLocation(lonLat[1], lonLat[0], function(weatherData) {
                        var content = popup.querySelector('.popup-content');
                        content.innerHTML = generatePopupContent(props, weatherData);
                        overlay.setPosition(coords);
                    });
                } else {
                    overlay.setPosition(undefined);
                }
            });

            map.getView().on('change:center', function() {
                overlay.setPosition(undefined);
            });

            loadBushfireData();
        }

        function toggleWatchtowerPlacement() {
            watchtowerPlacementMode = !watchtowerPlacementMode;
            var btn = document.getElementById('watchtower-btn');
            var mapElement = document.getElementById('map');
            
            if (watchtowerPlacementMode) {
                btn.classList.add('active');
                btn.textContent = 'üóº Click Map to Place';
                mapElement.classList.add('placement-mode');
                showPlacementHint();
            } else {
                btn.classList.remove('active');
                btn.textContent = 'üóº Set Watchtower';
                mapElement.classList.remove('placement-mode');
                hidePlacementHint();
            }
        }

        function showPlacementHint() {
            var hint = document.createElement('div');
            hint.id = 'placement-hint';
            hint.className = 'placement-hint';
            hint.textContent = 'üìç Click anywhere on the map to place your watchtower';
            document.body.appendChild(hint);
            
            setTimeout(function() {
                if (hint.parentNode) {
                    hint.style.opacity = '0';
                    hint.style.transition = 'opacity 0.5s';
                    setTimeout(function() {
                        if (hint.parentNode) hint.remove();
                    }, 500);
                }
            }, 3000);
        }

        function hidePlacementHint() {
            var hint = document.getElementById('placement-hint');
            if (hint) hint.remove();
        }

        function setWatchtower(lon, lat) {
            watchtowerLocation = [lon, lat];
            
            if (watchtowerMarker) {
                vectorSource.removeFeature(watchtowerMarker);
            }

            var coords = ol.proj.fromLonLat(watchtowerLocation);
            
            watchtowerMarker = new ol.Feature({
                geometry: new ol.geom.Point(coords),
                isWatchtower: true
            });

            watchtowerMarker.setStyle(new ol.style.Style({
                image: new ol.style.Icon({
                    src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="14" fill="%234CAF50" stroke="white" stroke-width="3"/><text x="16" y="22" font-size="18" text-anchor="middle" fill="white">üóº</text></svg>',
                    scale: 1.2
                })
            }));

            vectorSource.addFeature(watchtowerMarker);

            map.getView().animate({
                center: coords,
                zoom: 10,
                duration: 1000
            });

            // Turn off placement mode
            watchtowerPlacementMode = false;
            var btn = document.getElementById('watchtower-btn');
            btn.textContent = 'üóº Set Watchtower';
            document.getElementById('map').classList.remove('placement-mode');
            hidePlacementHint();

            updateWatchtowerStatus();

            if (measureActive) {
                drawDistanceLines();
            }
        }

        function clearWatchtower() {
            if (watchtowerMarker) {
                vectorSource.removeFeature(watchtowerMarker);
                watchtowerMarker = null;
            }
            
            watchtowerLocation = null;
            watchtowerPlacementMode = false;
            
            var panel = document.getElementById('watchtower-status');
            if (panel) {
                panel.remove();
            }
            
            var btn = document.getElementById('watchtower-btn');
            btn.classList.remove('active');
            btn.textContent = 'üóº Set Watchtower';
            
            document.getElementById('map').classList.remove('placement-mode');
            hidePlacementHint();
            
            if (measureActive) {
                distanceSource.clear();
            }
        }

        function updateWatchtowerStatus() {
            var existingPanel = document.getElementById('watchtower-status');
            if (existingPanel) {
                existingPanel.remove();
            }

            if (!watchtowerLocation) return;

            var panel = document.createElement('div');
            panel.id = 'watchtower-status';
            panel.className = 'watchtower-panel';

            var fires = vectorSource.getFeatures().filter(f => !f.get('isWatchtower'));
            var nearestDistance = Infinity;
            var fireCount = fires.length;

            fires.forEach(function(fire) {
                var fireGeom = fire.getGeometry();
                var fireCoord;
                
                if (fireGeom instanceof ol.geom.Point) {
                    fireCoord = fireGeom.getCoordinates();
                } else if (fireGeom instanceof ol.geom.Polygon) {
                    fireCoord = ol.extent.getCenter(fireGeom.getExtent());
                }

                if (fireCoord) {
                    var distance = ol.sphere.getDistance(
                        ol.proj.toLonLat(ol.proj.fromLonLat(watchtowerLocation)),
                        ol.proj.toLonLat(fireCoord)
                    );
                    nearestDistance = Math.min(nearestDistance, distance);
                }
            });

            var html = '<h3>üóº Watchtower Active</h3>';
            html += '<div class="status"><strong>Location:</strong> ' + watchtowerLocation[1].toFixed(4) + ', ' + watchtowerLocation[0].toFixed(4) + '</div>';
            html += '<div class="status"><strong>Fires Tracked:</strong> ' + fireCount + '</div>';
            
            if (nearestDistance !== Infinity) {
                html += '<div class="status"><strong>Nearest Fire:</strong> ' + (nearestDistance / 1000).toFixed(1) + ' km</div>';
            } else {
                html += '<div class="status"><strong>Nearest Fire:</strong> None detected</div>';
            }
            
            html += '<button onclick="clearWatchtower()">Clear Watchtower</button>';

            panel.innerHTML = html;
            document.body.appendChild(panel);
        }

        function toggleMeasure() {
            measureActive = !measureActive;
            var btn = document.getElementById('measure-btn');
            
            if (measureActive) {
                btn.classList.add('active');
                if (watchtowerLocation) {
                    drawDistanceLines();
                } else {
                    alert('Please set a watchtower location first');
                    measureActive = false;
                    btn.classList.remove('active');
                }
            } else {
                btn.classList.remove('active');
                distanceSource.clear();
            }
        }

        function drawDistanceLines() {
            distanceSource.clear();

            if (!watchtowerLocation) return;

            var watchtowerCoords = ol.proj.fromLonLat(watchtowerLocation);
            var features = vectorSource.getFeatures().filter(f => !f.get('isWatchtower'));

            features.forEach(function(feature) {
                var geom = feature.getGeometry();
                var fireCoord;

                if (geom instanceof ol.geom.Point) {
                    fireCoord = geom.getCoordinates();
                } else if (geom instanceof ol.geom.Polygon) {
                    fireCoord = ol.extent.getCenter(geom.getExtent());
                } else {
                    return;
                }

                var line = new ol.geom.LineString([watchtowerCoords, fireCoord]);
                var lineFeature = new ol.Feature({
                    geometry: line
                });

                lineFeature.setStyle(new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: 'rgba(33, 150, 243, 0.6)',
                        width: 2,
                        lineDash: [10, 10]
                    })
                }));

                distanceSource.addFeature(lineFeature);

                var distance = ol.sphere.getDistance(
                    ol.proj.toLonLat(watchtowerCoords),
                    ol.proj.toLonLat(fireCoord)
                );

                var midpoint = [
                    (watchtowerCoords[0] + fireCoord[0]) / 2,
                    (watchtowerCoords[1] + fireCoord[1]) / 2
                ];

                var labelFeature = new ol.Feature({
                    geometry: new ol.geom.Point(midpoint)
                });

                labelFeature.setStyle(new ol.style.Style({
                    text: new ol.style.Text({
                        text: (distance / 1000).toFixed(1) + ' km',
                        font: '600 11px sans-serif',
                        fill: new ol.style.Fill({ color: '#333' }),
                        stroke: new ol.style.Stroke({ color: 'white', width: 3 }),
                        backgroundFill: new ol.style.Fill({ color: 'rgba(255, 255, 255, 0.9)' }),
                        backgroundStroke: new ol.style.Stroke({ color: '#666', width: 1 }),
                        padding: [4, 8, 4, 8]
                    })
                }));

                distanceSource.addFeature(labelFeature);
            });
        }

        function toggleWind() {
            windEnabled = !windEnabled;
            var btn = document.getElementById('wind-btn');
            
            if (windEnabled) {
                btn.classList.add('active');
                fetchWindDataForFires();
            } else {
                btn.classList.remove('active');
                clearWindArrows();
            }
        }

        function clearWindArrows() {
            var features = vectorSource.getFeatures();
            features.forEach(function(feature) {
                if (feature.get('isWindArrow')) {
                    vectorSource.removeFeature(feature);
                }
            });
        }

        function fetchWindDataForFires() {
            clearWindArrows();
            
            var features = vectorSource.getFeatures().filter(f => !f.get('isWatchtower'));
            
            features.forEach(function(feature) {
                var geom = feature.getGeometry();
                var coord;
                
                if (geom instanceof ol.geom.Point) {
                    coord = geom.getCoordinates();
                } else if (geom instanceof ol.geom.Polygon) {
                    coord = ol.extent.getCenter(geom.getExtent());
                } else {
                    return;
                }
                
                var lonLat = ol.proj.toLonLat(coord);
                
                fetchWeatherForLocation(lonLat[1], lonLat[0], function(weatherData) {
                    if (weatherData && windEnabled) {
                        addWindArrow(coord, weatherData.windDirection, weatherData.windSpeed);
                    }
                });
            });
        }

        function addWindArrow(coord, direction, speed) {
            var arrowLength = Math.min(50 + speed * 2, 150);
            var angle = (direction - 180) * (Math.PI / 180);
            
            var dx = arrowLength * Math.sin(angle);
            var dy = arrowLength * Math.cos(angle);
            
            var endCoord = [coord[0] + dx, coord[1] + dy];
            
            var line = new ol.geom.LineString([coord, endCoord]);
            var arrowFeature = new ol.Feature({
                geometry: line,
                isWindArrow: true
            });
            
            arrowFeature.setStyle(new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: 'rgba(76, 175, 80, 0.8)',
                    width: 3
                }),
                text: new ol.style.Text({
                    text: '‚Üí',
                    font: 'bold 20px sans-serif',
                    fill: new ol.style.Fill({ color: 'rgba(76, 175, 80, 1)' }),
                    rotateWithView: false,
                    rotation: -angle,
                    offsetY: -10
                })
            }));
            
            vectorSource.addFeature(arrowFeature);
        }

        function fetchWeatherForLocation(lat, lon, callback) {
            var cacheKey = lat.toFixed(2) + ',' + lon.toFixed(2);
            
            if (fireWeatherCache[cacheKey]) {
                callback(fireWeatherCache[cacheKey]);
                return;
            }

            var url = 'https://api.open-meteo.com/v1/forecast?latitude=' + lat + 
                      '&longitude=' + lon + 
                      '&current=temperature_2m,relative_humidity_2m,wind_speed_10m,wind_direction_10m';
            
            fetch(url)
                .then(function(response) { return response.json(); })
                .then(function(data) {
                    var weatherData = {
                        temp: Math.round(data.current.temperature_2m),
                        humidity: data.current.relative_humidity_2m,
                        windSpeed: Math.round(data.current.wind_speed_10m),
                        windDirection: data.current.wind_direction_10m,
                        windDirectionText: getWindDirection(data.current.wind_direction_10m)
                    };
                    
                    fireWeatherCache[cacheKey] = weatherData;
                    callback(weatherData);
                })
                .catch(function(error) {
                    console.error('Weather fetch error:', error);
                    callback(null);
                });
        }

        function getWindDirection(degrees) {
            var directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            var index = Math.round(degrees / 22.5) % 16;
            return directions[index];
        }

        function getAlertColor(severity) {
            // Map both CAP standard severity and Australian alert levels
            var severityUpper = (severity || '').toUpperCase();
            
            // Emergency Warning / Extreme
            if (severityUpper.includes('EXTREME') || severityUpper.includes('EMERGENCY')) {
                return [211, 47, 47, 0.7];
            }
            // Watch and Act / Severe
            if (severityUpper.includes('SEVERE') || severityUpper.includes('WATCH')) {
                return [245, 124, 0, 0.7];
            }
            // Advice / Moderate
            if (severityUpper.includes('MODERATE') || severityUpper.includes('ADVICE')) {
                return [255, 215, 0, 0.7];
            }
            // Minor / Not Applicable
            return [144, 202, 249, 0.7];
        }

        function generatePopupContent(props, weatherData) {
            var html = '<h3>' + (props.headline || props.event || 'Fire Alert') + '</h3>';
            html += '<div class="detail"><strong>Event:</strong> ' + (props.event || 'N/A') + '</div>';
            html += '<div class="detail"><strong>Severity:</strong> ' + (props.severity || 'N/A') + '</div>';
            html += '<div class="detail"><strong>Area:</strong> ' + (props.areaDesc || 'N/A') + '</div>';
            
            if (props.description) html += '<div class="detail"><strong>Description:</strong> ' + props.description + '</div>';
            if (props.instruction) html += '<div class="detail"><strong>Instructions:</strong> ' + props.instruction + '</div>';
            if (props.effective) html += '<div class="detail"><strong>Effective:</strong> ' + new Date(props.effective).toLocaleString() + '</div>';
            if (props.expires) html += '<div class="detail"><strong>Expires:</strong> ' + new Date(props.expires).toLocaleString() + '</div>';
            
            if (weatherData) {
                html += '<div class="popup-weather">';
                html += '<h4>üå§Ô∏è Current Conditions at Fire Location</h4>';
                html += '<div class="weather-item">';
                html += '<span>üí® Wind: ' + weatherData.windSpeed + ' km/h</span>';
                html += '<span class="wind-arrow" style="transform: rotate(' + weatherData.windDirection + 'deg);">‚Üë</span>';
                html += '<span style="margin-left: 8px;">(' + weatherData.windDirectionText + ')</span>';
                html += '</div>';
                html += '<div class="weather-item">';
                html += '<span>üå°Ô∏è Temperature: ' + weatherData.temp + '¬∞C</span>';
                html += '</div>';
                html += '<div class="weather-item">';
                html += '<span>üíß Humidity: ' + weatherData.humidity + '%</span>';
                html += '</div>';
                html += '</div>';
            } else {
                html += '<div class="popup-weather">';
                html += '<h4>üå§Ô∏è Loading weather data...</h4>';
                html += '</div>';
            }
            
            return html;
        }

        function parseCapXMLToGeoJSON(xmlText) {
            var parser = new DOMParser();
            var xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            
            var alerts = xmlDoc.getElementsByTagNameNS('urn:oasis:names:tc:emergency:cap:1.2', 'alert');
            
            if (alerts.length === 0) {
                alerts = xmlDoc.getElementsByTagName('cap:alert');
            }
            
            console.log('Found', alerts.length, 'CAP alerts');
            
            var features = [];
            
            for (var i = 0; i < alerts.length; i++) {
                var alert = alerts[i];
                
                var info = alert.getElementsByTagName('cap:info')[0];
                if (!info) continue;
                
                var area = info.getElementsByTagName('cap:area')[0];
                if (!area) continue;
                
                var getElementText = function(parent, tagName) {
                    var elem = parent.getElementsByTagName(tagName)[0];
                    return elem ? elem.textContent.trim() : '';
                };
                
                var polygon = area.getElementsByTagName('cap:polygon')[0];
                var circle = area.getElementsByTagName('cap:circle')[0];
                
                var geometry = null;
                
                if (polygon) {
                    var coordsText = polygon.textContent.trim();
                    var points = coordsText.split(/\s+/);
                    var coordinates = [];
                    
                    for (var j = 0; j < points.length; j++) {
                        var parts = points[j].split(',');
                        if (parts.length === 2) {
                            coordinates.push([parseFloat(parts[1]), parseFloat(parts[0])]);
                        }
                    }
                    
                    if (coordinates.length > 0) {
                        geometry = {
                            type: 'Polygon',
                            coordinates: [coordinates]
                        };
                    }
                } else if (circle) {
                    var circleText = circle.textContent.trim();
                    var parts = circleText.split(/\s+/);
                    var centerParts = parts[0].split(',');
                    
                    geometry = {
                        type: 'Point',
                        coordinates: [parseFloat(centerParts[1]), parseFloat(centerParts[0])]
                    };
                }
                
                if (!geometry) continue;
                
                features.push({
                    type: 'Feature',
                    geometry: geometry,
                    properties: {
                        event: getElementText(info, 'cap:event'),
                        category: getElementText(info, 'cap:category'),
                        severity: getElementText(info, 'cap:severity'),
                        certainty: getElementText(info, 'cap:certainty'),
                        headline: getElementText(info, 'cap:headline'),
                        description: getElementText(info, 'cap:description'),
                        instruction: getElementText(info, 'cap:instruction'),
                        areaDesc: getElementText(area, 'cap:areaDesc'),
                        effective: getElementText(info, 'cap:effective'),
                        expires: getElementText(info, 'cap:expires')
                    }
                });
            }
            
            console.log('Parsed', features.length, 'features from CAP XML');
            
            return {
                type: 'FeatureCollection',
                features: features
            };
        }

        function addFireToMap(feature) {
            var props = feature.properties;
            var geom = feature.geometry;
            
            if (!geom) return;

            var color = getAlertColor(props.severity);

            if (geom.type === 'Point') {
                var coords = ol.proj.fromLonLat(geom.coordinates);
                
                var circleFeature = new ol.Feature({
                    geometry: new ol.geom.Point(coords),
                    properties: props
                });

                circleFeature.setStyle(new ol.style.Style({
                    image: new ol.style.Circle({
                        radius: 12,
                        fill: new ol.style.Fill({ color: color }),
                        stroke: new ol.style.Stroke({
                            color: [color[0], color[1], color[2], 1],
                            width: 2
                        })
                    })
                }));

                vectorSource.addFeature(circleFeature);
                
            } else if (geom.type === 'Polygon') {
                var coordinates = geom.coordinates[0].map(function(coord) {
                    return ol.proj.fromLonLat(coord);
                });
                
                var polygonFeature = new ol.Feature({
                    geometry: new ol.geom.Polygon([coordinates]),
                    properties: props
                });

                polygonFeature.setStyle(new ol.style.Style({
                    fill: new ol.style.Fill({ color: color }),
                    stroke: new ol.style.Stroke({
                        color: [color[0], color[1], color[2], 1],
                        width: 3
                    })
                }));

                vectorSource.addFeature(polygonFeature);
            }
        }

        function loadBushfireData() {
            var loading = document.getElementById('loading');
            loading.style.display = 'block';
            loading.classList.remove('error');
            loading.textContent = 'Loading QLD bushfire data...';

            if (vectorSource) {
                var features = vectorSource.getFeatures();
                features.forEach(function(f) {
                    if (!f.get('isWatchtower')) {
                        vectorSource.removeFeature(f);
                    }
                });
            }

            fireWeatherCache = {};

            var corsProxy = 'https://corsproxy.io/?';
            var feedUrl = 'https://publiccontent-gis-psba-qld-gov-au.s3.amazonaws.com/content/Feeds/BushfireCurrentIncidents/bushfireAlert_capau.xml';
            
            fetch(corsProxy + encodeURIComponent(feedUrl))
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('HTTP ' + response.status);
                    }
                    return response.text();
                })
                .then(function(xmlText) {
                    var data = parseCapXMLToGeoJSON(xmlText);
                    processData(data);
                })
                .catch(function(error) {
                    console.error('Error:', error);
                    loading.classList.add('error');
                    loading.textContent = 'Error loading QLD data: ' + error.message;
                    setTimeout(function() {
                        loading.style.display = 'none';
                    }, 5000);
                });
        }

        function processData(data) {
            var loading = document.getElementById('loading');
            var features = data.features || [];
            
            if (features.length > 0) {
                features.forEach(function(feature) {
                    addFireToMap(feature);
                });

                document.getElementById('incident-count').textContent = features.length;
                document.getElementById('last-update').textContent = new Date().toLocaleTimeString();

                if (measureActive && watchtowerLocation) {
                    drawDistanceLines();
                }
                
                if (windEnabled) {
                    fetchWindDataForFires();
                }

                if (watchtowerLocation) {
                    updateWatchtowerStatus();
                }

                var extent = vectorSource.getExtent();
                if (extent[0] !== Infinity && !watchtowerLocation) {
                    map.getView().fit(extent, {
                        padding: [50, 50, 50, 50],
                        maxZoom: 12
                    });
                }
            } else {
                document.getElementById('incident-count').textContent = '0';
                document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
                
                if (watchtowerLocation) {
                    updateWatchtowerStatus();
                }
            }

            loading.style.display = 'none';
        }

        window.onload = initMap;
    </script>
</body>
</html>
