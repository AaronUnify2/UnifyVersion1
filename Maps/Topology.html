<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warwick QLD - 3D Terrain</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }
        .control-item {
            margin: 5px 0;
        }
        label {
            display: inline-block;
            width: 120px;
        }
        input[type="range"] {
            width: 150px;
        }
        button {
            margin: 5px 5px 5px 0;
            padding: 5px 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        #touchControls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none;
            z-index: 100;
        }
        #dpad {
            position: relative;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        .dpad-btn {
            position: absolute;
            width: 45px;
            height: 45px;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            transition: all 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .dpad-btn:active {
            background: rgba(76, 175, 80, 0.9);
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        #dpad-up { top: 5px; left: 52.5px; }
        #dpad-down { bottom: 5px; left: 52.5px; }
        #dpad-left { left: 5px; top: 52.5px; }
        #dpad-right { right: 5px; top: 52.5px; }
        #dpad-center { left: 52.5px; top: 52.5px; background: rgba(100, 150, 255, 0.8); font-size: 16px; }
        #dpad-center:active { background: rgba(100, 150, 255, 1); }
        #zoomControls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        .zoom-btn {
            width: 55px;
            height: 55px;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            transition: all 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
        }
        .zoom-btn:active {
            background: rgba(76, 175, 80, 0.9);
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        @media (max-width: 768px) {
            #info {
                font-size: 11px;
                padding: 8px;
                max-width: 160px;
                top: 5px;
                left: 5px;
            }
            #info h3 {
                font-size: 13px;
                margin-bottom: 5px;
            }
            #info p {
                margin: 3px 0;
                line-height: 1.3;
            }
            #controls {
                font-size: 10px;
                padding: 8px;
                top: 5px;
                right: 5px;
            }
            #controls h4 {
                font-size: 12px;
            }
            input[type="range"] {
                width: 100px;
            }
        }
        @media (hover: none) and (pointer: coarse) {
            #touchControls, #zoomControls {
                display: block;
            }
            #zoomControls {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div id="info">
        <h3 style="margin-top: 0;">Warwick QLD Terrain</h3>
        <p><strong>Elevation Data</strong><br>
        <small style="color: #9acd32;">From topographic contours<br>450-625m elevation range</small></p>
        <p><strong>Controls:</strong><br>
        <strong>Desktop:</strong><br>
        • Mouse: Rotate/Pan/Zoom<br>
        • Arrows: Fly around<br>
        • Space: Reset<br>
        <strong>Touch:</strong><br>
        • Swipe: Rotate<br>
        • Pinch: Zoom<br>
        • D-pad: Move</p>
    </div>

    <div id="controls">
        <h4 style="margin-top: 0;">View Settings</h4>
        <div class="control-item">
            <label>Vertical Scale:</label>
            <input type="range" id="heightScale" min="0.1" max="10" step="0.1" value="0.1">
            <span id="heightValue">0.1</span>
        </div>
        <div class="control-item" style="font-size: 10px; color: #ccc; margin: 5px 0;">
            Scale shows realistic proportions at 0.1x
        </div>
        <div class="control-item">
            <label>Wireframe:</label>
            <input type="checkbox" id="wireframe">
        </div>
        <div class="control-item">
            <button onclick="resetCamera()">Reset View</button>
            <button onclick="topView()">Top View</button>
        </div>
        <div class="control-item">
            <button onclick="setRealisticScale()">Real (1x)</button>
            <button onclick="toggleAnimation()">Auto Rotate</button>
        </div>
        <div class="control-item">
            <button onclick="toggleTouchControls()">Touch UI</button>
        </div>
    </div>

    <div id="touchControls">
        <div id="dpad">
            <div class="dpad-btn" id="dpad-up">↑</div>
            <div class="dpad-btn" id="dpad-down">↓</div>
            <div class="dpad-btn" id="dpad-left">←</div>
            <div class="dpad-btn" id="dpad-right">→</div>
            <div class="dpad-btn" id="dpad-center">●</div>
        </div>
    </div>

    <div id="zoomControls">
        <div class="zoom-btn" id="zoom-in">+</div>
        <div class="zoom-btn" id="zoom-out">−</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, terrain;
        let animating = false;
        let originalHeightData = [];
        const GRID_SIZE = 50;
        
        const movement = { forward: false, backward: false, left: false, right: false, up: false, down: false };
        let cameraRotationState = { theta: 0, phi: Math.PI / 4 };
        let cameraDistanceState = 120;
        let cameraTargetState = new THREE.Vector3(0, 50, 0);

        function generateTerrainData() {
            const elevationData = [];
            
            for (let row = 0; row <= GRID_SIZE; row++) {
                elevationData[row] = [];
                for (let col = 0; col <= GRID_SIZE; col++) {
                    const x = (col - GRID_SIZE / 2) * 2.4;
                    const z = (row - GRID_SIZE / 2) * 2.4;
                    const dist = Math.sqrt(x * x + z * z);
                    const angle = Math.atan2(z, x);
                    
                    let elevation = 465;
                    
                    if (dist < 12) {
                        elevation = 460 - (12 - dist) * 0.8;
                    } else {
                        elevation += (dist - 12) * 1.5;
                    }
                    
                    const northeastFactor = (Math.cos(angle - Math.PI/4) + 1) / 2;
                    if (northeastFactor > 0.3 && dist > 15) elevation += northeastFactor * 60 + Math.sin(dist * 0.1) * 15;
                    
                    const northFactor = (Math.cos(angle - Math.PI/2) + 1) / 2;
                    if (northFactor > 0.4 && dist > 10) elevation += northFactor * 25 + Math.sin(dist * 0.08) * 10;
                    
                    const westFactor = (Math.cos(angle - Math.PI) + 1) / 2;
                    if (westFactor > 0.5 && dist > 8) elevation += westFactor * 18;
                    
                    const southFactor = (Math.cos(angle + Math.PI/2) + 1) / 2;
                    if (southFactor > 0.4 && dist > 10) elevation += southFactor * 20;
                    
                    const eastFactor = (Math.cos(angle) + 1) / 2;
                    if (eastFactor > 0.5 && dist > 12) elevation += eastFactor * 22;
                    
                    elevation += Math.sin(x * 0.04 + z * 0.03) * 8;
                    elevation += Math.cos(x * 0.06 - z * 0.05) * 6;
                    elevation += Math.sin(x * 0.08) * 4;
                    elevation += Math.cos(z * 0.07) * 4;
                    
                    const riverEffect1 = Math.exp(-Math.pow(x + 15, 2) / 80) * Math.exp(-Math.pow(z - 10, 2) / 120);
                    elevation -= riverEffect1 * 15;
                    
                    const riverEffect2 = Math.exp(-Math.pow(x + 5, 2) / 60) * Math.exp(-Math.pow(z + 20, 2) / 100);
                    elevation -= riverEffect2 * 12;
                    
                    elevation += (Math.random() - 0.5) * 4;
                    
                    if (dist > 20 && dist < 35) {
                        const ridgeFactor = Math.sin(angle * 3) * 0.5 + 0.5;
                        elevation += ridgeFactor * 8;
                    }
                    
                    elevation = Math.max(450, Math.min(625, elevation));
                    elevationData[row][col] = elevation;
                }
            }
            
            return elevationData;
        }

        function init() {
            const elevationData = generateTerrainData();
            
            let minElevation = Infinity, maxElevation = -Infinity;
            for (let row = 0; row <= GRID_SIZE; row++) {
                for (let col = 0; col <= GRID_SIZE; col++) {
                    minElevation = Math.min(minElevation, elevationData[row][col]);
                    maxElevation = Math.max(maxElevation, elevationData[row][col]);
                }
            }
            
            console.log('Elevation:', minElevation.toFixed(1), '-', maxElevation.toFixed(1), 'm');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 500);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 80, 100);
            camera.lookAt(0, 50, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            createTerrainFromData(elevationData, minElevation, maxElevation);

            const gridHelper = new THREE.GridHelper(200, 50, 0x888888, 0x444444);
            gridHelper.position.y = -2;
            scene.add(gridHelper);

            setupControls();
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('heightScale').addEventListener('input', updateHeightScale);
            document.getElementById('wireframe').addEventListener('change', toggleWireframe);
            setupTouchControls();
            animate();
        }

        function createTerrainFromData(elevationData, minElevation, maxElevation) {
            const geometry = new THREE.PlaneGeometry(120, 120, GRID_SIZE, GRID_SIZE);
            geometry.rotateX(-Math.PI / 2);

            const vertices = geometry.attributes.position.array;
            const baseElevation = minElevation;
            const elevationRange = maxElevation - minElevation;
            
            let idx = 0;
            for (let row = 0; row <= GRID_SIZE; row++) {
                for (let col = 0; col <= GRID_SIZE; col++) {
                    const normalizedElevation = elevationData[row][col] - baseElevation;
                    vertices[idx * 3 + 1] = normalizedElevation * 0.1;
                    originalHeightData.push(normalizedElevation);
                    idx++;
                }
            }

            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({ vertexColors: true, flatShading: false, side: THREE.DoubleSide });
            const colors = [];
            const color = new THREE.Color();
            
            for (let i = 0; i < vertices.length; i += 3) {
                const normalizedHeight = originalHeightData[i / 3] / elevationRange;
                if (normalizedHeight < 0.2) color.setHex(0x4a7c59);
                else if (normalizedHeight < 0.4) color.setHex(0x6b8e23);
                else if (normalizedHeight < 0.6) color.setHex(0x9acd32);
                else if (normalizedHeight < 0.8) color.setHex(0xdaa520);
                else color.setHex(0xd2b48c);
                colors.push(color.r, color.g, color.b);
            }
            
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            terrain = new THREE.Mesh(geometry, material);
            terrain.castShadow = true;
            terrain.receiveShadow = true;
            scene.add(terrain);
        }

        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    if (e.buttons === 1) {
                        cameraRotationState.theta -= deltaX * 0.01;
                        cameraRotationState.phi -= deltaY * 0.01;
                        cameraRotationState.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraRotationState.phi));
                    } else if (e.buttons === 2) {
                        const right = new THREE.Vector3();
                        camera.getWorldDirection(right);
                        right.cross(new THREE.Vector3(0, 1, 0)).normalize();
                        cameraTargetState.add(right.multiplyScalar(-deltaX * 0.1));
                        cameraTargetState.y += deltaY * 0.1;
                    }
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                    updateCameraFromState();
                }
            });

            renderer.domElement.addEventListener('mouseup', () => isDragging = false);
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistanceState += e.deltaY * 0.05;
                cameraDistanceState = Math.max(10, Math.min(200, cameraDistanceState));
                updateCameraFromState();
            });
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function updateCameraFromState() {
            camera.position.x = cameraTargetState.x + cameraDistanceState * Math.sin(cameraRotationState.phi) * Math.cos(cameraRotationState.theta);
            camera.position.y = cameraTargetState.y + cameraDistanceState * Math.cos(cameraRotationState.phi);
            camera.position.z = cameraTargetState.z + cameraDistanceState * Math.sin(cameraRotationState.phi) * Math.sin(cameraRotationState.theta);
            camera.lookAt(cameraTargetState);
        }

        function setupTouchControls() {
            ['dpad-up', 'dpad-down', 'dpad-left', 'dpad-right', 'dpad-center'].forEach((id, i) => {
                const dir = ['forward', 'backward', 'left', 'right', 'up'][i];
                const btn = document.getElementById(id);
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); movement[dir] = true; });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); movement[dir] = false; });
                btn.addEventListener('mousedown', (e) => { e.preventDefault(); movement[dir] = true; });
                btn.addEventListener('mouseup', (e) => { e.preventDefault(); movement[dir] = false; });
            });

            let zoomInterval;
            ['zoom-in', 'zoom-out'].forEach((id) => {
                const delta = id === 'zoom-in' ? -5 : 5;
                const btn = document.getElementById(id);
                const start = () => { 
                    cameraDistanceState += delta;
                    updateCameraFromState();
                    zoomInterval = setInterval(() => { cameraDistanceState += delta; updateCameraFromState(); }, 100);
                };
                const stop = () => clearInterval(zoomInterval);
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); start(); });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); stop(); });
                btn.addEventListener('mousedown', start);
                btn.addEventListener('mouseup', stop);
            });

            let lastTouch = { x: 0, y: 0, dist: 0 };
            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouch.dist = Math.sqrt(dx * dx + dy * dy);
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const dx = e.touches[0].clientX - lastTouch.x;
                    const dy = e.touches[0].clientY - lastTouch.y;
                    cameraRotationState.theta -= dx * 0.01;
                    cameraRotationState.phi -= dy * 0.01;
                    cameraRotationState.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraRotationState.phi));
                    updateCameraFromState();
                    lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    cameraDistanceState += (lastTouch.dist - dist) * 0.5;
                    updateCameraFromState();
                    lastTouch.dist = dist;
                }
            });
        }

        function onKeyDown(e) {
            if (e.key === 'ArrowUp' || e.key === 'w') movement.forward = true;
            if (e.key === 'ArrowDown' || e.key === 's') movement.backward = true;
            if (e.key === 'ArrowLeft' || e.key === 'a') movement.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') movement.right = true;
            if (e.key === 'q') movement.up = true;
            if (e.key === 'e') movement.down = true;
            if (e.key === ' ') resetCamera();
        }

        function onKeyUp(e) {
            if (e.key === 'ArrowUp' || e.key === 'w') movement.forward = false;
            if (e.key === 'ArrowDown' || e.key === 's') movement.backward = false;
            if (e.key === 'ArrowLeft' || e.key === 'a') movement.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') movement.right = false;
            if (e.key === 'q') movement.up = false;
            if (e.key === 'e') movement.down = false;
        }

        function updateMovement() {
            const dir = new THREE.Vector3(), right = new THREE.Vector3();
            camera.getWorldDirection(dir);
            right.crossVectors(dir, new THREE.Vector3(0, 1, 0)).normalize();
            if (movement.forward) camera.position.add(dir.multiplyScalar(0.5));
            if (movement.backward) camera.position.sub(dir.multiplyScalar(0.5));
            if (movement.left) camera.position.sub(right.multiplyScalar(0.5));
            if (movement.right) camera.position.add(right.multiplyScalar(0.5));
            if (movement.up) camera.position.y += 0.5;
            if (movement.down) camera.position.y -= 0.5;
        }

        function updateHeightScale(e) {
            const scale = parseFloat(e.target.value);
            document.getElementById('heightValue').textContent = scale.toFixed(1);
            const vertices = terrain.geometry.attributes.position.array;
            const colors = terrain.geometry.attributes.color.array;
            const color = new THREE.Color();
            const elevationRange = Math.max(...originalHeightData) - Math.min(...originalHeightData);
            
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 1] = originalHeightData[i / 3] * scale;
                const normalizedHeight = originalHeightData[i / 3] / elevationRange;
                if (normalizedHeight < 0.2) color.setHex(0x4a7c59);
                else if (normalizedHeight < 0.4) color.setHex(0x6b8e23);
                else if (normalizedHeight < 0.6) color.setHex(0x9acd32);
                else if (normalizedHeight < 0.8) color.setHex(0xdaa520);
                else color.setHex(0xd2b48c);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }
            
            terrain.geometry.attributes.position.needsUpdate = true;
            terrain.geometry.attributes.color.needsUpdate = true;
            terrain.geometry.computeVertexNormals();
        }

        function toggleWireframe(e) { terrain.material.wireframe = e.target.checked; }
        function resetCamera() {
            camera.position.set(0, 80, 100);
            camera.lookAt(0, 50, 0);
            cameraRotationState = { theta: 0, phi: Math.PI / 4 };
            cameraDistanceState = 120;
            cameraTargetState = new THREE.Vector3(0, 50, 0);
        }
        function topView() {
            camera.position.set(0, 200, 0);
            camera.lookAt(0, 50, 0);
            cameraRotationState = { theta: 0, phi: 0.01 };
            cameraDistanceState = 200;
        }
        function toggleAnimation() { animating = !animating; }
        function setRealisticScale() {
            document.getElementById('heightScale').value = 0.1;
            document.getElementById('heightScale').dispatchEvent(new Event('input'));
        }
        function toggleTouchControls() {
            const tc = document.getElementById('touchControls');
            const zc = document.getElementById('zoomControls');
            const show = tc.style.display === 'none' || !tc.style.display;
            tc.style.display = show ? 'block' : 'none';
            zc.style.display = show ? 'flex' : 'none';
        }

        function animate() {
            requestAnimationFrame(animate);
            updateMovement();
            if (animating && !Object.values(movement).some(v => v)) {
                camera.position.x = Math.sin(Date.now() * 0.0002) * 100;
                camera.position.z = Math.cos(Date.now() * 0.0002) * 100;
                camera.lookAt(0, 50, 0);
            }
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
