<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map with 3D Terrain Generator - Rain Simulation</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.2.1/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v10.2.1/dist/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 15px;
            z-index: 1000;
        }

        .control-btn {
            display: block;
            width: 100%;
            padding: 12px 20px;
            margin-bottom: 10px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            color: #333;
            touch-action: manipulation;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .control-btn {
                padding: 14px 22px;
                font-size: 16px;
            }
        }

        .control-btn:last-child {
            margin-bottom: 0;
        }

        .control-btn:hover {
            background: #f5f5f5;
            border-color: #2196F3;
        }

        .control-btn.active {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Toast notification */
        .toast {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 2000;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 12px 15px;
            font-size: 12px;
            z-index: 1000;
            max-width: 200px;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            color: #666;
        }

        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 8px;
            background: #8B4513;
        }

        /* 3D Viewer Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            width: 90%;
            height: 90%;
            background: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            background: #2a2a2a;
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .modal-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .modal-title {
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            min-width: 80px;
            touch-action: manipulation;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .modal-close {
                padding: 12px 20px;
                font-size: 16px;
                min-width: 100px;
            }
        }

        .modal-close:hover {
            background: #ff6666;
        }

        .modal-close[style*="4CAF50"]:hover {
            background: #66BB6A !important;
        }

        .modal-close[style*="2196F3"]:hover {
            background: #42A5F5 !important;
        }

        .modal-close[style*="666"]:hover {
            background: #888 !important;
        }

        .modal-close[style*="FF9800"]:hover {
            background: #FFB74D !important;
        }

        /* Toolbar controls */
        .toolbar-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .toolbar-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .toolbar-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .toolbar-btn.active {
            background: #2196F3;
            border-color: #2196F3;
        }

        .toolbar-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-label input[type="range"] {
            width: 120px;
        }

        .toolbar-label input[type="checkbox"] {
            cursor: pointer;
        }

        #flyingModeStatus {
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-weight: bold;
            font-size: 12px;
            color: white;
        }

        /* Rain Simulation Panel */
        .rain-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(42, 42, 42, 0.95);
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 150;
            display: none;
            min-width: 320px;
        }

        .rain-panel.show {
            display: block;
        }

        .rain-panel h3 {
            color: white;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .rain-control-group {
            margin-bottom: 12px;
        }

        .rain-control-group label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            display: block;
            margin-bottom: 5px;
        }

        .rain-control-group input[type="range"],
        .rain-control-group input[type="number"] {
            width: 100%;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .rain-control-group input[type="range"] {
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.2);
        }

        .rain-control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #2196F3;
            cursor: pointer;
            border-radius: 50%;
        }

        .rain-value-display {
            color: #2196F3;
            font-weight: bold;
            margin-left: 8px;
        }

        .rain-buttons {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .rain-btn {
            flex: 1;
            min-width: 70px;
            padding: 8px 12px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .rain-btn:hover {
            background: #42A5F5;
        }

        .rain-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .rain-btn.danger {
            background: #f44336;
        }

        .rain-btn.danger:hover {
            background: #ef5350;
        }

        .rain-btn.warning {
            background: #FF9800;
        }

        .rain-btn.warning:hover {
            background: #FFB74D;
        }

        /* Rain Stats Display */
        .rain-stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            z-index: 150;
            display: none;
            min-width: 250px;
            font-size: 13px;
        }

        .rain-stats.show {
            display: block;
        }

        .rain-stats h4 {
            margin-bottom: 10px;
            color: #2196F3;
        }

        .rain-stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .rain-stat-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .rain-stat-value {
            color: white;
            font-weight: bold;
        }

        #viewer3d {
            flex: 1;
            width: 100%;
            position: relative;
        }

        .loading-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 8px;
            z-index: 10001;
            display: none;
            text-align: center;
        }

        .loading-overlay.show {
            display: block;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Pointer lock info */
        .pointer-lock-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px 40px;
            border-radius: 12px;
            text-align: center;
            z-index: 200;
            max-width: 500px;
            transition: opacity 0.3s ease;
        }

        .pointer-lock-info.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .pointer-lock-info h2 {
            margin-bottom: 15px;
            font-size: 24px;
        }

        .pointer-lock-info p {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .pointer-lock-info strong {
            color: #2196F3;
        }

        /* Controls hint */
        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 100;
            transition: opacity 0.3s ease;
        }

        .controls-hint.hidden {
            opacity: 0;
        }

        /* Touch controls */
        .touch-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            display: none;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .touch-controls {
                display: flex;
                gap: 40px;
                align-items: flex-end;
            }
        }

        .dpad-container {
            position: relative;
            width: 140px;
            height: 140px;
        }

        .dpad {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .dpad-btn {
            position: absolute;
            width: 45px;
            height: 45px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .dpad-btn:active {
            background: rgba(33, 150, 243, 0.6);
            border-color: rgba(33, 150, 243, 0.8);
            transform: scale(0.95);
        }

        #dpad-up {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        #dpad-down {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        #dpad-left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        #dpad-right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .vertical-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .vertical-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .vertical-btn:active {
            background: rgba(33, 150, 243, 0.6);
            border-color: rgba(33, 150, 243, 0.8);
            transform: scale(0.95);
        }

        /* Look zone for touch look controls */
        .look-zone {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            z-index: 50;
            touch-action: none;
        }

        .look-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .look-hint.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="control-panel">
        <button id="locationBtn" class="control-btn">üìç Get Location</button>
        <button id="contoursBtn" class="control-btn">üìà Toggle Contours</button>
        <button id="satelliteBtn" class="control-btn">üõ∞Ô∏è Toggle Satellite</button>
        <button id="selectAreaBtn" class="control-btn">üìê Select Area</button>
        <button id="open3DViewerBtn" class="control-btn">üéÆ 3D Viewer</button>
        <button id="saveDataBtn" class="control-btn">üíæ Save Data</button>
        <button id="loadDataBtn" class="control-btn">üìÇ Load Data</button>
    </div>

    <div class="legend">
        <div class="legend-title">Contours</div>
        <div class="legend-item">
            <div class="legend-line"></div>
            <span>10m intervals</span>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- 3D Viewer Modal -->
    <div class="modal" id="modal3d">
        <div class="modal-content">
            <div class="modal-header">
                <!-- First row: Title and main buttons -->
                <div class="modal-header-row">
                    <span class="modal-title">üóª 3D Terrain Viewer</span>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button id="rainSimBtn" class="modal-close" style="background: #FF9800;">üåßÔ∏è Rain Simulation</button>
                        <button id="saveDataBtn3D" class="modal-close" style="background: #4CAF50;">üíæ Save</button>
                        <button id="loadDataBtn3D" class="modal-close" style="background: #2196F3;">üìÇ Load</button>
                        <button id="closeModal" class="modal-close">‚úï Close</button>
                    </div>
                </div>
                
                <!-- Second row: Controls -->
                <div class="toolbar-controls">
                    <div id="flyingModeStatus">RUNNING MODE</div>
                    <button id="resetViewBtn" class="toolbar-btn">Reset View</button>
                    <button id="topViewBtn" class="toolbar-btn">Top View</button>
                    <button id="autoRotateBtn" class="toolbar-btn">Auto-Rotate</button>
                    <button id="toggleTexture" class="toolbar-btn" style="display: none;">Toggle Texture</button>
                    <label class="toolbar-label">
                        Scale: <span id="scaleValue">0.1</span>x
                        <input type="range" id="verticalScale" min="0.1" max="5" step="0.1" value="0.1">
                    </label>
                    <label class="toolbar-label">
                        <input type="checkbox" id="wireframeToggle"> Wireframe
                    </label>
                </div>
            </div>
            <div id="viewer3d">
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div>Generating 3D terrain...</div>
                </div>

                <!-- Rain Simulation Panel -->
                <div class="rain-panel" id="rainPanel">
                    <h3>üåßÔ∏è Rain Simulation Settings</h3>
                    
                    <div class="rain-control-group">
                        <label>
                            Rainfall Amount: <span class="rain-value-display" id="rainfallDisplay">100</span> mm
                        </label>
                        <input type="range" id="rainfallAmount" min="1" max="500" value="100" step="1">
                    </div>

                    <div class="rain-control-group">
                        <label>
                            Duration: <span class="rain-value-display" id="durationDisplay">6</span> hours
                        </label>
                        <input type="range" id="rainDuration" min="1" max="48" value="6" step="1">
                    </div>

                    <div class="rain-control-group">
                        <label>
                            Soil Drainage Rate: <span class="rain-value-display" id="drainageDisplay">50</span>%
                        </label>
                        <input type="range" id="drainageRate" min="0" max="100" value="50" step="1">
                    </div>

                    <div class="rain-buttons">
                        <button class="rain-btn" id="startRainBtn">‚ñ∂ Start</button>
                        <button class="rain-btn warning" id="pauseRainBtn" disabled>‚è∏ Pause</button>
                        <button class="rain-btn" id="stepRainBtn" disabled>‚è≠ Step</button>
                        <button class="rain-btn danger" id="stopRainBtn" disabled>‚èπ Stop</button>
                    </div>
                </div>

                <!-- Rain Stats Display -->
                <div class="rain-stats" id="rainStats">
                    <h4>üìä Simulation Stats</h4>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Time:</span>
                        <span class="rain-stat-value" id="statTime">0 / 0 hours</span>
                    </div>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Total Water:</span>
                        <span class="rain-stat-value" id="statWater">0 ML</span>
                    </div>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Max Depth:</span>
                        <span class="rain-stat-value" id="statDepth">0 mm</span>
                    </div>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Avg Saturation:</span>
                        <span class="rain-stat-value" id="statSaturation">0%</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display: none;">

    <script>
        // Debug function
        function debug(msg) {
            console.log('[3D Terrain] ' + msg);
        }

        // Toast notification
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Initialize map
        const map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM()
                })
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([0, 0]),
                zoom: 2
            })
        });

        // State
        let currentElevationData = null;
        let contoursVisible = false;
        let satelliteVisible = false;
        let isSelecting = false;
        let selectionBox = null;
        let startCoord = null;

        // Layers
        const satelliteLayer = new ol.layer.Tile({
            source: new ol.source.XYZ({
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                maxZoom: 19
            }),
            visible: false
        });

        const contoursLayer = new ol.layer.Vector({
            source: new ol.source.Vector(),
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: '#8B4513',
                    width: 1
                })
            }),
            visible: false
        });

        const selectionLayer = new ol.layer.Vector({
            source: new ol.source.Vector(),
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: 'rgba(33, 150, 243, 0.8)',
                    width: 2,
                    lineDash: [5, 5]
                }),
                fill: new ol.style.Fill({
                    color: 'rgba(33, 150, 243, 0.1)'
                })
            })
        });

        map.addLayer(satelliteLayer);
        map.addLayer(contoursLayer);
        map.addLayer(selectionLayer);

        // Location marker
        const locationLayer = new ol.layer.Vector({
            source: new ol.source.Vector()
        });
        map.addLayer(locationLayer);

        // Get user location
        function getUserLocation() {
            if (!navigator.geolocation) {
                showToast('Geolocation not supported');
                return;
            }

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const coords = [position.coords.longitude, position.coords.latitude];
                    const location = ol.proj.fromLonLat(coords);
                    
                    map.getView().setCenter(location);
                    map.getView().setZoom(15);
                    
                    locationLayer.getSource().clear();
                    const marker = new ol.Feature({
                        geometry: new ol.geom.Point(location),
                        name: 'Your Location'
                    });
                    
                    marker.setStyle(new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 8,
                            fill: new ol.style.Fill({ color: '#2196F3' }),
                            stroke: new ol.style.Stroke({
                                color: 'white',
                                width: 3
                            })
                        })
                    }));
                    
                    locationLayer.getSource().addFeature(marker);
                    showToast('Location found!');
                },
                (error) => {
                    showToast('Could not get location');
                }
            );
        }

        // Toggle contours
        function toggleContours() {
            contoursVisible = !contoursVisible;
            contoursLayer.setVisible(contoursVisible);
            document.getElementById('contoursBtn').classList.toggle('active', contoursVisible);
        }

        // Toggle satellite
        function toggleSatellite() {
            satelliteVisible = !satelliteVisible;
            satelliteLayer.setVisible(satelliteVisible);
            document.getElementById('satelliteBtn').classList.toggle('active', satelliteVisible);
        }

        // Area selection
        function toggleAreaSelection() {
            isSelecting = !isSelecting;
            const btn = document.getElementById('selectAreaBtn');
            btn.classList.toggle('active', isSelecting);
            
            if (!isSelecting) {
                selectionLayer.getSource().clear();
                startCoord = null;
                selectionBox = null;
            }
            
            showToast(isSelecting ? 'Click and drag to select area' : 'Selection cancelled');
        }

        map.on('pointerdown', (evt) => {
            if (!isSelecting) return;
            startCoord = evt.coordinate;
            selectionBox = null;
        });

        map.on('pointerdrag', (evt) => {
            if (!isSelecting || !startCoord) return;
            
            const extent = ol.extent.boundingExtent([startCoord, evt.coordinate]);
            
            if (selectionBox) {
                selectionBox.setGeometry(ol.geom.Polygon.fromExtent(extent));
            } else {
                selectionBox = new ol.Feature(ol.geom.Polygon.fromExtent(extent));
                selectionLayer.getSource().addFeature(selectionBox);
            }
        });

        map.on('pointerup', (evt) => {
            if (!isSelecting || !startCoord) return;
            
            const extent = ol.extent.boundingExtent([startCoord, evt.coordinate]);
            const [minX, minY, maxX, maxY] = extent;
            
            const bottomLeft = ol.proj.toLonLat([minX, minY]);
            const topRight = ol.proj.toLonLat([maxX, maxY]);
            
            const width = Math.abs(maxX - minX);
            const height = Math.abs(maxY - minY);
            
            if (width < 1000 || height < 1000) {
                showToast('Area too small - draw a larger area');
                return;
            }
            
            isSelecting = false;
            document.getElementById('selectAreaBtn').classList.remove('active');
            
            fetchElevationData(bottomLeft, topRight);
        });

        // Fetch elevation data
        async function fetchElevationData(bottomLeft, topRight) {
            const loading = document.getElementById('loadingOverlay');
            loading.classList.add('show');
            
            try {
                const width = 100;
                const height = 100;
                
                const elevationData = [];
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        const lat = bottomLeft[1] + (topRight[1] - bottomLeft[1]) * (i / (height - 1));
                        const lon = bottomLeft[0] + (topRight[0] - bottomLeft[0]) * (j / (width - 1));
                        
                        const elevation = Math.random() * 100 + Math.sin(i / 10) * Math.cos(j / 10) * 50;
                        elevationData.push(elevation);
                    }
                }
                
                currentElevationData = {
                    elevationData,
                    width,
                    height,
                    bottomLeft,
                    topRight
                };
                
                document.getElementById('open3DViewerBtn').disabled = false;
                showToast('Elevation data fetched!');
                
                setTimeout(() => {
                    create3DTerrain(elevationData, width, height, bottomLeft, topRight);
                }, 500);
                
            } catch (error) {
                showToast('Error fetching data: ' + error.message);
            } finally {
                loading.classList.remove('show');
            }
        }

        // Save terrain data
        function saveTerrainData() {
            if (!currentElevationData) {
                showToast('No terrain data to save');
                return;
            }
            
            const json = JSON.stringify(currentElevationData);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'terrain_data.json';
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('Terrain data saved!');
        }

        // Load terrain data
        function loadTerrainData(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    currentElevationData = JSON.parse(e.target.result);
                    showToast('Terrain data loaded!');
                    document.getElementById('open3DViewerBtn').disabled = false;
                    
                    // Only auto-open if modal is not already showing
                    const modal = document.getElementById('modal3d');
                    if (currentElevationData && !modal.classList.contains('show')) {
                        create3DTerrain(
                            currentElevationData.elevationData,
                            currentElevationData.width,
                            currentElevationData.height,
                            currentElevationData.bottomLeft,
                            currentElevationData.topRight
                        );
                    } else if (currentElevationData && modal.classList.contains('show')) {
                        // Modal is already open, recreate the terrain
                        create3DTerrain(
                            currentElevationData.elevationData,
                            currentElevationData.width,
                            currentElevationData.height,
                            currentElevationData.bottomLeft,
                            currentElevationData.topRight
                        );
                    }
                } catch (error) {
                    showToast('Error loading file: ' + error.message);
                    console.error('File load error:', error);
                }
            };
            reader.readAsText(file);
        }

        // Fetch satellite texture
        async function fetchSatelliteTexture(bottomLeft, topRight, width, height) {
            try {
                debug('Fetching satellite texture for bounds:');
                debug('  Bottom-left: ' + bottomLeft[0] + ', ' + bottomLeft[1]);
                debug('  Top-right: ' + topRight[0] + ', ' + topRight[1]);
                
                const latDiff = Math.abs(topRight[1] - bottomLeft[1]);
                const lonDiff = Math.abs(topRight[0] - bottomLeft[0]);
                
                let zoom;
                const maxDiff = Math.max(latDiff, lonDiff);
                if (maxDiff > 1) zoom = 10;
                else if (maxDiff > 0.5) zoom = 11;
                else if (maxDiff > 0.25) zoom = 12;
                else if (maxDiff > 0.1) zoom = 13;
                else if (maxDiff > 0.05) zoom = 14;
                else if (maxDiff > 0.025) zoom = 15;
                else if (maxDiff > 0.01) zoom = 16;
                else zoom = 17;
                
                debug('  Zoom level: ' + zoom + ' (area size: ' + maxDiff.toFixed(4) + '¬∞)');
                
                function latLonToTile(lat, lon, z) {
                    const n = Math.pow(2, z);
                    const x = Math.floor((lon + 180) / 360 * n);
                    const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);
                    return { x, y };
                }
                
                const minTile = latLonToTile(bottomLeft[1], bottomLeft[0], zoom);
                const maxTile = latLonToTile(topRight[1], topRight[0], zoom);
                
                const minX = Math.min(minTile.x, maxTile.x);
                const maxX = Math.max(minTile.x, maxTile.x);
                const minY = Math.min(minTile.y, maxTile.y);
                const maxY = Math.max(minTile.y, maxTile.y);
                
                const tilesX = maxX - minX + 1;
                const tilesY = maxY - minY + 1;
                
                debug('  Tiles needed: ' + tilesX + ' x ' + tilesY + ' = ' + (tilesX * tilesY));
                
                const tileSize = 256;
                const canvas = document.createElement('canvas');
                canvas.width = tilesX * tileSize;
                canvas.height = tilesY * tileSize;
                const ctx = canvas.getContext('2d');
                
                const tilePromises = [];
                for (let y = minY; y <= maxY; y++) {
                    for (let x = minX; x <= maxX; x++) {
                        const url = `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoom}/${y}/${x}`;
                        
                        const promise = new Promise((resolve, reject) => {
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.onload = () => {
                                const canvasX = (x - minX) * tileSize;
                                const canvasY = (y - minY) * tileSize;
                                ctx.drawImage(img, canvasX, canvasY);
                                resolve();
                            };
                            img.onerror = () => {
                                debug('  Failed to load tile: ' + x + ',' + y);
                                reject(new Error('Tile load failed'));
                            };
                            img.src = url;
                        });
                        
                        tilePromises.push(promise);
                    }
                }
                
                await Promise.all(tilePromises);
                debug('  All tiles loaded successfully');
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.needsUpdate = true;
                
                return texture;
            } catch (error) {
                debug('Texture fetch error: ' + error.message);
                return null;
            }
        }

        // Create 3D terrain visualization
        function create3DTerrain(elevationData, width, height, bottomLeft, topRight) {
            debug('Creating 3D terrain: ' + width + 'x' + height);
            
            const modal = document.getElementById('modal3d');
            const container = document.getElementById('viewer3d');
            
            // Clear previous content except rain panel and stats
            const rainPanel = document.getElementById('rainPanel');
            const rainStats = document.getElementById('rainStats');
            const loadingOverlay = document.getElementById('loadingOverlay');
            
            container.innerHTML = '';
            container.appendChild(loadingOverlay);
            container.appendChild(rainPanel);
            container.appendChild(rainStats);
            
            // Camera state
            const camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.01,
                10000
            );
            
            const velocity = new THREE.Vector3();
            const direction = new THREE.Vector3();
            
            let pitch = 0;
            let yaw = 0;
            
            const keys = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                up: false,
                down: false
            };
            
            let isPointerLocked = false;
            let isFlying = false;
            let lastUpTapTime = 0;
            const doubleTapDelay = 300;
            
            // Setup Three.js scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Find elevation range
            let minElev = Infinity;
            let maxElev = -Infinity;
            for (let i = 0; i < elevationData.length; i++) {
                if (elevationData[i] > -9999 && elevationData[i] !== 0) {
                    minElev = Math.min(minElev, elevationData[i]);
                    maxElev = Math.max(maxElev, elevationData[i]);
                }
            }
            
            if (minElev === Infinity || maxElev === -Infinity || minElev === maxElev) {
                debug('WARN: Invalid data, using test terrain');
                minElev = 0;
                maxElev = 100;
                for (let i = 0; i < elevationData.length; i++) {
                    elevationData[i] = Math.sin(i / 10) * 50 + 50;
                }
            }
            
            const elevRange = maxElev - minElev;
            const scale = Math.max(width, height) / 100;
            const verticalExaggeration = 0.1;
            let originalHeightData = [];
            
            // Calculate real-world measurements
            let metersPerSceneUnit = 1;
            let totalAreaSquareMeters = 0;
            
            if (bottomLeft && topRight) {
                const lat1 = bottomLeft[1] * Math.PI / 180;
                const lat2 = topRight[1] * Math.PI / 180;
                const lon1 = bottomLeft[0] * Math.PI / 180;
                const lon2 = topRight[0] * Math.PI / 180;
                
                const R = 6371000;
                const dLat = lat2 - lat1;
                const dLon = lon2 - lon1;
                
                const latDistance = R * Math.abs(lat2 - lat1);
                const lonDistance = R * Math.abs(dLon) * Math.cos((lat1 + lat2) / 2);
                
                totalAreaSquareMeters = latDistance * lonDistance;
                
                const sceneWidth = width * scale;
                const sceneHeight = height * scale;
                
                const metersPerUnitWidth = lonDistance / sceneWidth;
                const metersPerUnitHeight = latDistance / sceneHeight;
                metersPerSceneUnit = (metersPerUnitWidth + metersPerUnitHeight) / 2;
                
                debug('Real-world area: ' + (totalAreaSquareMeters / 1000000).toFixed(2) + ' km¬≤');
                debug('Meters per scene unit: ' + metersPerSceneUnit.toFixed(4));
            } else {
                const sceneWidth = width * scale;
                totalAreaSquareMeters = 1000000; // 1 km¬≤ default
                metersPerSceneUnit = 1000 / sceneWidth;
            }
            
            const terrainScaleFactor = (verticalExaggeration * scale * 50) / elevRange;
            const playerHeight = 2.8 * terrainScaleFactor;
            
            const walkingSpeedMetersPerSecond = 4.2;
            const walkingSpeedMetersPerFrame = walkingSpeedMetersPerSecond / 60;
            const walkSpeed = walkingSpeedMetersPerFrame / metersPerSceneUnit;
            
            const sceneWidth = width * scale;
            const sceneHeight = height * scale;
            const mapDiagonal = Math.sqrt(sceneWidth * sceneWidth + sceneHeight * sceneHeight);
            const flySpeed = mapDiagonal / 10 / 60;
            
            // Create geometry
            const geometry = new THREE.PlaneGeometry(
                width * scale,
                height * scale,
                width - 1,
                height - 1
            );
            
            const vertices = geometry.attributes.position.array;
            
            // Apply elevation data
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const idx = i * width + j;
                    const vertIdx = (i * width + j) * 3;
                    
                    let elevation = elevationData[idx];
                    if (elevation < -9999) elevation = minElev;
                    
                    const normalizedHeight = ((elevation - minElev) / elevRange) * verticalExaggeration * scale * 50;
                    vertices[vertIdx + 2] = normalizedHeight;
                    originalHeightData.push(normalizedHeight);
                }
            }
            
            geometry.computeVertexNormals();
            
            // Create material with vertex colors
            const colors = new Float32Array(vertices.length);
            for (let i = 0; i < vertices.length; i += 3) {
                const height = vertices[i + 2];
                const normalized = height / (verticalExaggeration * scale * 50);
                
                let r, g, b;
                if (normalized < 0.25) {
                    r = 0.2; g = 0.5 + normalized * 2; b = 0.3;
                } else if (normalized < 0.5) {
                    r = 0.3 + (normalized - 0.25) * 2; g = 0.7; b = 0.2;
                } else if (normalized < 0.75) {
                    r = 0.7 + (normalized - 0.5) * 0.8; g = 0.7 - (normalized - 0.5) * 1.2; b = 0.2;
                } else {
                    r = 0.5 + (normalized - 0.75) * 0.8; g = 0.4 - (normalized - 0.75) * 0.8; b = 0.2;
                }
                
                colors[i] = r; colors[i + 1] = g; colors[i + 2] = b;
            }
            
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            let material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                flatShading: false,
                shininess: 10,
                side: THREE.DoubleSide
            });
            
            let satelliteTexture = null;
            let useTexture = true;
            
            // Load satellite texture
            if (bottomLeft && topRight) {
                fetchSatelliteTexture(bottomLeft, topRight, width, height).then(texture => {
                    if (texture) {
                        satelliteTexture = texture;
                        material.map = texture;
                        material.vertexColors = false;
                        material.needsUpdate = true;
                        debug('Satellite texture applied');
                        showToast('Satellite texture loaded!');
                        
                        const toggleBtn = document.getElementById('toggleTexture');
                        if (toggleBtn) {
                            toggleBtn.style.display = 'block';
                            toggleBtn.classList.add('active');
                        }
                    }
                }).catch(error => {
                    debug('Texture load failed: ' + error.message);
                });
            }
            
            const terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            scene.add(terrain);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            camera.position.set(0, playerHeight, 0);
            camera.rotation.order = 'YXZ';
            
            // RAIN SIMULATION SYSTEM
            let rainSimulation = {
                active: false,
                paused: false,
                config: {
                    rainfall: 100, // mm
                    duration: 6,   // hours
                    drainage: 50   // %
                },
                state: {
                    currentHour: 0,
                    waterDepth: new Float32Array(width * height),  // mm of water
                    soilSaturation: new Float32Array(width * height), // 0-100%
                    totalWaterLiters: 0,
                    maxDepth: 0
                },
                particles: null,
                waterMesh: null,
                originalSkyColor: new THREE.Color(0x87CEEB)
            };
            
            // Create rain particles
            function createRainParticles() {
                const particleCount = 5000;
                const particleGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount);
                
                const halfWidth = (width * scale) / 2;
                const halfHeight = (height * scale) / 2;
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * width * scale;
                    positions[i * 3 + 1] = Math.random() * scale * 200 + 50;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * height * scale;
                    velocities[i] = 2 + Math.random() * 2;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));
                
                const particleMaterial = new THREE.PointsMaterial({
                    color: 0xaaaaff,
                    size: 0.3,
                    transparent: true,
                    opacity: 0.6
                });
                
                return new THREE.Points(particleGeometry, particleMaterial);
            }
            
            // Create water layer mesh
            function createWaterLayer() {
                const waterGeometry = new THREE.PlaneGeometry(
                    width * scale,
                    height * scale,
                    width - 1,
                    height - 1
                );
                
                const waterMaterial = new THREE.MeshPhongMaterial({
                    color: 0x0066ff,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    shininess: 100
                });
                
                const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
                waterMesh.rotation.x = -Math.PI / 2;
                waterMesh.visible = false;
                
                return waterMesh;
            }
            
            // Get terrain height at grid position
            function getTerrainHeightAtGrid(gridX, gridY) {
                const clampedX = Math.max(0, Math.min(width - 1, Math.floor(gridX)));
                const clampedY = Math.max(0, Math.min(height - 1, Math.floor(gridY)));
                const idx = clampedY * width + clampedX;
                return originalHeightData[idx] || 0;
            }
            
            // Simulate one hour of rain
            function simulateRainHour() {
                const sim = rainSimulation;
                
                // Apply rainfall (1mm over 1 m¬≤ = 1 liter)
                const rainfallThisHour = sim.config.rainfall / sim.config.duration; // mm per hour
                const gridCellAreaM2 = totalAreaSquareMeters / (width * height);
                const litersPerCell = rainfallThisHour * gridCellAreaM2 / 1000; // Convert mm to meters
                
                // Add rainfall to each cell
                for (let i = 0; i < width * height; i++) {
                    sim.state.waterDepth[i] += rainfallThisHour;
                }
                
                // 10 sub-steps for water flow simulation
                const subSteps = 10;
                for (let step = 0; step < subSteps; step++) {
                    const newWaterDepth = new Float32Array(sim.state.waterDepth);
                    
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = y * width + x;
                            const terrainHeight = originalHeightData[idx];
                            const waterLevel = terrainHeight + sim.state.waterDepth[idx] * terrainScaleFactor * 0.001;
                            
                            // Flow to neighbors
                            const neighbors = [
                                [x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]
                            ];
                            
                            let totalFlow = 0;
                            for (const [nx, ny] of neighbors) {
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const nIdx = ny * width + nx;
                                    const nTerrainHeight = originalHeightData[nIdx];
                                    const nWaterLevel = nTerrainHeight + sim.state.waterDepth[nIdx] * terrainScaleFactor * 0.001;
                                    
                                    if (waterLevel > nWaterLevel) {
                                        const heightDiff = waterLevel - nWaterLevel;
                                        const flowAmount = Math.min(
                                            sim.state.waterDepth[idx] * 0.1,
                                            heightDiff * 100
                                        );
                                        
                                        newWaterDepth[idx] -= flowAmount / 4;
                                        newWaterDepth[nIdx] += flowAmount / 4;
                                        totalFlow += flowAmount / 4;
                                    }
                                }
                            }
                            
                            // Apply drainage
                            const drainageRate = sim.config.drainage / 100;
                            const soilCapacity = 100; // mm
                            const availableSoilSpace = Math.max(0, soilCapacity - sim.state.soilSaturation[idx]);
                            const drainageAmount = Math.min(
                                newWaterDepth[idx] * drainageRate * 0.1,
                                availableSoilSpace
                            );
                            
                            newWaterDepth[idx] -= drainageAmount;
                            sim.state.soilSaturation[idx] += drainageAmount;
                            sim.state.soilSaturation[idx] = Math.min(100, sim.state.soilSaturation[idx]);
                        }
                    }
                    
                    sim.state.waterDepth = newWaterDepth;
                }
                
                // Update water mesh
                if (sim.waterMesh) {
                    const waterVertices = sim.waterMesh.geometry.attributes.position.array;
                    let totalWater = 0;
                    let maxDepth = 0;
                    
                    for (let i = 0; i < height; i++) {
                        for (let j = 0; j < width; j++) {
                            const idx = i * width + j;
                            const vertIdx = (i * width + j) * 3;
                            
                            const waterHeight = sim.state.waterDepth[idx] * terrainScaleFactor * 0.001;
                            waterVertices[vertIdx + 2] = originalHeightData[idx] + waterHeight;
                            
                            totalWater += sim.state.waterDepth[idx];
                            maxDepth = Math.max(maxDepth, sim.state.waterDepth[idx]);
                        }
                    }
                    
                    sim.waterMesh.geometry.attributes.position.needsUpdate = true;
                    sim.waterMesh.geometry.computeVertexNormals();
                    sim.waterMesh.visible = maxDepth > 0.1;
                    
                    // Update stats
                    const gridCellArea = totalAreaSquareMeters / (width * height);
                    sim.state.totalWaterLiters = (totalWater / 1000) * gridCellArea; // Convert mm to meters
                    sim.state.maxDepth = maxDepth;
                }
            }
            
            // Update rain particles
            function updateRainParticles(delta) {
                if (!rainSimulation.particles) return;
                
                const positions = rainSimulation.particles.geometry.attributes.position.array;
                const velocities = rainSimulation.particles.geometry.attributes.velocity.array;
                
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3 + 1] -= velocities[i] * delta * 60;
                    
                    if (positions[i * 3 + 1] < 0) {
                        positions[i * 3 + 1] = scale * 200 + Math.random() * 50;
                    }
                }
                
                rainSimulation.particles.geometry.attributes.position.needsUpdate = true;
            }
            
            // Update rain stats display
            function updateRainStats() {
                const sim = rainSimulation;
                
                document.getElementById('statTime').textContent = 
                    sim.state.currentHour + ' / ' + sim.config.duration + ' hours';
                
                document.getElementById('statWater').textContent = 
                    (sim.state.totalWaterLiters / 1000000).toFixed(2) + ' ML';
                
                document.getElementById('statDepth').textContent = 
                    sim.state.maxDepth.toFixed(1) + ' mm';
                
                let avgSaturation = 0;
                for (let i = 0; i < sim.state.soilSaturation.length; i++) {
                    avgSaturation += sim.state.soilSaturation[i];
                }
                avgSaturation /= sim.state.soilSaturation.length;
                
                document.getElementById('statSaturation').textContent = 
                    avgSaturation.toFixed(1) + '%';
            }
            
            // Rain simulation controls
            let rainAnimationInterval = null;
            
            function startRainSimulation() {
                const sim = rainSimulation;
                
                // Get config values
                sim.config.rainfall = parseInt(document.getElementById('rainfallAmount').value);
                sim.config.duration = parseInt(document.getElementById('rainDuration').value);
                sim.config.drainage = parseInt(document.getElementById('drainageRate').value);
                
                // Reset state
                sim.state.currentHour = 0;
                sim.state.waterDepth.fill(0);
                sim.state.soilSaturation.fill(0);
                sim.state.totalWaterLiters = 0;
                sim.state.maxDepth = 0;
                
                // Create visual elements
                if (!sim.particles) {
                    sim.particles = createRainParticles();
                    scene.add(sim.particles);
                }
                if (!sim.waterMesh) {
                    sim.waterMesh = createWaterLayer();
                    scene.add(sim.waterMesh);
                }
                
                sim.particles.visible = true;
                scene.background = new THREE.Color(0x606060); // Darken sky
                
                sim.active = true;
                sim.paused = false;
                
                // Update UI
                document.getElementById('startRainBtn').disabled = true;
                document.getElementById('pauseRainBtn').disabled = false;
                document.getElementById('stepRainBtn').disabled = false;
                document.getElementById('stopRainBtn').disabled = false;
                document.getElementById('rainStats').classList.add('show');
                
                // Run simulation (2 seconds per hour)
                rainAnimationInterval = setInterval(() => {
                    if (!sim.paused && sim.state.currentHour < sim.config.duration) {
                        simulateRainHour();
                        sim.state.currentHour++;
                        updateRainStats();
                        
                        if (sim.state.currentHour >= sim.config.duration) {
                            pauseRainSimulation();
                            sim.particles.visible = false;
                            scene.background = sim.originalSkyColor;
                            showToast('Rain simulation complete!');
                        }
                    }
                }, 2000);
                
                showToast('Rain simulation started!');
            }
            
            function pauseRainSimulation() {
                rainSimulation.paused = !rainSimulation.paused;
                const btn = document.getElementById('pauseRainBtn');
                btn.textContent = rainSimulation.paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
            }
            
            function stepRainSimulation() {
                const sim = rainSimulation;
                if (sim.state.currentHour < sim.config.duration) {
                    simulateRainHour();
                    sim.state.currentHour++;
                    updateRainStats();
                    
                    if (sim.state.currentHour >= sim.config.duration) {
                        sim.particles.visible = false;
                        scene.background = sim.originalSkyColor;
                        showToast('Rain simulation complete!');
                    }
                }
            }
            
            function stopRainSimulation() {
                const sim = rainSimulation;
                
                // Clear interval
                if (rainAnimationInterval) {
                    clearInterval(rainAnimationInterval);
                    rainAnimationInterval = null;
                }
                
                // Reset and hide
                sim.active = false;
                sim.paused = false;
                
                if (sim.particles) {
                    sim.particles.visible = false;
                }
                if (sim.waterMesh) {
                    sim.waterMesh.visible = false;
                }
                
                scene.background = sim.originalSkyColor;
                
                // Update UI
                document.getElementById('startRainBtn').disabled = false;
                document.getElementById('pauseRainBtn').disabled = true;
                document.getElementById('stepRainBtn').disabled = true;
                document.getElementById('stopRainBtn').disabled = true;
                document.getElementById('rainStats').classList.remove('show');
                document.getElementById('pauseRainBtn').textContent = '‚è∏ Pause';
                
                showToast('Rain simulation stopped');
            }
            
            // Rain UI event listeners
            document.getElementById('rainfallAmount').addEventListener('input', (e) => {
                document.getElementById('rainfallDisplay').textContent = e.target.value;
            });
            
            document.getElementById('rainDuration').addEventListener('input', (e) => {
                document.getElementById('durationDisplay').textContent = e.target.value;
            });
            
            document.getElementById('drainageRate').addEventListener('input', (e) => {
                document.getElementById('drainageDisplay').textContent = e.target.value;
            });
            
            document.getElementById('startRainBtn').addEventListener('click', startRainSimulation);
            document.getElementById('pauseRainBtn').addEventListener('click', pauseRainSimulation);
            document.getElementById('stepRainBtn').addEventListener('click', stepRainSimulation);
            document.getElementById('stopRainBtn').addEventListener('click', stopRainSimulation);
            
            // Mobile controls
            const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const pointerLockInfo = document.createElement('div');
            pointerLockInfo.className = 'pointer-lock-info';
            
            if (isMobile) {
                pointerLockInfo.innerHTML = `
                    <h2>üì± Touch Controls</h2>
                    <p>
                        <strong>D-Pad (left)</strong> - Run around<br>
                        <strong>Double-tap ‚Üë</strong> - Toggle flying mode<br>
                        <strong>‚Üë‚Üì Buttons</strong> - Fly up/down<br>
                        <strong>Swipe right side</strong> - Look around<br>
                    </p>
                    <p style="margin-top: 10px; font-size: 13px; opacity: 0.8;">
                        Running speed: 4.2 m/s at 2.8m height
                    </p>
                    <p style="margin-top: 10px; font-size: 12px; opacity: 0.7;">
                        Tap anywhere to dismiss
                    </p>
                `;
                pointerLockInfo.addEventListener('click', () => {
                    pointerLockInfo.classList.add('hidden');
                });
            } else {
                pointerLockInfo.innerHTML = `
                    <h2>üéÆ Minecraft Creative Mode Controls</h2>
                    <p><strong>Click anywhere to enable mouse look</strong></p>
                    <p>
                        <strong>W/A/S/D</strong> - Run forward/left/backward/right<br>
                        <strong>Double-tap Space</strong> - Toggle flying mode<br>
                        <strong>Space/Shift</strong> - Fly up/down<br>
                        <strong>Mouse</strong> - Look around<br>
                        <strong>Escape</strong> - Exit mouse look
                    </p>
                    <p style="margin-top: 10px; font-size: 13px; opacity: 0.8;">
                        Running speed: 4.2 m/s at 2.8m height
                    </p>
                `;
            }
            container.appendChild(pointerLockInfo);
            
            const controlsHint = document.createElement('div');
            controlsHint.className = 'controls-hint hidden';
            if (isMobile) {
                controlsHint.innerHTML = 'Double-tap ‚Üë to toggle flying mode';
            } else {
                controlsHint.innerHTML = 'Press ESC to exit | Double-tap Space to fly';
            }
            container.appendChild(controlsHint);
            
            // Touch controls
            const touchControls = document.createElement('div');
            touchControls.className = 'touch-controls';
            touchControls.id = 'touchControls';
            touchControls.innerHTML = `
                <div class="dpad-container">
                    <div class="dpad">
                        <div class="dpad-btn" id="dpad-up">W</div>
                        <div class="dpad-btn" id="dpad-down">S</div>
                        <div class="dpad-btn" id="dpad-left">A</div>
                        <div class="dpad-btn" id="dpad-right">D</div>
                    </div>
                </div>
                <div class="vertical-controls">
                    <div class="vertical-btn" id="btn-up">‚Üë</div>
                    <div class="vertical-btn" id="btn-down">‚Üì</div>
                </div>
            `;
            container.appendChild(touchControls);
            
            const lookZone = document.createElement('div');
            lookZone.className = 'look-zone';
            container.appendChild(lookZone);
            
            const lookHint = document.createElement('div');
            lookHint.className = 'look-hint show';
            lookHint.textContent = 'Swipe to look around';
            lookZone.appendChild(lookHint);
            
            setTimeout(() => lookHint.classList.remove('show'), 3000);
            
            // Pointer lock
            function requestPointerLock() {
                if (isMobile) return;
                renderer.domElement.requestPointerLock = 
                    renderer.domElement.requestPointerLock ||
                    renderer.domElement.mozRequestPointerLock ||
                    renderer.domElement.webkitRequestPointerLock;
                renderer.domElement.requestPointerLock();
            }
            
            function exitPointerLock() {
                if (isMobile) return;
                document.exitPointerLock = 
                    document.exitPointerLock ||
                    document.mozExitPointerLock ||
                    document.webkitExitPointerLock;
                document.exitPointerLock();
            }
            
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
                if (isPointerLocked) {
                    pointerLockInfo.classList.add('hidden');
                    controlsHint.classList.remove('hidden');
                } else {
                    controlsHint.classList.add('hidden');
                }
            });
            
            if (!isMobile) {
                renderer.domElement.addEventListener('click', () => {
                    if (!isPointerLocked) requestPointerLock();
                });
            }
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'KeyW': keys.forward = true; break;
                    case 'KeyS': keys.backward = true; break;
                    case 'KeyA': keys.left = true; break;
                    case 'KeyD': keys.right = true; break;
                    case 'Space':
                        const now = performance.now();
                        if (now - lastUpTapTime < doubleTapDelay) {
                            isFlying = !isFlying;
                            updateFlyingModeStatus();
                        }
                        lastUpTapTime = now;
                        keys.up = true;
                        e.preventDefault();
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        keys.down = true;
                        break;
                    case 'Escape':
                        if (isPointerLocked) exitPointerLock();
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyW': keys.forward = false; break;
                    case 'KeyS': keys.backward = false; break;
                    case 'KeyA': keys.left = false; break;
                    case 'KeyD': keys.right = false; break;
                    case 'Space': keys.up = false; break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        keys.down = false;
                        break;
                }
            });
            
            // Mouse look
            if (!isMobile) {
                document.addEventListener('mousemove', (e) => {
                    if (!isPointerLocked) return;
                    
                    const sensitivity = 0.002;
                    yaw -= e.movementX * sensitivity;
                    pitch -= e.movementY * sensitivity;
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                    
                    camera.rotation.y = yaw;
                    camera.rotation.x = pitch;
                });
            }
            
            // Touch controls implementation
            if (isMobile) {
                const dpadUp = document.getElementById('dpad-up');
                const dpadDown = document.getElementById('dpad-down');
                const dpadLeft = document.getElementById('dpad-left');
                const dpadRight = document.getElementById('dpad-right');
                
                function touchStart(key) {
                    return (e) => {
                        e.preventDefault();
                        keys[key] = true;
                    };
                }
                
                function touchEnd(key) {
                    return (e) => {
                        e.preventDefault();
                        keys[key] = false;
                    };
                }
                
                dpadUp.addEventListener('touchstart', touchStart('forward'));
                dpadUp.addEventListener('touchend', touchEnd('forward'));
                dpadDown.addEventListener('touchstart', touchStart('backward'));
                dpadDown.addEventListener('touchend', touchEnd('backward'));
                dpadLeft.addEventListener('touchstart', touchStart('left'));
                dpadLeft.addEventListener('touchend', touchEnd('left'));
                dpadRight.addEventListener('touchstart', touchStart('right'));
                dpadRight.addEventListener('touchend', touchEnd('right'));
                
                const btnUp = document.getElementById('btn-up');
                const btnDown = document.getElementById('btn-down');
                
                let lastUpBtnTap = 0;
                
                btnUp.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.up = true;
                    
                    const now = performance.now();
                    if (now - lastUpBtnTap < doubleTapDelay) {
                        isFlying = !isFlying;
                        updateFlyingModeStatus();
                    }
                    lastUpBtnTap = now;
                });
                
                btnUp.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.up = false;
                });
                
                btnDown.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.down = true;
                });
                
                btnDown.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.down = false;
                });
                
                // Touch look
                let touchStartX = 0;
                let touchStartY = 0;
                
                lookZone.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    pointerLockInfo.classList.add('hidden');
                });
                
                lookZone.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    
                    const deltaX = e.touches[0].clientX - touchStartX;
                    const deltaY = e.touches[0].clientY - touchStartY;
                    
                    const sensitivity = 0.005;
                    yaw -= deltaX * sensitivity;
                    pitch -= deltaY * sensitivity;
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                    
                    camera.rotation.y = yaw;
                    camera.rotation.x = pitch;
                    
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });
            }
            
            // Get terrain height
            function getTerrainHeightAt(x, z) {
                const halfWidth = (width * scale) / 2;
                const halfHeight = (height * scale) / 2;
                
                const gridX = ((x + halfWidth) / (width * scale)) * (width - 1);
                const gridZ = ((z + halfHeight) / (height * scale)) * (height - 1);
                
                const clampedX = Math.max(0, Math.min(width - 2, Math.floor(gridX)));
                const clampedZ = Math.max(0, Math.min(height - 2, Math.floor(gridZ)));
                
                const idx00 = clampedZ * width + clampedX;
                const idx10 = clampedZ * width + (clampedX + 1);
                const idx01 = (clampedZ + 1) * width + clampedX;
                const idx11 = (clampedZ + 1) * width + (clampedX + 1);
                
                const h00 = originalHeightData[idx00] || 0;
                const h10 = originalHeightData[idx10] || 0;
                const h01 = originalHeightData[idx01] || 0;
                const h11 = originalHeightData[idx11] || 0;
                
                const fracX = gridX - clampedX;
                const fracZ = gridZ - clampedZ;
                
                const h0 = h00 * (1 - fracX) + h10 * fracX;
                const h1 = h01 * (1 - fracX) + h11 * fracX;
                const h = h0 * (1 - fracZ) + h1 * fracZ;
                
                return h;
            }
            
            // Movement update
            function updateMovement(delta) {
                if (delta > 0.1) delta = 0.1;
                
                const currentSpeed = isFlying ? flySpeed : walkSpeed;
                
                direction.set(0, 0, 0);
                
                if (keys.forward) direction.z -= 1;
                if (keys.backward) direction.z += 1;
                if (keys.left) direction.x -= 1;
                if (keys.right) direction.x += 1;
                
                if (direction.length() > 0) {
                    direction.normalize();
                }
                
                const rotatedDirection = direction.clone();
                rotatedDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                
                velocity.x = rotatedDirection.x * currentSpeed;
                velocity.z = rotatedDirection.z * currentSpeed;
                
                if (isFlying) {
                    velocity.y = 0;
                    if (keys.up) velocity.y = currentSpeed;
                    if (keys.down) velocity.y = -currentSpeed;
                } else {
                    velocity.y = 0;
                }
                
                camera.position.x += velocity.x;
                camera.position.y += velocity.y;
                camera.position.z += velocity.z;
                
                if (!isFlying) {
                    const groundHeight = getTerrainHeightAt(camera.position.x, camera.position.z);
                    camera.position.y = groundHeight + playerHeight;
                }
                
                const halfWidth = (width * scale) / 2;
                const halfHeight = (height * scale) / 2;
                camera.position.x = Math.max(-halfWidth, Math.min(halfWidth, camera.position.x));
                camera.position.z = Math.max(-halfHeight, Math.min(halfHeight, camera.position.z));
            }
            
            // Cleanup
            window.cleanup3DViewer = () => {
                if (rainAnimationInterval) {
                    clearInterval(rainAnimationInterval);
                }
                geometry.dispose();
                material.dispose();
                if (satelliteTexture) satelliteTexture.dispose();
                renderer.dispose();
            };
            
            // View controls
            function resetView() {
                camera.position.set(0, playerHeight, 0);
                pitch = 0;
                yaw = 0;
                camera.rotation.set(pitch, yaw, 0);
            }
            
            function topView() {
                camera.position.set(0, scale * 150, 0);
                pitch = -Math.PI / 2;
                yaw = 0;
                camera.rotation.set(pitch, yaw, 0);
            }
            
            let autoRotate = false;
            function toggleAutoRotate() {
                autoRotate = !autoRotate;
                const btn = document.getElementById('autoRotateBtn');
                if (btn) btn.classList.toggle('active', autoRotate);
            }
            
            function toggleTexture() {
                if (!satelliteTexture) return;
                
                useTexture = !useTexture;
                const toggleBtn = document.getElementById('toggleTexture');
                
                if (useTexture) {
                    material.map = satelliteTexture;
                    material.vertexColors = false;
                    if (toggleBtn) toggleBtn.classList.add('active');
                } else {
                    material.map = null;
                    material.vertexColors = true;
                    if (toggleBtn) toggleBtn.classList.remove('active');
                }
                material.needsUpdate = true;
            }
            
            function updateVerticalScale(value) {
                const newScale = parseFloat(value);
                document.getElementById('scaleValue').textContent = newScale.toFixed(1);
                
                const vertices = geometry.attributes.position.array;
                for (let i = 0; i < originalHeightData.length; i++) {
                    vertices[i * 3 + 2] = originalHeightData[i] * (newScale / verticalExaggeration);
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
            }
            
            function toggleWireframe(checked) {
                material.wireframe = checked;
            }
            
            function updateFlyingModeStatus() {
                const statusDiv = document.getElementById('flyingModeStatus');
                if (statusDiv) {
                    if (isFlying) {
                        statusDiv.textContent = 'FLYING MODE';
                        statusDiv.style.background = 'rgba(33, 150, 243, 0.7)';
                    } else {
                        statusDiv.textContent = 'RUNNING MODE';
                        statusDiv.style.background = 'rgba(0, 0, 0, 0.3)';
                    }
                }
            }
            
            // Event listeners
            const resetBtn = document.getElementById('resetViewBtn');
            const topBtn = document.getElementById('topViewBtn');
            const autoBtn = document.getElementById('autoRotateBtn');
            const textureBtn = document.getElementById('toggleTexture');
            const scaleSlider = document.getElementById('verticalScale');
            const wireframeCheck = document.getElementById('wireframeToggle');
            
            if (resetBtn) resetBtn.addEventListener('click', resetView);
            if (topBtn) topBtn.addEventListener('click', topView);
            if (autoBtn) autoBtn.addEventListener('click', toggleAutoRotate);
            if (textureBtn) textureBtn.addEventListener('click', toggleTexture);
            if (scaleSlider) scaleSlider.addEventListener('input', (e) => updateVerticalScale(e.target.value));
            if (wireframeCheck) wireframeCheck.addEventListener('change', (e) => toggleWireframe(e.target.checked));
            
            // Animation loop
            let lastTime = performance.now();
            
            function animate() {
                requestAnimationFrame(animate);
                
                const currentTime = performance.now();
                const delta = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                updateMovement(delta);
                
                if (autoRotate && !Object.values(keys).some(v => v)) {
                    yaw += 0.01;
                    camera.rotation.y = yaw;
                }
                
                // Update rain particles
                if (rainSimulation.active && rainSimulation.particles && rainSimulation.particles.visible) {
                    updateRainParticles(delta);
                }
                
                renderer.render(scene, camera);
            }
            
            animate();
            updateMovement(0);
            
            // Handle resize
            const resizeHandler = () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            };
            window.addEventListener('resize', resizeHandler);
            
            modal.classList.add('show');
        }

        // Open 3D viewer
        function open3DViewer() {
            if (currentElevationData) {
                create3DTerrain(
                    currentElevationData.elevationData,
                    currentElevationData.width,
                    currentElevationData.height,
                    currentElevationData.bottomLeft,
                    currentElevationData.topRight
                );
            } else {
                const modal = document.getElementById('modal3d');
                const container = document.getElementById('viewer3d');
                
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.alignItems = 'center';
                container.style.justifyContent = 'center';
                container.style.color = 'white';
                container.style.fontSize = '18px';
                container.innerHTML = '<div style="text-align: center;"><p>üìÇ Click "Load Data" to import a terrain file</p><p style="margin-top: 10px; font-size: 14px; color: #aaa;">or use "Select Area" on the map to fetch elevation data</p></div>';
                
                modal.classList.add('show');
            }
        }

        // Toggle rain panel
        function toggleRainPanel() {
            const panel = document.getElementById('rainPanel');
            panel.classList.toggle('show');
        }

        // Event listeners
        document.getElementById('locationBtn').addEventListener('click', getUserLocation);
        document.getElementById('contoursBtn').addEventListener('click', toggleContours);
        document.getElementById('satelliteBtn').addEventListener('click', toggleSatellite);
        document.getElementById('selectAreaBtn').addEventListener('click', toggleAreaSelection);
        document.getElementById('open3DViewerBtn').addEventListener('click', open3DViewer);
        document.getElementById('rainSimBtn').addEventListener('click', toggleRainPanel);
        document.getElementById('closeModal').addEventListener('click', () => {
            document.getElementById('modal3d').classList.remove('show');
            document.getElementById('rainPanel').classList.remove('show');
            document.getElementById('rainStats').classList.remove('show');
            if (window.cleanup3DViewer) {
                window.cleanup3DViewer();
            }
        });
        document.getElementById('saveDataBtn').addEventListener('click', saveTerrainData);
        document.getElementById('saveDataBtn3D').addEventListener('click', saveTerrainData);
        document.getElementById('loadDataBtn').addEventListener('click', () => {
            debug('Load button clicked (main)');
            document.getElementById('fileInput').click();
        });
        document.getElementById('loadDataBtn3D').addEventListener('click', () => {
            debug('Load button clicked (3D viewer)');
            document.getElementById('fileInput').click();
        });
        document.getElementById('fileInput').addEventListener('change', (e) => {
            debug('File input changed, files: ' + e.target.files.length);
            if (e.target.files.length > 0) {
                debug('Loading file: ' + e.target.files[0].name);
                loadTerrainData(e.target.files[0]);
                // Reset file input so the same file can be loaded again
                e.target.value = '';
            }
        });

        // Popup for location
        const popup = new ol.Overlay({
            element: document.createElement('div'),
            positioning: 'bottom-center',
            stopEvent: false,
            offset: [0, -10]
        });
        map.addOverlay(popup);

        map.on('click', (evt) => {
            if (isSelecting) return;
            
            const feature = map.forEachFeatureAtPixel(evt.pixel, (feature) => feature);
            
            if (feature && feature.get('name') === 'Your Location') {
                const coordinates = feature.getGeometry().getCoordinates();
                const lonLat = ol.proj.toLonLat(coordinates);
                
                const popupElement = popup.getElement();
                popupElement.innerHTML = `
                    <div style="background: white; padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); font-size: 13px;">
                        <strong>Your Location</strong><br>
                        <span style="color: #666;">
                            Lat: ${lonLat[1].toFixed(6)}<br>
                            Lon: ${lonLat[0].toFixed(6)}
                        </span>
                    </div>
                `;
                popup.setPosition(coordinates);
            } else {
                popup.setPosition(undefined);
            }
        });

        map.on('pointermove', (evt) => {
            if (isSelecting) {
                map.getTarget().style.cursor = 'crosshair';
                return;
            }
            
            const pixel = map.getEventPixel(evt.originalEvent);
            const hit = map.hasFeatureAtPixel(pixel);
            map.getTarget().style.cursor = hit ? 'pointer' : '';
        });
    </script>
</body>
</html>
