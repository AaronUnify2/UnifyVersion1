<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map with 3D Terrain Generator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.2.1/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v10.2.1/dist/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 15px;
            z-index: 1000;
        }

        .control-btn {
            display: block;
            width: 100%;
            padding: 12px 20px;
            margin-bottom: 10px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            color: #333;
            touch-action: manipulation;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .control-btn {
                padding: 14px 22px;
                font-size: 16px;
            }
        }

        .control-btn:last-child {
            margin-bottom: 0;
        }

        .control-btn:hover {
            background: #f5f5f5;
            border-color: #2196F3;
        }

        .control-btn.active {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Toast notification */
        .toast {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 2000;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 12px 15px;
            font-size: 12px;
            z-index: 1000;
            max-width: 200px;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            color: #666;
        }

        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 8px;
            background: #8B4513;
        }

        /* 3D Viewer Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            width: 90%;
            height: 90%;
            background: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            background: #2a2a2a;
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .modal-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .modal-title {
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            min-width: 80px;
            touch-action: manipulation;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .modal-close {
                padding: 12px 20px;
                font-size: 16px;
                min-width: 100px;
            }
        }

        .modal-close:hover {
            background: #ff6666;
        }

        .modal-close[style*="4CAF50"]:hover {
            background: #66BB6A !important;
        }

        .modal-close[style*="2196F3"]:hover {
            background: #42A5F5 !important;
        }

        .modal-close[style*="666"]:hover {
            background: #888 !important;
        }

        /* Toolbar controls */
        .toolbar-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .toolbar-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .toolbar-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .toolbar-btn.active {
            background: #2196F3;
            border-color: #2196F3;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            font-size: 13px;
        }

        .slider-container input[type="range"] {
            width: 120px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            width: 14px;
            height: 14px;
            background: #2196F3;
            border-radius: 50%;
            cursor: pointer;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 13px;
        }

        #viewer3d {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        /* Flying mode status */
        .flying-mode-status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            z-index: 100;
            transition: background 0.3s ease;
        }

        /* Rain Simulation Panel */
        .rain-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            color: white;
            z-index: 200;
            min-width: 320px;
            max-width: 400px;
            display: none;
            backdrop-filter: blur(10px);
        }

        .rain-panel.show {
            display: block;
        }

        .rain-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        .rain-panel-title {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rain-close-btn {
            background: rgba(255, 68, 68, 0.8);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .rain-close-btn:hover {
            background: rgba(255, 102, 102, 0.9);
        }

        .rain-control-group {
            margin-bottom: 20px;
        }

        .rain-control-label {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 8px;
            display: block;
            color: rgba(255, 255, 255, 0.9);
        }

        .rain-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .rain-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 14px;
        }

        .rain-input:focus {
            outline: none;
            border-color: #2196F3;
            background: rgba(255, 255, 255, 0.15);
        }

        .rain-unit {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
            min-width: 60px;
        }

        .rain-slider {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            margin-top: 8px;
        }

        .rain-slider::-webkit-slider-thumb {
            width: 18px;
            height: 18px;
            background: #2196F3;
            border-radius: 50%;
            cursor: pointer;
        }

        .rain-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #2196F3;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .rain-value-display {
            text-align: right;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 4px;
        }

        .rain-btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        .rain-btn {
            background: rgba(33, 150, 243, 0.8);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .rain-btn:hover {
            background: rgba(33, 150, 243, 1);
            transform: translateY(-1px);
        }

        .rain-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .rain-btn.danger {
            background: rgba(244, 67, 54, 0.8);
        }

        .rain-btn.danger:hover {
            background: rgba(244, 67, 54, 1);
        }

        .rain-btn.success {
            background: rgba(76, 175, 80, 0.8);
        }

        .rain-btn.success:hover {
            background: rgba(76, 175, 80, 1);
        }

        .rain-btn.warning {
            background: rgba(255, 152, 0, 0.8);
        }

        .rain-btn.warning:hover {
            background: rgba(255, 152, 0, 1);
        }

        /* Rain Stats Display */
        .rain-stats {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .rain-stats.show {
            display: block;
        }

        .rain-stats-title {
            font-size: 12px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .rain-stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .rain-stat-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .rain-stat-value {
            color: white;
            font-weight: 500;
        }

        .rain-stat-value.highlight {
            color: #2196F3;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- Control Panel -->
    <div class="control-panel">
        <button id="locationBtn" class="control-btn">üìç My Location</button>
        <button id="satelliteBtn" class="control-btn">üõ∞Ô∏è Satellite</button>
        <button id="contoursBtn" class="control-btn">üìè Contours</button>
        <button id="selectAreaBtn" class="control-btn">üî≤ Select Area</button>
        <button id="open3DViewerBtn" class="control-btn">üèîÔ∏è 3D Viewer</button>
        <button id="saveDataBtn" class="control-btn">üíæ Save Data</button>
        <button id="loadDataBtn" class="control-btn">üìÇ Load Data</button>
    </div>

    <!-- Legend -->
    <div class="legend">
        <div class="legend-title">Elevation Contours</div>
        <div class="legend-item">
            <div class="legend-line"></div>
            <span>10m intervals</span>
        </div>
    </div>

    <!-- Toast notification -->
    <div id="toast" class="toast"></div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept=".json" style="display: none;">

    <!-- 3D Viewer Modal -->
    <div id="modal3d" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-header-row">
                    <h2 class="modal-title">üèîÔ∏è 3D Terrain Viewer</h2>
                    <button id="closeModal" class="modal-close">‚úï Close</button>
                </div>
                <div class="toolbar-controls">
                    <button id="resetViewBtn" class="toolbar-btn">üîÑ Reset View</button>
                    <button id="topViewBtn" class="toolbar-btn">‚¨áÔ∏è Top View</button>
                    <button id="autoRotateBtn" class="toolbar-btn">üîÑ Auto-Rotate</button>
                    <button id="toggleTexture" class="toolbar-btn">üõ∞Ô∏è Satellite</button>
                    <button id="rainSimBtn" class="toolbar-btn">üåßÔ∏è Rain Simulation</button>
                    <div class="slider-container">
                        <label>Height: <span id="scaleValue">3.0</span>x</label>
                        <input type="range" id="verticalScale" min="0.5" max="10" step="0.1" value="3">
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="wireframeToggle">
                        <label>Wireframe</label>
                    </div>
                    <button id="saveDataBtn3D" class="toolbar-btn" style="background: rgba(76, 175, 80, 0.3); border-color: rgba(76, 175, 80, 0.5);">üíæ Save</button>
                    <button id="loadDataBtn3D" class="toolbar-btn" style="background: rgba(33, 150, 243, 0.3); border-color: rgba(33, 150, 243, 0.5);">üìÇ Load</button>
                </div>
            </div>
            <div id="viewer3d"></div>
        </div>
    </div>

    <script>
        // Initialize map
        const map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM()
                })
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([0, 0]),
                zoom: 2
            })
        });

        let userMarker = null;
        let contourLayer = null;
        let satelliteLayer = null;
        let isSelecting = false;
        let selectionBox = null;
        let selectionLayer = null;
        let currentElevationData = null;

        // Show toast notification
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        // Get user location
        function getUserLocation() {
            if (!navigator.geolocation) {
                showToast('Geolocation is not supported by your browser');
                return;
            }

            showToast('Getting your location...');
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const coords = [position.coords.longitude, position.coords.latitude];
                    const webMercator = ol.proj.fromLonLat(coords);
                    
                    map.getView().animate({
                        center: webMercator,
                        zoom: 14,
                        duration: 1000
                    });

                    if (userMarker) {
                        map.removeLayer(userMarker);
                    }

                    userMarker = new ol.layer.Vector({
                        source: new ol.source.Vector({
                            features: [
                                new ol.Feature({
                                    geometry: new ol.geom.Point(webMercator),
                                    name: 'Your Location'
                                })
                            ]
                        }),
                        style: new ol.style.Style({
                            image: new ol.style.Circle({
                                radius: 8,
                                fill: new ol.style.Fill({ color: '#2196F3' }),
                                stroke: new ol.style.Stroke({ color: 'white', width: 3 })
                            })
                        })
                    });

                    map.addLayer(userMarker);
                    showToast('üìç Location found!');
                },
                (error) => {
                    showToast('Unable to get location: ' + error.message);
                }
            );
        }

        // Toggle contours
        function toggleContours() {
            const btn = document.getElementById('contoursBtn');
            
            if (contourLayer) {
                map.removeLayer(contourLayer);
                contourLayer = null;
                btn.classList.remove('active');
                showToast('Contours hidden');
            } else {
                const extent = map.getView().calculateExtent(map.getSize());
                const bottomLeft = ol.proj.toLonLat([extent[0], extent[1]]);
                const topRight = ol.proj.toLonLat([extent[2], extent[3]]);
                
                fetchElevationData(bottomLeft, topRight, 100, 100, true);
                btn.classList.add('active');
            }
        }

        // Toggle satellite view
        function toggleSatellite() {
            const btn = document.getElementById('satelliteBtn');
            
            if (satelliteLayer) {
                map.removeLayer(satelliteLayer);
                satelliteLayer = null;
                btn.classList.remove('active');
                showToast('Satellite view disabled');
            } else {
                satelliteLayer = new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                        maxZoom: 19
                    }),
                    opacity: 0.7
                });
                map.addLayer(satelliteLayer);
                btn.classList.add('active');
                showToast('Satellite view enabled');
            }
        }

        // Area selection functionality
        function toggleAreaSelection() {
            const btn = document.getElementById('selectAreaBtn');
            isSelecting = !isSelecting;
            
            if (isSelecting) {
                btn.classList.add('active');
                showToast('Click and drag to select an area');
                map.getTarget().style.cursor = 'crosshair';
            } else {
                btn.classList.remove('active');
                map.getTarget().style.cursor = '';
                if (selectionLayer) {
                    map.removeLayer(selectionLayer);
                    selectionLayer = null;
                }
            }
        }

        let startCoord = null;
        map.on('pointerdown', (evt) => {
            if (!isSelecting) return;
            startCoord = evt.coordinate;
        });

        map.on('pointermove', (evt) => {
            if (!isSelecting || !startCoord) return;
            
            if (selectionLayer) {
                map.removeLayer(selectionLayer);
            }
            
            const extent = [
                Math.min(startCoord[0], evt.coordinate[0]),
                Math.min(startCoord[1], evt.coordinate[1]),
                Math.max(startCoord[0], evt.coordinate[0]),
                Math.max(startCoord[1], evt.coordinate[1])
            ];
            
            selectionLayer = new ol.layer.Vector({
                source: new ol.source.Vector({
                    features: [new ol.Feature(new ol.geom.Polygon([[
                        [extent[0], extent[1]],
                        [extent[0], extent[3]],
                        [extent[2], extent[3]],
                        [extent[2], extent[1]],
                        [extent[0], extent[1]]
                    ]]))]
                }),
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({ color: '#2196F3', width: 3 }),
                    fill: new ol.style.Fill({ color: 'rgba(33, 150, 243, 0.1)' })
                })
            });
            
            map.addLayer(selectionLayer);
        });

        map.on('pointerup', (evt) => {
            if (!isSelecting || !startCoord) return;
            
            const extent = [
                Math.min(startCoord[0], evt.coordinate[0]),
                Math.min(startCoord[1], evt.coordinate[1]),
                Math.max(startCoord[0], evt.coordinate[0]),
                Math.max(startCoord[1], evt.coordinate[1])
            ];
            
            const bottomLeft = ol.proj.toLonLat([extent[0], extent[1]]);
            const topRight = ol.proj.toLonLat([extent[2], extent[3]]);
            
            startCoord = null;
            isSelecting = false;
            document.getElementById('selectAreaBtn').classList.remove('active');
            map.getTarget().style.cursor = '';
            
            showToast('Fetching elevation data...');
            fetchElevationData(bottomLeft, topRight, 200, 200, false);
        });

        // Fetch elevation data
        async function fetchElevationData(bottomLeft, topRight, width, height, contoursOnly = false) {
            try {
                const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        locations: generateGrid(bottomLeft, topRight, width, height)
                    })
                });

                const data = await response.json();
                const elevationData = data.results.map(r => r.elevation);
                
                if (contoursOnly) {
                    drawContours(elevationData, width, height, bottomLeft, topRight);
                } else {
                    currentElevationData = {
                        elevationData,
                        width,
                        height,
                        bottomLeft,
                        topRight
                    };
                    showToast('‚úÖ Elevation data loaded! Open 3D Viewer to see terrain');
                    if (selectionLayer) {
                        map.removeLayer(selectionLayer);
                        selectionLayer = null;
                    }
                }
            } catch (error) {
                showToast('Error fetching elevation data: ' + error.message);
            }
        }

        function generateGrid(bottomLeft, topRight, width, height) {
            const locations = [];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const lat = bottomLeft[1] + (topRight[1] - bottomLeft[1]) * (y / (height - 1));
                    const lon = bottomLeft[0] + (topRight[0] - bottomLeft[0]) * (x / (width - 1));
                    locations.push({ latitude: lat, longitude: lon });
                }
            }
            return locations;
        }

        function drawContours(elevationData, width, height, bottomLeft, topRight) {
            if (contourLayer) {
                map.removeLayer(contourLayer);
            }

            const features = [];
            const interval = 10;
            const minElev = Math.min(...elevationData);
            const maxElev = Math.max(...elevationData);

            for (let elevation = Math.ceil(minElev / interval) * interval; elevation <= maxElev; elevation += interval) {
                const contourPoints = [];
                
                for (let y = 0; y < height - 1; y++) {
                    for (let x = 0; x < width - 1; x++) {
                        const idx = y * width + x;
                        const e1 = elevationData[idx];
                        const e2 = elevationData[idx + 1];
                        const e3 = elevationData[idx + width];
                        
                        if ((e1 <= elevation && e2 >= elevation) || (e1 >= elevation && e2 <= elevation)) {
                            const t = (elevation - e1) / (e2 - e1);
                            const lon = bottomLeft[0] + (topRight[0] - bottomLeft[0]) * ((x + t) / (width - 1));
                            const lat = bottomLeft[1] + (topRight[1] - bottomLeft[1]) * (y / (height - 1));
                            contourPoints.push(ol.proj.fromLonLat([lon, lat]));
                        }
                        
                        if ((e1 <= elevation && e3 >= elevation) || (e1 >= elevation && e3 <= elevation)) {
                            const t = (elevation - e1) / (e3 - e1);
                            const lon = bottomLeft[0] + (topRight[0] - bottomLeft[0]) * (x / (width - 1));
                            const lat = bottomLeft[1] + (topRight[1] - bottomLeft[1]) * ((y + t) / (height - 1));
                            contourPoints.push(ol.proj.fromLonLat([lon, lat]));
                        }
                    }
                }

                if (contourPoints.length > 1) {
                    features.push(new ol.Feature({
                        geometry: new ol.geom.LineString(contourPoints),
                        elevation: elevation
                    }));
                }
            }

            contourLayer = new ol.layer.Vector({
                source: new ol.source.Vector({ features }),
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#8B4513',
                        width: 1.5
                    })
                })
            });

            map.addLayer(contourLayer);
            showToast('Contours displayed');
        }

        // Save terrain data
        function saveTerrainData() {
            if (!currentElevationData) {
                showToast('No terrain data to save. Select an area first.');
                return;
            }

            const dataStr = JSON.stringify(currentElevationData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `terrain_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('üíæ Terrain data saved!');
        }

        // Load terrain data
        function loadTerrainData(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    currentElevationData = data;
                    
                    const center = [
                        (data.bottomLeft[0] + data.topRight[0]) / 2,
                        (data.bottomLeft[1] + data.topRight[1]) / 2
                    ];
                    
                    map.getView().animate({
                        center: ol.proj.fromLonLat(center),
                        zoom: 14,
                        duration: 1000
                    });
                    
                    showToast('‚úÖ Terrain data loaded!');
                    
                    const modal = document.getElementById('modal3d');
                    if (modal.classList.contains('show')) {
                        create3DTerrain(data.elevationData, data.width, data.height, data.bottomLeft, data.topRight);
                    }
                } catch (error) {
                    showToast('Error loading file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // 3D Terrain Creation
        function create3DTerrain(elevationData, width, height, bottomLeft, topRight) {
            const modal = document.getElementById('modal3d');
            const container = document.getElementById('viewer3d');
            
            container.innerHTML = '';
            container.style.display = 'block';

            function debug(msg) {
                console.log('[3D Viewer]', msg);
            }

            debug('Initializing 3D viewer...');
            debug('Data dimensions: ' + width + 'x' + height);

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 3000);

            const camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                10000
            );

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 0.5);
            scene.add(directionalLight);

            // Calculate terrain dimensions
            const latDiff = topRight[1] - bottomLeft[1];
            const lonDiff = topRight[0] - bottomLeft[0];
            const avgLat = (bottomLeft[1] + topRight[1]) / 2;
            
            const latMeters = latDiff * 111320;
            const lonMeters = lonDiff * 111320 * Math.cos(avgLat * Math.PI / 180);
            
            const maxDim = Math.max(latMeters, lonMeters);
            const scale = 100 / maxDim;

            const terrainWidth = lonMeters * scale;
            const terrainHeight = latMeters * scale;

            debug('Terrain size: ' + terrainWidth.toFixed(2) + ' x ' + terrainHeight.toFixed(2));

            // Create geometry
            const geometry = new THREE.PlaneGeometry(
                terrainWidth,
                terrainHeight,
                width - 1,
                height - 1
            );

            const minElev = Math.min(...elevationData);
            const maxElev = Math.max(...elevationData);
            const elevRange = maxElev - minElev;
            
            const verticalExaggeration = 3.0;
            const originalHeightData = [];

            const vertices = geometry.attributes.position.array;
            const colors = new Float32Array(vertices.length);

            for (let i = 0; i < elevationData.length; i++) {
                const elevation = elevationData[i];
                const heightValue = ((elevation - minElev) / elevRange) * elevRange * scale * verticalExaggeration;
                originalHeightData.push(heightValue);
                vertices[i * 3 + 2] = heightValue;

                const t = (elevation - minElev) / elevRange;
                let r, g, b;
                
                if (t < 0.3) {
                    r = 0.13 + t * 0.5;
                    g = 0.55 + t * 0.3;
                    b = 0.13 + t * 0.2;
                } else if (t < 0.6) {
                    const t2 = (t - 0.3) / 0.3;
                    r = 0.28 + t2 * 0.3;
                    g = 0.64 + t2 * 0.2;
                    b = 0.19 + t2 * 0.1;
                } else if (t < 0.8) {
                    const t2 = (t - 0.6) / 0.2;
                    r = 0.58 + t2 * 0.2;
                    g = 0.84 - t2 * 0.3;
                    b = 0.29 - t2 * 0.1;
                } else {
                    const t2 = (t - 0.8) / 0.2;
                    r = 0.78 + t2 * 0.22;
                    g = 0.54 + t2 * 0.46;
                    b = 0.19 + t2 * 0.81;
                }

                colors[i * 3] = r;
                colors[i * 3 + 1] = g;
                colors[i * 3 + 2] = b;
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();

            // Material
            let satelliteTexture = null;
            let useTexture = false;

            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: false,
                shininess: 5
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            scene.add(mesh);

            // Load satellite texture
            const tileSize = 256;
            const zoom = Math.floor(Math.log2(360 / lonDiff)) + 1;
            const centerLat = (bottomLeft[1] + topRight[1]) / 2;
            const centerLon = (bottomLeft[0] + topRight[0]) / 2;
            
            const x = Math.floor((centerLon + 180) / 360 * Math.pow(2, zoom));
            const y = Math.floor((1 - Math.log(Math.tan(centerLat * Math.PI / 180) + 1 / Math.cos(centerLat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
            
            const textureUrl = `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoom}/${y}/${x}`;
            
            new THREE.TextureLoader().load(
                textureUrl,
                (texture) => {
                    satelliteTexture = texture;
                    debug('Satellite texture loaded');
                },
                undefined,
                (error) => {
                    debug('Texture load failed: ' + error);
                }
            );

            // Camera position
            const avgHeight = originalHeightData.reduce((a, b) => a + b, 0) / originalHeightData.length;
            camera.position.set(terrainWidth * 0.8, avgHeight + scale * 100, terrainHeight * 0.8);
            
            let pitch = -0.3;
            let yaw = -Math.PI / 4;
            camera.rotation.order = 'YXZ';
            camera.rotation.set(pitch, yaw, 0);

            // Movement controls
            const keys = { w: false, a: false, s: false, d: false, q: false, e: false, shift: false, space: false };
            const moveSpeed = 50;
            const mouseSensitivity = 0.002;
            let isFlying = false;

            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (key in keys) {
                    keys[key] = true;
                    e.preventDefault();
                }
                if (key === 'f') {
                    isFlying = !isFlying;
                    updateFlyingModeStatus();
                }
            });

            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (key in keys) keys[key] = false;
            });

            let isMouseDown = false;
            renderer.domElement.addEventListener('mousedown', () => isMouseDown = true);
            window.addEventListener('mouseup', () => isMouseDown = false);

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;

                yaw -= e.movementX * mouseSensitivity;
                pitch -= e.movementY * mouseSensitivity;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

                camera.rotation.set(pitch, yaw, 0);
            });

            function getTerrainHeight(x, y) {
                const gridX = ((x + terrainWidth / 2) / terrainWidth) * (width - 1);
                const gridY = ((y + terrainHeight / 2) / terrainHeight) * (height - 1);

                const x0 = Math.floor(gridX);
                const y0 = Math.floor(gridY);
                const x1 = Math.min(x0 + 1, width - 1);
                const y1 = Math.min(y0 + 1, height - 1);

                if (x0 < 0 || y0 < 0 || x1 >= width || y1 >= height) {
                    return 0;
                }

                const fx = gridX - x0;
                const fy = gridY - y0;

                const h00 = originalHeightData[y0 * width + x0];
                const h10 = originalHeightData[y0 * width + x1];
                const h01 = originalHeightData[y1 * width + x0];
                const h11 = originalHeightData[y1 * width + x1];

                const h0 = h00 * (1 - fx) + h10 * fx;
                const h1 = h01 * (1 - fx) + h11 * fx;

                return h0 * (1 - fy) + h1 * fy;
            }

            function updateMovement(delta) {
                const forward = new THREE.Vector3(
                    -Math.sin(yaw),
                    0,
                    -Math.cos(yaw)
                ).normalize();

                const right = new THREE.Vector3(
                    Math.cos(yaw),
                    0,
                    -Math.sin(yaw)
                ).normalize();

                const speedMultiplier = keys.shift ? 3 : 1;
                const speed = moveSpeed * delta * speedMultiplier;

                if (keys.w) camera.position.addScaledVector(forward, speed);
                if (keys.s) camera.position.addScaledVector(forward, -speed);
                if (keys.a) camera.position.addScaledVector(right, -speed);
                if (keys.d) camera.position.addScaledVector(right, speed);

                if (isFlying) {
                    if (keys.space) camera.position.y += speed;
                    if (keys.q) camera.position.y -= speed;
                } else {
                    const terrainHeight = getTerrainHeight(camera.position.x, camera.position.z);
                    const playerHeight = scale * 5;
                    camera.position.y = terrainHeight + playerHeight;
                }
            }

            // Flying mode status display
            const flyingStatus = document.createElement('div');
            flyingStatus.id = 'flyingModeStatus';
            flyingStatus.className = 'flying-mode-status';
            flyingStatus.textContent = 'RUNNING MODE';
            container.appendChild(flyingStatus);

            // View controls
            function resetView() {
                camera.position.set(terrainWidth * 0.8, avgHeight + scale * 100, terrainHeight * 0.8);
                pitch = -0.3;
                yaw = -Math.PI / 4;
                camera.rotation.set(pitch, yaw, 0);
                
                const upBtn = document.getElementById('toggleTexture');
                if (upBtn) {
                    upBtn.style.background = 'rgba(255, 255, 255, 0.4)';
                    upBtn.style.borderColor = 'rgba(255, 255, 255, 0.6)';
                }
                
                debug('View reset');
            }
            
            function topView() {
                camera.position.set(0, scale * 150, 0);
                pitch = -Math.PI / 2;
                yaw = 0;
                camera.rotation.set(pitch, yaw, 0);
                debug('Top view');
            }
            
            let autoRotate = false;
            function toggleAutoRotate() {
                autoRotate = !autoRotate;
                const btn = document.getElementById('autoRotateBtn');
                if (btn) btn.classList.toggle('active', autoRotate);
                debug('Auto-rotate: ' + (autoRotate ? 'ON' : 'OFF'));
            }
            
            function toggleTexture() {
                if (!satelliteTexture) return;
                
                useTexture = !useTexture;
                const toggleBtn = document.getElementById('toggleTexture');
                
                if (useTexture) {
                    material.map = satelliteTexture;
                    material.vertexColors = false;
                    if (toggleBtn) toggleBtn.classList.add('active');
                    debug('Satellite texture ON');
                } else {
                    material.map = null;
                    material.vertexColors = true;
                    if (toggleBtn) toggleBtn.classList.remove('active');
                    debug('Satellite texture OFF');
                }
                material.needsUpdate = true;
            }
            
            function updateVerticalScale(value) {
                const newScale = parseFloat(value);
                document.getElementById('scaleValue').textContent = newScale.toFixed(1);
                
                const vertices = geometry.attributes.position.array;
                for (let i = 0; i < originalHeightData.length; i++) {
                    vertices[i * 3 + 2] = originalHeightData[i] * (newScale / verticalExaggeration);
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
            }
            
            function toggleWireframe(checked) {
                material.wireframe = checked;
            }
            
            function updateFlyingModeStatus() {
                const statusDiv = document.getElementById('flyingModeStatus');
                if (statusDiv) {
                    if (isFlying) {
                        statusDiv.textContent = 'FLYING MODE';
                        statusDiv.style.background = 'rgba(33, 150, 243, 0.7)';
                    } else {
                        statusDiv.textContent = 'RUNNING MODE';
                        statusDiv.style.background = 'rgba(0, 0, 0, 0.3)';
                    }
                }
            }

            // ============================================
            // RAIN SIMULATION SYSTEM
            // ============================================
            
            let rainSimulation = null;
            
            function initRainSimulation() {
                // Rain simulation panel
                let rainPanel = document.querySelector('.rain-panel');
                if (!rainPanel) {
                    rainPanel = document.createElement('div');
                    rainPanel.className = 'rain-panel';
                    rainPanel.innerHTML = `
                        <div class="rain-panel-header">
                            <div class="rain-panel-title">üåßÔ∏è Rain Simulation</div>
                            <button class="rain-close-btn" onclick="closeRainPanel()">‚úï</button>
                        </div>
                        
                        <div class="rain-control-group">
                            <label class="rain-control-label">Rainfall Amount</label>
                            <div class="rain-input-group">
                                <input type="number" id="rainfallAmount" class="rain-input" value="100" min="1" max="500">
                                <span class="rain-unit">mm</span>
                            </div>
                            <input type="range" id="rainfallSlider" class="rain-slider" min="1" max="500" value="100">
                            <div class="rain-value-display">1mm rain over 1m¬≤ = 1 liter</div>
                        </div>
                        
                        <div class="rain-control-group">
                            <label class="rain-control-label">Duration</label>
                            <div class="rain-input-group">
                                <input type="number" id="rainDuration" class="rain-input" value="6" min="1" max="48">
                                <span class="rain-unit">hours</span>
                            </div>
                            <input type="range" id="durationSlider" class="rain-slider" min="1" max="48" value="6">
                        </div>
                        
                        <div class="rain-control-group">
                            <label class="rain-control-label">Soil Drainage Rate</label>
                            <div class="rain-input-group">
                                <input type="number" id="drainageRate" class="rain-input" value="30" min="0" max="100">
                                <span class="rain-unit">%</span>
                            </div>
                            <input type="range" id="drainageSlider" class="rain-slider" min="0" max="100" value="30">
                            <div class="rain-value-display">How fast water soaks into ground</div>
                        </div>
                        
                        <div class="rain-btn-group">
                            <button class="rain-btn success" onclick="startRainSimulation()">üåßÔ∏è Start</button>
                            <button class="rain-btn warning" id="pauseRainBtn" onclick="togglePauseRain()" disabled>‚è∏Ô∏è Pause</button>
                            <button class="rain-btn" id="stepRainBtn" onclick="stepRainForward()" disabled>‚è≠Ô∏è Step</button>
                            <button class="rain-btn danger" id="stopRainBtn" onclick="stopRainSimulation()" disabled>‚èπÔ∏è Stop & Clear</button>
                        </div>
                        
                        <div class="rain-stats" id="rainStats">
                            <div class="rain-stats-title">üìä Simulation Stats</div>
                            <div class="rain-stat-row">
                                <span class="rain-stat-label">Progress:</span>
                                <span class="rain-stat-value" id="rainProgress">0 / 0 hours</span>
                            </div>
                            <div class="rain-stat-row">
                                <span class="rain-stat-label">Total Water:</span>
                                <span class="rain-stat-value highlight" id="totalWater">0 ML</span>
                            </div>
                            <div class="rain-stat-row">
                                <span class="rain-stat-label">Max Depth:</span>
                                <span class="rain-stat-value" id="maxDepth">0 m</span>
                            </div>
                            <div class="rain-stat-row">
                                <span class="rain-stat-label">Avg Saturation:</span>
                                <span class="rain-stat-value" id="avgSaturation">0%</span>
                            </div>
                        </div>
                    `;
                    container.appendChild(rainPanel);
                    
                    // Link sliders and inputs
                    const rainfallInput = document.getElementById('rainfallAmount');
                    const rainfallSlider = document.getElementById('rainfallSlider');
                    const durationInput = document.getElementById('rainDuration');
                    const durationSlider = document.getElementById('durationSlider');
                    const drainageInput = document.getElementById('drainageRate');
                    const drainageSlider = document.getElementById('drainageSlider');
                    
                    rainfallInput.addEventListener('input', (e) => rainfallSlider.value = e.target.value);
                    rainfallSlider.addEventListener('input', (e) => rainfallInput.value = e.target.value);
                    durationInput.addEventListener('input', (e) => durationSlider.value = e.target.value);
                    durationSlider.addEventListener('input', (e) => durationInput.value = e.target.value);
                    drainageInput.addEventListener('input', (e) => drainageSlider.value = e.target.value);
                    drainageSlider.addEventListener('input', (e) => drainageInput.value = e.target.value);
                }
                
                rainPanel.classList.add('show');
                
                // Initialize rain simulation object
                if (!rainSimulation) {
                    rainSimulation = {
                        active: false,
                        paused: false,
                        currentHour: 0,
                        totalHours: 0,
                        rainfallMM: 0,
                        drainageRate: 0,
                        waterDepth: new Float32Array(width * height),
                        soilSaturation: new Float32Array(width * height),
                        waterMesh: null,
                        rainParticles: null,
                        animationTimeout: null
                    };
                    
                    // Create water mesh
                    const waterGeometry = new THREE.PlaneGeometry(
                        terrainWidth,
                        terrainHeight,
                        width - 1,
                        height - 1
                    );
                    
                    const waterMaterial = new THREE.MeshPhongMaterial({
                        color: 0x2196F3,
                        transparent: true,
                        opacity: 0.6,
                        side: THREE.DoubleSide,
                        flatShading: false
                    });
                    
                    rainSimulation.waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
                    rainSimulation.waterMesh.rotation.x = -Math.PI / 2;
                    rainSimulation.waterMesh.visible = false;
                    scene.add(rainSimulation.waterMesh);
                    
                    // Create rain particles
                    const particleCount = 5000;
                    const particleGeometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(particleCount * 3);
                    const velocities = new Float32Array(particleCount);
                    
                    for (let i = 0; i < particleCount; i++) {
                        positions[i * 3] = (Math.random() - 0.5) * terrainWidth * 2;
                        positions[i * 3 + 1] = Math.random() * 200 + 50;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * terrainHeight * 2;
                        velocities[i] = Math.random() * 2 + 3;
                    }
                    
                    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    particleGeometry.userData.velocities = velocities;
                    
                    const particleMaterial = new THREE.PointsMaterial({
                        color: 0x87CEEB,
                        size: 0.5,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    rainSimulation.rainParticles = new THREE.Points(particleGeometry, particleMaterial);
                    rainSimulation.rainParticles.visible = false;
                    scene.add(rainSimulation.rainParticles);
                }
            }
            
            window.closeRainPanel = function() {
                const rainPanel = document.querySelector('.rain-panel');
                if (rainPanel) rainPanel.classList.remove('show');
            };
            
            window.startRainSimulation = function() {
                const rainfallAmount = parseFloat(document.getElementById('rainfallAmount').value);
                const duration = parseInt(document.getElementById('rainDuration').value);
                const drainage = parseFloat(document.getElementById('drainageRate').value);
                
                // Reset simulation
                rainSimulation.currentHour = 0;
                rainSimulation.totalHours = duration;
                rainSimulation.rainfallMM = rainfallAmount;
                rainSimulation.drainageRate = drainage / 100;
                rainSimulation.active = true;
                rainSimulation.paused = false;
                rainSimulation.waterDepth.fill(0);
                rainSimulation.soilSaturation.fill(0);
                
                // Show visuals
                rainSimulation.waterMesh.visible = true;
                rainSimulation.rainParticles.visible = true;
                document.getElementById('rainStats').classList.add('show');
                
                // Darken sky
                scene.background = new THREE.Color(0x5a6b7a);
                scene.fog.color = new THREE.Color(0x5a6b7a);
                
                // Update buttons
                document.getElementById('pauseRainBtn').disabled = false;
                document.getElementById('stepRainBtn').disabled = false;
                document.getElementById('stopRainBtn').disabled = false;
                
                // Start simulation
                runRainHour();
                
                debug('Rain simulation started: ' + rainfallAmount + 'mm over ' + duration + ' hours');
            };
            
            window.togglePauseRain = function() {
                rainSimulation.paused = !rainSimulation.paused;
                const btn = document.getElementById('pauseRainBtn');
                
                if (rainSimulation.paused) {
                    btn.textContent = '‚ñ∂Ô∏è Resume';
                    if (rainSimulation.animationTimeout) {
                        clearTimeout(rainSimulation.animationTimeout);
                    }
                } else {
                    btn.textContent = '‚è∏Ô∏è Pause';
                    runRainHour();
                }
            };
            
            window.stepRainForward = function() {
                if (!rainSimulation.paused) {
                    rainSimulation.paused = true;
                    document.getElementById('pauseRainBtn').textContent = '‚ñ∂Ô∏è Resume';
                }
                
                simulateRainHour();
                
                if (rainSimulation.currentHour >= rainSimulation.totalHours) {
                    finishRainSimulation();
                }
            };
            
            window.stopRainSimulation = function() {
                rainSimulation.active = false;
                rainSimulation.paused = false;
                
                if (rainSimulation.animationTimeout) {
                    clearTimeout(rainSimulation.animationTimeout);
                }
                
                // Hide visuals
                rainSimulation.waterMesh.visible = false;
                rainSimulation.rainParticles.visible = false;
                document.getElementById('rainStats').classList.remove('show');
                
                // Restore sky
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog.color = new THREE.Color(0x87CEEB);
                
                // Reset buttons
                document.getElementById('pauseRainBtn').disabled = true;
                document.getElementById('pauseRainBtn').textContent = '‚è∏Ô∏è Pause';
                document.getElementById('stepRainBtn').disabled = true;
                document.getElementById('stopRainBtn').disabled = true;
                
                debug('Rain simulation stopped');
            };
            
            function runRainHour() {
                if (!rainSimulation.active || rainSimulation.paused) return;
                
                if (rainSimulation.currentHour >= rainSimulation.totalHours) {
                    finishRainSimulation();
                    return;
                }
                
                simulateRainHour();
                
                rainSimulation.animationTimeout = setTimeout(runRainHour, 2000); // 2 seconds per hour
            }
            
            function simulateRainHour() {
                const mmPerHour = rainSimulation.rainfallMM / rainSimulation.totalHours;
                const metersPerHour = mmPerHour / 1000; // Convert mm to meters
                
                // Add rainfall uniformly
                for (let i = 0; i < rainSimulation.waterDepth.length; i++) {
                    rainSimulation.waterDepth[i] += metersPerHour;
                }
                
                // Run 10 sub-steps for flow simulation
                for (let step = 0; step < 10; step++) {
                    const newWaterDepth = new Float32Array(rainSimulation.waterDepth);
                    
                    // Water flow simulation
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const idx = y * width + x;
                            const currentElevation = originalHeightData[idx] + rainSimulation.waterDepth[idx];
                            
                            // Check neighbors
                            const neighbors = [
                                {idx: idx - 1, x: x - 1, y: y},      // left
                                {idx: idx + 1, x: x + 1, y: y},      // right
                                {idx: idx - width, x: x, y: y - 1},  // up
                                {idx: idx + width, x: x, y: y + 1}   // down
                            ];
                            
                            let totalOutflow = 0;
                            const outflows = [];
                            
                            for (const neighbor of neighbors) {
                                const neighborElevation = originalHeightData[neighbor.idx] + rainSimulation.waterDepth[neighbor.idx];
                                const heightDiff = currentElevation - neighborElevation;
                                
                                if (heightDiff > 0 && rainSimulation.waterDepth[idx] > 0) {
                                    const flowRate = Math.min(
                                        rainSimulation.waterDepth[idx] * 0.1,
                                        heightDiff * 0.5
                                    );
                                    outflows.push({idx: neighbor.idx, flow: flowRate});
                                    totalOutflow += flowRate;
                                }
                            }
                            
                            // Limit outflow to available water
                            if (totalOutflow > rainSimulation.waterDepth[idx]) {
                                const scale = rainSimulation.waterDepth[idx] / totalOutflow;
                                for (const outflow of outflows) {
                                    outflow.flow *= scale;
                                }
                                totalOutflow = rainSimulation.waterDepth[idx];
                            }
                            
                            // Apply outflows
                            newWaterDepth[idx] -= totalOutflow;
                            for (const outflow of outflows) {
                                newWaterDepth[outflow.idx] += outflow.flow;
                            }
                        }
                    }
                    
                    rainSimulation.waterDepth = newWaterDepth;
                }
                
                // Soil drainage
                for (let i = 0; i < rainSimulation.waterDepth.length; i++) {
                    const drainage = rainSimulation.waterDepth[i] * rainSimulation.drainageRate * 0.1;
                    rainSimulation.waterDepth[i] -= drainage;
                    rainSimulation.soilSaturation[i] = Math.min(1, rainSimulation.soilSaturation[i] + drainage * 2);
                    
                    // Ensure no negative values
                    if (rainSimulation.waterDepth[i] < 0) rainSimulation.waterDepth[i] = 0;
                }
                
                // Update water mesh
                const waterVertices = rainSimulation.waterMesh.geometry.attributes.position.array;
                for (let i = 0; i < rainSimulation.waterDepth.length; i++) {
                    waterVertices[i * 3 + 2] = originalHeightData[i] + rainSimulation.waterDepth[i] * scale * 100;
                }
                rainSimulation.waterMesh.geometry.attributes.position.needsUpdate = true;
                rainSimulation.waterMesh.geometry.computeVertexNormals();
                
                rainSimulation.currentHour++;
                updateRainStats();
            }
            
            function updateRainStats() {
                // Calculate total water volume in mega liters
                const cellAreaM2 = (terrainWidth / scale / (width - 1)) * (terrainHeight / scale / (height - 1));
                let totalWaterM3 = 0;
                let maxDepth = 0;
                let totalSaturation = 0;
                
                for (let i = 0; i < rainSimulation.waterDepth.length; i++) {
                    totalWaterM3 += rainSimulation.waterDepth[i] * cellAreaM2;
                    maxDepth = Math.max(maxDepth, rainSimulation.waterDepth[i]);
                    totalSaturation += rainSimulation.soilSaturation[i];
                }
                
                const totalWaterML = totalWaterM3 / 1000; // Convert to mega liters
                const avgSaturation = (totalSaturation / rainSimulation.waterDepth.length) * 100;
                
                document.getElementById('rainProgress').textContent = rainSimulation.currentHour + ' / ' + rainSimulation.totalHours + ' hours';
                document.getElementById('totalWater').textContent = totalWaterML.toFixed(2) + ' ML';
                document.getElementById('maxDepth').textContent = maxDepth.toFixed(3) + ' m';
                document.getElementById('avgSaturation').textContent = avgSaturation.toFixed(1) + '%';
            }
            
            function finishRainSimulation() {
                rainSimulation.paused = true;
                rainSimulation.rainParticles.visible = false;
                
                // Restore sky
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog.color = new THREE.Color(0x87CEEB);
                
                document.getElementById('pauseRainBtn').textContent = '‚ñ∂Ô∏è Resume';
                
                debug('Rain simulation complete');
            }
            
            // Rain particle animation
            function updateRainParticles(delta) {
                if (!rainSimulation || !rainSimulation.rainParticles.visible) return;
                
                const positions = rainSimulation.rainParticles.geometry.attributes.position.array;
                const velocities = rainSimulation.rainParticles.geometry.userData.velocities;
                
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3 + 1] -= velocities[i] * delta * 50;
                    
                    // Reset particle if it hits the ground
                    if (positions[i * 3 + 1] < 0) {
                        positions[i * 3] = (Math.random() - 0.5) * terrainWidth * 2;
                        positions[i * 3 + 1] = Math.random() * 200 + 50;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * terrainHeight * 2;
                    }
                }
                
                rainSimulation.rainParticles.geometry.attributes.position.needsUpdate = true;
            }
            
            // Add event listeners
            const resetBtn = document.getElementById('resetViewBtn');
            const topBtn = document.getElementById('topViewBtn');
            const autoBtn = document.getElementById('autoRotateBtn');
            const textureBtn = document.getElementById('toggleTexture');
            const rainBtn = document.getElementById('rainSimBtn');
            const scaleSlider = document.getElementById('verticalScale');
            const wireframeCheck = document.getElementById('wireframeToggle');
            
            if (resetBtn) resetBtn.addEventListener('click', resetView);
            if (topBtn) topBtn.addEventListener('click', topView);
            if (autoBtn) autoBtn.addEventListener('click', toggleAutoRotate);
            if (textureBtn) textureBtn.addEventListener('click', toggleTexture);
            if (rainBtn) rainBtn.addEventListener('click', initRainSimulation);
            if (scaleSlider) scaleSlider.addEventListener('input', (e) => updateVerticalScale(e.target.value));
            if (wireframeCheck) wireframeCheck.addEventListener('change', (e) => toggleWireframe(e.target.checked));
            
            // Animation loop
            let lastTime = performance.now();
            let frameCount = 0;
            
            function animate() {
                requestAnimationFrame(animate);
                
                const currentTime = performance.now();
                const delta = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                updateMovement(delta);
                updateRainParticles(delta);
                
                if (autoRotate && !Object.values(keys).some(v => v)) {
                    yaw += 0.01;
                    camera.rotation.y = yaw;
                }
                
                renderer.render(scene, camera);
                
                if (frameCount < 3) {
                    debug('Frame ' + frameCount + ' rendered');
                    frameCount++;
                }
            }
            
            animate();
            debug('Animation loop started');
            
            updateMovement(0);
            debug('Initial position set on terrain');
            
            // Handle window resize
            const resizeHandler = () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            };
            window.addEventListener('resize', resizeHandler);
            
            // Show modal
            modal.classList.add('show');
        }

        // Open empty 3D viewer
        function open3DViewer() {
            if (currentElevationData) {
                create3DTerrain(
                    currentElevationData.elevationData,
                    currentElevationData.width,
                    currentElevationData.height,
                    currentElevationData.bottomLeft,
                    currentElevationData.topRight
                );
            } else {
                const modal = document.getElementById('modal3d');
                const container = document.getElementById('viewer3d');
                
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.alignItems = 'center';
                container.style.justifyContent = 'center';
                container.style.color = 'white';
                container.style.fontSize = '18px';
                container.innerHTML = '<div style="text-align: center;"><p>üìÇ Click "Load Data" to import a terrain file</p><p style="margin-top: 10px; font-size: 14px; color: #aaa;">or use "Select Area" on the map to fetch elevation data</p></div>';
                
                modal.classList.add('show');
            }
        }

        // Add click events
        document.getElementById('locationBtn').addEventListener('click', getUserLocation);
        document.getElementById('contoursBtn').addEventListener('click', toggleContours);
        document.getElementById('satelliteBtn').addEventListener('click', toggleSatellite);
        document.getElementById('selectAreaBtn').addEventListener('click', toggleAreaSelection);
        document.getElementById('open3DViewerBtn').addEventListener('click', open3DViewer);
        document.getElementById('closeModal').addEventListener('click', () => {
            document.getElementById('modal3d').classList.remove('show');
            if (window.cleanup3DViewer) {
                window.cleanup3DViewer();
            }
        });
        document.getElementById('saveDataBtn').addEventListener('click', saveTerrainData);
        document.getElementById('saveDataBtn3D').addEventListener('click', saveTerrainData);
        document.getElementById('loadDataBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        document.getElementById('loadDataBtn3D').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadTerrainData(e.target.files[0]);
            }
        });

        // Add popup on click for location marker
        const popup = new ol.Overlay({
            element: document.createElement('div'),
            positioning: 'bottom-center',
            stopEvent: false,
            offset: [0, -10]
        });
        map.addOverlay(popup);

        map.on('click', (evt) => {
            if (isSelecting) return;
            
            const feature = map.forEachFeatureAtPixel(evt.pixel, (feature) => feature);
            
            if (feature && feature.get('name') === 'Your Location') {
                const coordinates = feature.getGeometry().getCoordinates();
                const lonLat = ol.proj.toLonLat(coordinates);
                
                const popupElement = popup.getElement();
                popupElement.innerHTML = `
                    <div style="background: white; padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); font-size: 13px;">
                        <strong>Your Location</strong><br>
                        <span style="color: #666;">
                            Lat: ${lonLat[1].toFixed(6)}<br>
                            Lon: ${lonLat[0].toFixed(6)}
                        </span>
                    </div>
                `;
                popup.setPosition(coordinates);
            } else {
                popup.setPosition(undefined);
            }
        });

        // Change cursor on hover
        map.on('pointermove', (evt) => {
            if (isSelecting) {
                map.getTarget().style.cursor = 'crosshair';
                return;
            }
            
            const pixel = map.getEventPixel(evt.originalEvent);
            const hit = map.hasFeatureAtPixel(pixel);
            map.getTarget().style.cursor = hit ? 'pointer' : '';
        });
    </script>
</body>
</html>
