<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map with 3D Terrain Generator - Rain Simulation</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.2.1/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v10.2.1/dist/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        #map {
            width: 100%;
            height: 100%;
            display: none; /* Hidden - we only use 3D viewer */
        }

        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 15px;
            z-index: 1000;
            display: none; /* Hidden - we only use 3D viewer */
        }

        .control-btn {
            display: block;
            width: 100%;
            padding: 12px 20px;
            margin-bottom: 10px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            color: #333;
            touch-action: manipulation;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .control-btn {
                padding: 14px 22px;
                font-size: 16px;
            }
        }

        .control-btn:last-child {
            margin-bottom: 0;
        }

        .control-btn:hover {
            background: #f5f5f5;
            border-color: #2196F3;
        }

        .control-btn.active {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Toast notification */
        .toast {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 2000;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 12px 15px;
            font-size: 12px;
            z-index: 1000;
            max-width: 200px;
            display: none; /* Hidden - we only use 3D viewer */
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            color: #666;
        }

        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 8px;
            background: #8B4513;
        }

        /* 3D Viewer Modal */
        .modal {
            display: flex; /* Always visible */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            border-radius: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            background: #2a2a2a;
            padding: 8px 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .modal-header {
                padding: 6px 10px;
                gap: 6px;
            }
        }

        .modal-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
        }

        .modal-title {
            color: white;
            font-size: 16px;
            font-weight: 600;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .modal-title {
                font-size: 14px;
            }
        }

        .modal-close {
            background: #ff4444;
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            min-width: 70px;
            touch-action: manipulation;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .modal-close {
                padding: 8px 12px;
                font-size: 12px;
                min-width: 60px;
            }
        }

        .modal-close:hover {
            background: #ff6666;
        }

        .modal-close[style*="4CAF50"]:hover {
            background: #66BB6A !important;
        }

        .modal-close[style*="2196F3"]:hover {
            background: #42A5F5 !important;
        }

        .modal-close[style*="666"]:hover {
            background: #888 !important;
        }

        .modal-close[style*="FF9800"]:hover {
            background: #FFB74D !important;
        }

        /* Toolbar controls */
        .toolbar-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .toolbar-controls {
                gap: 4px;
            }
        }

        #flyingModeStatus {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            transition: background 0.3s ease;
        }

        @media (max-width: 768px), (pointer: coarse) {
            #flyingModeStatus {
                padding: 5px 10px;
                font-size: 10px;
            }
        }

        .toolbar-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .toolbar-btn {
                padding: 5px 8px;
                font-size: 10px;
            }
        }

        .toolbar-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .toolbar-btn.active {
            background: rgba(33, 150, 243, 0.6);
            border-color: rgba(33, 150, 243, 0.8);
        }

        .toolbar-label {
            color: white;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .toolbar-label {
                font-size: 10px;
                gap: 4px;
            }
        }

        .toolbar-label input[type="range"] {
            width: 80px;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .toolbar-label input[type="range"] {
                width: 60px;
            }
        }

        .toolbar-label input[type="checkbox"] {
            cursor: pointer;
        }

        /* Touch controls */
        .touch-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            display: none;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .touch-controls {
                display: flex;
                gap: 40px;
                align-items: flex-end;
            }
        }

        .dpad-container {
            position: relative;
            width: 140px;
            height: 140px;
        }

        .dpad {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .dpad-btn {
            position: absolute;
            width: 45px;
            height: 45px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .dpad-btn:active {
            background: rgba(33, 150, 243, 0.6);
            border-color: rgba(33, 150, 243, 0.8);
            transform: scale(0.95);
        }

        #dpad-up {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        #dpad-down {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        #dpad-left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        #dpad-right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .vertical-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .vertical-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .vertical-btn:active {
            background: rgba(33, 150, 243, 0.6);
            border-color: rgba(33, 150, 243, 0.8);
            transform: scale(0.95);
        }

        /* Look zone for touch look controls */
        .look-zone {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            z-index: 50;
            touch-action: none;
        }

        /* 3D Viewer Container */
        #viewer3d {
            flex: 1;
            position: relative;
            overflow: auto;
            background: #1a1a1a;
            -webkit-overflow-scrolling: touch;
        }

        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            color: white;
            font-size: 18px;
        }

        .loading-overlay.show {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Rain Simulation Panel */
        .rain-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 20px;
            color: white;
            min-width: 300px;
            max-width: 400px;
            z-index: 20;
            display: none;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 768px), (pointer: coarse) {
            .rain-panel {
                top: auto;
                bottom: 180px; /* Position above D-pad */
                left: 10px;
                right: 10px;
                min-width: auto;
                max-width: none;
                padding: 15px;
                max-height: 50vh;
                overflow-y: auto;
            }
        }

        .rain-panel.show {
            display: block;
        }

        .rain-panel h3 {
            margin: 0 0 20px 0;
            font-size: 18px;
            color: #64B5F6;
            border-bottom: 2px solid rgba(100, 181, 246, 0.3);
            padding-bottom: 10px;
        }

        .rain-control-group {
            margin-bottom: 20px;
        }

        .rain-control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
        }

        .rain-value-display {
            color: #64B5F6;
            font-weight: 600;
            margin-left: 5px;
        }

        .rain-control-group input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        .rain-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .rain-btn {
            flex: 1;
            min-width: 80px;
            padding: 10px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .rain-btn {
                padding: 12px 18px;
                font-size: 14px;
            }
        }

        .rain-btn:hover:not(:disabled) {
            background: #42A5F5;
            transform: translateY(-1px);
        }

        .rain-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .rain-btn.warning {
            background: #FF9800;
        }

        .rain-btn.warning:hover:not(:disabled) {
            background: #FFB74D;
        }

        .rain-btn.danger {
            background: #f44336;
        }

        .rain-btn.danger:hover:not(:disabled) {
            background: #ef5350;
        }

        /* Rain Stats Display */
        .rain-stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px 20px;
            color: white;
            min-width: 250px;
            z-index: 20;
            display: none;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 768px), (pointer: coarse) {
            .rain-stats {
                top: 80px; /* Below header */
                right: 10px;
                left: 10px;
                min-width: auto;
                padding: 12px 15px;
                max-height: 40vh;
                overflow-y: auto;
            }
        }

        .rain-stats.show {
            display: block;
        }

        .rain-stats h4 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #64B5F6;
            border-bottom: 2px solid rgba(100, 181, 246, 0.3);
            padding-bottom: 8px;
        }

        .rain-stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .rain-stat-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .rain-stat-value {
            color: #64B5F6;
            font-weight: 600;
        }

        /* Mouse look hint */
        .look-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .look-hint.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="control-panel">
        <button id="locationBtn" class="control-btn">üìç Get Location</button>
        <button id="contoursBtn" class="control-btn">üìà Toggle Contours</button>
        <button id="satelliteBtn" class="control-btn">üõ∞Ô∏è Toggle Satellite</button>
        <button id="selectAreaBtn" class="control-btn">üìê Select Area</button>
        <button id="open3DViewerBtn" class="control-btn">üéÆ 3D Viewer</button>
        <button id="saveDataBtn" class="control-btn">üíæ Save Data</button>
        <button id="loadDataBtn" class="control-btn">üìÇ Load Data</button>
    </div>

    <div class="legend">
        <div class="legend-title">Contours</div>
        <div class="legend-item">
            <div class="legend-line"></div>
            <span>10m intervals</span>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- 3D Viewer Modal -->
    <div class="modal" id="modal3d">
        <div class="modal-content">
            <div class="modal-header">
                <!-- First row: Title and main buttons -->
                <div class="modal-header-row">
                    <span class="modal-title">üóª 3D Terrain Viewer</span>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        <button id="rainSimBtn" class="modal-close" style="background: #FF9800;">üåßÔ∏è Rain</button>
                        <button id="saveDataBtn3D" class="modal-close" style="background: #4CAF50;">üíæ Save</button>
                        <button id="loadDataBtn3D" class="modal-close" style="background: #2196F3;">üìÇ Load</button>
                    </div>
                </div>
                
                <!-- Second row: Controls -->
                <div class="toolbar-controls">
                    <div id="flyingModeStatus">RUNNING MODE</div>
                    <button id="resetViewBtn" class="toolbar-btn">Reset View</button>
                    <button id="topViewBtn" class="toolbar-btn">Top View</button>
                    <button id="autoRotateBtn" class="toolbar-btn">Auto-Rotate</button>
                    <button id="toggleTexture" class="toolbar-btn" style="display: none;">Toggle Texture</button>
                    <label class="toolbar-label">
                        Scale: <span id="scaleValue">0.1</span>x
                        <input type="range" id="verticalScale" min="0.1" max="5" step="0.1" value="0.1">
                    </label>
                    <label class="toolbar-label">
                        <input type="checkbox" id="wireframeToggle"> Wireframe
                    </label>
                </div>
            </div>
            <div id="viewer3d">
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div>Generating 3D terrain...</div>
                </div>

                <!-- Rain Simulation Panel -->
                <div class="rain-panel" id="rainPanel">
                    <h3>üåßÔ∏è Rain Simulation Settings</h3>
                    
                    <div class="rain-control-group">
                        <label>
                            Rainfall Amount: <span class="rain-value-display" id="rainfallDisplay">100</span> mm
                        </label>
                        <input type="range" id="rainfallAmount" min="1" max="500" value="100" step="1">
                    </div>

                    <div class="rain-control-group">
                        <label>
                            Duration: <span class="rain-value-display" id="durationDisplay">6</span> hours
                        </label>
                        <input type="range" id="rainDuration" min="1" max="48" value="6" step="1">
                    </div>

                    <div class="rain-control-group">
                        <label>
                            Soil Drainage Rate: <span class="rain-value-display" id="drainageDisplay">50</span>%
                        </label>
                        <input type="range" id="drainageRate" min="0" max="100" value="50" step="1">
                    </div>

                    <div class="rain-buttons">
                        <button class="rain-btn" id="startRainBtn">‚ñ∂ Start</button>
                        <button class="rain-btn warning" id="pauseRainBtn" disabled>‚è∏ Pause</button>
                        <button class="rain-btn" id="stepRainBtn" disabled>‚è≠ Step</button>
                        <button class="rain-btn danger" id="stopRainBtn" disabled>‚èπ Stop</button>
                    </div>
                </div>

                <!-- Rain Stats Display -->
                <div class="rain-stats" id="rainStats">
                    <h4>üìä Simulation Stats</h4>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Time:</span>
                        <span class="rain-stat-value" id="statTime">0 / 0 hours</span>
                    </div>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Total Water:</span>
                        <span class="rain-stat-value" id="statWater">0 ML</span>
                    </div>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Max Depth:</span>
                        <span class="rain-stat-value" id="statDepth">0 mm</span>
                    </div>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Avg Saturation:</span>
                        <span class="rain-stat-value" id="statSaturation">0%</span>
                    </div>
                    <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2);">
                        <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-bottom: 8px;">Water Depth Scale:</div>
                        <div style="font-size: 11px; color: rgba(255,255,255,0.6);">
                            <div style="margin-bottom: 3px;">üíß &lt;100mm: No visible water</div>
                            <div style="margin-bottom: 3px;"><span style="color: #64c8ff;">‚óè</span> 100mm: Light blue</div>
                            <div style="margin-bottom: 3px;"><span style="color: #8080e0;">‚óè</span> 500mm: Blue-purple</div>
                            <div><span style="color: #9632c8;">‚óè</span> 1000mm+: Purple</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display: none;">

    <script>
        // Debug function
        function debug(msg) {
            console.log('[3D Terrain] ' + msg);
        }

        // Map setup
        const map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM()
                })
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([0, 0]),
                zoom: 2
            }),
            controls: ol.control.defaults.defaults().extend([
                new ol.control.ScaleLine()
            ])
        });

        // Global state
        let currentElevationData = null;
        let contoursVisible = false;
        let contourLayer = null;
        let satelliteVisible = false;
        let satelliteLayer = null;
        let isSelecting = false;
        let selectSource = null;
        let selectLayer = null;

        // Toast notifications
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Get user location
        function getUserLocation() {
            if (!navigator.geolocation) {
                showToast('Geolocation not supported');
                return;
            }

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const coords = [position.coords.longitude, position.coords.latitude];
                    
                    const view = map.getView();
                    view.animate({
                        center: ol.proj.fromLonLat(coords),
                        zoom: 15,
                        duration: 1000
                    });

                    const marker = new ol.Feature({
                        geometry: new ol.geom.Point(ol.proj.fromLonLat(coords)),
                        name: 'Your Location'
                    });

                    marker.setStyle(new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 8,
                            fill: new ol.style.Fill({ color: '#2196F3' }),
                            stroke: new ol.style.Stroke({ color: 'white', width: 2 })
                        })
                    }));

                    const vectorSource = new ol.source.Vector({
                        features: [marker]
                    });

                    const existingLayer = map.getLayers().getArray().find(l => l.get('name') === 'location');
                    if (existingLayer) {
                        map.removeLayer(existingLayer);
                    }

                    const vectorLayer = new ol.layer.Vector({
                        source: vectorSource,
                        name: 'location'
                    });

                    map.addLayer(vectorLayer);
                    showToast('Location found!');
                },
                (error) => {
                    showToast('Could not get location: ' + error.message);
                }
            );
        }

        // Toggle contours
        function toggleContours() {
            contoursVisible = !contoursVisible;
            document.getElementById('contoursBtn').classList.toggle('active', contoursVisible);

            if (contoursVisible && !contourLayer) {
                contourLayer = new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
                        attributions: 'Esri'
                    }),
                    opacity: 0.5
                });
                map.addLayer(contourLayer);
            } else if (contourLayer) {
                map.removeLayer(contourLayer);
                contourLayer = null;
            }

            showToast(contoursVisible ? 'Contours enabled' : 'Contours disabled');
        }

        // Toggle satellite
        function toggleSatellite() {
            satelliteVisible = !satelliteVisible;
            document.getElementById('satelliteBtn').classList.toggle('active', satelliteVisible);

            if (satelliteVisible && !satelliteLayer) {
                satelliteLayer = new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                        attributions: 'Esri'
                    })
                });
                map.getLayers().insertAt(0, satelliteLayer);
            } else if (satelliteLayer) {
                map.removeLayer(satelliteLayer);
                satelliteLayer = null;
            }

            showToast(satelliteVisible ? 'Satellite enabled' : 'Satellite disabled');
        }

        // Toggle area selection
        function toggleAreaSelection() {
            isSelecting = !isSelecting;
            document.getElementById('selectAreaBtn').classList.toggle('active', isSelecting);

            if (isSelecting) {
                if (!selectLayer) {
                    selectSource = new ol.source.Vector();
                    selectLayer = new ol.layer.Vector({
                        source: selectSource,
                        style: new ol.style.Style({
                            fill: new ol.style.Fill({
                                color: 'rgba(33, 150, 243, 0.2)'
                            }),
                            stroke: new ol.style.Stroke({
                                color: '#2196F3',
                                width: 2
                            })
                        })
                    });
                    map.addLayer(selectLayer);
                }

                let startCoord = null;
                let currentFeature = null;

                const clickHandler = (evt) => {
                    if (!startCoord) {
                        startCoord = evt.coordinate;
                        showToast('Click again to finish selection');
                    } else {
                        const extent = ol.extent.boundingExtent([startCoord, evt.coordinate]);
                        const geometry = ol.geom.Polygon.fromExtent(extent);
                        
                        if (currentFeature) {
                            selectSource.removeFeature(currentFeature);
                        }
                        
                        currentFeature = new ol.Feature(geometry);
                        selectSource.addFeature(currentFeature);
                        
                        fetchElevationData(extent);
                        
                        map.un('click', clickHandler);
                        map.un('pointermove', moveHandler);
                        isSelecting = false;
                        document.getElementById('selectAreaBtn').classList.remove('active');
                        startCoord = null;
                    }
                };

                const moveHandler = (evt) => {
                    if (startCoord) {
                        const extent = ol.extent.boundingExtent([startCoord, evt.coordinate]);
                        const geometry = ol.geom.Polygon.fromExtent(extent);
                        
                        if (currentFeature) {
                            selectSource.removeFeature(currentFeature);
                        }
                        
                        currentFeature = new ol.Feature(geometry);
                        selectSource.addFeature(currentFeature);
                    }
                };

                map.on('click', clickHandler);
                map.on('pointermove', moveHandler);
                showToast('Click to start selection');
            }
        }

        // Fetch elevation data
        async function fetchElevationData(extent) {
            const [minX, minY, maxX, maxY] = extent;
            const bottomLeft = ol.proj.toLonLat([minX, minY]);
            const topRight = ol.proj.toLonLat([maxX, maxY]);
            
            debug('Fetching elevation for bounds:');
            debug('  Bottom-left: ' + bottomLeft[0] + ', ' + bottomLeft[1]);
            debug('  Top-right: ' + topRight[0] + ', ' + topRight[1]);
            
            const width = 100;
            const height = 100;
            
            showToast('Fetching elevation data...');
            
            try {
                const elevationData = [];
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const lon = bottomLeft[0] + (topRight[0] - bottomLeft[0]) * (x / (width - 1));
                        const lat = bottomLeft[1] + (topRight[1] - bottomLeft[1]) * (y / (height - 1));
                        
                        const url = `https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lon}`;
                        
                        try {
                            const response = await fetch(url);
                            const data = await response.json();
                            
                            if (data.results && data.results[0]) {
                                elevationData.push(data.results[0].elevation);
                            } else {
                                elevationData.push(0);
                            }
                        } catch (error) {
                            debug('Elevation fetch error for ' + lat + ',' + lon + ': ' + error.message);
                            elevationData.push(0);
                        }
                        
                        if ((y * width + x) % 10 === 0) {
                            showToast('Fetching: ' + Math.round((y * width + x) / (width * height) * 100) + '%');
                        }
                    }
                }
                
                currentElevationData = {
                    elevationData: elevationData,
                    width: width,
                    height: height,
                    bottomLeft: bottomLeft,
                    topRight: topRight
                };
                
                showToast('Elevation data ready!');
                document.getElementById('open3DViewerBtn').disabled = false;
                
                create3DTerrain(elevationData, width, height, bottomLeft, topRight);
                
            } catch (error) {
                showToast('Error fetching elevation: ' + error.message);
                debug('Elevation fetch error: ' + error);
            }
        }

        // Save terrain data
        function saveTerrainData() {
            if (!currentElevationData) {
                showToast('No terrain data to save');
                return;
            }

            const dataStr = JSON.stringify(currentElevationData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'terrain_data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Terrain data saved!');
        }

        // Load terrain data
        function loadTerrainData(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    currentElevationData = JSON.parse(e.target.result);
                    showToast('Terrain data loaded!');
                    document.getElementById('open3DViewerBtn').disabled = false;
                    
                    // Only auto-open if modal is not already showing
                    const modal = document.getElementById('modal3d');
                    if (currentElevationData && !modal.classList.contains('show')) {
                        create3DTerrain(
                            currentElevationData.elevationData,
                            currentElevationData.width,
                            currentElevationData.height,
                            currentElevationData.bottomLeft,
                            currentElevationData.topRight
                        );
                    } else if (currentElevationData && modal.classList.contains('show')) {
                        // Modal is already open, recreate the terrain
                        create3DTerrain(
                            currentElevationData.elevationData,
                            currentElevationData.width,
                            currentElevationData.height,
                            currentElevationData.bottomLeft,
                            currentElevationData.topRight
                        );
                    }
                } catch (error) {
                    showToast('Error loading file: ' + error.message);
                    console.error('File load error:', error);
                }
            };
            reader.readAsText(file);
        }

        // Fetch satellite texture
        async function fetchSatelliteTexture(bottomLeft, topRight, width, height) {
            try {
                debug('Fetching satellite texture for bounds:');
                debug('  Bottom-left: ' + bottomLeft[0] + ', ' + bottomLeft[1]);
                debug('  Top-right: ' + topRight[0] + ', ' + topRight[1]);
                
                const latDiff = Math.abs(topRight[1] - bottomLeft[1]);
                const lonDiff = Math.abs(topRight[0] - bottomLeft[0]);
                
                let zoom;
                const maxDiff = Math.max(latDiff, lonDiff);
                if (maxDiff > 1) zoom = 10;
                else if (maxDiff > 0.5) zoom = 11;
                else if (maxDiff > 0.25) zoom = 12;
                else if (maxDiff > 0.1) zoom = 13;
                else if (maxDiff > 0.05) zoom = 14;
                else if (maxDiff > 0.025) zoom = 15;
                else if (maxDiff > 0.01) zoom = 16;
                else zoom = 17;
                
                debug('  Zoom level: ' + zoom + ' (area size: ' + maxDiff.toFixed(4) + '¬∞)');
                
                function latLonToTile(lat, lon, z) {
                    const n = Math.pow(2, z);
                    const x = Math.floor((lon + 180) / 360 * n);
                    const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);
                    return { x, y };
                }
                
                const minTile = latLonToTile(bottomLeft[1], bottomLeft[0], zoom);
                const maxTile = latLonToTile(topRight[1], topRight[0], zoom);
                
                const minX = Math.min(minTile.x, maxTile.x);
                const maxX = Math.max(minTile.x, maxTile.x);
                const minY = Math.min(minTile.y, maxTile.y);
                const maxY = Math.max(minTile.y, maxTile.y);
                
                const tilesX = maxX - minX + 1;
                const tilesY = maxY - minY + 1;
                
                debug('  Tiles needed: ' + tilesX + ' x ' + tilesY + ' = ' + (tilesX * tilesY));
                
                const tileSize = 256;
                const canvas = document.createElement('canvas');
                canvas.width = tilesX * tileSize;
                canvas.height = tilesY * tileSize;
                const ctx = canvas.getContext('2d');
                
                const tilePromises = [];
                for (let y = minY; y <= maxY; y++) {
                    for (let x = minX; x <= maxX; x++) {
                        const url = `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoom}/${y}/${x}`;
                        
                        const promise = new Promise((resolve, reject) => {
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.onload = () => {
                                const canvasX = (x - minX) * tileSize;
                                const canvasY = (y - minY) * tileSize;
                                ctx.drawImage(img, canvasX, canvasY);
                                resolve();
                            };
                            img.onerror = () => {
                                debug('  Failed to load tile: ' + x + ',' + y);
                                reject(new Error('Tile load failed'));
                            };
                            img.src = url;
                        });
                        
                        tilePromises.push(promise);
                    }
                }
                
                await Promise.all(tilePromises);
                debug('  All tiles loaded, creating texture');
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.minFilter = THREE.LinearFilter;
                
                return texture;
            } catch (error) {
                debug('Texture fetch error: ' + error.message);
                return null;
            }
        }

        // Create 3D terrain
        function create3DTerrain(elevationData, width, height, bottomLeft, topRight) {
            debug('Creating 3D terrain: ' + width + 'x' + height);
            
            const modal = document.getElementById('modal3d');
            const container = document.getElementById('viewer3d');
            
            // Get references to essential elements BEFORE clearing
            let rainPanel = document.getElementById('rainPanel');
            let rainStats = document.getElementById('rainStats');
            let loadingOverlay = document.getElementById('loadingOverlay');
            
            // If elements don't exist (were destroyed), recreate them
            if (!rainPanel) {
                rainPanel = document.createElement('div');
                rainPanel.id = 'rainPanel';
                rainPanel.className = 'rain-panel';
                rainPanel.innerHTML = `
                    <h3>üåßÔ∏è Rain Simulation Settings</h3>
                    <div class="rain-control-group">
                        <label>
                            Rainfall Amount: <span class="rain-value-display" id="rainfallDisplay">100</span> mm
                        </label>
                        <input type="range" id="rainfallAmount" min="1" max="500" value="100" step="1">
                    </div>
                    <div class="rain-control-group">
                        <label>
                            Duration: <span class="rain-value-display" id="durationDisplay">6</span> hours
                        </label>
                        <input type="range" id="rainDuration" min="1" max="48" value="6" step="1">
                    </div>
                    <div class="rain-control-group">
                        <label>
                            Soil Drainage Rate: <span class="rain-value-display" id="drainageDisplay">50</span>%
                        </label>
                        <input type="range" id="drainageRate" min="0" max="100" value="50" step="1">
                    </div>
                    <div class="rain-buttons">
                        <button class="rain-btn" id="startRainBtn">‚ñ∂ Start</button>
                        <button class="rain-btn warning" id="pauseRainBtn" disabled>‚è∏ Pause</button>
                        <button class="rain-btn" id="stepRainBtn" disabled>‚è≠ Step</button>
                        <button class="rain-btn danger" id="stopRainBtn" disabled>‚èπ Stop</button>
                    </div>
                `;
            }
            
            if (!rainStats) {
                rainStats = document.createElement('div');
                rainStats.id = 'rainStats';
                rainStats.className = 'rain-stats';
                rainStats.innerHTML = `
                    <h4>üìä Simulation Stats</h4>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Time:</span>
                        <span class="rain-stat-value" id="statTime">0 / 0 hours</span>
                    </div>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Total Water:</span>
                        <span class="rain-stat-value" id="statWater">0 ML</span>
                    </div>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Max Depth:</span>
                        <span class="rain-stat-value" id="statDepth">0 mm</span>
                    </div>
                    <div class="rain-stat-item">
                        <span class="rain-stat-label">Avg Saturation:</span>
                        <span class="rain-stat-value" id="statSaturation">0%</span>
                    </div>
                    <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2);">
                        <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-bottom: 8px;">Water Depth Scale:</div>
                        <div style="font-size: 11px; color: rgba(255,255,255,0.6);">
                            <div style="margin-bottom: 3px;">üíß &lt;100mm: No visible water</div>
                            <div style="margin-bottom: 3px;"><span style="color: #64c8ff;">‚óè</span> 100mm: Light blue</div>
                            <div style="margin-bottom: 3px;"><span style="color: #8080e0;">‚óè</span> 500mm: Blue-purple</div>
                            <div><span style="color: #9632c8;">‚óè</span> 1000mm+: Purple</div>
                        </div>
                    </div>
                `;
            }
            
            if (!loadingOverlay) {
                loadingOverlay = document.createElement('div');
                loadingOverlay.id = 'loadingOverlay';
                loadingOverlay.className = 'loading-overlay';
                loadingOverlay.innerHTML = `
                    <div class="spinner"></div>
                    <div>Generating 3D terrain...</div>
                `;
            }
            
            // Now clear the container and add the elements back
            container.innerHTML = '';
            container.appendChild(loadingOverlay);
            container.appendChild(rainPanel);
            container.appendChild(rainStats);
            
            // Camera state
            const camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.01,
                10000
            );
            
            const velocity = new THREE.Vector3();
            const direction = new THREE.Vector3();
            
            let pitch = 0;
            let yaw = 0;
            
            const keys = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                up: false,
                down: false
            };
            
            let isPointerLocked = false;
            let isFlying = false;
            let lastUpTapTime = 0;
            const doubleTapDelay = 300;
            
            // Setup Three.js scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Find elevation range
            let minElev = Infinity;
            let maxElev = -Infinity;
            for (let i = 0; i < elevationData.length; i++) {
                if (elevationData[i] > -9999 && elevationData[i] !== 0) {
                    minElev = Math.min(minElev, elevationData[i]);
                    maxElev = Math.max(maxElev, elevationData[i]);
                }
            }
            
            if (minElev === Infinity || maxElev === -Infinity || minElev === maxElev) {
                debug('WARN: Invalid data, using test terrain');
                minElev = 0;
                maxElev = 100;
                for (let i = 0; i < elevationData.length; i++) {
                    elevationData[i] = Math.sin(i / 10) * 50 + 50;
                }
            }
            
            const elevRange = maxElev - minElev;
            const scale = Math.max(width, height) / 100;
            const verticalExaggeration = 0.1;
            let originalHeightData = [];
            
            // Calculate real-world measurements
            let metersPerSceneUnit = 1;
            let totalAreaSquareMeters = 0;
            
            if (bottomLeft && topRight) {
                const lat1 = bottomLeft[1] * Math.PI / 180;
                const lat2 = topRight[1] * Math.PI / 180;
                const lon1 = bottomLeft[0] * Math.PI / 180;
                const lon2 = topRight[0] * Math.PI / 180;
                
                const R = 6371000;
                const dLat = lat2 - lat1;
                const dLon = lon2 - lon1;
                
                const latDistance = R * Math.abs(lat2 - lat1);
                const lonDistance = R * Math.abs(dLon) * Math.cos((lat1 + lat2) / 2);
                
                totalAreaSquareMeters = latDistance * lonDistance;
                
                const sceneWidth = width * scale;
                const sceneHeight = height * scale;
                
                const metersPerUnitWidth = lonDistance / sceneWidth;
                const metersPerUnitHeight = latDistance / sceneHeight;
                metersPerSceneUnit = (metersPerUnitWidth + metersPerUnitHeight) / 2;
                
                debug('Real-world area: ' + (totalAreaSquareMeters / 1000000).toFixed(2) + ' km¬≤');
                debug('Meters per scene unit: ' + metersPerSceneUnit.toFixed(4));
            } else {
                const sceneWidth = width * scale;
                totalAreaSquareMeters = 1000000; // 1 km¬≤ default
                metersPerSceneUnit = 1000 / sceneWidth;
            }
            
            const playerHeight = 2;
            
            debug('Elevation range: ' + minElev.toFixed(1) + 'm to ' + maxElev.toFixed(1) + 'm (Œî ' + elevRange.toFixed(1) + 'm)');
            
            // Build terrain geometry
            const geometry = new THREE.PlaneGeometry(
                width * scale,
                height * scale,
                width - 1,
                height - 1
            );
            
            const vertices = geometry.attributes.position.array;
            
            for (let i = 0, idx = 0; i < height; i++) {
                for (let j = 0; j < width; j++, idx++) {
                    const elevation = elevationData[idx];
                    const normalizedHeight = ((elevation - minElev) / elevRange) * verticalExaggeration * scale * 50;
                    vertices[idx * 3 + 2] = normalizedHeight;
                    originalHeightData.push(normalizedHeight);
                }
            }
            
            geometry.computeVertexNormals();
            
            // Create material with vertex colors
            const colors = new Float32Array(vertices.length);
            for (let i = 0; i < vertices.length; i += 3) {
                const height = vertices[i + 2];
                const normalized = height / (verticalExaggeration * scale * 50);
                
                let r, g, b;
                if (normalized < 0.25) {
                    r = 0.2; g = 0.5 + normalized * 2; b = 0.3;
                } else if (normalized < 0.5) {
                    r = 0.3 + (normalized - 0.25) * 2; g = 0.7; b = 0.2;
                } else if (normalized < 0.75) {
                    r = 0.7 + (normalized - 0.5) * 0.8; g = 0.7 - (normalized - 0.5) * 1.2; b = 0.2;
                } else {
                    r = 0.5 + (normalized - 0.75) * 0.8; g = 0.4 - (normalized - 0.75) * 0.8; b = 0.2;
                }
                
                colors[i] = r; colors[i + 1] = g; colors[i + 2] = b;
            }
            
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            let material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                flatShading: false,
                shininess: 10,
                side: THREE.DoubleSide
            });
            
            let satelliteTexture = null;
            let useTexture = true;
            
            // Load satellite texture
            if (bottomLeft && topRight) {
                fetchSatelliteTexture(bottomLeft, topRight, width, height).then(texture => {
                    if (texture) {
                        satelliteTexture = texture;
                        material.map = texture;
                        material.vertexColors = false;
                        material.needsUpdate = true;
                        debug('Satellite texture applied');
                        showToast('Satellite texture loaded!');
                        
                        const toggleBtn = document.getElementById('toggleTexture');
                        if (toggleBtn) {
                            toggleBtn.style.display = 'block';
                            toggleBtn.classList.add('active');
                        }
                    }
                }).catch(error => {
                    debug('Texture load failed: ' + error.message);
                });
            }
            
            const terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            scene.add(terrain);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            camera.position.set(0, playerHeight, 0);
            camera.rotation.order = 'YXZ';
            
            // RAIN SIMULATION SYSTEM
            let rainSimulation = {
                active: false,
                paused: false,
                config: {
                    rainfall: 100, // mm
                    duration: 6,   // hours
                    drainage: 50   // %
                },
                state: {
                    currentHour: 0,
                    waterDepth: new Float32Array(width * height),  // mm of water
                    soilSaturation: new Float32Array(width * height), // 0-100%
                    totalWaterLiters: 0,
                    maxDepth: 0
                },
                particles: null,
                waterMesh: null,
                originalSkyColor: new THREE.Color(0x87CEEB)
            };
            
            // Create rain particles
            function createRainParticles() {
                const particleCount = 5000;
                const particleGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount);
                
                const halfWidth = (width * scale) / 2;
                const halfHeight = (height * scale) / 2;
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * width * scale;
                    positions[i * 3 + 1] = Math.random() * scale * 200 + 50;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * height * scale;
                    velocities[i] = 2 + Math.random() * 2;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));
                
                const particleMaterial = new THREE.PointsMaterial({
                    color: 0xaaaaff,
                    size: 0.3,
                    transparent: true,
                    opacity: 0.6
                });
                
                return new THREE.Points(particleGeometry, particleMaterial);
            }
            
            // Create water layer mesh
            function createWaterLayer() {
                const waterGeometry = new THREE.PlaneGeometry(
                    width * scale,
                    height * scale,
                    width - 1,
                    height - 1
                );
                
                // Add color attribute for gradient visualization
                const waterColors = new Float32Array((width * height) * 3);
                waterGeometry.setAttribute('color', new THREE.BufferAttribute(waterColors, 3));
                
                const waterMaterial = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide,
                    shininess: 100
                });
                
                const water = new THREE.Mesh(waterGeometry, waterMaterial);
                water.rotation.x = -Math.PI / 2;
                water.position.y = 0.1;
                
                return water;
            }
            
            // Update rain controls
            function updateRainControls() {
                document.getElementById('rainfallDisplay').textContent = rainSimulation.config.rainfall;
                document.getElementById('durationDisplay').textContent = rainSimulation.config.duration;
                document.getElementById('drainageDisplay').textContent = rainSimulation.config.drainage;
            }
            
            // Rain control event listeners
            document.getElementById('rainfallAmount').addEventListener('input', (e) => {
                rainSimulation.config.rainfall = parseInt(e.target.value);
                updateRainControls();
            });
            
            document.getElementById('rainDuration').addEventListener('input', (e) => {
                rainSimulation.config.duration = parseInt(e.target.value);
                updateRainControls();
            });
            
            document.getElementById('drainageRate').addEventListener('input', (e) => {
                rainSimulation.config.drainage = parseInt(e.target.value);
                updateRainControls();
            });
            
            document.getElementById('startRainBtn').addEventListener('click', () => {
                if (!rainSimulation.active) {
                    startRainSimulation();
                } else if (rainSimulation.paused) {
                    rainSimulation.paused = false;
                    document.getElementById('pauseRainBtn').textContent = '‚è∏ Pause';
                }
            });
            
            document.getElementById('pauseRainBtn').addEventListener('click', () => {
                if (rainSimulation.active && !rainSimulation.paused) {
                    rainSimulation.paused = true;
                    document.getElementById('pauseRainBtn').textContent = '‚ñ∂ Resume';
                }
            });
            
            document.getElementById('stepRainBtn').addEventListener('click', () => {
                if (rainSimulation.active && rainSimulation.paused) {
                    simulateRainStep();
                }
            });
            
            document.getElementById('stopRainBtn').addEventListener('click', () => {
                stopRainSimulation();
            });
            
            function startRainSimulation() {
                debug('Starting rain simulation');
                rainSimulation.active = true;
                rainSimulation.paused = false;
                rainSimulation.state.currentHour = 0;
                rainSimulation.state.waterDepth.fill(0);
                rainSimulation.state.soilSaturation.fill(0);
                rainSimulation.state.totalWaterLiters = 0;
                rainSimulation.state.maxDepth = 0;
                rainSimTimeAccumulator = 0; // Reset timer
                
                // Create rain particles
                if (!rainSimulation.particles) {
                    rainSimulation.particles = createRainParticles();
                    scene.add(rainSimulation.particles);
                }
                rainSimulation.particles.visible = true;
                
                // Create water layer
                if (!rainSimulation.waterMesh) {
                    rainSimulation.waterMesh = createWaterLayer();
                    scene.add(rainSimulation.waterMesh);
                }
                rainSimulation.waterMesh.visible = true;
                
                // Change sky color
                scene.background = new THREE.Color(0x505060);
                
                // Update UI
                document.getElementById('startRainBtn').disabled = true;
                document.getElementById('pauseRainBtn').disabled = false;
                document.getElementById('stepRainBtn').disabled = false;
                document.getElementById('stopRainBtn').disabled = false;
                document.getElementById('rainStats').classList.add('show');
                
                updateRainStats();
                showToast('Rain simulation started!');
            }
            
            function stopRainSimulation() {
                debug('Stopping rain simulation');
                rainSimulation.active = false;
                rainSimulation.paused = false;
                
                if (rainSimulation.particles) {
                    rainSimulation.particles.visible = false;
                }
                
                if (rainSimulation.waterMesh) {
                    rainSimulation.waterMesh.visible = false;
                }
                
                scene.background = rainSimulation.originalSkyColor;
                
                document.getElementById('startRainBtn').disabled = false;
                document.getElementById('pauseRainBtn').disabled = true;
                document.getElementById('pauseRainBtn').textContent = '‚è∏ Pause';
                document.getElementById('stepRainBtn').disabled = true;
                document.getElementById('stopRainBtn').disabled = true;
                
                showToast('Rain simulation stopped');
            }
            
            function simulateRainStep() {
                if (rainSimulation.state.currentHour >= rainSimulation.config.duration) {
                    showToast('Simulation complete!');
                    return;
                }
                
                debug('Simulating hour ' + (rainSimulation.state.currentHour + 1));
                
                const mmPerHour = rainSimulation.config.rainfall / rainSimulation.config.duration;
                const drainageRate = rainSimulation.config.drainage / 100;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = y * width + x;
                        const elevation = elevationData[idx];
                        
                        // Add rainfall
                        rainSimulation.state.waterDepth[idx] += mmPerHour;
                        
                        // Soil absorption
                        const soilCapacity = 100 - rainSimulation.state.soilSaturation[idx];
                        const absorbed = Math.min(mmPerHour * 0.3, soilCapacity * 0.1);
                        rainSimulation.state.soilSaturation[idx] += absorbed;
                        rainSimulation.state.waterDepth[idx] -= absorbed;
                        
                        // Drainage
                        const drained = rainSimulation.state.waterDepth[idx] * drainageRate * 0.1;
                        rainSimulation.state.waterDepth[idx] -= drained;
                        
                        // Flow to lowest neighbor
                        let lowestElev = elevation;
                        let lowestIdx = -1;
                        
                        const neighbors = [
                            [x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1],
                            [x - 1, y - 1], [x + 1, y - 1], [x - 1, y + 1], [x + 1, y + 1]
                        ];
                        
                        for (const [nx, ny] of neighbors) {
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const nIdx = ny * width + nx;
                                const nElev = elevationData[nIdx];
                                if (nElev < lowestElev) {
                                    lowestElev = nElev;
                                    lowestIdx = nIdx;
                                }
                            }
                        }
                        
                        if (lowestIdx !== -1 && rainSimulation.state.waterDepth[idx] > 10) {
                            const flow = rainSimulation.state.waterDepth[idx] * 0.2;
                            rainSimulation.state.waterDepth[idx] -= flow;
                            rainSimulation.state.waterDepth[lowestIdx] += flow;
                        }
                    }
                }
                
                rainSimulation.state.currentHour++;
                updateWaterVisualization();
                updateRainStats();
            }
            
            function updateWaterVisualization() {
                if (!rainSimulation.waterMesh) return;
                
                const waterGeom = rainSimulation.waterMesh.geometry;
                const positions = waterGeom.attributes.position.array;
                const colors = waterGeom.attributes.color.array;
                
                rainSimulation.state.maxDepth = 0;
                
                for (let i = 0, idx = 0; i < height; i++) {
                    for (let j = 0; j < width; j++, idx++) {
                        const depth = rainSimulation.state.waterDepth[idx];
                        rainSimulation.state.maxDepth = Math.max(rainSimulation.state.maxDepth, depth);
                        
                        // Position at terrain height + water depth
                        const terrainHeight = vertices[idx * 3 + 2];
                        const waterHeight = Math.max(0, (depth / 1000) * scale);
                        positions[idx * 3 + 2] = terrainHeight + waterHeight;
                        
                        // Color based on depth
                        let r, g, b, alpha;
                        if (depth < 100) {
                            r = g = b = 0;
                            alpha = 0;
                        } else if (depth < 500) {
                            const t = (depth - 100) / 400;
                            r = 0.4 * t;
                            g = 0.8 - 0.3 * t;
                            b = 1.0;
                        } else {
                            const t = Math.min((depth - 500) / 500, 1);
                            r = 0.4 + 0.2 * t;
                            g = 0.5 - 0.2 * t;
                            b = 1.0 - 0.4 * t;
                        }
                        
                        colors[idx * 3] = r;
                        colors[idx * 3 + 1] = g;
                        colors[idx * 3 + 2] = b;
                    }
                }
                
                waterGeom.attributes.position.needsUpdate = true;
                waterGeom.attributes.color.needsUpdate = true;
                waterGeom.computeVertexNormals();
            }
            
            function updateRainStats() {
                const cellArea = metersPerSceneUnit * metersPerSceneUnit;
                let totalWater = 0;
                let totalSaturation = 0;
                
                for (let i = 0; i < width * height; i++) {
                    totalWater += (rainSimulation.state.waterDepth[i] / 1000) * cellArea;
                    totalSaturation += rainSimulation.state.soilSaturation[i];
                }
                
                rainSimulation.state.totalWaterLiters = totalWater;
                const avgSaturation = totalSaturation / (width * height);
                
                document.getElementById('statTime').textContent = 
                    rainSimulation.state.currentHour + ' / ' + rainSimulation.config.duration + ' hours';
                document.getElementById('statWater').textContent = 
                    (totalWater / 1000000).toFixed(2) + ' ML';
                document.getElementById('statDepth').textContent = 
                    rainSimulation.state.maxDepth.toFixed(1) + ' mm';
                document.getElementById('statSaturation').textContent = 
                    avgSaturation.toFixed(1) + '%';
            }
            
            function updateRainParticles(delta) {
                if (!rainSimulation.particles) return;
                
                const positions = rainSimulation.particles.geometry.attributes.position.array;
                const velocities = rainSimulation.particles.geometry.attributes.velocity.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] -= velocities[i / 3] * delta * 100;
                    
                    if (positions[i + 1] < 0) {
                        positions[i + 1] = scale * 200;
                        positions[i] = (Math.random() - 0.5) * width * scale;
                        positions[i + 2] = (Math.random() - 0.5) * height * scale;
                    }
                }
                
                rainSimulation.particles.geometry.attributes.position.needsUpdate = true;
            }
            
            // Track time for rain simulation advancement
            let rainSimTimeAccumulator = 0;
            const rainSimStepInterval = 1.0; // Advance simulation every 1 second
            
            function advanceRainSimulation(delta) {
                if (!rainSimulation.active || rainSimulation.paused) return;
                if (rainSimulation.state.currentHour >= rainSimulation.config.duration) return;
                
                rainSimTimeAccumulator += delta;
                
                if (rainSimTimeAccumulator >= rainSimStepInterval) {
                    rainSimTimeAccumulator -= rainSimStepInterval;
                    simulateRainStep();
                }
            }
            
            // Mouse/touch controls
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                           ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            
            // Touch controls (D-pad)
            const touchControls = document.createElement('div');
            touchControls.className = 'touch-controls';
            touchControls.id = 'touchControls';
            touchControls.innerHTML = `
                <div class="dpad-container">
                    <div class="dpad">
                        <div class="dpad-btn" id="dpad-up">W</div>
                        <div class="dpad-btn" id="dpad-down">S</div>
                        <div class="dpad-btn" id="dpad-left">A</div>
                        <div class="dpad-btn" id="dpad-right">D</div>
                    </div>
                </div>
                <div class="vertical-controls">
                    <div class="vertical-btn" id="btn-up">‚Üë</div>
                    <div class="vertical-btn" id="btn-down">‚Üì</div>
                </div>
            `;
            container.appendChild(touchControls);
            
            // Look zone for mobile
            const lookZone = document.createElement('div');
            lookZone.className = 'look-zone';
            container.appendChild(lookZone);
            
            const lookHint = document.createElement('div');
            lookHint.className = 'look-hint';
            if (isMobile) {
                lookHint.textContent = 'Swipe right side to look around';
            } else {
                lookHint.textContent = 'Click to look around (WASD to move, Space to fly)';
            }
            if (isMobile) {
                lookZone.appendChild(lookHint);
            } else {
                container.appendChild(lookHint);
            }
            
            setTimeout(() => {
                lookHint.classList.add('show');
                setTimeout(() => lookHint.classList.remove('show'), 5000);
            }, 1000);
            
            renderer.domElement.addEventListener('click', () => {
                if (!isMobile) {
                    renderer.domElement.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
                if (isPointerLocked) {
                    lookHint.classList.remove('show');
                }
            });
            
            const sensitivity = 0.002;
            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked) return;
                
                yaw -= e.movementX * sensitivity;
                pitch -= e.movementY * sensitivity;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                
                camera.rotation.set(pitch, yaw, 0);
            });
            
            // Touch controls implementation for mobile
            if (isMobile) {
                const dpadUp = document.getElementById('dpad-up');
                const dpadDown = document.getElementById('dpad-down');
                const dpadLeft = document.getElementById('dpad-left');
                const dpadRight = document.getElementById('dpad-right');
                const btnUp = document.getElementById('btn-up');
                const btnDown = document.getElementById('btn-down');
                
                function touchStart(key) {
                    return (e) => {
                        e.preventDefault();
                        keys[key] = true;
                    };
                }
                
                function touchEnd(key) {
                    return (e) => {
                        e.preventDefault();
                        keys[key] = false;
                    };
                }
                
                dpadUp.addEventListener('touchstart', touchStart('forward'));
                dpadUp.addEventListener('touchend', touchEnd('forward'));
                dpadDown.addEventListener('touchstart', touchStart('backward'));
                dpadDown.addEventListener('touchend', touchEnd('backward'));
                dpadLeft.addEventListener('touchstart', touchStart('left'));
                dpadLeft.addEventListener('touchend', touchEnd('left'));
                dpadRight.addEventListener('touchstart', touchStart('right'));
                dpadRight.addEventListener('touchend', touchEnd('right'));
                
                let lastUpBtnTap = 0;
                
                btnUp.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.up = true;
                    
                    const now = performance.now();
                    if (now - lastUpBtnTap < doubleTapDelay) {
                        isFlying = !isFlying;
                        updateFlyingModeStatus();
                    }
                    lastUpBtnTap = now;
                });
                
                btnUp.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.up = false;
                });
                
                btnDown.addEventListener('touchstart', touchStart('down'));
                btnDown.addEventListener('touchend', touchEnd('down'));
                
                // Touch look controls
                let touchStartX = 0;
                let touchStartY = 0;
                let isTouchingLookZone = false;
                
                lookZone.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        isTouchingLookZone = true;
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                        lookHint.classList.remove('show');
                    }
                });
                
                lookZone.addEventListener('touchmove', (e) => {
                    if (!isTouchingLookZone || e.touches.length !== 1) return;
                    e.preventDefault();
                    
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    
                    yaw -= deltaX * sensitivity * 2;
                    pitch -= deltaY * sensitivity * 2;
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                    
                    camera.rotation.set(pitch, yaw, 0);
                    
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                });
                
                lookZone.addEventListener('touchend', () => {
                    isTouchingLookZone = false;
                });
            }
            
            // Keyboard controls
            const keyMap = {
                'KeyW': 'forward',
                'KeyS': 'backward',
                'KeyA': 'left',
                'KeyD': 'right',
                'Space': 'up',
                'ShiftLeft': 'down',
                'ShiftRight': 'down'
            };
            
            document.addEventListener('keydown', (e) => {
                if (keyMap[e.code]) {
                    keys[keyMap[e.code]] = true;
                    e.preventDefault();
                }
                
                // Double-tap space to toggle fly mode
                if (e.code === 'Space') {
                    const now = Date.now();
                    if (now - lastUpTapTime < doubleTapDelay) {
                        isFlying = !isFlying;
                        updateFlyingModeStatus();
                        showToast(isFlying ? 'Flying mode enabled' : 'Running mode enabled');
                    }
                    lastUpTapTime = now;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (keyMap[e.code]) {
                    keys[keyMap[e.code]] = false;
                    e.preventDefault();
                }
            });
            
            // Movement
            function updateMovement(delta) {
                const moveSpeed = 10 * metersPerSceneUnit / scale;
                const flySpeed = 20 * metersPerSceneUnit / scale;
                
                direction.set(0, 0, 0);
                
                if (keys.forward) direction.z -= 1;
                if (keys.backward) direction.z += 1;
                if (keys.left) direction.x -= 1;
                if (keys.right) direction.x += 1;
                
                if (direction.length() > 0) {
                    direction.normalize();
                    direction.applyEuler(new THREE.Euler(0, yaw, 0));
                }
                
                const speed = isFlying ? flySpeed : moveSpeed;
                velocity.x = direction.x * speed;
                velocity.z = direction.z * speed;
                
                if (isFlying) {
                    if (keys.up) velocity.y = flySpeed;
                    else if (keys.down) velocity.y = -flySpeed;
                    else velocity.y = 0;
                } else {
                    velocity.y = 0;
                }
                
                camera.position.x += velocity.x * delta;
                camera.position.y += velocity.y * delta;
                camera.position.z += velocity.z * delta;
                
                // Keep camera above terrain
                if (!isFlying) {
                    const camX = camera.position.x;
                    const camZ = camera.position.z;
                    
                    const gridX = Math.floor((camX / scale + width / 2));
                    const gridZ = Math.floor((camZ / scale + height / 2));
                    
                    if (gridX >= 0 && gridX < width && gridZ >= 0 && gridZ < height) {
                        const idx = gridZ * width + gridX;
                        const terrainHeight = vertices[idx * 3 + 2];
                        camera.position.y = Math.max(camera.position.y, terrainHeight + playerHeight);
                    }
                }
            }
            
            function resetView() {
                camera.position.set(0, scale * 30, scale * 50);
                pitch = -0.3;
                yaw = 0;
                camera.rotation.set(pitch, yaw, 0);
            }
            
            function topView() {
                camera.position.set(0, scale * 150, 0);
                pitch = -Math.PI / 2;
                yaw = 0;
                camera.rotation.set(pitch, yaw, 0);
            }
            
            let autoRotate = false;
            function toggleAutoRotate() {
                autoRotate = !autoRotate;
                const btn = document.getElementById('autoRotateBtn');
                if (btn) btn.classList.toggle('active', autoRotate);
            }
            
            function toggleTexture() {
                if (!satelliteTexture) return;
                
                useTexture = !useTexture;
                const toggleBtn = document.getElementById('toggleTexture');
                
                if (useTexture) {
                    material.map = satelliteTexture;
                    material.vertexColors = false;
                    if (toggleBtn) toggleBtn.classList.add('active');
                } else {
                    material.map = null;
                    material.vertexColors = true;
                    if (toggleBtn) toggleBtn.classList.remove('active');
                }
                material.needsUpdate = true;
            }
            
            function updateVerticalScale(value) {
                const newScale = parseFloat(value);
                document.getElementById('scaleValue').textContent = newScale.toFixed(1);
                
                const vertices = geometry.attributes.position.array;
                for (let i = 0; i < originalHeightData.length; i++) {
                    vertices[i * 3 + 2] = originalHeightData[i] * (newScale / verticalExaggeration);
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
            }
            
            function toggleWireframe(checked) {
                material.wireframe = checked;
            }
            
            function updateFlyingModeStatus() {
                const statusDiv = document.getElementById('flyingModeStatus');
                if (statusDiv) {
                    if (isFlying) {
                        statusDiv.textContent = 'FLYING MODE';
                        statusDiv.style.background = 'rgba(33, 150, 243, 0.7)';
                    } else {
                        statusDiv.textContent = 'RUNNING MODE';
                        statusDiv.style.background = 'rgba(0, 0, 0, 0.3)';
                    }
                }
            }
            
            // Event listeners
            const resetBtn = document.getElementById('resetViewBtn');
            const topBtn = document.getElementById('topViewBtn');
            const autoBtn = document.getElementById('autoRotateBtn');
            const textureBtn = document.getElementById('toggleTexture');
            const scaleSlider = document.getElementById('verticalScale');
            const wireframeCheck = document.getElementById('wireframeToggle');
            
            if (resetBtn) resetBtn.addEventListener('click', resetView);
            if (topBtn) topBtn.addEventListener('click', topView);
            if (autoBtn) autoBtn.addEventListener('click', toggleAutoRotate);
            if (textureBtn) textureBtn.addEventListener('click', toggleTexture);
            if (scaleSlider) scaleSlider.addEventListener('input', (e) => updateVerticalScale(e.target.value));
            if (wireframeCheck) wireframeCheck.addEventListener('change', (e) => toggleWireframe(e.target.checked));
            
            // Animation loop
            let lastTime = performance.now();
            
            function animate() {
                requestAnimationFrame(animate);
                
                const currentTime = performance.now();
                const delta = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                updateMovement(delta);
                
                if (autoRotate && !Object.values(keys).some(v => v)) {
                    yaw += 0.01;
                    camera.rotation.y = yaw;
                }
                
                // Update rain particles and advance simulation
                if (rainSimulation.active && rainSimulation.particles && rainSimulation.particles.visible) {
                    updateRainParticles(delta);
                    advanceRainSimulation(delta);
                }
                
                renderer.render(scene, camera);
            }
            
            animate();
            updateMovement(0);
            
            // Handle resize
            const resizeHandler = () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            };
            window.addEventListener('resize', resizeHandler);
        }

        // Open 3D viewer
        function open3DViewer() {
            if (currentElevationData) {
                create3DTerrain(
                    currentElevationData.elevationData,
                    currentElevationData.width,
                    currentElevationData.height,
                    currentElevationData.bottomLeft,
                    currentElevationData.topRight
                );
            } else {
                const modal = document.getElementById('modal3d');
                const container = document.getElementById('viewer3d');
                
                // FIXED: Don't destroy essential UI elements - just hide the renderer if it exists
                // and show a placeholder message
                const existingCanvas = container.querySelector('canvas');
                if (existingCanvas) {
                    existingCanvas.style.display = 'none';
                }
                
                // Check if placeholder already exists
                let placeholder = container.querySelector('.no-data-placeholder');
                if (!placeholder) {
                    placeholder = document.createElement('div');
                    placeholder.className = 'no-data-placeholder';
                    placeholder.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-size: 18px; text-align: center; z-index: 5;';
                    placeholder.innerHTML = '<div><p>üìÇ Click "Load Data" to import a terrain file</p><p style="margin-top: 10px; font-size: 14px; color: #aaa;">or use "Select Area" on the map to fetch elevation data</p></div>';
                    container.appendChild(placeholder);
                } else {
                    placeholder.style.display = 'flex';
                }
            }
        }

        // Toggle rain panel
        function toggleRainPanel() {
            const panel = document.getElementById('rainPanel');
            panel.classList.toggle('show');
        }

        // Event listeners
        document.getElementById('locationBtn').addEventListener('click', getUserLocation);
        document.getElementById('contoursBtn').addEventListener('click', toggleContours);
        document.getElementById('satelliteBtn').addEventListener('click', toggleSatellite);
        document.getElementById('selectAreaBtn').addEventListener('click', toggleAreaSelection);
        document.getElementById('open3DViewerBtn').addEventListener('click', open3DViewer);
        document.getElementById('rainSimBtn').addEventListener('click', toggleRainPanel);
        document.getElementById('saveDataBtn').addEventListener('click', saveTerrainData);
        document.getElementById('saveDataBtn3D').addEventListener('click', saveTerrainData);
        document.getElementById('loadDataBtn').addEventListener('click', () => {
            debug('Load button clicked (main)');
            document.getElementById('fileInput').click();
        });
        document.getElementById('loadDataBtn3D').addEventListener('click', () => {
            debug('Load button clicked (3D viewer)');
            document.getElementById('fileInput').click();
        });
        document.getElementById('fileInput').addEventListener('change', (e) => {
            debug('File input changed, files: ' + e.target.files.length);
            if (e.target.files.length > 0) {
                debug('Loading file: ' + e.target.files[0].name);
                loadTerrainData(e.target.files[0]);
                // Reset file input so the same file can be loaded again
                e.target.value = '';
            }
        });

        // Popup for location
        const popup = new ol.Overlay({
            element: document.createElement('div'),
            positioning: 'bottom-center',
            stopEvent: false,
            offset: [0, -10]
        });
        map.addOverlay(popup);

        map.on('click', (evt) => {
            if (isSelecting) return;
            
            const feature = map.forEachFeatureAtPixel(evt.pixel, (feature) => feature);
            
            if (feature && feature.get('name') === 'Your Location') {
                const coordinates = feature.getGeometry().getCoordinates();
                const lonLat = ol.proj.toLonLat(coordinates);
                
                const popupElement = popup.getElement();
                popupElement.innerHTML = `
                    <div style="background: white; padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); font-size: 13px;">
                        <strong>Your Location</strong><br>
                        <span style="color: #666;">
                            Lat: ${lonLat[1].toFixed(6)}<br>
                            Lon: ${lonLat[0].toFixed(6)}
                        </span>
                    </div>
                `;
                popup.setPosition(coordinates);
            } else {
                popup.setPosition(undefined);
            }
        });

        map.on('pointermove', (evt) => {
            if (isSelecting) {
                map.getTarget().style.cursor = 'crosshair';
                return;
            }
            
            const pixel = map.getEventPixel(evt.originalEvent);
            const hit = map.hasFeatureAtPixel(pixel);
            map.getTarget().style.cursor = hit ? 'pointer' : '';
        });

        // Auto-open 3D viewer on page load
        window.addEventListener('load', () => {
            open3DViewer();
        });
    </script>
</body>
</html>
