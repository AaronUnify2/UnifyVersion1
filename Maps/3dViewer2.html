<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Terrain Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            color: white;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }

        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .logo {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #fff, #e0e0e0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .upload-area {
            background: rgba(255, 255, 255, 0.1);
            border: 3px dashed rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 40px 60px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .upload-area:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.02);
        }

        .upload-area input {
            display: none;
        }

        .upload-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 20px;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .upload-hint {
            font-size: 14px;
            opacity: 0.7;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }

        .loading-spinner.active {
            display: block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            margin-top: 10px;
            display: none;
        }

        .loading-text.active {
            display: block;
        }

        /* Control Panel */
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            min-width: 280px;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
        }

        .control-panel.collapsed {
            transform: translateX(calc(100% + 20px));
        }

        .control-panel-toggle {
            position: absolute;
            left: -50px;
            top: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s;
        }

        .control-panel-toggle:hover {
            background: rgba(103, 126, 234, 0.8);
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .control-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            opacity: 0.7;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .control-btn {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .control-btn.active {
            background: rgba(103, 126, 234, 0.5);
            border-color: #677eea;
        }

        .control-btn:last-child {
            margin-bottom: 0;
        }

        .btn-icon {
            margin-right: 8px;
        }

        .toggle-indicator {
            width: 40px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            position: relative;
            transition: background 0.3s;
        }

        .toggle-indicator::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .control-btn.active .toggle-indicator {
            background: #677eea;
        }

        .control-btn.active .toggle-indicator::after {
            transform: translateX(20px);
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 13px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-label {
            opacity: 0.7;
        }

        .info-value {
            font-weight: 600;
        }

        .stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            font-family: monospace;
            z-index: 1000;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px 30px;
            max-width: 600px;
            z-index: 1000;
            transition: all 0.3s;
            opacity: 0;
            pointer-events: none;
        }

        .instructions.show {
            opacity: 1;
            pointer-events: all;
        }

        .instructions-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }

        .instructions-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .instruction-item {
            display: flex;
            align-items: center;
            font-size: 13px;
        }

        .instruction-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 5px;
            margin-right: 10px;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div class="logo">üèîÔ∏è TerrainView</div>
        <div class="upload-area" id="uploadArea">
            <input type="file" id="fileInput" accept=".json">
            <div class="upload-icon">üìÅ</div>
            <div class="upload-text">Click or drag JSON file here</div>
            <div class="upload-hint">Supports terrain elevation data in JSON format</div>
        </div>
        <div class="loading-spinner" id="loadingSpinner"></div>
        <div class="loading-text" id="loadingText">Loading terrain...</div>
    </div>

    <div id="container"></div>

    <div class="stats" id="stats">FPS: 60</div>

    <div class="control-panel" id="controlPanel">
        <div class="control-panel-toggle" id="controlPanelToggle">‚óÄ</div>
        
        <div class="control-section">
            <div class="control-title">Visualization</div>
            <button class="control-btn active" id="elevationToggle">
                <span><span class="btn-icon">üé®</span>Elevation Colors</span>
                <div class="toggle-indicator"></div>
            </button>
            <button class="control-btn" id="satelliteToggle">
                <span><span class="btn-icon">üõ∞Ô∏è</span>Satellite View</span>
                <div class="toggle-indicator"></div>
            </button>
        </div>

        <div class="control-section">
            <div class="control-title">Camera</div>
            <button class="control-btn" id="autoRotateToggle">
                <span><span class="btn-icon">üîÑ</span>Auto Rotate</span>
                <div class="toggle-indicator"></div>
            </button>
            <button class="control-btn" id="resetCamera">
                <span><span class="btn-icon">üéØ</span>Reset Camera</span>
            </button>
            <button class="control-btn" id="topViewCamera">
                <span><span class="btn-icon">‚¨áÔ∏è</span>Top View</span>
            </button>
            <button class="control-btn" id="walkModeToggle">
                <span><span class="btn-icon">üïäÔ∏è</span>Fly Mode (R)</span>
                <div class="toggle-indicator"></div>
            </button>
        </div>

        <div class="control-section">
            <div class="control-title">Terrain Info</div>
            <div class="info-item">
                <span class="info-label">Size:</span>
                <span class="info-value" id="terrainSize">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">Elevation:</span>
                <span class="info-value" id="elevationRange">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">Grid:</span>
                <span class="info-value" id="gridResolution">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">Position:</span>
                <span class="info-value" id="cameraPosition">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">Altitude:</span>
                <span class="info-value" id="cameraAltitude">-</span>
            </div>
        </div>

        <div class="control-section">
            <button class="control-btn" id="showInstructions">
                <span><span class="btn-icon">‚ùì</span>Show Controls</span>
            </button>
        </div>
    </div>

    <div class="instructions" id="instructions">
        <button class="close-btn" id="closeInstructions">√ó</button>
        <div class="instructions-title">Controls</div>
        <div class="instructions-grid">
            <div class="instruction-item">
                <div class="instruction-key">W/S</div>
                <div>Move Forward/Back</div>
            </div>
            <div class="instruction-item">
                <div class="instruction-key">A/D</div>
                <div>Move Left/Right</div>
            </div>
            <div class="instruction-item">
                <div class="instruction-key">Space/Shift</div>
                <div>Move Up/Down</div>
            </div>
            <div class="instruction-item">
                <div class="instruction-key">Mouse</div>
                <div>Look Around</div>
            </div>
            <div class="instruction-item">
                <div class="instruction-key">R</div>
                <div>Toggle Walk/Fly</div>
            </div>
            <div class="instruction-item">
                <div class="instruction-key">F</div>
                <div>Fullscreen</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, terrainMesh, terrainGeometry, terrainMaterial;
        let satelliteTexture = null;
        let terrainData = null;
        let autoRotate = false;
        let showElevation = true;
        let showSatellite = false;
        let walkMode = false;
        
        // Camera controls
        const rotation = new THREE.Euler(0, 0, 0, 'YXZ');
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const WALK_SPEED = 400;
        const FLY_SPEED = 800;
        const CAMERA_HEIGHT_OFFSET = 10;
        
        // Movement state
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false;
        
        // Performance monitoring
        let fps = 0, frames = 0, lastTime = performance.now();
        const clock = new THREE.Clock();

        init();
        setupFileUpload();
        setupEventListeners();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 500, 2000);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                5000
            );
            camera.position.set(0, 100, 200);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 200, 100);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x6B8E23, 0.4);
            scene.add(hemiLight);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', () => {
                if (terrainData) {
                    renderer.domElement.requestPointerLock();
                }
            });
        }

        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            uploadArea.addEventListener('click', () => fileInput.click());

            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = 'rgba(255, 255, 255, 0.8)';
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                const file = e.dataTransfer.files[0];
                if (file && file.name.endsWith('.json')) {
                    handleFile(file);
                }
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFile(file);
                }
            });
        }

        function handleFile(file) {
            const reader = new FileReader();
            
            document.getElementById('loadingSpinner').classList.add('active');
            document.getElementById('loadingText').classList.add('active');

            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    terrainData = parseTerrainData(jsonData);
                    createTerrain();
                    updateInfoPanel();
                    
                    setTimeout(() => {
                        document.getElementById('loadingScreen').classList.add('hidden');
                        animate();
                    }, 500);
                } catch (error) {
                    console.error('Error parsing terrain data:', error);
                    alert('Error loading terrain data. Please check the file format.');
                    document.getElementById('loadingSpinner').classList.remove('active');
                    document.getElementById('loadingText').classList.remove('active');
                }
            };

            reader.readAsText(file);
        }

        function parseTerrainData(jsonData) {
            // Parse the new JSON format with flat elevationData array
            const width = jsonData.width || 80;
            const height = jsonData.height || 80;
            const elevationData = jsonData.elevationData || [];
            
            // Convert flat array to 2D grid
            const elevationGrid = [];
            for (let y = 0; y < height; y++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    const index = y * width + x;
                    const elevation = elevationData[index] || 0;
                    row.push({
                        elevation: elevation === 0 ? 'NoData' : elevation,
                        lat: 0,
                        lon: 0
                    });
                }
                elevationGrid.push(row);
            }

            // Calculate min and max elevation (excluding 0/NoData values)
            const validElevations = elevationData.filter(e => e !== 0);
            const minElev = Math.min(...validElevations);
            const maxElev = Math.max(...validElevations);

            // Parse coordinates
            const bottomLeft = jsonData.bottomLeft || [0, 0];
            const topRight = jsonData.topRight || [1, 1];

            return {
                elevationGrid: elevationGrid,
                metadata: {
                    gridSize: width,
                    bounds: {
                        minLon: bottomLeft[0],
                        maxLon: topRight[0],
                        minLat: bottomLeft[1],
                        maxLat: topRight[1]
                    },
                    elevation: {
                        min: minElev,
                        max: maxElev
                    },
                    center: {
                        lat: (bottomLeft[1] + topRight[1]) / 2,
                        lon: (bottomLeft[0] + topRight[0]) / 2
                    },
                    dataSource: jsonData.dataSource || 'Unknown',
                    timestamp: jsonData.timestamp || new Date().toISOString()
                }
            };
        }

        function createTerrain() {
            if (terrainMesh) {
                scene.remove(terrainMesh);
            }

            const gridSize = terrainData.metadata.gridSize;
            const bounds = terrainData.metadata.bounds;
            const elevationGrid = terrainData.elevationGrid;

            // Calculate terrain dimensions in meters
            const lonDiff = bounds.maxLon - bounds.minLon;
            const latDiff = bounds.maxLat - bounds.minLat;
            const widthMeters = lonDiff * 111320 * Math.cos(terrainData.metadata.center.lat * Math.PI / 180);
            const heightMeters = latDiff * 110540;

            // Create geometry
            terrainGeometry = new THREE.PlaneGeometry(
                widthMeters,
                heightMeters,
                gridSize - 1,
                gridSize - 1
            );

            // Set vertex heights and colors
            const vertices = terrainGeometry.attributes.position.array;
            const colors = new Float32Array(vertices.length);
            const minElev = terrainData.metadata.elevation.min;
            const maxElev = terrainData.metadata.elevation.max;
            const elevRange = maxElev - minElev;

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const vertexIndex = (i * gridSize + j) * 3;
                    const gridRow = gridSize - 1 - i;
                    const elevation = elevationGrid[gridRow][j].elevation;
                    
                    const actualElevation = elevation === 'NoData' ? 0 : elevation;
                    vertices[vertexIndex + 2] = actualElevation * 1.5; // Vertical exaggeration

                    // Color based on elevation
                    const normalizedElev = elevRange > 0 ? (actualElevation - minElev) / elevRange : 0;
                    const color = getElevationColor(normalizedElev);
                    colors[vertexIndex] = color.r;
                    colors[vertexIndex + 1] = color.g;
                    colors[vertexIndex + 2] = color.b;
                }
            }

            terrainGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            terrainGeometry.computeVertexNormals();

            // Create material
            terrainMaterial = new THREE.MeshStandardMaterial({
                vertexColors: true,
                flatShading: false,
                roughness: 0.8,
                metalness: 0.2
            });

            // Create mesh
            terrainMesh = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrainMesh.rotation.x = -Math.PI / 2;
            scene.add(terrainMesh);

            // Position camera
            camera.position.set(0, maxElev + 50, heightMeters * 0.4);
            rotation.set(0, Math.PI, 0);
        }

        function getElevationColor(normalizedElev) {
            // Color gradient from low (blue) to high (white/red)
            const colors = [
                { stop: 0.0, color: { r: 0.0, g: 0.3, b: 0.8 } },  // Deep blue (water/low)
                { stop: 0.2, color: { r: 0.0, g: 0.6, b: 0.3 } },  // Green (low land)
                { stop: 0.4, color: { r: 0.4, g: 0.7, b: 0.2 } },  // Light green
                { stop: 0.6, color: { r: 0.8, g: 0.7, b: 0.3 } },  // Yellow (mid elevation)
                { stop: 0.8, color: { r: 0.7, g: 0.4, b: 0.2 } },  // Brown (high)
                { stop: 1.0, color: { r: 1.0, g: 1.0, b: 1.0 } }   // White (peaks)
            ];

            // Find the two colors to interpolate between
            let lowerColor = colors[0];
            let upperColor = colors[colors.length - 1];

            for (let i = 0; i < colors.length - 1; i++) {
                if (normalizedElev >= colors[i].stop && normalizedElev <= colors[i + 1].stop) {
                    lowerColor = colors[i];
                    upperColor = colors[i + 1];
                    break;
                }
            }

            // Interpolate
            const range = upperColor.stop - lowerColor.stop;
            const t = range > 0 ? (normalizedElev - lowerColor.stop) / range : 0;

            return {
                r: lowerColor.color.r + (upperColor.color.r - lowerColor.color.r) * t,
                g: lowerColor.color.g + (upperColor.color.g - lowerColor.color.g) * t,
                b: lowerColor.color.b + (upperColor.color.b - lowerColor.color.b) * t
            };
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': moveUp = true; event.preventDefault(); break;
                case 'ShiftLeft': moveDown = true; break;
                case 'KeyR': toggleWalkMode(); break;
                case 'KeyF': toggleFullscreen(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'Space': moveUp = false; break;
                case 'ShiftLeft': moveDown = false; break;
            }
        }

        function onMouseMove(event) {
            if (document.pointerLockElement === renderer.domElement) {
                const sensitivity = 0.002;
                rotation.y -= event.movementX * sensitivity;
                rotation.x -= event.movementY * sensitivity;
                rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));
            }
        }

        function toggleWalkMode() {
            walkMode = !walkMode;
            const btn = document.getElementById('walkModeToggle');
            if (walkMode) {
                btn.classList.add('active');
                btn.querySelector('span').innerHTML = '<span class="btn-icon">üö∂</span>Walk Mode (R)';
            } else {
                btn.classList.remove('active');
                btn.querySelector('span').innerHTML = '<span class="btn-icon">üïäÔ∏è</span>Fly Mode (R)';
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function getTerrainHeightAt(x, z) {
            // Get terrain height at world position
            if (!terrainGeometry) return 0;
            
            const gridSize = terrainData.metadata.gridSize;
            const bounds = terrainData.metadata.bounds;
            
            const lonDiff = bounds.maxLon - bounds.minLon;
            const latDiff = bounds.maxLat - bounds.minLat;
            const widthMeters = lonDiff * 111320 * Math.cos(terrainData.metadata.center.lat * Math.PI / 180);
            const heightMeters = latDiff * 110540;
            
            // Convert world position to grid coordinates
            const gridX = ((x + widthMeters / 2) / widthMeters) * (gridSize - 1);
            const gridZ = ((z + heightMeters / 2) / heightMeters) * (gridSize - 1);
            
            // Clamp to grid bounds
            const clampedX = Math.max(0, Math.min(gridSize - 1, gridX));
            const clampedZ = Math.max(0, Math.min(gridSize - 1, gridZ));
            
            // Get the four surrounding points
            const x0 = Math.floor(clampedX);
            const x1 = Math.min(gridSize - 1, Math.ceil(clampedX));
            const z0 = Math.floor(clampedZ);
            const z1 = Math.min(gridSize - 1, Math.ceil(clampedZ));
            
            // Get elevations
            const elevationGrid = terrainData.elevationGrid;
            const e00 = elevationGrid[gridSize - 1 - z0][x0].elevation === 'NoData' ? 0 : elevationGrid[gridSize - 1 - z0][x0].elevation;
            const e10 = elevationGrid[gridSize - 1 - z0][x1].elevation === 'NoData' ? 0 : elevationGrid[gridSize - 1 - z0][x1].elevation;
            const e01 = elevationGrid[gridSize - 1 - z1][x0].elevation === 'NoData' ? 0 : elevationGrid[gridSize - 1 - z1][x0].elevation;
            const e11 = elevationGrid[gridSize - 1 - z1][x1].elevation === 'NoData' ? 0 : elevationGrid[gridSize - 1 - z1][x1].elevation;
            
            // Bilinear interpolation
            const tx = clampedX - x0;
            const tz = clampedZ - z0;
            
            const e0 = e00 * (1 - tx) + e10 * tx;
            const e1 = e01 * (1 - tx) + e11 * tx;
            const elevation = e0 * (1 - tz) + e1 * tz;
            
            return elevation * 1.5; // Match vertical scale
        }

        function updateMovement(delta) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= velocity.y * 10.0 * delta;
            
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.y = Number(moveUp) - Number(moveDown);
            direction.normalize();
            
            const speed = walkMode ? WALK_SPEED : FLY_SPEED;
            
            if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
            if (moveUp || moveDown) velocity.y += direction.y * speed * delta;
            
            // Apply rotation
            camera.quaternion.setFromEuler(rotation);
            
            // Move camera
            const moveVector = new THREE.Vector3();
            moveVector.set(velocity.x, 0, velocity.z);
            moveVector.applyQuaternion(camera.quaternion);
            
            camera.position.x += moveVector.x * delta;
            camera.position.z += moveVector.z * delta;
            
            if (!walkMode) {
                camera.position.y += velocity.y * delta;
            } else {
                // In walk mode, maintain height above terrain
                const terrainHeight = getTerrainHeightAt(camera.position.x, camera.position.z);
                const targetHeight = terrainHeight + CAMERA_HEIGHT_OFFSET;
                camera.position.y += (targetHeight - camera.position.y) * 5.0 * delta;
            }
        }

        function updateInfoPanel() {
            if (!terrainData) return;
            
            const bounds = terrainData.metadata.bounds;
            const lonDiff = bounds.maxLon - bounds.minLon;
            const latDiff = bounds.maxLat - bounds.minLat;
            const widthKm = (lonDiff * 111.32 * Math.cos(terrainData.metadata.center.lat * Math.PI / 180)).toFixed(2);
            const heightKm = (latDiff * 110.54).toFixed(2);
            
            document.getElementById('terrainSize').textContent = `${widthKm} √ó ${heightKm} km`;
            
            const minElev = terrainData.metadata.elevation.min || 0;
            const maxElev = terrainData.metadata.elevation.max || 0;
            document.getElementById('elevationRange').textContent = `${minElev.toFixed(1)}m - ${maxElev.toFixed(1)}m`;
            
            document.getElementById('gridResolution').textContent = `${terrainData.metadata.gridSize} √ó ${terrainData.metadata.gridSize}`;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update movement
            updateMovement(delta);
            
            // Auto rotate
            if (autoRotate) {
                rotation.y += 0.2 * delta;
            }
            
            // Update position info
            const terrainHeight = getTerrainHeightAt(camera.position.x, camera.position.z);
            const altitude = camera.position.y - terrainHeight;
            document.getElementById('cameraPosition').textContent = 
                `${camera.position.x.toFixed(1)}, ${camera.position.z.toFixed(1)}`;
            document.getElementById('cameraAltitude').textContent = `${altitude.toFixed(1)}m`;
            
            // Update FPS
            frames++;
            const now = performance.now();
            if (now >= lastTime + 1000) {
                fps = Math.round((frames * 1000) / (now - lastTime));
                document.getElementById('stats').textContent = `FPS: ${fps}`;
                frames = 0;
                lastTime = now;
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupEventListeners() {
            // Control panel toggle
            document.getElementById('controlPanelToggle').addEventListener('click', function() {
                const panel = document.getElementById('controlPanel');
                panel.classList.toggle('collapsed');
                this.textContent = panel.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
            });
            
            // Satellite toggle
            document.getElementById('satelliteToggle').addEventListener('click', function() {
                showSatellite = !showSatellite;
                this.classList.toggle('active');
                
                if (showSatellite && satelliteTexture) {
                    terrainMaterial.map = satelliteTexture;
                    terrainMaterial.vertexColors = false;
                } else {
                    terrainMaterial.map = null;
                    terrainMaterial.vertexColors = showElevation;
                }
                terrainMaterial.needsUpdate = true;
            });
            
            // Elevation toggle
            document.getElementById('elevationToggle').addEventListener('click', function() {
                showElevation = !showElevation;
                this.classList.toggle('active');
                
                if (!showSatellite) {
                    terrainMaterial.vertexColors = showElevation;
                    terrainMaterial.needsUpdate = true;
                }
            });
            
            // Auto rotate
            document.getElementById('autoRotateToggle').addEventListener('click', function() {
                autoRotate = !autoRotate;
                this.classList.toggle('active');
            });
            
            // Reset camera
            document.getElementById('resetCamera').addEventListener('click', () => {
                const bounds = terrainData.metadata.bounds;
                const maxElevation = terrainData.metadata.elevation.max || 100;
                camera.position.set(0, maxElevation + 50, 200);
                rotation.set(0, Math.PI, 0);
            });
            
            // Top view
            document.getElementById('topViewCamera').addEventListener('click', () => {
                const maxElevation = terrainData.metadata.elevation.max || 100;
                camera.position.set(0, maxElevation + 300, 0);
                rotation.set(-Math.PI / 2, 0, 0);
            });
            
            // Walk mode toggle
            document.getElementById('walkModeToggle').addEventListener('click', toggleWalkMode);
            
            // Instructions
            document.getElementById('showInstructions').addEventListener('click', () => {
                document.getElementById('instructions').classList.add('show');
            });
            
            document.getElementById('closeInstructions').addEventListener('click', () => {
                document.getElementById('instructions').classList.remove('show');
            });
        }
    </script>
</body>
</html>
