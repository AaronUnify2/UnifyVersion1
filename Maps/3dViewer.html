<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map with 3D Terrain Generator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.2.1/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v10.2.1/dist/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 15px;
            z-index: 1000;
        }

        .control-btn {
            display: block;
            width: 100%;
            padding: 12px 20px;
            margin-bottom: 10px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            color: #333;
            touch-action: manipulation;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .control-btn {
                padding: 14px 22px;
                font-size: 16px;
            }
        }

        .control-btn:last-child {
            margin-bottom: 0;
        }

        .control-btn:hover {
            background: #f5f5f5;
            border-color: #2196F3;
        }

        .control-btn.active {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Toast notification */
        .toast {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 2000;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 12px 15px;
            font-size: 12px;
            z-index: 1000;
            max-width: 200px;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            color: #666;
        }

        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 8px;
            background: #8B4513;
        }

        /* 3D Viewer Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            width: 90%;
            height: 90%;
            background: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            background: #2a2a2a;
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .modal-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .modal-title {
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            min-width: 80px;
            touch-action: manipulation;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .modal-close {
                padding: 12px 20px;
                font-size: 16px;
                min-width: 100px;
            }
        }

        .modal-close:hover {
            background: #ff6666;
        }

        .modal-close[style*="4CAF50"]:hover {
            background: #66BB6A !important;
        }

        .modal-close[style*="2196F3"]:hover {
            background: #42A5F5 !important;
        }

        .modal-close[style*="666"]:hover {
            background: #888 !important;
        }

        /* Toolbar controls */
        .toolbar-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .toolbar-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .toolbar-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .toolbar-btn.active {
            background: #2196F3;
            border-color: #2196F3;
        }

        .toolbar-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-label input[type="range"] {
            width: 120px;
        }

        .toolbar-label input[type="checkbox"] {
            cursor: pointer;
        }

        #flyingModeStatus {
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-weight: bold;
            font-size: 12px;
            color: white;
        }

        #viewer3d {
            flex: 1;
            width: 100%;
            position: relative;
        }

        .loading-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 8px;
            z-index: 10001;
            display: none;
            text-align: center;
        }

        .loading-overlay.show {
            display: block;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Pointer lock info */
        .pointer-lock-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px 40px;
            border-radius: 12px;
            text-align: center;
            z-index: 200;
            max-width: 500px;
            transition: opacity 0.3s ease;
        }

        .pointer-lock-info.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .pointer-lock-info h2 {
            margin-bottom: 15px;
            font-size: 24px;
        }

        .pointer-lock-info p {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .pointer-lock-info strong {
            color: #2196F3;
        }

        /* Controls hint */
        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 100;
            transition: opacity 0.3s ease;
        }

        .controls-hint.hidden {
            opacity: 0;
        }

        /* Touch controls */
        .touch-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            display: none;
        }

        @media (max-width: 768px), (pointer: coarse) {
            .touch-controls {
                display: block;
            }
        }

        .dpad-container {
            position: relative;
            width: 140px;
            height: 140px;
        }

        .dpad {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .dpad-btn {
            position: absolute;
            width: 45px;
            height: 45px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .dpad-btn:active {
            background: rgba(33, 150, 243, 0.6);
            border-color: rgba(33, 150, 243, 0.8);
            transform: scale(0.95);
        }

        #dpad-up {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        #dpad-down {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        #dpad-left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        #dpad-right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .vertical-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .vertical-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .vertical-btn:active {
            background: rgba(33, 150, 243, 0.6);
            border-color: rgba(33, 150, 243, 0.8);
            transform: scale(0.95);
        }

        /* Look zone for touch look controls */
        .look-zone {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            z-index: 50;
            touch-action: none;
        }

        .look-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .look-hint.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="control-panel">
        <button id="locationBtn" class="control-btn">üìç Get Location</button>
        <button id="contoursBtn" class="control-btn">üìà Toggle Contours</button>
        <button id="satelliteBtn" class="control-btn">üõ∞Ô∏è Toggle Satellite</button>
        <button id="selectAreaBtn" class="control-btn">üìê Select Area</button>
        <button id="open3DViewerBtn" class="control-btn">üéÆ 3D Viewer</button>
        <button id="saveDataBtn" class="control-btn">üíæ Save Data</button>
        <button id="loadDataBtn" class="control-btn">üìÇ Load Data</button>
    </div>

    <div class="legend">
        <div class="legend-title">Contours</div>
        <div class="legend-item">
            <div class="legend-line"></div>
            <span>10m intervals</span>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- 3D Viewer Modal -->
    <div class="modal" id="modal3d">
        <div class="modal-content">
            <div class="modal-header">
                <!-- First row: Title and main buttons -->
                <div class="modal-header-row">
                    <span class="modal-title">üóª 3D Terrain Viewer</span>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button id="saveDataBtn3D" class="modal-close" style="background: #4CAF50;">üíæ Save</button>
                        <button id="loadDataBtn3D" class="modal-close" style="background: #2196F3;">üìÇ Load</button>
                        <button id="closeModal" class="modal-close">‚úï Close</button>
                    </div>
                </div>
                
                <!-- Second row: Controls -->
                <div class="toolbar-controls">
                    <div id="flyingModeStatus">RUNNING MODE</div>
                    <button id="resetViewBtn" class="toolbar-btn">Reset View</button>
                    <button id="topViewBtn" class="toolbar-btn">Top View</button>
                    <button id="autoRotateBtn" class="toolbar-btn">Auto-Rotate</button>
                    <button id="toggleTexture" class="toolbar-btn" style="display: none;">Toggle Texture</button>
                    <label class="toolbar-label">
                        Scale: <span id="scaleValue">0.1</span>x
                        <input type="range" id="verticalScale" min="0.1" max="5" step="0.1" value="0.1">
                    </label>
                    <label class="toolbar-label">
                        <input type="checkbox" id="wireframeToggle"> Wireframe
                    </label>
                </div>
            </div>
            <div id="viewer3d">
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div>Generating 3D terrain...</div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display: none;">

    <script>
        // Debug function
        function debug(msg) {
            console.log('[3D Terrain] ' + msg);
        }

        // Toast notification
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Initialize map
        const map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM()
                })
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([0, 0]),
                zoom: 2
            })
        });

        // State
        let currentElevationData = null;
        let contoursVisible = false;
        let satelliteVisible = false;
        let isSelecting = false;
        let selectionBox = null;
        let startCoord = null;

        // Layers
        const satelliteLayer = new ol.layer.Tile({
            source: new ol.source.XYZ({
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                maxZoom: 19
            }),
            visible: false
        });

        const contoursLayer = new ol.layer.Vector({
            source: new ol.source.Vector(),
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: '#8B4513',
                    width: 1
                })
            }),
            visible: false
        });

        const selectionLayer = new ol.layer.Vector({
            source: new ol.source.Vector(),
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: 'rgba(33, 150, 243, 0.8)',
                    width: 2,
                    lineDash: [5, 5]
                }),
                fill: new ol.style.Fill({
                    color: 'rgba(33, 150, 243, 0.1)'
                })
            })
        });

        map.addLayer(satelliteLayer);
        map.addLayer(contoursLayer);
        map.addLayer(selectionLayer);

        // Location marker
        const locationLayer = new ol.layer.Vector({
            source: new ol.source.Vector()
        });
        map.addLayer(locationLayer);

        // Get user location
        function getUserLocation() {
            if (!navigator.geolocation) {
                showToast('Geolocation not supported');
                return;
            }

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const coords = [position.coords.longitude, position.coords.latitude];
                    const location = ol.proj.fromLonLat(coords);
                    
                    map.getView().setCenter(location);
                    map.getView().setZoom(15);
                    
                    locationLayer.getSource().clear();
                    const marker = new ol.Feature({
                        geometry: new ol.geom.Point(location),
                        name: 'Your Location'
                    });
                    
                    marker.setStyle(new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 8,
                            fill: new ol.style.Fill({ color: '#2196F3' }),
                            stroke: new ol.style.Stroke({
                                color: 'white',
                                width: 3
                            })
                        })
                    }));
                    
                    locationLayer.getSource().addFeature(marker);
                    showToast('Location found!');
                },
                (error) => {
                    showToast('Could not get location');
                }
            );
        }

        // Toggle contours
        function toggleContours() {
            contoursVisible = !contoursVisible;
            contoursLayer.setVisible(contoursVisible);
            document.getElementById('contoursBtn').classList.toggle('active', contoursVisible);
        }

        // Toggle satellite
        function toggleSatellite() {
            satelliteVisible = !satelliteVisible;
            satelliteLayer.setVisible(satelliteVisible);
            document.getElementById('satelliteBtn').classList.toggle('active', satelliteVisible);
        }

        // Area selection
        function toggleAreaSelection() {
            isSelecting = !isSelecting;
            const btn = document.getElementById('selectAreaBtn');
            btn.classList.toggle('active', isSelecting);
            
            if (!isSelecting) {
                selectionLayer.getSource().clear();
                startCoord = null;
                selectionBox = null;
            }
            
            showToast(isSelecting ? 'Click and drag to select area' : 'Selection cancelled');
        }

        map.on('pointerdown', (evt) => {
            if (!isSelecting) return;
            startCoord = evt.coordinate;
            selectionBox = null;
        });

        map.on('pointerdrag', (evt) => {
            if (!isSelecting || !startCoord) return;
            
            const extent = ol.extent.boundingExtent([startCoord, evt.coordinate]);
            
            if (selectionBox) {
                selectionBox.setGeometry(ol.geom.Polygon.fromExtent(extent));
            } else {
                selectionBox = new ol.Feature(ol.geom.Polygon.fromExtent(extent));
                selectionLayer.getSource().addFeature(selectionBox);
            }
        });

        map.on('pointerup', (evt) => {
            if (!isSelecting || !startCoord) return;
            
            const extent = ol.extent.boundingExtent([startCoord, evt.coordinate]);
            const [minX, minY, maxX, maxY] = extent;
            
            const bottomLeft = ol.proj.toLonLat([minX, minY]);
            const topRight = ol.proj.toLonLat([maxX, maxY]);
            
            const width = Math.abs(maxX - minX);
            const height = Math.abs(maxY - minY);
            
            if (width < 1000 || height < 1000) {
                showToast('Area too small - draw a larger area');
                return;
            }
            
            isSelecting = false;
            document.getElementById('selectAreaBtn').classList.remove('active');
            
            fetchElevationData(bottomLeft, topRight);
        });

        // Fetch elevation data
        async function fetchElevationData(bottomLeft, topRight) {
            const loading = document.getElementById('loadingOverlay');
            loading.classList.add('show');
            
            try {
                const width = 100;
                const height = 100;
                
                const elevationData = [];
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        const lat = bottomLeft[1] + (topRight[1] - bottomLeft[1]) * (i / (height - 1));
                        const lon = bottomLeft[0] + (topRight[0] - bottomLeft[0]) * (j / (width - 1));
                        
                        const elevation = Math.random() * 100 + Math.sin(i / 10) * Math.cos(j / 10) * 50;
                        elevationData.push(elevation);
                    }
                }
                
                currentElevationData = {
                    elevationData,
                    width,
                    height,
                    bottomLeft,
                    topRight
                };
                
                document.getElementById('open3DViewerBtn').disabled = false;
                showToast('Elevation data fetched!');
                
                setTimeout(() => {
                    create3DTerrain(elevationData, width, height, bottomLeft, topRight);
                }, 500);
                
            } catch (error) {
                showToast('Error fetching data: ' + error.message);
            } finally {
                loading.classList.remove('show');
            }
        }

        // Save terrain data
        function saveTerrainData() {
            if (!currentElevationData) {
                showToast('No terrain data to save');
                return;
            }
            
            const json = JSON.stringify(currentElevationData);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'terrain_data.json';
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('Terrain data saved!');
        }

        // Load terrain data
        function loadTerrainData(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    currentElevationData = JSON.parse(e.target.result);
                    showToast('Terrain data loaded!');
                    document.getElementById('open3DViewerBtn').disabled = false;
                    
                    // Open 3D viewer automatically
                    if (currentElevationData) {
                        create3DTerrain(
                            currentElevationData.elevationData,
                            currentElevationData.width,
                            currentElevationData.height,
                            currentElevationData.bottomLeft,
                            currentElevationData.topRight
                        );
                    }
                } catch (error) {
                    showToast('Error loading file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Fetch satellite texture with proper coverage
        async function fetchSatelliteTexture(bottomLeft, topRight, width, height) {
            try {
                debug('Fetching satellite texture for bounds:');
                debug('  Bottom-left: ' + bottomLeft[0] + ', ' + bottomLeft[1]);
                debug('  Top-right: ' + topRight[0] + ', ' + topRight[1]);
                
                // Calculate appropriate zoom level based on area size
                const latDiff = Math.abs(topRight[1] - bottomLeft[1]);
                const lonDiff = Math.abs(topRight[0] - bottomLeft[0]);
                
                // Determine zoom level - larger area = lower zoom
                let zoom;
                const maxDiff = Math.max(latDiff, lonDiff);
                if (maxDiff > 1) zoom = 10;
                else if (maxDiff > 0.5) zoom = 11;
                else if (maxDiff > 0.25) zoom = 12;
                else if (maxDiff > 0.1) zoom = 13;
                else if (maxDiff > 0.05) zoom = 14;
                else if (maxDiff > 0.025) zoom = 15;
                else if (maxDiff > 0.01) zoom = 16;
                else zoom = 17;
                
                debug('  Zoom level: ' + zoom + ' (area size: ' + maxDiff.toFixed(4) + '¬∞)');
                
                // Convert lat/lon to tile coordinates
                function latLonToTile(lat, lon, z) {
                    const n = Math.pow(2, z);
                    const x = Math.floor((lon + 180) / 360 * n);
                    const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);
                    return { x, y };
                }
                
                // Get tile coordinates for bounds
                const minTile = latLonToTile(bottomLeft[1], bottomLeft[0], zoom);
                const maxTile = latLonToTile(topRight[1], topRight[0], zoom);
                
                // Ensure proper ordering (swap if needed)
                const minX = Math.min(minTile.x, maxTile.x);
                const maxX = Math.max(minTile.x, maxTile.x);
                const minY = Math.min(minTile.y, maxTile.y);
                const maxY = Math.max(minTile.y, maxTile.y);
                
                const tilesX = maxX - minX + 1;
                const tilesY = maxY - minY + 1;
                
                debug('  Tiles needed: ' + tilesX + ' x ' + tilesY + ' = ' + (tilesX * tilesY));
                debug('  Tile range X: ' + minX + ' to ' + maxX);
                debug('  Tile range Y: ' + minY + ' to ' + maxY);
                
                // Create canvas to combine tiles
                const tileSize = 256;
                const canvas = document.createElement('canvas');
                canvas.width = tilesX * tileSize;
                canvas.height = tilesY * tileSize;
                const ctx = canvas.getContext('2d');
                
                debug('  Canvas size: ' + canvas.width + ' x ' + canvas.height);
                
                // Load all tiles
                const tilePromises = [];
                for (let y = minY; y <= maxY; y++) {
                    for (let x = minX; x <= maxX; x++) {
                        const url = `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoom}/${y}/${x}`;
                        
                        const promise = new Promise((resolve, reject) => {
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.onload = () => {
                                const canvasX = (x - minX) * tileSize;
                                const canvasY = (y - minY) * tileSize;
                                ctx.drawImage(img, canvasX, canvasY);
                                resolve();
                            };
                            img.onerror = () => {
                                debug('  Failed to load tile: ' + x + ',' + y);
                                reject(new Error('Tile load failed'));
                            };
                            img.src = url;
                        });
                        
                        tilePromises.push(promise);
                    }
                }
                
                // Wait for all tiles to load
                await Promise.all(tilePromises);
                debug('  All tiles loaded successfully');
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.needsUpdate = true;
                
                debug('  Texture created: ' + canvas.width + 'x' + canvas.height);
                
                return texture;
            } catch (error) {
                debug('Texture fetch error: ' + error.message);
                return null;
            }
        }

        // Create 3D terrain visualization with Minecraft-style flying camera
        function create3DTerrain(elevationData, width, height, bottomLeft, topRight) {
            debug('Creating 3D terrain: ' + width + 'x' + height);
            debug('Data length: ' + elevationData.length);
            debug('Min elev: ' + Math.min(...elevationData) + 'm');
            debug('Max elev: ' + Math.max(...elevationData) + 'm');
            
            const modal = document.getElementById('modal3d');
            const container = document.getElementById('viewer3d');
            
            // Clear previous content
            container.innerHTML = '';
            
            // Re-add loading overlay
            const loadingOverlay = document.createElement('div');
            loadingOverlay.className = 'loading-overlay';
            loadingOverlay.id = 'loadingOverlay';
            loadingOverlay.innerHTML = '<div class="spinner"></div><div>Generating 3D terrain...</div>';
            container.appendChild(loadingOverlay);
            
            // Camera state for first-person flying
            const camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.01,
                10000
            );
            
            const velocity = new THREE.Vector3();
            const direction = new THREE.Vector3();
            
            // Euler angles for camera rotation
            let pitch = 0;
            let yaw = 0;
            
            // Movement state
            const keys = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                up: false,
                down: false
            };
            
            let isPointerLocked = false;
            let isFlying = false;
            let lastUpTapTime = 0;
            const doubleTapDelay = 300;
            
            // Setup Three.js scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            debug('Renderer: ' + container.clientWidth + 'x' + container.clientHeight);
            
            // Find elevation range for scaling
            let minElev = Infinity;
            let maxElev = -Infinity;
            for (let i = 0; i < elevationData.length; i++) {
                if (elevationData[i] > -9999 && elevationData[i] !== 0) {
                    minElev = Math.min(minElev, elevationData[i]);
                    maxElev = Math.max(maxElev, elevationData[i]);
                }
            }
            
            // If all values are zero or invalid, create a test terrain
            if (minElev === Infinity || maxElev === -Infinity || minElev === maxElev) {
                debug('WARN: Invalid data, using test terrain');
                minElev = 0;
                maxElev = 100;
                for (let i = 0; i < elevationData.length; i++) {
                    elevationData[i] = Math.sin(i / 10) * 50 + 50;
                }
            }
            
            debug('Final elevation range: ' + minElev + ' to ' + maxElev + 'm');
            
            const elevRange = maxElev - minElev;
            const scale = Math.max(width, height) / 100;
            const verticalExaggeration = 0.1;
            let originalHeightData = [];
            
            // Calculate real-world distances from GPS coordinates
            let metersPerSceneUnit = 1;
            
            if (bottomLeft && topRight) {
                const lat1 = bottomLeft[1] * Math.PI / 180;
                const lat2 = topRight[1] * Math.PI / 180;
                const lon1 = bottomLeft[0] * Math.PI / 180;
                const lon2 = topRight[0] * Math.PI / 180;
                
                const R = 6371000;
                const dLat = lat2 - lat1;
                const dLon = lon2 - lon1;
                
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1) * Math.cos(lat2) *
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                const latDistance = R * Math.abs(lat2 - lat1);
                const lonDistance = R * Math.abs(dLon) * Math.cos((lat1 + lat2) / 2);
                
                const sceneWidth = width * scale;
                const sceneHeight = height * scale;
                
                const metersPerUnitWidth = lonDistance / sceneWidth;
                const metersPerUnitHeight = latDistance / sceneHeight;
                metersPerSceneUnit = (metersPerUnitWidth + metersPerUnitHeight) / 2;
                
                debug('Real-world width: ' + lonDistance.toFixed(2) + 'm');
                debug('Real-world height: ' + latDistance.toFixed(2) + 'm');
                debug('Scene width: ' + sceneWidth.toFixed(2) + ' units');
                debug('Scene height: ' + sceneHeight.toFixed(2) + ' units');
                debug('Meters per scene unit: ' + metersPerSceneUnit.toFixed(4));
            } else {
                const sceneWidth = width * scale;
                metersPerSceneUnit = 1000 / sceneWidth;
                debug('No GPS coords - using default: ' + metersPerSceneUnit.toFixed(4) + ' meters/unit');
            }
            
            const terrainScaleFactor = (verticalExaggeration * scale * 50) / elevRange;
            const playerHeight = 2.8 * terrainScaleFactor;
            
            debug('Player height in scene units: ' + playerHeight.toFixed(3) + ' (representing 2.8m)');
            
            const walkingSpeedMetersPerSecond = 4.2;
            const walkingSpeedMetersPerFrame = walkingSpeedMetersPerSecond / 60;
            const walkSpeed = walkingSpeedMetersPerFrame / metersPerSceneUnit;
            
            const sceneWidth = width * scale;
            const sceneHeight = height * scale;
            const mapDiagonal = Math.sqrt(sceneWidth * sceneWidth + sceneHeight * sceneHeight);
            const flySpeed = mapDiagonal / 10 / 60;
            
            debug('Walking speed: ' + walkSpeed.toFixed(4) + ' scene units/frame (' + walkingSpeedMetersPerSecond + ' m/s)');
            debug('Flying speed: ' + flySpeed.toFixed(4) + ' scene units/frame (crosses map in 10s)');
            
            // Create geometry
            const geometry = new THREE.PlaneGeometry(
                width * scale,
                height * scale,
                width - 1,
                height - 1
            );
            
            const vertices = geometry.attributes.position.array;
            
            // Apply elevation data and store original heights
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const idx = i * width + j;
                    const vertIdx = (i * width + j) * 3;
                    
                    let elevation = elevationData[idx];
                    if (elevation < -9999) elevation = minElev;
                    
                    const normalizedHeight = ((elevation - minElev) / elevRange) * verticalExaggeration * scale * 50;
                    vertices[vertIdx + 2] = normalizedHeight;
                    originalHeightData.push(normalizedHeight);
                }
            }
            
            geometry.computeVertexNormals();
            
            // Create material with vertex colors
            const colors = new Float32Array(vertices.length);
            for (let i = 0; i < vertices.length; i += 3) {
                const height = vertices[i + 2];
                const normalized = height / (verticalExaggeration * scale * 50);
                
                let r, g, b;
                if (normalized < 0.25) {
                    r = 0.2;
                    g = 0.5 + normalized * 2;
                    b = 0.3;
                } else if (normalized < 0.5) {
                    r = 0.3 + (normalized - 0.25) * 2;
                    g = 0.7;
                    b = 0.2;
                } else if (normalized < 0.75) {
                    r = 0.7 + (normalized - 0.5) * 0.8;
                    g = 0.7 - (normalized - 0.5) * 1.2;
                    b = 0.2;
                } else {
                    r = 0.5 + (normalized - 0.75) * 0.8;
                    g = 0.4 - (normalized - 0.75) * 0.8;
                    b = 0.2;
                }
                
                colors[i] = r;
                colors[i + 1] = g;
                colors[i + 2] = b;
            }
            
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            let material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                flatShading: false,
                shininess: 10,
                side: THREE.DoubleSide
            });
            
            let satelliteTexture = null;
            let useTexture = true;
            
            // Try to load satellite texture
            if (bottomLeft && topRight) {
                fetchSatelliteTexture(bottomLeft, topRight, width, height).then(texture => {
                    if (texture) {
                        satelliteTexture = texture;
                        material.map = texture;
                        material.vertexColors = false;
                        material.needsUpdate = true;
                        debug('Satellite texture applied');
                        showToast('Satellite texture loaded!');
                        
                        const toggleBtn = document.getElementById('toggleTexture');
                        if (toggleBtn) {
                            toggleBtn.style.display = 'block';
                            toggleBtn.classList.add('active');
                        }
                    }
                }).catch(error => {
                    debug('Texture load failed: ' + error.message);
                });
            }
            
            const terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            scene.add(terrain);
            
            debug('Terrain mesh added to scene');
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            camera.position.set(0, playerHeight, 0);
            camera.rotation.order = 'YXZ';
            
            debug('Camera at: ' + camera.position.x + ',' + camera.position.y + ',' + camera.position.z);
            
            // Add pointer lock instructions (desktop) or touch instructions (mobile)
            const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const pointerLockInfo = document.createElement('div');
            pointerLockInfo.className = 'pointer-lock-info';
            
            if (isMobile) {
                pointerLockInfo.innerHTML = `
                    <h2>üì± Touch Controls</h2>
                    <p>
                        <strong>D-Pad (left)</strong> - Run around<br>
                        <strong>Double-tap ‚Üë</strong> - Toggle flying mode<br>
                        <strong>‚Üë‚Üì Buttons</strong> - Fly up/down<br>
                        <strong>Swipe right side</strong> - Look around<br>
                    </p>
                    <p style="margin-top: 10px; font-size: 13px; opacity: 0.8;">
                        Running speed: 4.2 m/s at 2.8m height
                    </p>
                    <p style="margin-top: 10px; font-size: 12px; opacity: 0.7;">
                        Tap anywhere to dismiss
                    </p>
                `;
                pointerLockInfo.addEventListener('click', () => {
                    pointerLockInfo.classList.add('hidden');
                });
            } else {
                pointerLockInfo.innerHTML = `
                    <h2>üéÆ Minecraft Creative Mode Controls</h2>
                    <p><strong>Click anywhere to enable mouse look</strong></p>
                    <p>
                        <strong>W/A/S/D</strong> - Run forward/left/backward/right<br>
                        <strong>Double-tap Space</strong> - Toggle flying mode<br>
                        <strong>Space/Shift</strong> - Fly up/down<br>
                        <strong>Mouse</strong> - Look around<br>
                        <strong>Escape</strong> - Exit mouse look
                    </p>
                    <p style="margin-top: 10px; font-size: 13px; opacity: 0.8;">
                        Running speed: 4.2 m/s at 2.8m height
                    </p>
                `;
            }
            container.appendChild(pointerLockInfo);
            
            // Add controls hint
            const controlsHint = document.createElement('div');
            controlsHint.className = 'controls-hint hidden';
            if (isMobile) {
                controlsHint.innerHTML = 'Double-tap ‚Üë to toggle flying mode';
            } else {
                controlsHint.innerHTML = 'Press ESC to exit | Double-tap Space to fly';
            }
            container.appendChild(controlsHint);
            
            // Touch controls for mobile
            const touchControls = document.createElement('div');
            touchControls.className = 'touch-controls';
            touchControls.id = 'touchControls';
            touchControls.innerHTML = `
                <div class="dpad-container">
                    <div class="dpad">
                        <div class="dpad-btn" id="dpad-up">W</div>
                        <div class="dpad-btn" id="dpad-down">S</div>
                        <div class="dpad-btn" id="dpad-left">A</div>
                        <div class="dpad-btn" id="dpad-right">D</div>
                    </div>
                </div>
                <div class="vertical-controls">
                    <div class="vertical-btn" id="btn-up">‚Üë</div>
                    <div class="vertical-btn" id="btn-down">‚Üì</div>
                </div>
            `;
            container.appendChild(touchControls);
            
            // Add look zone for touch look controls
            const lookZone = document.createElement('div');
            lookZone.className = 'look-zone';
            container.appendChild(lookZone);
            
            // Add hint
            const lookHint = document.createElement('div');
            lookHint.className = 'look-hint show';
            lookHint.textContent = 'Swipe to look around';
            lookZone.appendChild(lookHint);
            
            // Hide hint after a few seconds
            setTimeout(() => {
                lookHint.classList.remove('show');
            }, 3000);
            
            // Pointer lock functionality
            function requestPointerLock() {
                if (isMobile) return;
                renderer.domElement.requestPointerLock = 
                    renderer.domElement.requestPointerLock ||
                    renderer.domElement.mozRequestPointerLock ||
                    renderer.domElement.webkitRequestPointerLock;
                renderer.domElement.requestPointerLock();
            }
            
            function exitPointerLock() {
                if (isMobile) return;
                document.exitPointerLock = 
                    document.exitPointerLock ||
                    document.mozExitPointerLock ||
                    document.webkitExitPointerLock;
                document.exitPointerLock();
            }
            
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
                if (isPointerLocked) {
                    pointerLockInfo.classList.add('hidden');
                    controlsHint.classList.remove('hidden');
                } else {
                    controlsHint.classList.add('hidden');
                }
            });
            
            if (!isMobile) {
                renderer.domElement.addEventListener('click', () => {
                    if (!isPointerLocked) {
                        requestPointerLock();
                    }
                });
            }
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'KeyW': keys.forward = true; break;
                    case 'KeyS': keys.backward = true; break;
                    case 'KeyA': keys.left = true; break;
                    case 'KeyD': keys.right = true; break;
                    case 'Space':
                        const now = performance.now();
                        if (now - lastUpTapTime < doubleTapDelay) {
                            isFlying = !isFlying;
                            updateFlyingModeStatus();
                            debug('Flying mode: ' + (isFlying ? 'ON' : 'OFF'));
                        }
                        lastUpTapTime = now;
                        keys.up = true;
                        e.preventDefault();
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        keys.down = true;
                        break;
                    case 'Escape':
                        if (isPointerLocked) {
                            exitPointerLock();
                        }
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyW': keys.forward = false; break;
                    case 'KeyS': keys.backward = false; break;
                    case 'KeyA': keys.left = false; break;
                    case 'KeyD': keys.right = false; break;
                    case 'Space': keys.up = false; break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        keys.down = false;
                        break;
                }
            });
            
            // Mouse look
            if (!isMobile) {
                document.addEventListener('mousemove', (e) => {
                    if (!isPointerLocked) return;
                    
                    const sensitivity = 0.002;
                    yaw -= e.movementX * sensitivity;
                    pitch -= e.movementY * sensitivity;
                    
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                    
                    camera.rotation.y = yaw;
                    camera.rotation.x = pitch;
                });
            }
            
            // Touch controls for mobile
            if (isMobile) {
                const dpadUp = document.getElementById('dpad-up');
                const dpadDown = document.getElementById('dpad-down');
                const dpadLeft = document.getElementById('dpad-left');
                const dpadRight = document.getElementById('dpad-right');
                
                function touchStart(key) {
                    return (e) => {
                        e.preventDefault();
                        keys[key] = true;
                    };
                }
                
                function touchEnd(key) {
                    return (e) => {
                        e.preventDefault();
                        keys[key] = false;
                    };
                }
                
                dpadUp.addEventListener('touchstart', touchStart('forward'));
                dpadUp.addEventListener('touchend', touchEnd('forward'));
                dpadDown.addEventListener('touchstart', touchStart('backward'));
                dpadDown.addEventListener('touchend', touchEnd('backward'));
                dpadLeft.addEventListener('touchstart', touchStart('left'));
                dpadLeft.addEventListener('touchend', touchEnd('left'));
                dpadRight.addEventListener('touchstart', touchStart('right'));
                dpadRight.addEventListener('touchend', touchEnd('right'));
                
                const btnUp = document.getElementById('btn-up');
                const btnDown = document.getElementById('btn-down');
                
                let lastUpBtnTap = 0;
                
                btnUp.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.up = true;
                    
                    const now = performance.now();
                    if (now - lastUpBtnTap < doubleTapDelay) {
                        isFlying = !isFlying;
                        updateFlyingModeStatus();
                        debug('Flying mode: ' + (isFlying ? 'ON' : 'OFF'));
                    }
                    lastUpBtnTap = now;
                });
                
                btnUp.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.up = false;
                });
                
                btnDown.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.down = true;
                });
                
                btnDown.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.down = false;
                });
                
                // Touch look controls
                let touchStartX = 0;
                let touchStartY = 0;
                
                lookZone.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    pointerLockInfo.classList.add('hidden');
                });
                
                lookZone.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    
                    const deltaX = e.touches[0].clientX - touchStartX;
                    const deltaY = e.touches[0].clientY - touchStartY;
                    
                    const sensitivity = 0.005;
                    yaw -= deltaX * sensitivity;
                    pitch -= deltaY * sensitivity;
                    
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                    
                    camera.rotation.y = yaw;
                    camera.rotation.x = pitch;
                    
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });
            }
            
            // Get terrain height at position
            function getTerrainHeightAt(x, z) {
                const halfWidth = (width * scale) / 2;
                const halfHeight = (height * scale) / 2;
                
                const gridX = ((x + halfWidth) / (width * scale)) * (width - 1);
                const gridZ = ((z + halfHeight) / (height * scale)) * (height - 1);
                
                const clampedX = Math.max(0, Math.min(width - 2, Math.floor(gridX)));
                const clampedZ = Math.max(0, Math.min(height - 2, Math.floor(gridZ)));
                
                const idx00 = clampedZ * width + clampedX;
                const idx10 = clampedZ * width + (clampedX + 1);
                const idx01 = (clampedZ + 1) * width + clampedX;
                const idx11 = (clampedZ + 1) * width + (clampedX + 1);
                
                const h00 = originalHeightData[idx00] || 0;
                const h10 = originalHeightData[idx10] || 0;
                const h01 = originalHeightData[idx01] || 0;
                const h11 = originalHeightData[idx11] || 0;
                
                const fracX = gridX - clampedX;
                const fracZ = gridZ - clampedZ;
                
                const h0 = h00 * (1 - fracX) + h10 * fracX;
                const h1 = h01 * (1 - fracX) + h11 * fracX;
                const h = h0 * (1 - fracZ) + h1 * fracZ;
                
                return h;
            }
            
            // Movement update function
            function updateMovement(delta) {
                if (delta > 0.1) delta = 0.1;
                
                const currentSpeed = isFlying ? flySpeed : walkSpeed;
                
                direction.set(0, 0, 0);
                
                if (keys.forward) direction.z -= 1;
                if (keys.backward) direction.z += 1;
                if (keys.left) direction.x -= 1;
                if (keys.right) direction.x += 1;
                
                if (direction.length() > 0) {
                    direction.normalize();
                }
                
                const rotatedDirection = direction.clone();
                rotatedDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                
                velocity.x = rotatedDirection.x * currentSpeed;
                velocity.z = rotatedDirection.z * currentSpeed;
                
                if (isFlying) {
                    velocity.y = 0;
                    if (keys.up) velocity.y = currentSpeed;
                    if (keys.down) velocity.y = -currentSpeed;
                } else {
                    velocity.y = 0;
                }
                
                camera.position.x += velocity.x;
                camera.position.y += velocity.y;
                camera.position.z += velocity.z;
                
                if (!isFlying) {
                    const groundHeight = getTerrainHeightAt(camera.position.x, camera.position.z);
                    const targetY = groundHeight + playerHeight;
                    camera.position.y = targetY;
                }
                
                const halfWidth = (width * scale) / 2;
                const halfHeight = (height * scale) / 2;
                camera.position.x = Math.max(-halfWidth, Math.min(halfWidth, camera.position.x));
                camera.position.z = Math.max(-halfHeight, Math.min(halfHeight, camera.position.z));
            }
            
            // Cleanup function
            window.cleanup3DViewer = () => {
                document.removeEventListener('keydown', null);
                document.removeEventListener('keyup', null);
                document.removeEventListener('mousemove', null);
                document.removeEventListener('pointerlockchange', null);
                
                geometry.dispose();
                material.dispose();
                if (satelliteTexture) satelliteTexture.dispose();
                renderer.dispose();
                
                debug('3D viewer cleaned up');
            };
            
            // View control functions
            function resetView() {
                camera.position.set(0, playerHeight, 0);
                pitch = 0;
                yaw = 0;
                camera.rotation.set(pitch, yaw, 0);
                
                const upBtn = document.getElementById('btn-up');
                if (upBtn) {
                    upBtn.style.background = 'rgba(255, 255, 255, 0.4)';
                    upBtn.style.borderColor = 'rgba(255, 255, 255, 0.6)';
                }
                
                debug('View reset');
            }
            
            function topView() {
                camera.position.set(0, scale * 150, 0);
                pitch = -Math.PI / 2;
                yaw = 0;
                camera.rotation.set(pitch, yaw, 0);
                debug('Top view');
            }
            
            let autoRotate = false;
            function toggleAutoRotate() {
                autoRotate = !autoRotate;
                const btn = document.getElementById('autoRotateBtn');
                if (btn) btn.classList.toggle('active', autoRotate);
                debug('Auto-rotate: ' + (autoRotate ? 'ON' : 'OFF'));
            }
            
            function toggleTexture() {
                if (!satelliteTexture) return;
                
                useTexture = !useTexture;
                const toggleBtn = document.getElementById('toggleTexture');
                
                if (useTexture) {
                    material.map = satelliteTexture;
                    material.vertexColors = false;
                    if (toggleBtn) toggleBtn.classList.add('active');
                    debug('Satellite texture ON');
                } else {
                    material.map = null;
                    material.vertexColors = true;
                    if (toggleBtn) toggleBtn.classList.remove('active');
                    debug('Satellite texture OFF');
                }
                material.needsUpdate = true;
            }
            
            function updateVerticalScale(value) {
                const newScale = parseFloat(value);
                document.getElementById('scaleValue').textContent = newScale.toFixed(1);
                
                const vertices = geometry.attributes.position.array;
                for (let i = 0; i < originalHeightData.length; i++) {
                    vertices[i * 3 + 2] = originalHeightData[i] * (newScale / verticalExaggeration);
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
            }
            
            function toggleWireframe(checked) {
                material.wireframe = checked;
            }
            
            function updateFlyingModeStatus() {
                const statusDiv = document.getElementById('flyingModeStatus');
                if (statusDiv) {
                    if (isFlying) {
                        statusDiv.textContent = 'FLYING MODE';
                        statusDiv.style.background = 'rgba(33, 150, 243, 0.7)';
                    } else {
                        statusDiv.textContent = 'RUNNING MODE';
                        statusDiv.style.background = 'rgba(0, 0, 0, 0.3)';
                    }
                }
            }
            
            // Add event listeners
            const resetBtn = document.getElementById('resetViewBtn');
            const topBtn = document.getElementById('topViewBtn');
            const autoBtn = document.getElementById('autoRotateBtn');
            const textureBtn = document.getElementById('toggleTexture');
            const scaleSlider = document.getElementById('verticalScale');
            const wireframeCheck = document.getElementById('wireframeToggle');
            
            if (resetBtn) resetBtn.addEventListener('click', resetView);
            if (topBtn) topBtn.addEventListener('click', topView);
            if (autoBtn) autoBtn.addEventListener('click', toggleAutoRotate);
            if (textureBtn) textureBtn.addEventListener('click', toggleTexture);
            if (scaleSlider) scaleSlider.addEventListener('input', (e) => updateVerticalScale(e.target.value));
            if (wireframeCheck) wireframeCheck.addEventListener('change', (e) => toggleWireframe(e.target.checked));
            
            // Animation loop
            let lastTime = performance.now();
            let frameCount = 0;
            
            function animate() {
                requestAnimationFrame(animate);
                
                const currentTime = performance.now();
                const delta = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                updateMovement(delta);
                
                if (autoRotate && !Object.values(keys).some(v => v)) {
                    yaw += 0.01;
                    camera.rotation.y = yaw;
                }
                
                renderer.render(scene, camera);
                
                if (frameCount < 3) {
                    debug('Frame ' + frameCount + ' rendered');
                    frameCount++;
                }
            }
            
            animate();
            debug('Animation loop started');
            
            updateMovement(0);
            debug('Initial position set on terrain');
            
            // Handle window resize
            const resizeHandler = () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            };
            window.addEventListener('resize', resizeHandler);
            
            // Show modal
            modal.classList.add('show');
        }

        // Open empty 3D viewer
        function open3DViewer() {
            if (currentElevationData) {
                create3DTerrain(
                    currentElevationData.elevationData,
                    currentElevationData.width,
                    currentElevationData.height,
                    currentElevationData.bottomLeft,
                    currentElevationData.topRight
                );
            } else {
                const modal = document.getElementById('modal3d');
                const container = document.getElementById('viewer3d');
                
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.alignItems = 'center';
                container.style.justifyContent = 'center';
                container.style.color = 'white';
                container.style.fontSize = '18px';
                container.innerHTML = '<div style="text-align: center;"><p>üìÇ Click "Load Data" to import a terrain file</p><p style="margin-top: 10px; font-size: 14px; color: #aaa;">or use "Select Area" on the map to fetch elevation data</p></div>';
                
                modal.classList.add('show');
            }
        }

        // Add click events
        document.getElementById('locationBtn').addEventListener('click', getUserLocation);
        document.getElementById('contoursBtn').addEventListener('click', toggleContours);
        document.getElementById('satelliteBtn').addEventListener('click', toggleSatellite);
        document.getElementById('selectAreaBtn').addEventListener('click', toggleAreaSelection);
        document.getElementById('open3DViewerBtn').addEventListener('click', open3DViewer);
        document.getElementById('closeModal').addEventListener('click', () => {
            document.getElementById('modal3d').classList.remove('show');
            if (window.cleanup3DViewer) {
                window.cleanup3DViewer();
            }
        });
        document.getElementById('saveDataBtn').addEventListener('click', saveTerrainData);
        document.getElementById('saveDataBtn3D').addEventListener('click', saveTerrainData);
        document.getElementById('loadDataBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        document.getElementById('loadDataBtn3D').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadTerrainData(e.target.files[0]);
            }
        });

        // Add popup on click for location marker
        const popup = new ol.Overlay({
            element: document.createElement('div'),
            positioning: 'bottom-center',
            stopEvent: false,
            offset: [0, -10]
        });
        map.addOverlay(popup);

        map.on('click', (evt) => {
            if (isSelecting) return;
            
            const feature = map.forEachFeatureAtPixel(evt.pixel, (feature) => feature);
            
            if (feature && feature.get('name') === 'Your Location') {
                const coordinates = feature.getGeometry().getCoordinates();
                const lonLat = ol.proj.toLonLat(coordinates);
                
                const popupElement = popup.getElement();
                popupElement.innerHTML = `
                    <div style="background: white; padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); font-size: 13px;">
                        <strong>Your Location</strong><br>
                        <span style="color: #666;">
                            Lat: ${lonLat[1].toFixed(6)}<br>
                            Lon: ${lonLat[0].toFixed(6)}
                        </span>
                    </div>
                `;
                popup.setPosition(coordinates);
            } else {
                popup.setPosition(undefined);
            }
        });

        // Change cursor on hover
        map.on('pointermove', (evt) => {
            if (isSelecting) {
                map.getTarget().style.cursor = 'crosshair';
                return;
            }
            
            const pixel = map.getEventPixel(evt.originalEvent);
            const hit = map.hasFeatureAtPixel(pixel);
            map.getTarget().style.cursor = hit ? 'pointer' : '';
        });
    </script>
</body>
</html>
