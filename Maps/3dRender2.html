<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain Analysis & 3D Export</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.2.1/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v10.2.1/dist/ol.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 15px;
            z-index: 1000;
            min-width: 200px;
        }

        .control-btn {
            display: block;
            width: 100%;
            padding: 12px 20px;
            margin-bottom: 10px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            color: #333;
        }

        .control-btn:last-child {
            margin-bottom: 0;
        }

        .control-btn:hover:not(:disabled) {
            background: #f5f5f5;
            border-color: #2196F3;
        }

        .control-btn.active {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Toast notification */
        .toast {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 2000;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            max-width: 80%;
            text-align: center;
        }

        .toast.show {
            opacity: 1;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 12px 15px;
            font-size: 12px;
            z-index: 1000;
            max-width: 220px;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            color: #666;
        }

        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 8px;
            background: #8B4513;
        }

        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            flex-direction: column;
            color: white;
        }

        .loading-overlay.show {
            display: flex;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            font-weight: 500;
        }

        .loading-progress {
            margin-top: 10px;
            font-size: 14px;
            opacity: 0.8;
        }

        /* Selection box style */
        .ol-dragbox {
            background-color: rgba(33, 150, 243, 0.2);
            border: 2px dashed #2196F3;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="control-panel">
        <button id="contoursBtn" class="control-btn">üóª Contours</button>
        <button id="satelliteBtn" class="control-btn">üõ∞Ô∏è Satellite View</button>
        <button id="selectAreaBtn" class="control-btn">üìç Select Area</button>
        <button id="fetchDataBtn" class="control-btn" disabled>üìä Fetch Terrain Data</button>
        <button id="saveDataBtn" class="control-btn" disabled>üíæ Save JSON</button>
    </div>

    <div id="legend" class="legend" style="display: none;">
        <div class="legend-title">Contour Lines</div>
        <div class="legend-item">
            <div class="legend-line"></div>
            <span>Auto: 1m, 5m, or 10m intervals</span>
        </div>
        <div style="font-size: 11px; color: #999; margin-top: 5px;">
            Resolution depends on zoom level and data availability
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Fetching high-resolution terrain data...</div>
        <div class="loading-progress" id="loadingProgress"></div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        // Global variables
        let selectedArea = null;
        let currentElevationData = null;
        let isSelectingArea = false;
        let dragBox = null;
        
        // Tap selection state for mobile
        let tapSelectionState = 'idle'; // 'idle', 'waitingForFirstCorner', 'waitingForSecondCorner'
        let firstCorner = null;
        let previewFeature = null;

        // Queensland high-resolution DEM service (LiDAR-based)
        const QLD_DEM_SERVICE = 'https://spatial-img.information.qld.gov.au/arcgis/rest/services/Elevation/DEM1mHillshadeAustralia_AllQld_Cache/ImageServer';

        // Map setup with better initial view of Queensland
        const map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM()
                })
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([153.0260, -27.4705]), // Brisbane area
                zoom: 13,
                maxZoom: 20
            })
        });

        // Vector layer for contours
        const contourVectorSource = new ol.source.Vector();
        const contourLayer = new ol.layer.Vector({
            source: contourVectorSource,
            visible: false,
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: '#8B4513',
                    width: 1.5
                })
            })
        });
        map.addLayer(contourLayer);

        // Vector layer for selected area
        const selectionVectorSource = new ol.source.Vector();
        const selectionLayer = new ol.layer.Vector({
            source: selectionVectorSource,
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: '#FF4444',
                    width: 3,
                    lineDash: [10, 5]
                }),
                fill: new ol.style.Fill({
                    color: 'rgba(255, 68, 68, 0.1)'
                })
            }),
            zIndex: 1000
        });
        map.addLayer(selectionLayer);

        // Satellite layer
        const satelliteLayer = new ol.layer.Tile({
            source: new ol.source.XYZ({
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                maxZoom: 19
            }),
            visible: false
        });
        map.getLayers().insertAt(0, satelliteLayer);

        // Utility functions
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), duration);
        }

        function showLoading(show, message = 'Loading...') {
            const overlay = document.getElementById('loadingOverlay');
            const progress = document.getElementById('loadingProgress');
            if (show) {
                overlay.classList.add('show');
                progress.textContent = message;
            } else {
                overlay.classList.remove('show');
            }
        }

        // Toggle contour layer
        function toggleContours() {
            const isVisible = contourLayer.getVisible();
            contourLayer.setVisible(!isVisible);
            document.getElementById('contoursBtn').classList.toggle('active');
            document.getElementById('legend').style.display = !isVisible ? 'block' : 'none';
            
            if (!isVisible && contourVectorSource.getFeatures().length === 0) {
                showToast('Zoom in and pan to see contour lines (computed from Queensland DEM)');
                generateContours();
            }
        }

        // Toggle satellite layer
        function toggleSatellite() {
            const isVisible = satelliteLayer.getVisible();
            satelliteLayer.setVisible(!isVisible);
            document.getElementById('satelliteBtn').classList.toggle('active');
        }

        // Generate contour lines for the current view
        async function generateContours() {
            const view = map.getView();
            const extent = view.calculateExtent(map.getSize());
            const zoom = view.getZoom();
            
            if (zoom < 13) {
                return;
            }
            
            contourVectorSource.clear();
            
            const [minX, minY, maxX, maxY] = extent;
            const bottomLeft = ol.proj.toLonLat([minX, minY]);
            const topRight = ol.proj.toLonLat([maxX, maxY]);
            
            const gridSize = 50;
            const lonStep = (topRight[0] - bottomLeft[0]) / (gridSize - 1);
            const latStep = (topRight[1] - bottomLeft[1]) / (gridSize - 1);
            
            const elevationGrid = [];
            for (let i = 0; i < gridSize; i++) {
                elevationGrid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    const lon = bottomLeft[0] + j * lonStep;
                    const lat = bottomLeft[1] + i * latStep;
                    const elevation = await queryElevation(lon, lat);
                    elevationGrid[i][j] = elevation !== null ? elevation : 0;
                }
            }
            
            let interval;
            if (zoom >= 16) interval = 1;
            else if (zoom >= 14) interval = 5;
            else interval = 10;
            
            const minElev = Math.min(...elevationGrid.flat());
            const maxElev = Math.max(...elevationGrid.flat());
            
            for (let elev = Math.ceil(minElev / interval) * interval; elev <= maxElev; elev += interval) {
                const segments = marchingSquares(elevationGrid, elev, bottomLeft, lonStep, latStep);
                segments.forEach(segment => {
                    const coords = segment.map(([lon, lat]) => 
                        ol.proj.fromLonLat([lon, lat])
                    );
                    const feature = new ol.Feature({
                        geometry: new ol.geom.LineString(coords)
                    });
                    contourVectorSource.addFeature(feature);
                });
            }
        }

        // Simplified marching squares for contour generation
        function marchingSquares(grid, threshold, origin, lonStep, latStep) {
            const segments = [];
            const rows = grid.length;
            const cols = grid[0].length;
            
            for (let i = 0; i < rows - 1; i++) {
                for (let j = 0; j < cols - 1; j++) {
                    const tl = grid[i][j] >= threshold ? 1 : 0;
                    const tr = grid[i][j+1] >= threshold ? 1 : 0;
                    const bl = grid[i+1][j] >= threshold ? 1 : 0;
                    const br = grid[i+1][j+1] >= threshold ? 1 : 0;
                    
                    const cellType = tl * 8 + tr * 4 + br * 2 + bl;
                    
                    if (cellType === 0 || cellType === 15) continue;
                    
                    const x = origin[0] + j * lonStep;
                    const y = origin[1] + i * latStep;
                    
                    const getEdgePoint = (edge) => {
                        switch(edge) {
                            case 'top': return [x + lonStep/2, y];
                            case 'right': return [x + lonStep, y + latStep/2];
                            case 'bottom': return [x + lonStep/2, y + latStep];
                            case 'left': return [x, y + latStep/2];
                        }
                    };
                    
                    const configs = {
                        1: [['left', 'bottom']], 2: [['bottom', 'right']], 3: [['left', 'right']],
                        4: [['top', 'right']], 5: [['top', 'bottom'], ['left', 'right']],
                        6: [['top', 'bottom']], 7: [['left', 'top']], 8: [['left', 'top']],
                        9: [['bottom', 'top']], 10: [['left', 'right'], ['top', 'bottom']],
                        11: [['right', 'top']], 12: [['left', 'right']], 13: [['bottom', 'right']],
                        14: [['left', 'bottom']]
                    };
                    
                    if (configs[cellType]) {
                        configs[cellType].forEach(([e1, e2]) => {
                            segments.push([getEdgePoint(e1), getEdgePoint(e2)]);
                        });
                    }
                }
            }
            
            return segments;
        }

        // Handle map click for tap selection
        function handleMapClick(evt) {
            if (!isSelectingArea) return;
            
            if (tapSelectionState === 'waitingForFirstCorner') {
                firstCorner = evt.coordinate;
                tapSelectionState = 'waitingForSecondCorner';
                showToast('Tap the second corner', 3000);
            } else if (tapSelectionState === 'waitingForSecondCorner') {
                const secondCorner = evt.coordinate;
                
                const extent = [
                    Math.min(firstCorner[0], secondCorner[0]),
                    Math.min(firstCorner[1], secondCorner[1]),
                    Math.max(firstCorner[0], secondCorner[0]),
                    Math.max(firstCorner[1], secondCorner[1])
                ];
                
                selectionVectorSource.clear();
                if (previewFeature) {
                    previewFeature = null;
                }
                
                const polygon = new ol.geom.Polygon([[
                    [extent[0], extent[1]],
                    [extent[2], extent[1]],
                    [extent[2], extent[3]],
                    [extent[0], extent[3]],
                    [extent[0], extent[1]]
                ]]);
                
                const feature = new ol.Feature(polygon);
                selectionVectorSource.addFeature(feature);
                selectedArea = extent;
                
                document.getElementById('fetchDataBtn').disabled = false;
                
                const [minX, minY, maxX, maxY] = extent;
                const bottomLeft = ol.proj.toLonLat([minX, minY]);
                const topRight = ol.proj.toLonLat([maxX, maxY]);
                
                const widthKm = (Math.abs(topRight[0] - bottomLeft[0]) * 111).toFixed(2);
                const heightKm = (Math.abs(topRight[1] - bottomLeft[1]) * 111).toFixed(2);
                
                showToast(`Area selected: ${widthKm}km √ó ${heightKm}km - Ready to fetch!`, 5000);
                
                tapSelectionState = 'waitingForFirstCorner';
                firstCorner = null;
            }
        }

        // Handle pointer move for preview
        function handlePointerMove(evt) {
            if (tapSelectionState === 'waitingForSecondCorner' && firstCorner) {
                const currentCoord = evt.coordinate;
                
                const extent = [
                    Math.min(firstCorner[0], currentCoord[0]),
                    Math.min(firstCorner[1], currentCoord[1]),
                    Math.max(firstCorner[0], currentCoord[0]),
                    Math.max(firstCorner[1], currentCoord[1])
                ];
                
                selectionVectorSource.clear();
                
                const polygon = new ol.geom.Polygon([[
                    [extent[0], extent[1]],
                    [extent[2], extent[1]],
                    [extent[2], extent[3]],
                    [extent[0], extent[3]],
                    [extent[0], extent[1]]
                ]]);
                
                previewFeature = new ol.Feature(polygon);
                selectionVectorSource.addFeature(previewFeature);
            }
        }

        // Toggle area selection mode
        function toggleAreaSelection() {
            const selectBtn = document.getElementById('selectAreaBtn');
            
            if (isSelectingArea) {
                isSelectingArea = false;
                tapSelectionState = 'idle';
                firstCorner = null;
                if (dragBox) {
                    map.removeInteraction(dragBox);
                    dragBox = null;
                }
                selectBtn.classList.remove('active');
                if (previewFeature) {
                    selectionVectorSource.removeFeature(previewFeature);
                    previewFeature = null;
                }
            } else {
                selectionVectorSource.clear();
                selectedArea = null;
                document.getElementById('fetchDataBtn').disabled = true;
                document.getElementById('saveDataBtn').disabled = false;
                
                dragBox = new ol.interaction.DragBox({
                    condition: ol.events.condition.platformModifierKeyOnly
                });
                
                dragBox.on('boxend', function() {
                    const extent = dragBox.getGeometry().getExtent();
                    
                    selectionVectorSource.clear();
                    const polygon = new ol.geom.Polygon([[
                        [extent[0], extent[1]],
                        [extent[2], extent[1]],
                        [extent[2], extent[3]],
                        [extent[0], extent[3]],
                        [extent[0], extent[1]]
                    ]]);
                    
                    const feature = new ol.Feature(polygon);
                    selectionVectorSource.addFeature(feature);
                    selectedArea = extent;
                    
                    document.getElementById('fetchDataBtn').disabled = false;
                    
                    const [minX, minY, maxX, maxY] = extent;
                    const bottomLeft = ol.proj.toLonLat([minX, minY]);
                    const topRight = ol.proj.toLonLat([maxX, maxY]);
                    
                    const widthKm = (Math.abs(topRight[0] - bottomLeft[0]) * 111).toFixed(2);
                    const heightKm = (Math.abs(topRight[1] - bottomLeft[1]) * 111).toFixed(2);
                    
                    showToast(`Area selected: ${widthKm}km √ó ${heightKm}km - Ready to fetch!`, 5000);
                    
                    // Reset tap selection state
                    tapSelectionState = 'waitingForFirstCorner';
                    firstCorner = null;
                });
                
                map.addInteraction(dragBox);
                
                // Enable tap selection
                isSelectingArea = true;
                tapSelectionState = 'waitingForFirstCorner';
                selectBtn.classList.add('active');
                showToast('Desktop: Hold Ctrl/Cmd + drag | Mobile: Tap two corners', 5000);
            }
        }

        // Add event listeners for tap selection
        map.on('click', handleMapClick);
        map.on('pointermove', handlePointerMove);

        // Get satellite tiles for the selected area at zoom level 16
        function getSatelliteTiles(extent, zoom = 16) {
            const [minX, minY, maxX, maxY] = extent;
            
            // Convert extent corners to tile coordinates
            const getTileCoord = (lon, lat, zoom) => {
                const n = Math.pow(2, zoom);
                const xtile = Math.floor((lon + 180) / 360 * n);
                const ytile = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);
                return { x: xtile, y: ytile, z: zoom };
            };
            
            const bottomLeft = ol.proj.toLonLat([minX, minY]);
            const topRight = ol.proj.toLonLat([maxX, maxY]);
            
            const tileBL = getTileCoord(bottomLeft[0], bottomLeft[1], zoom);
            const tileTR = getTileCoord(topRight[0], topRight[1], zoom);
            
            const tiles = [];
            for (let x = Math.min(tileBL.x, tileTR.x); x <= Math.max(tileBL.x, tileTR.x); x++) {
                for (let y = Math.min(tileBL.y, tileTR.y); y <= Math.max(tileBL.y, tileTR.y); y++) {
                    tiles.push({
                        x: x,
                        y: y,
                        z: zoom,
                        url: `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoom}/${y}/${x}`
                    });
                }
            }
            
            return tiles;
        }

        // Query elevation from Queensland DEM ImageServer
        async function queryElevation(lon, lat) {
            // Format geometry as JSON object with spatial reference
            const geometry = {
                x: lon,
                y: lat,
                spatialReference: { wkid: 4326 }
            };
            
            const url = `${QLD_DEM_SERVICE}/identify?` + 
                `geometry=${encodeURIComponent(JSON.stringify(geometry))}` +
                `&geometryType=esriGeometryPoint` +
                `&returnGeometry=false` +
                `&returnCatalogItems=false` +
                `&f=json`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.value !== undefined && data.value !== null) {
                    return data.value; // Elevation in meters
                } else {
                    return null;
                }
            } catch (error) {
                console.error('Error querying elevation:', error);
                return null;
            }
        }

        // Fetch elevation data for the selected area using Queensland DEM
        async function fetchElevationData() {
            if (!selectedArea) {
                showToast('Please select an area first');
                return;
            }
            
            showLoading(true, 'Preparing to fetch high-resolution elevation data...');
            
            const [minX, minY, maxX, maxY] = selectedArea;
            const bottomLeft = ol.proj.toLonLat([minX, minY]);
            const topRight = ol.proj.toLonLat([maxX, maxY]);
            
            const gridSize = 90;
            const lonStep = (topRight[0] - bottomLeft[0]) / (gridSize - 1);
            const latStep = (topRight[1] - bottomLeft[1]) / (gridSize - 1);
            
            const elevationGrid = [];
            const coordinates = [];
            
            // Generate grid coordinates
            for (let i = 0; i < gridSize; i++) {
                elevationGrid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    const lon = bottomLeft[0] + j * lonStep;
                    const lat = bottomLeft[1] + i * latStep;
                    coordinates.push({ lon, lat, i, j });
                }
            }
            
            const totalPoints = coordinates.length;
            let completedPoints = 0;
            
            // Fetch elevation data with batching to avoid overwhelming the server
            const batchSize = 10;
            const delayBetweenBatches = 100; // ms
            
            for (let i = 0; i < coordinates.length; i += batchSize) {
                const batch = coordinates.slice(i, i + batchSize);
                
                // Process batch in parallel
                const promises = batch.map(coord => queryElevation(coord.lon, coord.lat));
                const results = await Promise.all(promises);
                
                // Store results
                results.forEach((elevation, idx) => {
                    const coord = batch[idx];
                    elevationGrid[coord.i][coord.j] = {
                        elevation: elevation !== null ? elevation : 0,
                        lon: coord.lon,
                        lat: coord.lat
                    };
                });
                
                completedPoints += batch.length;
                const percentage = ((completedPoints / totalPoints) * 100).toFixed(1);
                showLoading(true, `Fetching elevation data: ${completedPoints}/${totalPoints} (${percentage}%)`);
                
                // Small delay between batches
                if (i + batchSize < coordinates.length) {
                    await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
                }
            }
            
            // Get satellite tiles
            const satelliteTiles = getSatelliteTiles(selectedArea, 16);
            
            // Calculate min/max elevation for metadata
            let minElevation = Infinity;
            let maxElevation = -Infinity;
            elevationGrid.forEach(row => {
                row.forEach(point => {
                    if (point.elevation < minElevation) minElevation = point.elevation;
                    if (point.elevation > maxElevation) maxElevation = point.elevation;
                });
            });
            
            // Store the complete dataset
            currentElevationData = {
                metadata: {
                    gridSize: gridSize,
                    bounds: {
                        minLon: bottomLeft[0],
                        minLat: bottomLeft[1],
                        maxLon: topRight[0],
                        maxLat: topRight[1]
                    },
                    center: {
                        lon: (bottomLeft[0] + topRight[0]) / 2,
                        lat: (bottomLeft[1] + topRight[1]) / 2
                    },
                    elevation: {
                        min: minElevation,
                        max: maxElevation,
                        range: maxElevation - minElevation
                    },
                    dataSource: 'Queensland DEM (0.5m-1m LiDAR resolution)',
                    timestamp: new Date().toISOString(),
                    satelliteZoom: 16
                },
                elevationGrid: elevationGrid,
                satelliteTiles: satelliteTiles
            };
            
            showLoading(false);
            document.getElementById('saveDataBtn').disabled = false;
            
            showToast(`High-res data fetched! ${gridSize}x${gridSize} grid, elevation range: ${minElevation.toFixed(1)}m - ${maxElevation.toFixed(1)}m, ${satelliteTiles.length} satellite tiles`, 6000);
        }

        // Save elevation data as JSON
        function saveTerrainData() {
            if (!currentElevationData) {
                showToast('No terrain data to save');
                return;
            }
            
            const dataStr = JSON.stringify(currentElevationData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `terrain_data_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showToast('Terrain data saved successfully! Ready for 3D rendering.');
        }

        // Event listeners
        document.getElementById('contoursBtn').addEventListener('click', toggleContours);
        document.getElementById('satelliteBtn').addEventListener('click', toggleSatellite);
        document.getElementById('selectAreaBtn').addEventListener('click', toggleAreaSelection);
        document.getElementById('fetchDataBtn').addEventListener('click', fetchElevationData);
        document.getElementById('saveDataBtn').addEventListener('click', saveTerrainData);
    </script>
</body>
</html>
