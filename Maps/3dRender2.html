<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain Analysis & 3D Export</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.2.1/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v10.2.1/dist/ol.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 15px;
            z-index: 1000;
            min-width: 200px;
        }

        .control-btn {
            display: block;
            width: 100%;
            padding: 12px 20px;
            margin-bottom: 10px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            color: #333;
        }

        .control-btn:last-child {
            margin-bottom: 0;
        }

        .control-btn:hover:not(:disabled) {
            background: #f5f5f5;
            border-color: #2196F3;
        }

        .control-btn.active {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Toast notification */
        .toast {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 2000;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            max-width: 80%;
            text-align: center;
        }

        .toast.show {
            opacity: 1;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 12px 15px;
            font-size: 12px;
            z-index: 1000;
            max-width: 220px;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            color: #666;
        }

        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 8px;
            background: #8B4513;
        }

        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            flex-direction: column;
            color: white;
        }

        .loading-overlay.show {
            display: flex;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            font-weight: 500;
        }

        .loading-progress {
            margin-top: 10px;
            font-size: 14px;
            opacity: 0.8;
        }

        /* Selection box style */
        .ol-dragbox {
            background-color: rgba(33, 150, 243, 0.2);
            border: 2px dashed #2196F3;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="control-panel">
        <button id="contoursBtn" class="control-btn">üóª Contours</button>
        <button id="satelliteBtn" class="control-btn">üõ∞Ô∏è Satellite View</button>
        <button id="selectAreaBtn" class="control-btn">üìç Select Area</button>
        <button id="fetchDataBtn" class="control-btn" disabled>üìä Fetch Terrain Data</button>
        <button id="saveDataBtn" class="control-btn" disabled>üíæ Save JSON</button>
    </div>

    <div id="legend" class="legend" style="display: none;">
        <div class="legend-title">Contour Lines</div>
        <div class="legend-item">
            <div class="legend-line"></div>
            <span>Auto: 1m, 5m, or 10m intervals</span>
        </div>
        <div style="font-size: 11px; color: #999; margin-top: 5px;">
            Resolution depends on zoom level and data availability
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Fetching high-resolution elevation data...</div>
        <div class="loading-progress" id="loadingProgress">Initializing...</div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        // Global variables
        let selectedArea = null;
        let currentElevationData = null;
        let isSelectingArea = false;
        let dragBox = null;
        
        // Tap selection state for mobile
        let tapSelectionState = 'idle'; // 'idle', 'waitingForFirstCorner', 'waitingForSecondCorner'
        let firstCorner = null;
        let previewFeature = null;

        // Queensland 1m high-resolution DEM service
        const QLD_DEM_1M_SERVICE = 'https://spatial-img.information.qld.gov.au/arcgis/rest/services/Elevation/DEM1mHillshadeAustralia_AllQld_Cache/ImageServer';

        // Map setup with better initial view of Queensland
        const map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM()
                })
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([153.0260, -27.4705]), // Brisbane area
                zoom: 13,
                maxZoom: 20
            })
        });

        // Vector layer for contours
        const contourVectorSource = new ol.source.Vector();
        const contourLayer = new ol.layer.Vector({
            source: contourVectorSource,
            visible: false,
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: '#8B4513',
                    width: 1.5
                })
            })
        });
        map.addLayer(contourLayer);

        // Vector layer for selected area
        const selectionVectorSource = new ol.source.Vector();
        const selectionLayer = new ol.layer.Vector({
            source: selectionVectorSource,
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: '#FF4444',
                    width: 3,
                    lineDash: [10, 5]
                }),
                fill: new ol.style.Fill({
                    color: 'rgba(255, 68, 68, 0.1)'
                })
            }),
            zIndex: 1000
        });
        map.addLayer(selectionLayer);

        // Satellite layer
        const satelliteLayer = new ol.layer.Tile({
            source: new ol.source.XYZ({
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                maxZoom: 19
            }),
            visible: false
        });
        map.getLayers().insertAt(0, satelliteLayer);

        // Utility functions
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), duration);
        }

        function showLoading(show, message = 'Loading...') {
            const overlay = document.getElementById('loadingOverlay');
            const progress = document.getElementById('loadingProgress');
            if (show) {
                overlay.classList.add('show');
                progress.textContent = message;
            } else {
                overlay.classList.remove('show');
            }
        }

        function debug(message) {
            console.log('[Debug] ' + message);
        }

        // Toggle contour layer
        function toggleContours() {
            const isVisible = contourLayer.getVisible();
            contourLayer.setVisible(!isVisible);
            document.getElementById('contoursBtn').classList.toggle('active');
            document.getElementById('legend').style.display = !isVisible ? 'block' : 'none';
            
            if (!isVisible && contourVectorSource.getFeatures().length === 0) {
                showToast('Zoom in and pan to see contour lines (computed from Queensland DEM)');
                generateContours();
            }
        }

        // Toggle satellite layer
        function toggleSatellite() {
            const isVisible = satelliteLayer.getVisible();
            satelliteLayer.setVisible(!isVisible);
            document.getElementById('satelliteBtn').classList.toggle('active');
        }

        // Generate contour lines for the current view
        async function generateContours() {
            const view = map.getView();
            const extent = view.calculateExtent(map.getSize());
            const zoom = view.getZoom();
            
            if (zoom < 13) {
                return;
            }
            
            contourVectorSource.clear();
            
            const [minX, minY, maxX, maxY] = extent;
            const bottomLeft = ol.proj.toLonLat([minX, minY]);
            const topRight = ol.proj.toLonLat([maxX, maxY]);
            
            const gridSize = 50;
            const lonStep = (topRight[0] - bottomLeft[0]) / (gridSize - 1);
            const latStep = (topRight[1] - bottomLeft[1]) / (gridSize - 1);
            
            const elevationGrid = [];
            for (let i = 0; i < gridSize; i++) {
                elevationGrid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    const lon = bottomLeft[0] + j * lonStep;
                    const lat = bottomLeft[1] + i * latStep;
                    const elevation = await queryElevation(lon, lat);
                    elevationGrid[i][j] = elevation !== null ? elevation : 0;
                }
            }
            
            let interval;
            if (zoom >= 16) interval = 1;
            else if (zoom >= 14) interval = 5;
            else interval = 10;
            
            const minElev = Math.min(...elevationGrid.flat());
            const maxElev = Math.max(...elevationGrid.flat());
            
            for (let elev = Math.ceil(minElev / interval) * interval; elev <= maxElev; elev += interval) {
                const segments = marchingSquares(elevationGrid, elev, bottomLeft, lonStep, latStep);
                segments.forEach(segment => {
                    const coords = segment.map(([lon, lat]) => 
                        ol.proj.fromLonLat([lon, lat])
                    );
                    const feature = new ol.Feature({
                        geometry: new ol.geom.LineString(coords)
                    });
                    contourVectorSource.addFeature(feature);
                });
            }
        }

        // Simplified marching squares for contour generation
        function marchingSquares(grid, threshold, origin, lonStep, latStep) {
            const segments = [];
            const rows = grid.length;
            const cols = grid[0].length;
            
            for (let i = 0; i < rows - 1; i++) {
                for (let j = 0; j < cols - 1; j++) {
                    const tl = grid[i][j] >= threshold ? 1 : 0;
                    const tr = grid[i][j+1] >= threshold ? 1 : 0;
                    const bl = grid[i+1][j] >= threshold ? 1 : 0;
                    const br = grid[i+1][j+1] >= threshold ? 1 : 0;
                    
                    const cellType = tl * 8 + tr * 4 + br * 2 + bl;
                    
                    if (cellType === 0 || cellType === 15) continue;
                    
                    const x = origin[0] + j * lonStep;
                    const y = origin[1] + i * latStep;
                    
                    const getEdgePoint = (edge) => {
                        switch(edge) {
                            case 'top': return [x + lonStep/2, y];
                            case 'right': return [x + lonStep, y + latStep/2];
                            case 'bottom': return [x + lonStep/2, y + latStep];
                            case 'left': return [x, y + latStep/2];
                        }
                    };
                    
                    const configs = {
                        1: [['left', 'bottom']], 2: [['bottom', 'right']], 3: [['left', 'right']],
                        4: [['top', 'right']], 5: [['top', 'bottom'], ['left', 'right']],
                        6: [['top', 'bottom']], 7: [['left', 'top']], 8: [['left', 'top']],
                        9: [['bottom', 'top']], 10: [['left', 'right'], ['top', 'bottom']],
                        11: [['right', 'top']], 12: [['left', 'right']], 13: [['bottom', 'right']],
                        14: [['left', 'bottom']]
                    };
                    
                    if (configs[cellType]) {
                        configs[cellType].forEach(([e1, e2]) => {
                            segments.push([getEdgePoint(e1), getEdgePoint(e2)]);
                        });
                    }
                }
            }
            
            return segments;
        }

        // Handle map click for tap selection
        function handleMapClick(evt) {
            if (!isSelectingArea) return;
            
            if (tapSelectionState === 'waitingForFirstCorner') {
                firstCorner = evt.coordinate;
                tapSelectionState = 'waitingForSecondCorner';
                showToast('Tap the second corner', 3000);
            } else if (tapSelectionState === 'waitingForSecondCorner') {
                const secondCorner = evt.coordinate;
                
                const extent = [
                    Math.min(firstCorner[0], secondCorner[0]),
                    Math.min(firstCorner[1], secondCorner[1]),
                    Math.max(firstCorner[0], secondCorner[0]),
                    Math.max(firstCorner[1], secondCorner[1])
                ];
                
                selectionVectorSource.clear();
                if (previewFeature) {
                    previewFeature = null;
                }
                
                const polygon = new ol.geom.Polygon([[
                    [extent[0], extent[1]],
                    [extent[2], extent[1]],
                    [extent[2], extent[3]],
                    [extent[0], extent[3]],
                    [extent[0], extent[1]]
                ]]);
                
                const feature = new ol.Feature(polygon);
                selectionVectorSource.addFeature(feature);
                selectedArea = extent;
                
                document.getElementById('fetchDataBtn').disabled = false;
                
                const [minX, minY, maxX, maxY] = extent;
                const bottomLeft = ol.proj.toLonLat([minX, minY]);
                const topRight = ol.proj.toLonLat([maxX, maxY]);
                
                const widthKm = (Math.abs(topRight[0] - bottomLeft[0]) * 111).toFixed(2);
                const heightKm = (Math.abs(topRight[1] - bottomLeft[1]) * 111).toFixed(2);
                
                showToast(`Area selected: ${widthKm}km √ó ${heightKm}km - Ready to fetch!`, 5000);
                
                tapSelectionState = 'waitingForFirstCorner';
                firstCorner = null;
            }
        }

        // Handle pointer move for preview
        function handlePointerMove(evt) {
            if (tapSelectionState === 'waitingForSecondCorner' && firstCorner) {
                const currentCoord = evt.coordinate;
                
                const extent = [
                    Math.min(firstCorner[0], currentCoord[0]),
                    Math.min(firstCorner[1], currentCoord[1]),
                    Math.max(firstCorner[0], currentCoord[0]),
                    Math.max(firstCorner[1], currentCoord[1])
                ];
                
                selectionVectorSource.clear();
                
                const polygon = new ol.geom.Polygon([[
                    [extent[0], extent[1]],
                    [extent[2], extent[1]],
                    [extent[2], extent[3]],
                    [extent[0], extent[3]],
                    [extent[0], extent[1]]
                ]]);
                
                previewFeature = new ol.Feature(polygon);
                selectionVectorSource.addFeature(previewFeature);
            }
        }

        // Toggle area selection mode
        function toggleAreaSelection() {
            const selectBtn = document.getElementById('selectAreaBtn');
            
            if (isSelectingArea) {
                isSelectingArea = false;
                tapSelectionState = 'idle';
                firstCorner = null;
                if (dragBox) {
                    map.removeInteraction(dragBox);
                    dragBox = null;
                }
                selectBtn.classList.remove('active');
                if (previewFeature) {
                    selectionVectorSource.removeFeature(previewFeature);
                    previewFeature = null;
                }
            } else {
                selectionVectorSource.clear();
                selectedArea = null;
                document.getElementById('fetchDataBtn').disabled = true;
                document.getElementById('saveDataBtn').disabled = true;
                
                dragBox = new ol.interaction.DragBox({
                    condition: ol.events.condition.platformModifierKeyOnly
                });
                
                dragBox.on('boxend', function() {
                    const extent = dragBox.getGeometry().getExtent();
                    
                    selectionVectorSource.clear();
                    const polygon = new ol.geom.Polygon([[
                        [extent[0], extent[1]],
                        [extent[2], extent[1]],
                        [extent[2], extent[3]],
                        [extent[0], extent[3]],
                        [extent[0], extent[1]]
                    ]]);
                    
                    const feature = new ol.Feature(polygon);
                    selectionVectorSource.addFeature(feature);
                    selectedArea = extent;
                    
                    document.getElementById('fetchDataBtn').disabled = false;
                    
                    const [minX, minY, maxX, maxY] = extent;
                    const bottomLeft = ol.proj.toLonLat([minX, minY]);
                    const topRight = ol.proj.toLonLat([maxX, maxY]);
                    
                    const widthKm = (Math.abs(topRight[0] - bottomLeft[0]) * 111).toFixed(2);
                    const heightKm = (Math.abs(topRight[1] - bottomLeft[1]) * 111).toFixed(2);
                    
                    showToast(`Area selected: ${widthKm}km √ó ${heightKm}km - Ready to fetch!`, 5000);
                    
                    // Reset tap selection state
                    tapSelectionState = 'waitingForFirstCorner';
                    firstCorner = null;
                });
                
                map.addInteraction(dragBox);
                
                // Enable tap selection
                isSelectingArea = true;
                tapSelectionState = 'waitingForFirstCorner';
                selectBtn.classList.add('active');
                showToast('Desktop: Hold Ctrl/Cmd + drag | Mobile: Tap two corners', 5000);
            }
        }

        // Add event listeners for tap selection
        map.on('click', handleMapClick);
        map.on('pointermove', handlePointerMove);

        // Get satellite tiles for the selected area at zoom level 16
        function getSatelliteTiles(extent, zoom = 16) {
            const [minX, minY, maxX, maxY] = extent;
            
            // Convert extent corners to tile coordinates
            const getTileCoord = (lon, lat, zoom) => {
                const n = Math.pow(2, zoom);
                const xtile = Math.floor((lon + 180) / 360 * n);
                const ytile = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);
                return { x: xtile, y: ytile, z: zoom };
            };
            
            const bottomLeft = ol.proj.toLonLat([minX, minY]);
            const topRight = ol.proj.toLonLat([maxX, maxY]);
            
            const tileBL = getTileCoord(bottomLeft[0], bottomLeft[1], zoom);
            const tileTR = getTileCoord(topRight[0], topRight[1], zoom);
            
            const tiles = [];
            for (let x = Math.min(tileBL.x, tileTR.x); x <= Math.max(tileBL.x, tileTR.x); x++) {
                for (let y = Math.min(tileBL.y, tileTR.y); y <= Math.max(tileBL.y, tileTR.y); y++) {
                    tiles.push({
                        x: x,
                        y: y,
                        z: zoom,
                        url: `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoom}/${y}/${x}`
                    });
                }
            }
            
            return tiles;
        }

        // Query elevation from Queensland 1m DEM ImageServer using the proven method
        async function queryElevation(lon, lat) {
            try {
                // Use identify endpoint with URLSearchParams (proven method from reference file)
                const params = new URLSearchParams({
                    geometryType: 'esriGeometryPoint',
                    geometry: JSON.stringify({ x: lon, y: lat, spatialReference: { wkid: 4326 } }),
                    returnGeometry: false,
                    returnCatalogItems: false,
                    f: 'json'
                });
                
                const url = QLD_DEM_1M_SERVICE + '/identify?' + params.toString();
                
                const response = await fetch(url);
                const data = await response.json();
                
                // Check data.value first, then fallback to data.pixel[0]
                if (data.value !== undefined && data.value !== null) {
                    return data.value;
                } else if (data.pixel && data.pixel.length > 0) {
                    return data.pixel[0];
                } else {
                    return null;
                }
            } catch (error) {
                console.error('Error querying elevation:', error);
                return null;
            }
        }

        // Fetch elevation data for the selected area using the proven method from reference file
        async function fetchElevationData() {
            if (!selectedArea) {
                showToast('Please select an area first');
                return;
            }
            
            showLoading(true, 'Preparing to fetch 1m resolution elevation data...');
            
            const [minX, minY, maxX, maxY] = selectedArea;
            const bottomLeft = ol.proj.toLonLat([minX, minY]);
            const topRight = ol.proj.toLonLat([maxX, maxY]);
            
            try {
                // Use proven grid size from reference file (60x60 = 3600 samples)
                const gridSize = 60;
                const width = gridSize;
                const height = gridSize;
                
                const lonStep = (topRight[0] - bottomLeft[0]) / (width - 1);
                const latStep = (topRight[1] - bottomLeft[1]) / (height - 1);
                
                debug('Fetching elevation for ' + (width * height) + ' points at 1m resolution');
                
                const elevationGrid = [];
                let successCount = 0;
                let nullCount = 0;
                
                // Fetch elevation points one at a time (proven reliable method)
                for (let i = 0; i < height; i++) {
                    elevationGrid[i] = [];
                    for (let j = 0; j < width; j++) {
                        const idx = i * width + j;
                        const lon = bottomLeft[0] + j * lonStep;
                        const lat = bottomLeft[1] + i * latStep;
                        
                        const elevation = await queryElevation(lon, lat);
                        
                        if (elevation !== null) {
                            elevationGrid[i][j] = {
                                elevation: elevation,
                                lon: lon,
                                lat: lat
                            };
                            successCount++;
                        } else {
                            elevationGrid[i][j] = {
                                elevation: 0,
                                lon: lon,
                                lat: lat
                            };
                            nullCount++;
                        }
                        
                        // Update progress every 5%
                        if (idx % Math.floor((width * height) / 20) === 0) {
                            const progress = Math.round((idx / (width * height)) * 100);
                            showLoading(true, `Fetching elevation... ${progress}% (${successCount} valid, ${nullCount} null)`);
                            debug('Progress: ' + progress + '% - Success: ' + successCount + ', Null: ' + nullCount);
                        }
                    }
                }
                
                debug('Total successful samples: ' + successCount + ' out of ' + (width * height));
                
                // Get satellite tiles
                const satelliteTiles = getSatelliteTiles(selectedArea, 16);
                
                // Calculate min/max elevation for metadata
                let minElevation = Infinity;
                let maxElevation = -Infinity;
                elevationGrid.forEach(row => {
                    row.forEach(point => {
                        if (point.elevation < minElevation) minElevation = point.elevation;
                        if (point.elevation > maxElevation) maxElevation = point.elevation;
                    });
                });
                
                debug('Elevation range: ' + minElevation + 'm to ' + maxElevation + 'm');
                
                // Store the complete dataset
                currentElevationData = {
                    metadata: {
                        gridSize: gridSize,
                        bounds: {
                            minLon: bottomLeft[0],
                            minLat: bottomLeft[1],
                            maxLon: topRight[0],
                            maxLat: topRight[1]
                        },
                        center: {
                            lon: (bottomLeft[0] + topRight[0]) / 2,
                            lat: (bottomLeft[1] + topRight[1]) / 2
                        },
                        elevation: {
                            min: minElevation,
                            max: maxElevation,
                            range: maxElevation - minElevation
                        },
                        dataSource: 'Queensland DEM 1m (High-Resolution LiDAR)',
                        timestamp: new Date().toISOString(),
                        satelliteZoom: 16,
                        successRate: ((successCount / (width * height)) * 100).toFixed(1) + '%',
                        totalPoints: width * height,
                        validPoints: successCount,
                        nullPoints: nullCount
                    },
                    elevationGrid: elevationGrid,
                    satelliteTiles: satelliteTiles
                };
                
                showLoading(false);
                document.getElementById('saveDataBtn').disabled = false;
                
                if (successCount > 0) {
                    showToast(`1m data fetched! ${gridSize}x${gridSize} grid, elevation: ${minElevation.toFixed(1)}m - ${maxElevation.toFixed(1)}m, success rate: ${((successCount / (width * height)) * 100).toFixed(1)}%`, 6000);
                } else {
                    showToast('Warning: No valid elevation data received. Check service availability.', 6000);
                }
                
            } catch (error) {
                debug('ERROR: ' + error.message);
                showToast('Error fetching elevation data: ' + error.message);
                showLoading(false);
            }
        }

        // Save elevation data as JSON
        function saveTerrainData() {
            if (!currentElevationData) {
                showToast('No terrain data to save');
                return;
            }
            
            const dataStr = JSON.stringify(currentElevationData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `terrain_1m_data_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showToast('1m terrain data saved successfully! Ready for 3D rendering.');
        }

        // Event listeners
        document.getElementById('contoursBtn').addEventListener('click', toggleContours);
        document.getElementById('satelliteBtn').addEventListener('click', toggleSatellite);
        document.getElementById('selectAreaBtn').addEventListener('click', toggleAreaSelection);
        document.getElementById('fetchDataBtn').addEventListener('click', fetchElevationData);
        document.getElementById('saveDataBtn').addEventListener('click', saveTerrainData);
    </script>
</body>
</html>
