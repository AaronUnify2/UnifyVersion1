<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Enhanced PS2-Style Mascot Panda</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background-color: #000;
      touch-action: none;
    }
    canvas { 
      display: block; 
    }
    #controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }
    .direction-pad {
      display: grid;
      grid-template-columns: repeat(3, 60px);
      grid-template-rows: repeat(3, 60px);
      gap: 5px;
      pointer-events: none;
    }
    .camera-pad {
      display: grid;
      grid-template-columns: repeat(3, 60px);
      grid-template-rows: repeat(3, 60px);
      gap: 5px;
      pointer-events: none;
    }
    .control-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: white;
      user-select: none;
      pointer-events: auto;
      border: none;
      outline: none;
      -webkit-tap-highlight-color: transparent;
    }
    .control-btn:active, .control-btn.active {
      background-color: rgba(255, 255, 255, 0.6);
    }
    .control-btn.center {
      opacity: 0;
      pointer-events: none;
    }
    .instructions {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-family: Arial, sans-serif;
      background-color: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
    #fps-counter {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      font-family: monospace;
      background-color: rgba(0,0,0,0.6);
      padding: 5px;
      border-radius: 3px;
      font-size: 12px;
    }
    #hud {
      position: absolute;
      top: 60px;
      left: 20px;
      color: white;
      font-family: 'Arial', sans-serif;
      font-size: 16px;
      text-shadow: 2px 2px 2px rgba(0,0,0,0.8);
    }
    .gem-counter {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .gem-icon {
      width: 30px;
      height: 30px;
      background-color: #f8f;
      border-radius: 3px;
      margin-right: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 10px #f0f;
    }
  </style>
</head>
<body>
  <div class="instructions">
    Left buttons: Move Panda<br>
    Right buttons: Rotate Camera
  </div>

  <div id="fps-counter">FPS: 60</div>
  
  <div id="hud">
    <div class="gem-counter">
      <div class="gem-icon">♦</div>
      <span id="gem-count">0</span>
    </div>
  </div>
  
  <div id="controls">
    <div class="control-group">
      <div class="direction-pad">
        <button id="btn-nw" class="control-btn">↖</button>
        <button id="btn-n" class="control-btn">↑</button>
        <button id="btn-ne" class="control-btn">↗</button>
        <button id="btn-w" class="control-btn">←</button>
        <button id="btn-center" class="control-btn center">·</button>
        <button id="btn-e" class="control-btn">→</button>
        <button id="btn-sw" class="control-btn">↙</button>
        <button id="btn-s" class="control-btn">↓</button>
        <button id="btn-se" class="control-btn">↘</button>
      </div>
    </div>
    
    <div class="control-group">
      <div class="camera-pad">
        <button id="cam-zoom-in" class="control-btn">+</button>
        <button id="cam-up" class="control-btn">↑</button>
        <button id="cam-empty1" class="control-btn center">·</button>
        <button id="cam-left" class="control-btn">←</button>
        <button id="cam-empty2" class="control-btn center">·</button>
        <button id="cam-right" class="control-btn">→</button>
        <button id="cam-zoom-out" class="control-btn">-</button>
        <button id="cam-down" class="control-btn">↓</button>
        <button id="cam-empty3" class="control-btn center">·</button>
      </div>
    </div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Enhanced PS2-Style 3D Game Setup
    // With improved textures, normal maps, and advanced effects
    
    // Set up renderer with PS2-era capabilities (better than PS1)
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    
    // Set up scene
    const scene = new THREE.Scene();
    
    // Set up camera with PS2-era field of view
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 8);
    camera.lookAt(0, 1, 0);
    
    // PS2-era enhanced lighting system
    // Ambient light
    const ambientLight = new THREE.AmbientLight(0x666666);
    scene.add(ambientLight);
    
    // Main directional light with shadows
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 30);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 10;
    directionalLight.shadow.camera.far = 200;
    directionalLight.shadow.camera.left = -50;
    directionalLight.shadow.camera.right = 50;
    directionalLight.shadow.camera.top = 50;
    directionalLight.shadow.camera.bottom = -50;
    scene.add(directionalLight);
    
    // Secondary fill light - PS2 games often used multiple lights
    const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
    fillLight.position.set(-30, 50, -30);
    scene.add(fillLight);
    
    // ===== TEXTURE CREATION UTILITIES =====
    
    // Create a procedural normal map using a canvas
    function createProceduralNormalMap(width = 256, height = 256, scale = 10) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      
      // First, create a height map
      ctx.fillStyle = '#808080';
      ctx.fillRect(0, 0, width, height);
      
      // Add random noise
      for (let i = 0; i < 10000; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const size = Math.random() * 3 + 1;
        const gray = 100 + Math.random() * 60;
        
        ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
        ctx.fillRect(x, y, size, size);
      }
      
      // Add larger structures
      for (let i = 0; i < 20; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const radius = 10 + Math.random() * 40;
        
        const isBump = Math.random() > 0.5;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        
        if (isBump) {
          gradient.addColorStop(0, 'rgb(240, 240, 240)');
          gradient.addColorStop(1, 'rgb(128, 128, 128)');
        } else {
          gradient.addColorStop(0, 'rgb(60, 60, 60)');
          gradient.addColorStop(1, 'rgb(128, 128, 128)');
        }
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Convert to normal map
      const imgData = ctx.getImageData(0, 0, width, height);
      const data = imgData.data;
      
      const normalData = ctx.createImageData(width, height);
      const normalPixels = normalData.data;
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = (y * width + x) * 4;
          const left = data[idx - 4] / 255;
          const right = data[idx + 4] / 255;
          const up = data[(y - 1) * width * 4 + x * 4] / 255;
          const down = data[(y + 1) * width * 4 + x * 4] / 255;
          
          const dX = (right - left) * scale;
          const dY = (down - up) * scale;
          
          const length = Math.sqrt(dX * dX + dY * dY + 1);
          const nx = -dX / length;
          const ny = -dY / length;
          const nz = 1 / length;
          
          normalPixels[idx] = Math.floor((nx * 0.5 + 0.5) * 255);
          normalPixels[idx + 1] = Math.floor((ny * 0.5 + 0.5) * 255);
          normalPixels[idx + 2] = Math.floor((nz * 0.5 + 0.5) * 255);
          normalPixels[idx + 3] = 255;
        }
      }
      
      ctx.putImageData(normalData, 0, 0);
      
      return new THREE.CanvasTexture(canvas);
    }
    
    // Create a grass texture with normal map
    function createGrassWithNormalMap() {
  // Color texture
  const colorCanvas = document.createElement('canvas');
  colorCanvas.width = 512;  // Increase resolution
  colorCanvas.height = 512;
  const colorCtx = colorCanvas.getContext('2d');
  
  // Create a more varied base pattern
  // First layer - dark base
  colorCtx.fillStyle = '#335522';
  colorCtx.fillRect(0, 0, 512, 512);
  
  // Second layer - patches of different green
  for (let i = 0; i < 30; i++) {
    const x = Math.random() * 512;
    const y = Math.random() * 512;
    const radius = 20 + Math.random() * 60;
    
    const gradient = colorCtx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, 'rgba(120, 180, 65, 0.7)');
    gradient.addColorStop(1, 'rgba(51, 85, 34, 0)');
    
    colorCtx.fillStyle = gradient;
    colorCtx.beginPath();
    colorCtx.arc(x, y, radius, 0, Math.PI * 2);
    colorCtx.fill();
  }
  
  // Add grass blades
  for (let i = 0; i < 10000; i++) {
    const x = Math.random() * 512;
    const y = Math.random() * 512;
    
    // Grass blade
    const length = 3 + Math.random() * 12;
    const width = 1 + Math.random() * 2;
    
    // Vary the green color
    const r = 40 + Math.random() * 40;
    const g = 100 + Math.random() * 80;
    const b = 20 + Math.random() * 50;
    
    colorCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    
    // Rotate to create random blade orientation
    colorCtx.save();
    colorCtx.translate(x, y);
    colorCtx.rotate(Math.random() * Math.PI * 2);
    colorCtx.fillRect(-width/2, -length/2, width, length);
    colorCtx.restore();
  }
  
  // Add some soil/dirt spots
  for (let i = 0; i < 50; i++) {
    const x = Math.random() * 512;
    const y = Math.random() * 512;
    const radius = 3 + Math.random() * 10;
    
    colorCtx.fillStyle = `rgb(${90 + Math.random() * 40}, ${70 + Math.random() * 30}, ${30 + Math.random() * 30})`;
    colorCtx.beginPath();
    colorCtx.arc(x, y, radius, 0, Math.PI * 2);
    colorCtx.fill();
  }
  
  // Create matching normal map with more detail
  const normalMap = createProceduralNormalMap(512, 512, 15);
  
  // Create textures
  const colorTexture = new THREE.CanvasTexture(colorCanvas);
  
  // Set texture properties
  colorTexture.wrapS = THREE.RepeatWrapping;
  colorTexture.wrapT = THREE.RepeatWrapping;
  colorTexture.repeat.set(100, 100);
  
  normalMap.wrapS = THREE.RepeatWrapping;
  normalMap.wrapT = THREE.RepeatWrapping;
  normalMap.repeat.set(100, 100);
  
  return {
    colorMap: colorTexture,
    normalMap: normalMap
  };
}
    
    // Create fur texture with normal map
    function createFurTextureWithNormal() {
      // Create base color texture for fur
      const colorCanvas = document.createElement('canvas');
      colorCanvas.width = 256;
      colorCanvas.height = 256;
      const colorCtx = colorCanvas.getContext('2d');
      
      // Base fur color
      colorCtx.fillStyle = '#ffffff';
      colorCtx.fillRect(0, 0, 256, 256);
      
      // Add fur strands
      for (let i = 0; i < 2000; i++) {
        const x = Math.random() * 256;
        const y = Math.random() * 256;
        const length = 2 + Math.random() * 8;
        const width = 1 + Math.random() * 1.5;
        const angle = Math.random() * Math.PI * 2;
        
        // Random gray for the fur strand
        const gray = 200 + Math.random() * 55;
        colorCtx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
        
        // Draw a small line representing a fur strand
        colorCtx.save();
        colorCtx.translate(x, y);
        colorCtx.rotate(angle);
        colorCtx.fillRect(-width/2, -length/2, width, length);
        colorCtx.restore();
      }
      
      // Create a matching normal map
      const normalCanvas = document.createElement('canvas');
      normalCanvas.width = 256;
      normalCanvas.height = 256;
      const normalCtx = normalCanvas.getContext('2d');
      
      // Initialize with flat normal
      normalCtx.fillStyle = '#8080ff';
      normalCtx.fillRect(0, 0, 256, 256);
      
      // Add normal details for each fur strand
      for (let i = 0; i < 2000; i++) {
        const x = Math.random() * 256;
        const y = Math.random() * 256;
        const length = 2 + Math.random() * 8;
        const width = 1 + Math.random() * 1.5;
        const angle = Math.random() * Math.PI * 2;
        
        // Calculate normal based on angle
        const xNormal = Math.floor(128 + Math.cos(angle) * 64);
        const yNormal = Math.floor(128 + Math.sin(angle) * 64);
        
        normalCtx.fillStyle = `rgb(${xNormal}, ${yNormal}, 255)`;
        
        // Draw the strand normal
        normalCtx.save();
        normalCtx.translate(x, y);
        normalCtx.rotate(angle);
        normalCtx.fillRect(-width/2, -length/2, width, length);
        normalCtx.restore();
      }
      
      // Create textures
      const colorTexture = new THREE.CanvasTexture(colorCanvas);
      const normalTexture = new THREE.CanvasTexture(normalCanvas);
      
      // Set texture properties
      colorTexture.wrapS = THREE.RepeatWrapping;
      colorTexture.wrapT = THREE.RepeatWrapping;
      normalTexture.wrapS = THREE.RepeatWrapping;
      normalTexture.wrapT = THREE.RepeatWrapping;
      
      return {
        colorMap: colorTexture,
        normalMap: normalTexture
      };
    }
    
    // Create a bamboo texture
    function createBambooTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 512;
      const context = canvas.getContext('2d');
      
      // Base bamboo color
      context.fillStyle = '#3a6324';
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw bamboo segments/rings
      for (let y = 0; y < canvas.height; y += 60) {
        // Darker ring
        context.fillStyle = '#2d4f1e';
        context.fillRect(0, y, canvas.width, 10);
        
        // Add some texture variation
        for (let i = 0; i < 100; i++) {
          const x = Math.random() * canvas.width;
          const yPos = y + Math.random() * 60;
          const size = Math.random() * 3 + 1;
          const alpha = Math.random() * 0.2 + 0.1;
          
          context.fillStyle = `rgba(45, 79, 30, ${alpha})`;
          context.fillRect(x, yPos, size, size);
        }
      }
      
      // Create vertical stripes typical of bamboo
      for (let x = 0; x < canvas.width; x += 20) {
        context.fillStyle = 'rgba(45, 79, 30, 0.2)';
        context.fillRect(x, 0, 2, canvas.height);
      }
      
      return new THREE.CanvasTexture(canvas);
    }
    

// Create a jungle floor texture
function createJungleFloorTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 512;
  const ctx = canvas.getContext('2d');
  
  // Dark soil base
  ctx.fillStyle = '#3a2a1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Medium soil patches
  for (let i = 0; i < 40; i++) {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const radius = 20 + Math.random() * 60;
    
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, 'rgba(80, 60, 40, 0.8)');
    gradient.addColorStop(1, 'rgba(58, 42, 26, 0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Add leaf litter and small details
  for (let i = 0; i < 2000; i++) {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const size = 2 + Math.random() * 5;
    
    // Random browns and greens for leaves
    const r = 40 + Math.random() * 80;
    const g = 30 + Math.random() * 70;
    const b = 10 + Math.random() * 30;
    
    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(Math.random() * Math.PI * 2);
    ctx.fillRect(-size/2, -size/2, size, size);
    ctx.restore();
  }
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(10, 10);
  
  return texture;
}

// Create a textured sky
function createTexturedSky() {
  // Create canvas for the sky texture
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext('2d');
  
  // Create gradient sky
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#1e90ff');  // Deep blue at top
  gradient.addColorStop(0.5, '#87ceeb');  // Sky blue in middle
  gradient.addColorStop(1, '#e0f7ff');   // Lighter at horizon
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Add some clouds
  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
  
  // Draw several clouds
  for (let i = 0; i < 15; i++) {
    const x = Math.random() * canvas.width;
    const y = canvas.height * 0.2 + Math.random() * canvas.height * 0.5;
    const size = 30 + Math.random() * 60;
    
    // Draw cloud puffs
    for (let j = 0; j < 6; j++) {
      const puffX = x + (Math.random() - 0.5) * size;
      const puffY = y + (Math.random() - 0.5) * size * 0.6;
      const puffSize = (0.5 + Math.random() * 0.5) * size * 0.5;
      
      ctx.beginPath();
      ctx.arc(puffX, puffY, puffSize, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // Create texture from canvas
  const skyTexture = new THREE.CanvasTexture(canvas);
  
  // Create a large sky sphere
  const skyGeometry = new THREE.SphereGeometry(800, 32, 16);
  
  // Create material with the texture inside
  const skyMaterial = new THREE.MeshBasicMaterial({
    map: skyTexture,
    side: THREE.BackSide
  });
  
  const sky = new THREE.Mesh(skyGeometry, skyMaterial);
  
  // Add a simple update function for sky rotation
  sky.update = function(time) {
    sky.rotation.y = time * 0.02; // Slowly rotate the sky
  };
  
  return sky;
}

  
  
    
    // Create PS2-style water
    function createPS2Water(size = 40, position = { x: 0, y: -0.3, z: 0 }) {
      // Water group to hold all elements
      const waterGroup = new THREE.Group();
      waterGroup.position.set(position.x, position.y, position.z);
      
      // Create the water plane
      const waterGeometry = new THREE.PlaneGeometry(size, size, 16, 16);
      
      // Create a canvas for the water texture
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Fill with base water color
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#4585b7');
      gradient.addColorStop(0.5, '#5d9dc9');
      gradient.addColorStop(1, '#4585b7');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Add wave patterns
      for (let i = 0; i < 10; i++) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 2 + Math.random() * 2;
        
        ctx.beginPath();
        let y = Math.random() * canvas.height;
        ctx.moveTo(0, y);
        
        // Create wavy line
        for (let x = 0; x < canvas.width; x += 20) {
          y += (Math.random() - 0.5) * 20;
          ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
      
      // Create a second canvas for normal map
      const normalCanvas = document.createElement('canvas');
      normalCanvas.width = 512;
      normalCanvas.height = 512;
      const normalCtx = normalCanvas.getContext('2d');
      
      // Fill with neutral normal color
      normalCtx.fillStyle = '#8080ff';
      normalCtx.fillRect(0, 0, normalCanvas.width, normalCanvas.height);
      
      // Add normal map details
      for (let y = 0; y < normalCanvas.height; y += 4) {
        for (let x = 0; x < normalCanvas.width; x += 4) {
          const nx = Math.floor(128 + Math.sin(x * 0.1) * Math.cos(y * 0.1) * 127);
          const ny = Math.floor(128 + Math.sin(y * 0.1) * Math.cos(x * 0.1) * 127);
          normalCtx.fillStyle = `rgb(${nx}, ${ny}, 255)`;
          normalCtx.fillRect(x, y, 4, 4);
        }
      }
      
      // Create textures
      const waterTexture = new THREE.CanvasTexture(canvas);
      waterTexture.wrapS = THREE.RepeatWrapping;
      waterTexture.wrapT = THREE.RepeatWrapping;
      waterTexture.repeat.set(5, 5);
      
      const waterNormal = new THREE.CanvasTexture(normalCanvas);
      waterNormal.wrapS = THREE.RepeatWrapping;
      waterNormal.wrapT = THREE.RepeatWrapping;
      waterNormal.repeat.set(5, 5);
      
      // Create material
      const waterMaterial = new THREE.MeshStandardMaterial({
        color: 0x4499cc,
        map: waterTexture,
        normalMap: waterNormal,
        transparent: true,
        opacity: 0.8,
        roughness: 0.2,
        metalness: 0.1
      });
      
      // Create water mesh
      const water = new THREE.Mesh(waterGeometry, waterMaterial);
      water.rotation.x = -Math.PI / 2;
      water.receiveShadow = true;
      
      waterGroup.add(water);
      
      // Create an updatable ripple position
      const ripplePositions = [];
      const rippleTimes = [];
      const MAX_RIPPLES = 8;
      
      // Add animated highlights (sparkles)
      const sparkleGeometry = new THREE.BufferGeometry();
      const sparkleCount = 100;
      
      const positions = new Float32Array(sparkleCount * 3);
      const scales = new Float32Array(sparkleCount);
      
      for (let i = 0; i < sparkleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * size;
        positions[i * 3 + 1] = 0.05;
        positions[i * 3 + 2] = (Math.random() - 0.5) * size;
        scales[i] = Math.random() * 0.5 + 0.5;
      }
      
      sparkleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      sparkleGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
      
      const sparkleMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.2,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });
      
      const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
      sparkles.position.y = 0.05;
      waterGroup.add(sparkles);
      
      // Animation function
      waterGroup.update = function(time) {
        // Update water texture offsets
        water.material.map.offset.x = Math.sin(time * 0.05) * 0.05;
        water.material.map.offset.y = time * 0.03;
        water.material.normalMap.offset.x = time * 0.03;
        water.material.normalMap.offset.y = time * 0.02;
        
        // Update vertices for wave motion
        const vertices = water.geometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
          const x = vertices[i];
          const z = vertices[i + 2];
          
          vertices[i + 1] = Math.sin(x * 0.5 + time) * 0.1 + 
                           Math.cos(z * 0.5 + time * 0.8) * 0.1;
          
          // Apply ripple effects
          for (let r = 0; r < ripplePositions.length; r++) {
            const ripplePos = ripplePositions[r];
            const rippleAge = time - rippleTimes[r];
            
            const dx = x - ripplePos.x;
            const dz = z - ripplePos.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            const speed = 3.0;
            const waveWidth = 1.0;
            const amplitude = Math.max(0, 0.2 - rippleAge * 0.1);
            
            const wavePos = dist - rippleAge * speed;
            if (Math.abs(wavePos) < waveWidth) {
              vertices[i + 1] += Math.cos(wavePos / waveWidth * Math.PI) * amplitude;
            }
          }
        }
        
        water.geometry.attributes.position.needsUpdate = true;
        
// Update sparkles
        const sparklePositions = sparkles.geometry.attributes.position.array;
        const sparkleScales = sparkles.geometry.attributes.scale.array;
        
        for (let i = 0; i < sparkleCount; i++) {
          // Make sparkles "flicker"
          const x = sparklePositions[i * 3];
          const z = sparklePositions[i * 3 + 2];
          
          sparkleScales[i] = (Math.sin(time * 2 + x) * 0.25 + 0.75) * 
                             (Math.cos(time * 1.5 + z) * 0.25 + 0.75);
          
          // Slowly move sparkles
          sparklePositions[i * 3] += Math.sin(time + i) * 0.005;
          sparklePositions[i * 3 + 2] += Math.cos(time * 0.8 + i) * 0.005;
          
          // Keep within bounds
          if (sparklePositions[i * 3] > size / 2) sparklePositions[i * 3] -= size;
          if (sparklePositions[i * 3] < -size / 2) sparklePositions[i * 3] += size;
          if (sparklePositions[i * 3 + 2] > size / 2) sparklePositions[i * 3 + 2] -= size;
          if (sparklePositions[i * 3 + 2] < -size / 2) sparklePositions[i * 3 + 2] += size;
        }
        
        sparkles.geometry.attributes.position.needsUpdate = true;
        sparkles.geometry.attributes.scale.needsUpdate = true;
      };
      
      // Function to add a ripple
      waterGroup.addRipple = function(position) {
        // Convert position to water-local coordinates
        const waterPos = {
          x: position.x - this.position.x,
          z: position.z - this.position.z
        };
        
        // Limit number of ripples
        if (ripplePositions.length >= MAX_RIPPLES) {
          ripplePositions.shift();
          rippleTimes.shift();
        }
        
        ripplePositions.push(waterPos);
        rippleTimes.push(performance.now() * 0.001);
      };
      
      return waterGroup;
    }
    
    // Create enhanced particle system
    function createEnhancedParticleSystem() {
      // Main particle container
      const particleSystem = new THREE.Group();
      
      // Create dust effect (footsteps, landing)
      function createDustEffect() {
        const geometry = new THREE.BufferGeometry();
        const particleCount = 100;
        
        const positions = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const lifetimes = new Float32Array(particleCount);
        const velocities = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] = 0;
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = 0;
          sizes[i] = 0;
          lifetimes[i] = 0;
          velocities[i * 3] = 0;
          velocities[i * 3 + 1] = 0;
          velocities[i * 3 + 2] = 0;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        // Create dust texture
        const dustCanvas = document.createElement('canvas');
        dustCanvas.width = 128;
        dustCanvas.height = 128;
        const ctx = dustCanvas.getContext('2d');
        
        // Draw a soft dust particle
        const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 128, 128);
        
        const dustTexture = new THREE.CanvasTexture(dustCanvas);
        
        const material = new THREE.PointsMaterial({
          color: 0xeedddd,
          size: 0.15,
          map: dustTexture,
          transparent: true,
          opacity: 0.6,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(geometry, material);
        
        particles.userData = {
          lifetimes: lifetimes,
          velocities: velocities,
          activeParticles: 0
        };
        
        // Spawn function
        particles.spawn = function(position, count) {
          const positionArray = this.geometry.attributes.position.array;
          const sizeArray = this.geometry.attributes.size.array;
          const lifetimeArray = this.userData.lifetimes;
          const velocityArray = this.userData.velocities;
          
          let spawned = 0;
          for (let i = 0; i < particleCount && spawned < count; i++) {
            if (lifetimeArray[i] <= 0) {
              positionArray[i * 3] = position.x + (Math.random() - 0.5) * 0.5;
              positionArray[i * 3 + 1] = position.y + Math.random() * 0.1;
              positionArray[i * 3 + 2] = position.z + (Math.random() - 0.5) * 0.5;
              
              velocityArray[i * 3] = (Math.random() - 0.5) * 0.8;
              velocityArray[i * 3 + 1] = Math.random() * 1.5 + 0.5;
              velocityArray[i * 3 + 2] = (Math.random() - 0.5) * 0.8;
              
              sizeArray[i] = 0.05 + Math.random() * 0.1;
              
              lifetimeArray[i] = 0.5 + Math.random() * 0.5;
              
              spawned++;
              this.userData.activeParticles++;
            }
          }
          
          this.geometry.attributes.position.needsUpdate = true;
          this.geometry.attributes.size.needsUpdate = true;
        };
        
        // Update function
        particles.update = function(delta) {
          if (this.userData.activeParticles <= 0) return;
          
          const positionArray = this.geometry.attributes.position.array;
          const sizeArray = this.geometry.attributes.size.array;
          const lifetimeArray = this.userData.lifetimes;
          const velocityArray = this.userData.velocities;
          
          let activeCount = 0;
          
          for (let i = 0; i < particleCount; i++) {
            if (lifetimeArray[i] <= 0) continue;
            
            lifetimeArray[i] -= delta;
            
            if (lifetimeArray[i] > 0) {
              positionArray[i * 3] += velocityArray[i * 3] * delta;
              positionArray[i * 3 + 1] += velocityArray[i * 3 + 1] * delta;
              positionArray[i * 3 + 2] += velocityArray[i * 3 + 2] * delta;
              
              velocityArray[i * 3] *= 0.95;
              velocityArray[i * 3 + 1] -= 0.8 * delta;
              velocityArray[i * 3 + 2] *= 0.95;
              
              const lifeRatio = lifetimeArray[i] / (0.5 + Math.random() * 0.5);
              sizeArray[i] = 0.05 + Math.random() * 0.1 * lifeRatio;
              
              activeCount++;
            } else {
              sizeArray[i] = 0;
            }
          }
          
          this.userData.activeParticles = activeCount;
          
          this.geometry.attributes.position.needsUpdate = true;
          this.geometry.attributes.size.needsUpdate = true;
        };
        
        return particles;
      }
      
      // Create sparkle effect for collectibles
      function createSparkleEffect() {
        const geometry = new THREE.BufferGeometry();
        const particleCount = 50;
        
        const positions = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const colors = new Float32Array(particleCount * 3);
        const lifetimes = new Float32Array(particleCount);
        const velocities = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] = 0;
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = 0;
          sizes[i] = 0;
          lifetimes[i] = 0;
          colors[i * 3] = 1;
          colors[i * 3 + 1] = 1;
          colors[i * 3 + 2] = 1;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        // Create sparkle texture
        const sparkleCanvas = document.createElement('canvas');
        sparkleCanvas.width = 128;
        sparkleCanvas.height = 128;
        const ctx = sparkleCanvas.getContext('2d');
        
        // Draw a star shape
        ctx.fillStyle = 'white';
        ctx.beginPath();
        
        const centerX = 64;
        const centerY = 64;
        const outerRadius = 64;
        const innerRadius = 16;
        
        for (let i = 0; i < 8; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = i * Math.PI / 4;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.closePath();
        ctx.fill();
        
        const sparkleTexture = new THREE.CanvasTexture(sparkleCanvas);
        
        const material = new THREE.PointsMaterial({
          size: 0.2,
          map: sparkleTexture,
          transparent: true,
          opacity: 0.8,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexColors: true
        });
        
        const particles = new THREE.Points(geometry, material);
        
        particles.userData = {
          lifetimes: lifetimes,
          velocities: velocities,
          activeParticles: 0
        };
        
        // Spawn function
        particles.spawn = function(position, count) {
          const positionArray = this.geometry.attributes.position.array;
          const sizeArray = this.geometry.attributes.size.array;
          const colorArray = this.geometry.attributes.color.array;
          const lifetimeArray = this.userData.lifetimes;
          const velocityArray = this.userData.velocities;
          
          let spawned = 0;
          for (let i = 0; i < particleCount && spawned < count; i++) {
            if (lifetimeArray[i] <= 0) {
              positionArray[i * 3] = position.x + (Math.random() - 0.5) * 0.3;
              positionArray[i * 3 + 1] = position.y + (Math.random() - 0.5) * 0.3;
              positionArray[i * 3 + 2] = position.z + (Math.random() - 0.5) * 0.3;
              
              const angle = Math.random() * Math.PI * 2;
              const speed = 0.5 + Math.random() * 2;
              velocityArray[i * 3] = Math.cos(angle) * speed;
              velocityArray[i * 3 + 1] = Math.sin(angle) * speed;
              velocityArray[i * 3 + 2] = (Math.random() - 0.5) * speed;
              
              sizeArray[i] = 0.1 + Math.random() * 0.2;
              
              colorArray[i * 3] = Math.random() * 0.5 + 0.5;
              colorArray[i * 3 + 1] = Math.random() * 0.5 + 0.5;
              colorArray[i * 3 + 2] = Math.random() * 0.5 + 0.5;
              
              lifetimeArray[i] = 0.5 + Math.random() * 1.0;
              
              spawned++;
              this.userData.activeParticles++;
            }
          }
          
          this.geometry.attributes.position.needsUpdate = true;
          this.geometry.attributes.size.needsUpdate = true;
          this.geometry.attributes.color.needsUpdate = true;
        };
        
        // Update function
        particles.update = function(delta) {
          if (this.userData.activeParticles <= 0) return;
          
          const positionArray = this.geometry.attributes.position.array;
          const sizeArray = this.geometry.attributes.size.array;
          const colorArray = this.geometry.attributes.color.array;
          const lifetimeArray = this.userData.lifetimes;
          const velocityArray = this.userData.velocities;
          
          let activeCount = 0;
          
          for (let i = 0; i < particleCount; i++) {
            if (lifetimeArray[i] <= 0) continue;
            
            lifetimeArray[i] -= delta;
            
            if (lifetimeArray[i] > 0) {
              positionArray[i * 3] += velocityArray[i * 3] * delta;
              positionArray[i * 3 + 1] += velocityArray[i * 3 + 1] * delta;
              positionArray[i * 3 + 2] += velocityArray[i * 3 + 2] * delta;
              
              velocityArray[i * 3] *= 0.9;
              velocityArray[i * 3 + 1] *= 0.9;
              velocityArray[i * 3 + 2] *= 0.9;
              
              sizeArray[i] *= 0.99;
              
              colorArray[i * 3] = Math.min(1.0, colorArray[i * 3] + delta * 0.2);
              colorArray[i * 3 + 1] = Math.min(1.0, colorArray[i * 3 + 1] + delta * 0.2);
              colorArray[i * 3 + 2] = Math.min(1.0, colorArray[i * 3 + 2] + delta * 0.2);
              
              activeCount++;
            } else {
              sizeArray[i] = 0;
            }
          }
          
          this.userData.activeParticles = activeCount;
          
          this.geometry.attributes.position.needsUpdate = true;
          this.geometry.attributes.size.needsUpdate = true;
          this.geometry.attributes.color.needsUpdate = true;
        };
        
        return particles;
      }
      
      // Create different particle effect types
      const effectTypes = {
        dust: createDustEffect(),
        sparkle: createSparkleEffect()
      };
      
      // Add all effects to the particle system
      for (const [name, effect] of Object.entries(effectTypes)) {
        particleSystem.add(effect);
        particleSystem[name] = effect;
      }
      
      // Main update function
      particleSystem.update = function(delta) {
        for (const effect of Object.values(effectTypes)) {
          if (effect.update) {
            effect.update(delta);
          }
        }
      };
      
      // Spawn particles at position
      particleSystem.spawn = function(position, count, type) {
        if (effectTypes[type]) {
          effectTypes[type].spawn(position, count);
        }
      };
      
      return particleSystem;
    }
    
    // 
    // ===== Setup Scene Elements =====
    
    // Create sky
    // Create textured sky (replace the existing sky creation)
const sky = createTexturedSky();
scene.add(sky);

// Create jungle floor
const floorTexture = createJungleFloorTexture();
const floorGeometry = new THREE.PlaneGeometry(100, 100);
const floorMaterial = new THREE.MeshStandardMaterial({
  map: floorTexture,
  roughness: 0.9,
  metalness: 0.1
});
const floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = -Math.PI / 2;  // Rotate to be horizontal
floor.position.y = -0.6;  // Lower the floor
floor.receiveShadow = true;
scene.add(floor);

    
    // Create water
    const water = createPS2Water(40, { x: 20, y: -0.3, z: 20 });
    scene.add(water);
    
    // Create particle system
    const particleSystem = createEnhancedParticleSystem();
    scene.add(particleSystem);
    
    // ===== Create PS2-Style Panda Character =====
    function createPS2Panda() {
      const panda = new THREE.Group();
      
      // Get fur textures
      const furTextures = createFurTextureWithNormal();
      
      // Higher quality materials with textures
      const whiteMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        map: furTextures.colorMap,
        normalMap: furTextures.normalMap,
        normalScale: new THREE.Vector2(0.5, 0.5),
        roughness: 0.7,
        metalness: 0.1
      });
      
      const blackMaterial = new THREE.MeshStandardMaterial({
        color: 0x222222,
        map: furTextures.colorMap,
        normalMap: furTextures.normalMap,
        normalScale: new THREE.Vector2(0.5, 0.5),
        roughness: 0.7,
        metalness: 0.1
      });
      
      const blueMaterial = new THREE.MeshStandardMaterial({
        color: 0x3355ff,
        roughness: 0.6,
        metalness: 0.2
      });
      
      const redMaterial = new THREE.MeshStandardMaterial({
        color: 0xff3333,
        roughness: 0.5,
        metalness: 0.3
      });
      
      // Character components with higher polygon counts
      
      // ----- HEAD (200+ polygons with subdivisions) -----
      const headGeometry = new THREE.SphereGeometry(0.6, 12, 10);
      const head = new THREE.Mesh(headGeometry, whiteMaterial);
      head.position.y = 1.6;
      head.castShadow = true;
      panda.add(head);
      
      // ----- FACE DETAILS -----
      // Muzzle - higher poly for PS2
      const muzzleGeometry = new THREE.SphereGeometry(0.45, 10, 8);
      const muzzle = new THREE.Mesh(muzzleGeometry, whiteMaterial);
      muzzle.position.set(0, 1.45, 0.4);
      muzzle.scale.set(0.85, 0.75, 0.8);
      muzzle.castShadow = true;
      panda.add(muzzle);
      
      // Eyes with PS2-quality details
      const eyePatchGeometry = new THREE.SphereGeometry(0.32, 10, 8);
      
      const leftEyePatch = new THREE.Mesh(eyePatchGeometry, blackMaterial);
      leftEyePatch.position.set(0.29, 1.65, 0.45);
      leftEyePatch.scale.set(1, 1, 0.7);
      leftEyePatch.castShadow = true;
      panda.add(leftEyePatch);
      
      const rightEyePatch = new THREE.Mesh(eyePatchGeometry.clone(), blackMaterial);
      rightEyePatch.position.set(-0.29, 1.65, 0.45);
      rightEyePatch.scale.set(1, 1, 0.7);
      rightEyePatch.castShadow = true;
      panda.add(rightEyePatch);
      
      // Eye whites
      const eyeGeometry = new THREE.SphereGeometry(0.14, 10, 8);
      
      const leftEye = new THREE.Mesh(eyeGeometry, whiteMaterial);
      leftEye.position.set(0.31, 1.65, 0.57);
      panda.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeometry.clone(), whiteMaterial);
      rightEye.position.set(-0.31, 1.65, 0.57);
      panda.add(rightEye);
      
      // Pupils
      const pupilGeometry = new THREE.SphereGeometry(0.06, 8, 8);
      
      const leftPupil = new THREE.Mesh(pupilGeometry, blackMaterial);
      leftPupil.position.set(0.32, 1.66, 0.67);
      panda.add(leftPupil);
      
      const rightPupil = new THREE.Mesh(pupilGeometry.clone(), blackMaterial);
      rightPupil.position.set(-0.32, 1.66, 0.67);
      panda.add(rightPupil);
      
      // Nose detail
      const noseGeometry = new THREE.SphereGeometry(0.15, 8, 6);
      const nose = new THREE.Mesh(noseGeometry, blackMaterial);
      nose.position.set(0, 1.36, 0.78);
      nose.scale.set(0.7, 0.5, 0.5);
      nose.castShadow = true;
      panda.add(nose);
      
      // Mouth line
      const mouthGeometry = new THREE.TorusGeometry(0.14, 0.02, 10, 12, Math.PI);
      const mouth = new THREE.Mesh(mouthGeometry, blackMaterial);
      mouth.position.set(0, 1.25, 0.7);
      mouth.rotation.x = -Math.PI / 2;
      mouth.rotation.z = Math.PI;
      panda.add(mouth);
      
      // ----- EARS -----
      const earGeometry = new THREE.SphereGeometry(0.25, 10, 6);
      
      const leftEar = new THREE.Mesh(earGeometry, blackMaterial);
      leftEar.position.set(0.45, 2.0, 0);
      leftEar.scale.set(1, 1.2, 0.6);
      leftEar.castShadow = true;
      panda.add(leftEar);
      
      const rightEar = new THREE.Mesh(earGeometry.clone(), blackMaterial);
      rightEar.position.set(-0.45, 2.0, 0);
      rightEar.scale.set(1, 1.2, 0.6);
      rightEar.castShadow = true;
      panda.add(rightEar);
      
      // Inner ears
      const innerEarGeometry = new THREE.SphereGeometry(0.15, 8, 6);
      
      const leftInnerEar = new THREE.Mesh(innerEarGeometry, redMaterial);
      leftInnerEar.position.set(0.45, 2.0, 0.05);
      leftInnerEar.scale.set(0.7, 0.7, 0.3);
      panda.add(leftInnerEar);
      
      const rightInnerEar = new THREE.Mesh(innerEarGeometry.clone(), redMaterial);
      rightInnerEar.position.set(-0.45, 2.0, 0.05);
      rightInnerEar.scale.set(0.7, 0.7, 0.3);
      panda.add(rightInnerEar);
      
 // ----- BODY -----
// Use a more organic body shape
const torsoUpperGeometry = new THREE.SphereGeometry(0.42, 12, 10);
const torsoUpper = new THREE.Mesh(torsoUpperGeometry, whiteMaterial);
torsoUpper.position.y = 1.15;
torsoUpper.scale.set(1, 0.8, 0.9);
torsoUpper.castShadow = true;
panda.add(torsoUpper);

const torsoLowerGeometry = new THREE.SphereGeometry(0.45, 12, 10);
const torsoLower = new THREE.Mesh(torsoLowerGeometry, whiteMaterial);
torsoLower.position.y = 0.7;
torsoLower.scale.set(1, 0.9, 0.85);
torsoLower.castShadow = true;
panda.add(torsoLower);

// Add a belly
const bellyGeometry = new THREE.SphereGeometry(0.35, 10, 8);
const belly = new THREE.Mesh(bellyGeometry, whiteMaterial);
belly.position.set(0, 0.85, 0.2);
belly.scale.set(0.9, 0.8, 0.6);
belly.castShadow = true;
panda.add(belly);

// Reference to use in animations
const torso = new THREE.Group();
torso.position.y = 0.85;
panda.add(torso);
      
      // Black back patch
      const backPatchGeometry = new THREE.SphereGeometry(0.4, 10, 8);
      const backPatch = new THREE.Mesh(backPatchGeometry, blackMaterial);
      backPatch.position.set(0, 0.9, -0.15);
      backPatch.scale.set(0.8, 0.8, 0.3);
      backPatch.castShadow = true;
      panda.add(backPatch);
      
 // ----- ARMS -----
// Create more organic, less tube-like arms
// Upper arms with shoulder joints
const shoulderGeometry = new THREE.SphereGeometry(0.15, 10, 8);

const leftShoulder = new THREE.Mesh(shoulderGeometry, blackMaterial);
leftShoulder.position.set(0.42, 1.25, 0);
leftShoulder.castShadow = true;
panda.add(leftShoulder);

const rightShoulder = new THREE.Mesh(shoulderGeometry.clone(), blackMaterial);
rightShoulder.position.set(-0.42, 1.25, 0);
rightShoulder.castShadow = true;
panda.add(rightShoulder);

// More tapered upper arms
const upperArmGeometry = new THREE.SphereGeometry(0.12, 10, 8);

const leftUpperArm = new THREE.Mesh(upperArmGeometry, blackMaterial);
leftUpperArm.position.set(0.55, 1.15, 0.05);
leftUpperArm.scale.set(0.9, 1.2, 0.9);
leftUpperArm.rotation.z = -0.3;
leftUpperArm.castShadow = true;
panda.add(leftUpperArm);

const rightUpperArm = new THREE.Mesh(upperArmGeometry.clone(), blackMaterial);
rightUpperArm.position.set(-0.55, 1.15, 0.05);
rightUpperArm.scale.set(0.9, 1.2, 0.9);
rightUpperArm.rotation.z = 0.3;
rightUpperArm.castShadow = true;
panda.add(rightUpperArm);

// Elbow joints
const elbowGeometry = new THREE.SphereGeometry(0.11, 8, 6);

const leftElbow = new THREE.Mesh(elbowGeometry, blackMaterial);
leftElbow.position.set(0.65, 1.0, 0.08);
leftElbow.castShadow = true;
panda.add(leftElbow);

const rightElbow = new THREE.Mesh(elbowGeometry.clone(), blackMaterial);
rightElbow.position.set(-0.65, 1.0, 0.08);
rightElbow.castShadow = true;
panda.add(rightElbow);

// Lower arms - slightly tapered
const lowerArmGeometry = new THREE.SphereGeometry(0.1, 10, 8);

const leftLowerArm = new THREE.Mesh(lowerArmGeometry, blackMaterial);
leftLowerArm.position.set(0.75, 0.92, 0.1);
leftLowerArm.scale.set(0.85, 1.1, 0.85);
leftLowerArm.rotation.z = -0.5;
leftLowerArm.castShadow = true;
panda.add(leftLowerArm);

const rightLowerArm = new THREE.Mesh(lowerArmGeometry.clone(), blackMaterial);
rightLowerArm.position.set(-0.75, 0.92, 0.1);
rightLowerArm.scale.set(0.85, 1.1, 0.85);
rightLowerArm.rotation.z = 0.5;
rightLowerArm.castShadow = true;
panda.add(rightLowerArm);

// More detailed hands with wrist
const wristGeometry = new THREE.SphereGeometry(0.1, 8, 6);
const handGeometry = new THREE.SphereGeometry(0.13, 10, 8);

// Left wrist and hand
const leftWrist = new THREE.Mesh(wristGeometry, blackMaterial);
leftWrist.position.set(0.82, 0.85, 0.12);
leftWrist.castShadow = true;
panda.add(leftWrist);

const leftHand = new THREE.Mesh(handGeometry, blackMaterial);
leftHand.position.set(0.9, 0.82, 0.15);
leftHand.scale.set(1.1, 0.7, 0.85);
leftHand.rotation.z = -0.2;
leftHand.castShadow = true;
panda.add(leftHand);

// Right wrist and hand
const rightWrist = new THREE.Mesh(wristGeometry.clone(), blackMaterial);
rightWrist.position.set(-0.82, 0.85, 0.12);
rightWrist.castShadow = true;
panda.add(rightWrist);

const rightHand = new THREE.Mesh(handGeometry.clone(), blackMaterial);
rightHand.position.set(-0.9, 0.82, 0.15);
rightHand.scale.set(1.1, 0.7, 0.85);
rightHand.rotation.z = 0.2;
rightHand.castShadow = true;
panda.add(rightHand);
      
      // ----- LEGS -----
      // Hips
      const hipsGeometry = new THREE.BoxGeometry(0.6, 0.2, 0.5, 3, 2, 3);
      const hips = new THREE.Mesh(hipsGeometry, whiteMaterial);
      hips.position.y = 0.35;
      hips.castShadow = true;
      panda.add(hips);
      
// Upper legs
      const upperLegGeometry = new THREE.CylinderGeometry(0.15, 0.14, 0.5, 10, 3);
      
      const leftUpperLeg = new THREE.Mesh(upperLegGeometry, blackMaterial);
      leftUpperLeg.position.set(0.2, 0.1, 0);
      leftUpperLeg.castShadow = true;
      panda.add(leftUpperLeg);
      
      const rightUpperLeg = new THREE.Mesh(upperLegGeometry.clone(), blackMaterial);
      rightUpperLeg.position.set(-0.2, 0.1, 0);
      rightUpperLeg.castShadow = true;
      panda.add(rightUpperLeg);
      
      // Lower legs
      const lowerLegGeometry = new THREE.CylinderGeometry(0.13, 0.15, 0.5, 10, 3);
      
      const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, blackMaterial);
      leftLowerLeg.position.set(0.2, -0.3, 0);
      leftLowerLeg.castShadow = true;
      panda.add(leftLowerLeg);
      
      const rightLowerLeg = new THREE.Mesh(lowerLegGeometry.clone(), blackMaterial);
      rightLowerLeg.position.set(-0.2, -0.3, 0);
      rightLowerLeg.castShadow = true;
      panda.add(rightLowerLeg);
      
      // Feet
      const footGeometry = new THREE.SphereGeometry(0.15, 10, 8);
      
      const leftFoot = new THREE.Mesh(footGeometry, redMaterial);
      leftFoot.position.set(0.2, -0.6, 0.1);
      leftFoot.scale.set(1.3, 0.6, 1.6);
      leftFoot.castShadow = true;
      panda.add(leftFoot);
      
      const rightFoot = new THREE.Mesh(footGeometry.clone(), redMaterial);
      rightFoot.position.set(-0.2, -0.6, 0.1);
      rightFoot.scale.set(1.3, 0.6, 1.6);
      rightFoot.castShadow = true;
      panda.add(rightFoot);
      
      // ----- TAIL -----
      const tailBaseGeometry = new THREE.SphereGeometry(0.15, 10, 8);
      const tailBase = new THREE.Mesh(tailBaseGeometry, blackMaterial);
      tailBase.position.set(0, 0.5, -0.5);
      tailBase.castShadow = true;
      panda.add(tailBase);
      
      const tailMidGeometry = new THREE.SphereGeometry(0.12, 8, 6);
      const tailMid = new THREE.Mesh(tailMidGeometry, blackMaterial);
      tailMid.position.set(0, 0.55, -0.7);
      tailMid.castShadow = true;
      panda.add(tailMid);
      
      const tailTipGeometry = new THREE.SphereGeometry(0.08, 8, 6);
      const tailTip = new THREE.Mesh(tailTipGeometry, blackMaterial);
      tailTip.position.set(0, 0.6, -0.85);
      tailTip.castShadow = true;
      panda.add(tailTip);
      
      // ----- ACCESSORIES -----
      // Backpack
      const backpackGeometry = new THREE.BoxGeometry(0.6, 0.7, 0.3, 4, 4, 2);
      const backpack = new THREE.Mesh(backpackGeometry, blueMaterial);
      backpack.position.set(0, 0.9, -0.35);
      backpack.castShadow = true;
      panda.add(backpack);
      
      // Backpack strap
      const backpackStrapGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.8, 3, 1, 3);
      const backpackStrap = new THREE.Mesh(backpackStrapGeometry, blueMaterial);
      backpackStrap.position.set(0, 1.3, 0.05);
      backpackStrap.rotation.x = Math.PI / 8;
      backpackStrap.castShadow = true;
      panda.add(backpackStrap);
      
      // Backpack details
      const backpackDetailGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.05, 2, 2, 1);
      const backpackDetail = new THREE.Mesh(backpackDetailGeometry, redMaterial);
      backpackDetail.position.set(0, 0.95, -0.18);
      backpackDetail.castShadow = true;
      panda.add(backpackDetail);
      
      // Sunglasses on head
      const sunglassFrameGeometry = new THREE.BoxGeometry(0.6, 0.12, 0.05, 3, 2, 1);
      const sunglassFrame = new THREE.Mesh(sunglassFrameGeometry, redMaterial);
      sunglassFrame.position.set(0, 2.0, 0.4);
      sunglassFrame.rotation.x = 0.4;
      sunglassFrame.scale.set(1.1, 1.2, 1);
      sunglassFrame.castShadow = true;
      panda.add(sunglassFrame);
      
      // Sunglass lenses
      const lensGeometry = new THREE.CylinderGeometry(0.13, 0.13, 0.03, 12, 1);
      
      const leftLens = new THREE.Mesh(lensGeometry, blackMaterial);
      leftLens.position.set(0.20, 2.0, 0.42);
      leftLens.rotation.x = 0.4;
      panda.add(leftLens);
      
      const rightLens = new THREE.Mesh(lensGeometry.clone(), blackMaterial);
      rightLens.position.set(-0.20, 2.0, 0.42);
      rightLens.rotation.x = 0.4;
      panda.add(rightLens);
      
   // Store references for animations
panda.head = head;
panda.muzzle = muzzle;
panda.leftEyePatch = leftEyePatch;
panda.rightEyePatch = rightEyePatch;
panda.leftEye = leftEye;
panda.rightEye = rightEye;
panda.leftPupil = leftPupil;
panda.rightPupil = rightPupil;
panda.mouth = mouth;
panda.leftEar = leftEar;
panda.rightEar = rightEar;

// New body structure
panda.torso = torso;
panda.torsoUpper = torsoUpper;
panda.torsoLower = torsoLower;
panda.belly = belly;

// New arm structure
panda.leftShoulder = leftShoulder;
panda.rightShoulder = rightShoulder;
panda.leftUpperArm = leftUpperArm;
panda.rightUpperArm = rightUpperArm;
panda.leftElbow = leftElbow;
panda.rightElbow = rightElbow;
panda.leftLowerArm = leftLowerArm;
panda.rightLowerArm = rightLowerArm;
panda.leftWrist = leftWrist;
panda.rightWrist = rightWrist;
panda.leftHand = leftHand;
panda.rightHand = rightHand;

// Legs
panda.hips = hips;
panda.leftUpperLeg = leftUpperLeg;
panda.rightUpperLeg = rightUpperLeg;
panda.leftLowerLeg = leftLowerLeg;
panda.rightLowerLeg = rightLowerLeg;
panda.leftFoot = leftFoot;
panda.rightFoot = rightFoot;

// Tail and accessories
panda.tailBase = tailBase;
panda.tailMid = tailMid;
panda.tailTip = tailTip;
panda.backpack = backpack;
panda.sunglassFrame = sunglassFrame;

      // Initialize animation state management
      panda.animationState = {
        isWalking: false,
        isJumping: false,
        isInAir: false,
        jumpVelocity: 0,
        groundY: 0,
        blink: {
          timer: 0,
          interval: 4 + Math.random() * 3,
          duration: 0.15
        }
      };
      
      return panda;
    }
    
    // Create bamboo with textures
    function createBamboo(x, z) {
      const bambooGroup = new THREE.Group();
      
      const height = 3 + Math.random() * 4;
      const segments = Math.floor(height * 2);
      
      // Create the bamboo texture
      const bambooTexture = createBambooTexture();
      bambooTexture.wrapS = THREE.RepeatWrapping;
      bambooTexture.wrapT = THREE.RepeatWrapping;
      bambooTexture.repeat.set(1, segments/2);
      
      // Materials with texture
      const materialA = new THREE.MeshStandardMaterial({ 
        map: bambooTexture,
        color: 0x2d4f1e,
        roughness: 0.8,
        metalness: 0.1
      });
      
      const materialB = new THREE.MeshStandardMaterial({ 
        map: bambooTexture,
        color: 0x3a6324,
        roughness: 0.8,
        metalness: 0.1
      });
      
      for (let i = 0; i < segments; i++) {
        const segHeight = height / segments;
        const y = i * segHeight;
        const radius = 0.2 - (i * 0.01);
        
        const geometry = new THREE.CylinderGeometry(
          radius,
          radius - 0.01,
          segHeight,
          8,
          1
        );
        
        const material = i % 2 === 0 ? materialA : materialB;
        const segment = new THREE.Mesh(geometry, material);
        segment.position.y = y + segHeight/2;
        segment.castShadow = true;
        
        bambooGroup.add(segment);
      }
      
      // PS2 era leaf details
      for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
        const leafGeometry = new THREE.PlaneGeometry(0.7, 0.3, 3, 2);
        const leafMaterial = new THREE.MeshStandardMaterial({
          color: 0x44aa44,
          roughness: 0.8,
          metalness: 0.1,
          side: THREE.DoubleSide
        });
        
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
        
        const segment = Math.floor(segments * 0.7) + i;
        const yPos = (segment * height / segments);
        leaf.position.set(
          (Math.random() - 0.5) * 0.4,
          yPos,
          (Math.random() - 0.5) * 0.4
        );
        
        leaf.rotation.x = Math.random() * Math.PI;
        leaf.rotation.y = Math.random() * Math.PI * 2;
        leaf.rotation.z = Math.random() * Math.PI / 4;
        
        leaf.castShadow = true;
        bambooGroup.add(leaf);
      }
      
      bambooGroup.position.set(x, 0, z);
      return bambooGroup;
    }
    
    // PS2-quality gems with textures
    function createGem(x, y, z) {
      const gemGroup = new THREE.Group();
      
      const gemGeometry = new THREE.OctahedronGeometry(0.3, 2);
      const gemMaterial = new THREE.MeshStandardMaterial({
        color: 0xff44ff,
        roughness: 0.2,
        metalness: 0.7,
        emissive: 0x550055,
        emissiveIntensity: 0.5
      });
      
      const gem = new THREE.Mesh(gemGeometry, gemMaterial);
      gem.castShadow = true;
      gemGroup.add(gem);
      
      // Particle system for gem sparkle
      const sparkleGeometry = new THREE.BufferGeometry();
      const sparkleCount = 5;
      const positionArray = new Float32Array(sparkleCount * 3);
      const sizeArray = new Float32Array(sparkleCount);
      
      for (let i = 0; i < sparkleCount; i++) {
        positionArray[i * 3] = (Math.random() - 0.5) * 0.5;
        positionArray[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
        positionArray[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
        
        sizeArray[i] = 0.05 + Math.random() * 0.05;
      }
      
      sparkleGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
      sparkleGeometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));
      
      const sparkleMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.1,
        sizeAttenuation: true,
        transparent: true,
        blending: THREE.AdditiveBlending
      });
      
      const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
      gemGroup.add(sparkles);
      
      // Add animation
      gemGroup.update = function(time) {
        gem.rotation.y = time * 1.5;
        gem.rotation.z = time * 0.7;
        gem.position.y = Math.sin(time * 3) * 0.1 + 0.2;
        
        for (let i = 0; i < sparkleCount; i++) {
          const offset = i * 0.5;
          const scale = Math.sin(time * 5 + offset) * 0.5 + 0.5;
          sparkleGeometry.attributes.size.array[i] = 0.05 + 0.05 * scale;
        }
        sparkleGeometry.attributes.size.needsUpdate = true;
      };
      
      gemGroup.position.set(x, y, z);
      return gemGroup;
    }
    
    // Add bamboo to the scene
    const bamboos = [];
    for (let i = 0; i < 30; i++) {
      const distance = 5 + Math.random() * 20;
      const angle = Math.random() * Math.PI * 2;
      const x = Math.sin(angle) * distance;
      const z = Math.cos(angle) * distance;
      const bamboo = createBamboo(x, z);
      scene.add(bamboo);
      bamboos.push(bamboo);
    }
    
    // Add PS2-quality collectible gems
    const gems = [];
    for (let i = 0; i < 10; i++) {
      const distance = 3 + Math.random() * 15;
      const angle = Math.random() * Math.PI * 2;
      const x = Math.sin(angle) * distance;
      const z = Math.cos(angle) * distance;
      const gem = createGem(x, 0.8, z);
      scene.add(gem);
      gems.push(gem);
    }
    
    // Create the panda
    const panda = createPS2Panda();
    scene.add(panda);
    
    // Control state for player input
    const controls = {};
    
    function setupTouchControls() {
      const buttons = {
        'btn-n': 'moveForward',
        'btn-s': 'moveBackward',
        'btn-w': 'moveRight',
        'btn-e': 'moveLeft',
        'btn-nw': 'moveForwardRight',
        'btn-ne': 'moveForwardLeft',
        'btn-sw': 'moveBackwardRight',
        'btn-se': 'moveBackwardLeft',
        'cam-left': 'cameraTurnLeft',
        'cam-right': 'cameraTurnRight',
        'cam-up': 'cameraTiltUp',
        'cam-down': 'cameraTiltDown',
        'cam-zoom-in': 'cameraZoomIn',
        'cam-zoom-out': 'cameraZoomOut'
      };
      
      // Helper to setup touch events for a button
      function setupButtonEvents(buttonId, controlName) {
        const button = document.getElementById(buttonId);
        if (!button) return;
        
        // Start pressing button
        button.addEventListener('touchstart', (e) => {
          e.preventDefault();
          e.stopPropagation();
          controls[controlName] = true;
          button.classList.add('active');
          
          // Double-tap to jump
          if (controlName === 'moveForward' && 
              e.timeStamp - (button.lastTap || 0) < 300) {
            controls.jump = true;
            setTimeout(() => { controls.jump = false; }, 100);
          }
          button.lastTap = e.timeStamp;
        }, { passive: false });
        
        // Release button
        ['touchend', 'touchcancel'].forEach(eventType => {
          button.addEventListener(eventType, (e) => {
            e.preventDefault();
            e.stopPropagation();
            controls[controlName] = false;
            button.classList.remove('active');
          }, { passive: false });
        });
        
        // Prevent default
        button.addEventListener('touchmove', (e) => {
          e.preventDefault();
          e.stopPropagation();
        }, { passive: false });
      }
      
      // Set up all buttons
      for (const [buttonId, controlName] of Object.entries(buttons)) {
        setupButtonEvents(buttonId, controlName);
      }
    }
    
    // Initialize touch controls
    setupTouchControls();
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Prevent pinch zoom on mobile
    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 1) {
        e.preventDefault();
      }
    }, { passive: false });
    
    // Camera and physics variables
    let cameraAngle = 0;
    let cameraHeight = 3;
    let cameraDistance = 6;
    let gravity = 20;
    let score = 0;
    
    // Create FPS counter and update it
    const fpsElement = document.getElementById('fps-counter');
    const gemCountElement = document.getElementById('gem-count');
    let frameCount = 0;
    let lastTime = performance.now();
    
    function updateFPS() {
      frameCount++;
      const currentTime = performance.now();
      const elapsed = (currentTime - lastTime) / 1000;
      
      if (elapsed >= 1) {
        const fps = Math.round(frameCount / elapsed);
        fpsElement.textContent = `FPS: ${fps}`;
        frameCount = 0;
        lastTime = currentTime;
      }
    }
    
    // PS2-era character controller with physics
    function updateCharacter(delta) {
      // Process jump input
      if (controls.jump && !panda.animationState.isInAir) {
        panda.animationState.isJumping = true;
        panda.animationState.isInAir = true;
        panda.animationState.jumpVelocity = 8;
      }
      
      // Apply gravity
      if (panda.animationState.isInAir) {
        panda.animationState.jumpVelocity -= gravity * delta;
        panda.position.y += panda.animationState.jumpVelocity * delta;
        
        if (panda.position.y <= panda.animationState.groundY) {
          panda.position.y = panda.animationState.groundY;
          panda.animationState.isInAir = false;
          panda.animationState.isJumping = false;
          
          // Spawn dust particles on landing
          particleSystem.spawn(
            new THREE.Vector3(
              panda.position.x,
              panda.position.y - 0.5,
              panda.position.z
            ),
            10,
            'dust'
          );
        }
      }
      
      // Handle movement
      let moving = false;
      const moveSpeed = 5.0 * delta;
      
      // Get camera direction for relative movement
      let cameraForward = new THREE.Vector3(0, 0, -1);
      cameraForward.applyQuaternion(camera.quaternion);
      cameraForward.y = 0; // Project onto XZ plane
      cameraForward.normalize();
      
      // Get the right vector
      let cameraRight = new THREE.Vector3(cameraForward.z, 0, -cameraForward.x);
      
      // Initialize movement vector
      let moveVector = new THREE.Vector3(0, 0, 0);
      let targetRotationY = panda.rotation.y;
      
      // Calculate movement based on camera orientation
      if (controls.moveForward) {
        moveVector.add(cameraForward);
        targetRotationY = Math.atan2(cameraForward.x, cameraForward.z);
        moving = true;
      }
      if (controls.moveBackward) {
        moveVector.sub(cameraForward);
        targetRotationY = Math.atan2(-cameraForward.x, -cameraForward.z);
        moving = true;
      }
      if (controls.moveLeft) {
        moveVector.sub(cameraRight);
        targetRotationY = Math.atan2(-cameraRight.x, -cameraRight.z);
        moving = true;
      }
      if (controls.moveRight) {
        moveVector.add(cameraRight);
        targetRotationY = Math.atan2(cameraRight.x, cameraRight.z);
        moving = true;
      }
      
      // Calculate diagonal movement
      if (controls.moveForwardLeft) {
        let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight.clone().multiplyScalar(-1)).normalize();
        moveVector.add(diagonalDir);
        targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
        moving = true;
      }
      if (controls.moveForwardRight) {
        let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight).normalize();
        moveVector.add(diagonalDir);
        targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
        moving = true;
      }
      if (controls.moveBackwardLeft) {
        let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight.clone().multiplyScalar(-1)).normalize();
        moveVector.add(diagonalDir);
        targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
        moving = true;
      }
      if (controls.moveBackwardRight) {
        let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight).normalize();
        moveVector.add(diagonalDir);
        targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
        moving = true;
      }
      
      // Normalize and apply movement
      if (moving) {
        moveVector.normalize();
        
        // Apply movement speed
        panda.position.x += moveVector.x * moveSpeed;
        panda.position.z += moveVector.z * moveSpeed;
        
        // Smoothly rotate panda to face movement direction
        const rotationSpeed = 10 * delta;
        panda.rotation.y = THREE.MathUtils.lerp(
          panda.rotation.y,
          targetRotationY,
          rotationSpeed
        );
        
        // Generate footstep particles
        if (!panda.animationState.isInAir && Math.sin(performance.now() * 0.01) > 0.9) {
          particleSystem.spawn(
            new THREE.Vector3(
              panda.position.x,
              panda.position.y - 0.5,
              panda.position.z
            ),
            3,
            'dust'
          );
        }
      }
      
      // Check if panda is near water and add ripples
      const distanceToWater = new THREE.Vector2(panda.position.x - water.position.x, panda.position.z - water.position.z).length();
      if (distanceToWater < 20 && moving && Math.random() < 0.03) {
        water.addRipple({
          x: panda.position.x,
          z: panda.position.z
        });
      }
      
      // Set animation state
      panda.animationState.isWalking = moving && !panda.animationState.isInAir;
      
      // Return movement status
      return moving;
    }
    
    // Camera controller
    function updateCamera(delta) {
      // Camera controls
      if (controls.cameraTurnLeft) {
        cameraAngle += 2 * delta;
      }
      if (controls.cameraTurnRight) {
        cameraAngle -= 2 * delta;
      }
      if (controls.cameraTiltUp) {
        cameraHeight += 2 * delta;
        cameraHeight = Math.min(6, cameraHeight);
      }
      if (controls.cameraTiltDown) {
        cameraHeight -= 2 * delta;
        cameraHeight = Math.max(1.5, cameraHeight);
      }
      if (controls.cameraZoomIn) {
        cameraDistance -= 3 * delta;
        cameraDistance = Math.max(3, cameraDistance);
      }
      if (controls.cameraZoomOut) {
        cameraDistance += 3 * delta;
        cameraDistance = Math.min(10, cameraDistance);
      }
      
      // Smoothly update camera position
      const targetX = panda.position.x + Math.sin(cameraAngle) * cameraDistance;
      const targetZ = panda.position.z + Math.cos(cameraAngle) * cameraDistance;
      const targetY = panda.position.y + cameraHeight;
      
      camera.position.x += (targetX - camera.position.x) * 5 * delta;
      camera.position.z += (targetZ - camera.position.z) * 5 * delta;
      camera.position.y += (targetY - camera.position.y) * 5 * delta;
      
      // Look at character with slight offset
      camera.lookAt(
        panda.position.x,
        panda.position.y + 1,
        panda.position.z
      );
    }
    
    // Character animations
    function updateCharacterAnimations(time, delta, moving) {
      // Update blinking
      panda.animationState.blink.timer += delta;
      if (panda.animationState.blink.timer >= panda.animationState.blink.interval) {
        panda.animationState.blink.timer = 0;
        panda.animationState.blink.interval = 2 + Math.random() * 4;
      }
      
      // Perform blink
      const blinkPhase = panda.animationState.blink.timer / panda.animationState.blink.interval;
      const isBlinking = blinkPhase < panda.animationState.blink.duration / panda.animationState.blink.interval;
      
      if (isBlinking) {
        panda.leftEye.scale.y = 0.1;
        panda.rightEye.scale.y = 0.1;
      } else {
        panda.leftEye.scale.y = 1;
        panda.rightEye.scale.y = 1;
      }
      
      // Head animations
      if (!panda.animationState.isInAir) {
        // Normal head bob when on ground
        panda.head.position.y = 1.6 + Math.sin(time * 1.5) * 0.05;
        panda.head.rotation.y = Math.sin(time * 0.8) * 0.1;
      } else {
        // Look down when jumping/falling
        panda.head.rotation.x = panda.animationState.jumpVelocity > 0 ? -0.2 : 0.3;
      }
      
      // Eye movements
      panda.leftPupil.position.x = 0.32 + Math.sin(time * 0.6) * 0.04;
      panda.rightPupil.position.x = -0.32 + Math.sin(time * 0.6) * 0.04;
      
      // Mouth animation
      panda.mouth.scale.x = 1 + Math.sin(time * 2) * 0.1;
      
      // Ear animations
      panda.leftEar.rotation.z = -0.1 + Math.sin(time * 1.2) * 0.05;
      panda.rightEar.rotation.z = 0.1 - Math.sin(time * 1.2) * 0.05;
      
  // Idle animations when not moving
if (!moving && !panda.animationState.isInAir) {
  // Breathing animation
  panda.torsoUpper.scale.y = 1 + Math.sin(time * 1.2) * 0.03;
  panda.torsoUpper.scale.z = 1 - Math.sin(time * 1.2) * 0.01;
  panda.torsoLower.scale.y = 1 - Math.sin(time * 1.2) * 0.02;
  panda.belly.scale.z = 1 + Math.sin(time * 1.2) * 0.03;
  
  // Subtle arm movements
  panda.leftUpperArm.rotation.x = Math.sin(time * 0.7) * 0.1;
  panda.rightUpperArm.rotation.x = Math.sin(time * 0.7 + 0.5) * 0.1;
  panda.leftShoulder.position.y = 1.25 + Math.sin(time * 0.7) * 0.02;
  panda.rightShoulder.position.y = 1.25 + Math.sin(time * 0.7 + 0.5) * 0.02;
  
  // Reset legs
  panda.leftUpperLeg.rotation.x = 0;
  panda.rightUpperLeg.rotation.x = 0;
  panda.leftLowerLeg.rotation.x = 0;
  panda.rightLowerLeg.rotation.x = 0;
}
      
      // Walking animations
      if (panda.animationState.isWalking) {
        // Leg animations
        panda.leftUpperLeg.rotation.x = Math.sin(time * 10) * 0.7;
        panda.rightUpperLeg.rotation.x = Math.sin(time * 10 + Math.PI) * 0.7;
        
        // Lower legs follow with a delay
        panda.leftLowerLeg.rotation.x = Math.sin(time * 10 - Math.PI/3) * 0.5;
        panda.rightLowerLeg.rotation.x = Math.sin(time * 10 + Math.PI - Math.PI/3) * 0.5;
        
        // Arm swing animations
        panda.leftUpperArm.rotation.x = Math.sin(time * 10 + Math.PI) * 0.5;
        panda.rightUpperArm.rotation.x = Math.sin(time * 10) * 0.5;
        panda.leftLowerArm.rotation.x = Math.sin(time * 10 + Math.PI + Math.PI/4) * 0.3;
        panda.rightLowerArm.rotation.x = Math.sin(time * 10 + Math.PI/4) * 0.3;
        
        // Body movement
        panda.torso.rotation.y = Math.sin(time * 5) * 0.05;
        
        // Secondary animations
        panda.backpack.rotation.x = Math.sin(time * 10) * 0.1;
        panda.tailBase.rotation.y = Math.sin(time * 5) * 0.2;
      }
      
      // Jump animation
      if (panda.animationState.isInAir) {
        // Different poses for rising and falling
        if (panda.animationState.jumpVelocity > 0) {
          // Rising
          panda.leftUpperLeg.rotation.x = -0.4;
          panda.rightUpperLeg.rotation.x = -0.4;
          panda.leftLowerLeg.rotation.x = 0.6;
          panda.rightLowerLeg.rotation.x = 0.6;
          
          // Arms raised
          panda.leftUpperArm.rotation.x = -0.7;
          panda.rightUpperArm.rotation.x = -0.7;
          panda.leftLowerArm.rotation.x = -0.4;
          panda.rightLowerArm.rotation.x = -0.4;
        } else {
          // Falling
          panda.leftUpperLeg.rotation.x = 0.2;
          panda.rightUpperLeg.rotation.x = 0.2;
          panda.leftLowerLeg.rotation.x = 0.6;
          panda.rightLowerLeg.rotation.x = 0.6;
          
          // Arms out for balance
          panda.leftUpperArm.rotation.x = 0;
          panda.rightUpperArm.rotation.x = 0;
          panda.leftUpperArm.rotation.z = -0.6;
          panda.rightUpperArm.rotation.z = 0.6;
        }
      } else {
        // Reset arm rotation when not jumping
        panda.leftUpperArm.rotation.z = -0.3;
        panda.rightUpperArm.rotation.z = 0.3;
      }
      
      // Tail animations
      panda.tailBase.rotation.z = Math.sin(time * 2) * 0.2;
      panda.tailMid.rotation.z = Math.sin(time * 2 + 0.3) * 0.3;
      panda.tailTip.rotation.z = Math.sin(time * 2 + 0.6) * 0.4;
    }
   

// Create PS2-Style Foxy Character
function createPS2Foxy() {
  const foxy = new THREE.Group();
  
  // Get fur textures - we'll reuse the method from the panda but adjust colors
  const furTextures = createFurTextureWithNormal();
  
  // Enhanced materials with textures for Foxy's colors
  const orangeMaterial = new THREE.MeshStandardMaterial({
    color: 0xFF6347, // Tomato orange for main body
    map: furTextures.colorMap,
    normalMap: furTextures.normalMap,
    normalScale: new THREE.Vector2(0.5, 0.5),
    roughness: 0.7,
    metalness: 0.1
  });
  
  const whiteMaterial = new THREE.MeshStandardMaterial({
    color: 0xFFFFFF,
    map: furTextures.colorMap,
    normalMap: furTextures.normalMap,
    normalScale: new THREE.Vector2(0.5, 0.5),
    roughness: 0.7,
    metalness: 0.1
  });
  
  const peachMaterial = new THREE.MeshStandardMaterial({
    color: 0xFFDAB9, // Peach color for face
    map: furTextures.colorMap,
    normalMap: furTextures.normalMap,
    normalScale: new THREE.Vector2(0.5, 0.5),
    roughness: 0.7,
    metalness: 0.1
  });
  
  const blackMaterial = new THREE.MeshStandardMaterial({
    color: 0x222222,
    map: furTextures.colorMap,
    normalMap: furTextures.normalMap,
    normalScale: new THREE.Vector2(0.5, 0.5),
    roughness: 0.7,
    metalness: 0.1
  });
  
  const blueMaterial = new THREE.MeshStandardMaterial({
    color: 0x4169E1, // Royal blue for stripes
    roughness: 0.6,
    metalness: 0.2
  });
  
  const purpleMaterial = new THREE.MeshStandardMaterial({
    color: 0x9370DB, // Medium purple for paws
    roughness: 0.6,
    metalness: 0.2
  });
  
  const redMaterial = new THREE.MeshStandardMaterial({
    color: 0xFF0000, // Red for heart
    roughness: 0.5,
    metalness: 0.3
  });
  
  const brownMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Saddle brown for nose
    roughness: 0.7,
    metalness: 0.1
  });
  
  const greenMaterial = new THREE.MeshStandardMaterial({
    color: 0x90EE90, // Light green for ear insides
    roughness: 0.7,
    metalness: 0.1
  });
  
  // ----- HEAD -----
  const headGeometry = new THREE.SphereGeometry(0.6, 12, 10);
  const head = new THREE.Mesh(headGeometry, orangeMaterial);
  head.position.y = 1.6;
  head.castShadow = true;
  foxy.add(head);
  
  // Face - white muzzle area
  const muzzleGeometry = new THREE.SphereGeometry(0.55, 10, 8);
  const muzzle = new THREE.Mesh(muzzleGeometry, whiteMaterial);
  muzzle.position.set(0, 1.45, 0.25);
  muzzle.scale.set(0.9, 0.75, 0.7);
  muzzle.castShadow = true;
  foxy.add(muzzle);
  
  // Peach face patches
  const facePatchGeometry = new THREE.SphereGeometry(0.4, 10, 8);
  
  const leftFacePatch = new THREE.Mesh(facePatchGeometry, peachMaterial);
  leftFacePatch.position.set(0.3, 1.65, 0.35);
  leftFacePatch.scale.set(0.9, 0.8, 0.6);
  leftFacePatch.castShadow = true;
  foxy.add(leftFacePatch);
  
  const rightFacePatch = new THREE.Mesh(facePatchGeometry.clone(), peachMaterial);
  rightFacePatch.position.set(-0.3, 1.65, 0.35);
  rightFacePatch.scale.set(0.9, 0.8, 0.6);
  rightFacePatch.castShadow = true;
  foxy.add(rightFacePatch);
  
  // Eyes
  const eyeGeometry = new THREE.SphereGeometry(0.14, 10, 8);
  
  const leftEye = new THREE.Mesh(eyeGeometry, blackMaterial);
  leftEye.position.set(0.25, 1.65, 0.57);
  foxy.add(leftEye);
  
  const rightEye = new THREE.Mesh(eyeGeometry.clone(), blackMaterial);
  rightEye.position.set(-0.25, 1.65, 0.57);
  foxy.add(rightEye);
  
  // Eye highlights
  const highlightGeometry = new THREE.SphereGeometry(0.05, 8, 8);
  
  const leftHighlight = new THREE.Mesh(highlightGeometry, whiteMaterial);
  leftHighlight.position.set(0.29, 1.69, 0.65);
  foxy.add(leftHighlight);
  
  const rightHighlight = new THREE.Mesh(highlightGeometry.clone(), whiteMaterial);
  rightHighlight.position.set(-0.21, 1.69, 0.65);
  foxy.add(rightHighlight);
  
  // Nose
  const noseGeometry = new THREE.SphereGeometry(0.08, 8, 6);
  const nose = new THREE.Mesh(noseGeometry, brownMaterial);
  nose.position.set(0, 1.45, 0.75);
  nose.scale.set(1, 0.8, 0.8);
  nose.castShadow = true;
  foxy.add(nose);
  
  // Smile - stitched look
  const mouthGeometry = new THREE.TorusGeometry(0.13, 0.02, 10, 12, Math.PI);
  const mouth = new THREE.Mesh(mouthGeometry, purpleMaterial); // Purple stitching
  mouth.position.set(0, 1.35, 0.7);
  mouth.rotation.x = -Math.PI / 2;
  mouth.rotation.z = Math.PI;
  foxy.add(mouth);
  
// ----- EARS -----
  // More pointy ear geometry - taller and narrower cone with more segments
  const earGeometry = new THREE.ConeGeometry(0.15, 0.6, 8);
  
  // Add white spots on the top of the head (using small spheres)
  for (let i = 0; i < 7; i++) {
    const spotGeometry = new THREE.SphereGeometry(0.03, 6, 6);
    const spot = new THREE.Mesh(spotGeometry, whiteMaterial);
    // Position spots randomly on top of head
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * 0.3;
    spot.position.set(
      Math.sin(angle) * radius,
      1.95 + Math.random() * 0.1,
      Math.cos(angle) * radius
    );
    foxy.add(spot);
  }
  
  // Ears with green inside - more pointy
  const leftEar = new THREE.Mesh(earGeometry, orangeMaterial);
  leftEar.position.set(0.4, 2.1, 0);
  leftEar.rotation.z = Math.PI / 12;
  leftEar.rotation.x = -Math.PI / 12;
  leftEar.castShadow = true;
  foxy.add(leftEar);
  
  const rightEar = new THREE.Mesh(earGeometry.clone(), orangeMaterial);
  rightEar.position.set(-0.4, 2.1, 0);
  rightEar.rotation.z = -Math.PI / 12;
  rightEar.rotation.x = -Math.PI / 12;
  rightEar.castShadow = true;
  foxy.add(rightEar);
  
  // Inner ears - green pattern (also more pointy)
  const innerEarGeometry = new THREE.ConeGeometry(0.1, 0.5, 8);
  
  const leftInnerEar = new THREE.Mesh(innerEarGeometry, greenMaterial);
  leftInnerEar.position.set(0.4, 2.08, 0.02);
  leftInnerEar.rotation.z = Math.PI / 12;
  leftInnerEar.rotation.x = -Math.PI / 12;
  foxy.add(leftInnerEar);
  
  const rightInnerEar = new THREE.Mesh(innerEarGeometry.clone(), greenMaterial);
  rightInnerEar.position.set(-0.4, 2.08, 0.02);
  rightInnerEar.rotation.z = -Math.PI / 12;
  rightInnerEar.rotation.x = -Math.PI / 12;
  foxy.add(rightInnerEar);
  
  // ----- BODY -----
  // Main body
  const torsoUpperGeometry = new THREE.SphereGeometry(0.42, 12, 10);
  const torsoUpper = new THREE.Mesh(torsoUpperGeometry, orangeMaterial);
  torsoUpper.position.y = 1.15;
  torsoUpper.scale.set(1, 0.8, 0.9);
  torsoUpper.castShadow = true;
  foxy.add(torsoUpper);
  
  const torsoLowerGeometry = new THREE.SphereGeometry(0.45, 12, 10);
  const torsoLower = new THREE.Mesh(torsoLowerGeometry, orangeMaterial);
  torsoLower.position.y = 0.7;
  torsoLower.scale.set(1, 0.9, 0.85);
  torsoLower.castShadow = true;
  foxy.add(torsoLower);
  
  // Heart on chest
  const heartGeometry = new THREE.SphereGeometry(0.2, 10, 8);
  const heart = new THREE.Mesh(heartGeometry, whiteMaterial);
  heart.position.set(0, 1.05, 0.35);
  heart.scale.set(1.2, 1, 0.6);
  heart.castShadow = true;
  foxy.add(heart);
  
  // Heart outline
  const heartOutlineGeometry = new THREE.TorusGeometry(0.2, 0.02, 8, 16, Math.PI * 2);
  const heartOutline = new THREE.Mesh(heartOutlineGeometry, redMaterial);
  heartOutline.position.set(0, 1.05, 0.38);
  heartOutline.rotation.x = Math.PI / 2;
  heartOutline.scale.set(1.2, 1, 1);
  foxy.add(heartOutline);
  
  // Music note (simplified) on the heart
  const noteBaseGeometry = new THREE.SphereGeometry(0.04, 8, 8);
  const noteBase = new THREE.Mesh(noteBaseGeometry, blackMaterial);
  noteBase.position.set(0.03, 1.05, 0.42);
  foxy.add(noteBase);
  
  const noteStemGeometry = new THREE.BoxGeometry(0.02, 0.12, 0.02);
  const noteStem = new THREE.Mesh(noteStemGeometry, blackMaterial);
  noteStem.position.set(0.03, 1.12, 0.42);
  foxy.add(noteStem);
  
  // Reference group for torso
  const torso = new THREE.Group();
  torso.position.y = 0.85;
  foxy.add(torso);
  
  // ----- ARMS -----
  // Shoulders with blue and white stripes
  const shoulderGeometry = new THREE.SphereGeometry(0.15, 10, 8);
  
  const leftShoulder = new THREE.Mesh(shoulderGeometry, blueMaterial);
  leftShoulder.position.set(0.42, 1.25, 0);
  leftShoulder.castShadow = true;
  foxy.add(leftShoulder);
  
  const rightShoulder = new THREE.Mesh(shoulderGeometry.clone(), blueMaterial);
  rightShoulder.position.set(-0.42, 1.25, 0);
  rightShoulder.castShadow = true;
  foxy.add(rightShoulder);
  
  // Arm segments with alternating colors for stripes
  const upperArmGeometry = new THREE.SphereGeometry(0.12, 10, 8);
  
  const leftUpperArm = new THREE.Mesh(upperArmGeometry, whiteMaterial);
  leftUpperArm.position.set(0.55, 1.15, 0.05);
  leftUpperArm.scale.set(0.9, 1.2, 0.9);
  leftUpperArm.rotation.z = -0.3;
  leftUpperArm.castShadow = true;
  foxy.add(leftUpperArm);
  
  const rightUpperArm = new THREE.Mesh(upperArmGeometry.clone(), whiteMaterial);
  rightUpperArm.position.set(-0.55, 1.15, 0.05);
  rightUpperArm.scale.set(0.9, 1.2, 0.9);
  rightUpperArm.rotation.z = 0.3;
  rightUpperArm.castShadow = true;
  foxy.add(rightUpperArm);
  
  // Elbow joints - blue stripe
  const elbowGeometry = new THREE.SphereGeometry(0.11, 8, 6);
  
  const leftElbow = new THREE.Mesh(elbowGeometry, blueMaterial);
  leftElbow.position.set(0.65, 1.0, 0.08);
  leftElbow.castShadow = true;
  foxy.add(leftElbow);
  
  const rightElbow = new THREE.Mesh(elbowGeometry.clone(), blueMaterial);
  rightElbow.position.set(-0.65, 1.0, 0.08);
  rightElbow.castShadow = true;
  foxy.add(rightElbow);
  
  // Lower arms - white stripe
  const lowerArmGeometry = new THREE.SphereGeometry(0.1, 10, 8);
  
  const leftLowerArm = new THREE.Mesh(lowerArmGeometry, whiteMaterial);
  leftLowerArm.position.set(0.75, 0.92, 0.1);
  leftLowerArm.scale.set(0.85, 1.1, 0.85);
  leftLowerArm.rotation.z = -0.5;
  leftLowerArm.castShadow = true;
  foxy.add(leftLowerArm);
  
  const rightLowerArm = new THREE.Mesh(lowerArmGeometry.clone(), whiteMaterial);
  rightLowerArm.position.set(-0.75, 0.92, 0.1);
  rightLowerArm.scale.set(0.85, 1.1, 0.85);
  rightLowerArm.rotation.z = 0.5;
  rightLowerArm.castShadow = true;
  foxy.add(rightLowerArm);
  
  // Purple paws
  const wristGeometry = new THREE.SphereGeometry(0.1, 8, 6);
  const handGeometry = new THREE.SphereGeometry(0.13, 10, 8);
  
  // Left wrist and hand
  const leftWrist = new THREE.Mesh(wristGeometry, blueMaterial);
  leftWrist.position.set(0.82, 0.85, 0.12);
  leftWrist.castShadow = true;
  foxy.add(leftWrist);
  
  const leftHand = new THREE.Mesh(handGeometry, purpleMaterial);
  leftHand.position.set(0.9, 0.82, 0.15);
  leftHand.scale.set(1.1, 0.7, 0.85);
  leftHand.rotation.z = -0.2;
  leftHand.castShadow = true;
  foxy.add(leftHand);
  
  // Right wrist and hand
  const rightWrist = new THREE.Mesh(wristGeometry.clone(), blueMaterial);
  rightWrist.position.set(-0.82, 0.85, 0.12);
  rightWrist.castShadow = true;
  foxy.add(rightWrist);
  
  const rightHand = new THREE.Mesh(handGeometry.clone(), purpleMaterial);
  rightHand.position.set(-0.9, 0.82, 0.15);
  rightHand.scale.set(1.1, 0.7, 0.85);
  rightHand.rotation.z = 0.2;
  rightHand.castShadow = true;
  foxy.add(rightHand);
  
  // ----- LEGS -----
  // Upper legs with blue striped pattern
  const upperLegGeometry = new THREE.CylinderGeometry(0.15, 0.14, 0.25, 10, 3);
  
  const leftUpperLeg = new THREE.Mesh(upperLegGeometry, blueMaterial);
  leftUpperLeg.position.set(0.2, 0.25, 0);
  leftUpperLeg.castShadow = true;
  foxy.add(leftUpperLeg);
  
  const rightUpperLeg = new THREE.Mesh(upperLegGeometry.clone(), blueMaterial);
  rightUpperLeg.position.set(-0.2, 0.25, 0);
  rightUpperLeg.castShadow = true;
  foxy.add(rightUpperLeg);
  
  // Mid legs with white striped pattern
  const midLegGeometry = new THREE.CylinderGeometry(0.14, 0.13, 0.25, 10, 3);
  
  const leftMidLeg = new THREE.Mesh(midLegGeometry, whiteMaterial);
  leftMidLeg.position.set(0.2, 0, 0);
  leftMidLeg.castShadow = true;
  foxy.add(leftMidLeg);
  
  const rightMidLeg = new THREE.Mesh(midLegGeometry.clone(), whiteMaterial);
  rightMidLeg.position.set(-0.2, 0, 0);
  rightMidLeg.castShadow = true;
  foxy.add(rightMidLeg);
  
  // Lower legs with blue striped pattern
  const lowerLegGeometry = new THREE.CylinderGeometry(0.13, 0.15, 0.25, 10, 3);
  
  const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, blueMaterial);
  leftLowerLeg.position.set(0.2, -0.25, 0);
  leftLowerLeg.castShadow = true;
  foxy.add(leftLowerLeg);
  
  const rightLowerLeg = new THREE.Mesh(lowerLegGeometry.clone(), blueMaterial);
  rightLowerLeg.position.set(-0.2, -0.25, 0);
  rightLowerLeg.castShadow = true;
  foxy.add(rightLowerLeg);
  
  // Purple patterned feet
  const footGeometry = new THREE.SphereGeometry(0.15, 10, 8);
  
  const leftFoot = new THREE.Mesh(footGeometry, purpleMaterial);
  leftFoot.position.set(0.2, -0.5, 0.1);
  leftFoot.scale.set(1.3, 0.6, 1.6);
  leftFoot.castShadow = true;
  foxy.add(leftFoot);
  
  const rightFoot = new THREE.Mesh(footGeometry.clone(), purpleMaterial);
  rightFoot.position.set(-0.2, -0.5, 0.1);
  rightFoot.scale.set(1.3, 0.6, 1.6);
  rightFoot.castShadow = true;
  foxy.add(rightFoot);
  
  // ----- TAIL -----
  // Bushy fox tail with segments (base is purple, middle is orange, tip is white)
  const tailBaseGeometry = new THREE.SphereGeometry(0.18, 10, 8);
  const tailBase = new THREE.Mesh(tailBaseGeometry, purpleMaterial);
  tailBase.position.set(0, 0.5, -0.5);
  tailBase.castShadow = true;
  foxy.add(tailBase);
  
  const tailMidGeometry = new THREE.SphereGeometry(0.16, 8, 6);
  const tailMid = new THREE.Mesh(tailMidGeometry, orangeMaterial);
  tailMid.position.set(0, 0.6, -0.75);
  tailMid.castShadow = true;
  foxy.add(tailMid);
  
  const tailTipGeometry = new THREE.SphereGeometry(0.12, 8, 6);
  const tailTip = new THREE.Mesh(tailTipGeometry, whiteMaterial);
  tailTip.position.set(0, 0.65, -1.0);
  tailTip.castShadow = true;
  foxy.add(tailTip);
  
  // Store references for animations
  foxy.head = head;
  foxy.muzzle = muzzle;
  foxy.leftFacePatch = leftFacePatch;
  foxy.rightFacePatch = rightFacePatch;
  foxy.leftEye = leftEye;
  foxy.rightEye = rightEye;
  foxy.leftHighlight = leftHighlight;
  foxy.rightHighlight = rightHighlight;
  foxy.mouth = mouth;
  foxy.leftEar = leftEar;
  foxy.rightEar = rightEar;
  
  // Body structure
  foxy.torso = torso;
  foxy.torsoUpper = torsoUpper;
  foxy.torsoLower = torsoLower;
  
  // Arm structure
  foxy.leftShoulder = leftShoulder;
  foxy.rightShoulder = rightShoulder;
  foxy.leftUpperArm = leftUpperArm;
  foxy.rightUpperArm = rightUpperArm;
  foxy.leftElbow = leftElbow;
  foxy.rightElbow = rightElbow;
  foxy.leftLowerArm = leftLowerArm;
  foxy.rightLowerArm = rightLowerArm;
  foxy.leftWrist = leftWrist;
  foxy.rightWrist = rightWrist;
  foxy.leftHand = leftHand;
  foxy.rightHand = rightHand;
  
  // Legs
  foxy.leftUpperLeg = leftUpperLeg;
  foxy.rightUpperLeg = rightUpperLeg;
  foxy.leftMidLeg = leftMidLeg;
  foxy.rightMidLeg = rightMidLeg;
  foxy.leftLowerLeg = leftLowerLeg;
  foxy.rightLowerLeg = rightLowerLeg;
  foxy.leftFoot = leftFoot;
  foxy.rightFoot = rightFoot;
  
  // Tail
  foxy.tailBase = tailBase;
  foxy.tailMid = tailMid;
  foxy.tailTip = tailTip;
  
  // Initialize animation state management - same as panda
  foxy.animationState = {
    isWalking: false,
    isJumping: false,
    isInAir: false,
    jumpVelocity: 0,
    groundY: 0,
    blink: {
      timer: 0,
      interval: 4 + Math.random() * 3,
      duration: 0.15
    }
  };
  
  return foxy;
}

// Function to update character animations for Foxy
// This is similar to the panda animations but with adjustments for Foxy's unique features
function updateFoxyAnimations(foxy, time, delta, moving) {
  // Update blinking
  foxy.animationState.blink.timer += delta;
  if (foxy.animationState.blink.timer >= foxy.animationState.blink.interval) {
    foxy.animationState.blink.timer = 0;
    foxy.animationState.blink.interval = 2 + Math.random() * 4;
  }
  
  // Perform blink
  const blinkPhase = foxy.animationState.blink.timer / foxy.animationState.blink.interval;
  const isBlinking = blinkPhase < foxy.animationState.blink.duration / foxy.animationState.blink.interval;
  
  if (isBlinking) {
    foxy.leftEye.scale.y = 0.1;
    foxy.rightEye.scale.y = 0.1;
  } else {
    foxy.leftEye.scale.y = 1;
    foxy.rightEye.scale.y = 1;
  }
  
  // Head animations
  if (!foxy.animationState.isInAir) {
    // Normal head bob when on ground
    foxy.head.position.y = 1.6 + Math.sin(time * 1.5) * 0.05;
    foxy.head.rotation.y = Math.sin(time * 0.8) * 0.1;
  } else {
    // Look down when jumping/falling
    foxy.head.rotation.x = foxy.animationState.jumpVelocity > 0 ? -0.2 : 0.3;
  }
  
  // Eye movements
  foxy.leftHighlight.position.x = 0.29 + Math.sin(time * 0.6) * 0.03;
  foxy.rightHighlight.position.x = -0.21 + Math.sin(time * 0.6) * 0.03;
  
  // Mouth animation - purple stitched smile
  foxy.mouth.scale.x = 1 + Math.sin(time * 2) * 0.1;
  
  // Ear animations
  foxy.leftEar.rotation.z = Math.PI / 12 + Math.sin(time * 1.2) * 0.05;
  foxy.rightEar.rotation.z = -Math.PI / 12 - Math.sin(time * 1.2) * 0.05;
  
  // Tail animations - more active for a fox
  foxy.tailBase.rotation.z = Math.sin(time * 3) * 0.3;
  foxy.tailMid.rotation.z = Math.sin(time * 3 + 0.3) * 0.4;
  foxy.tailTip.rotation.z = Math.sin(time * 3 + 0.6) * 0.5;
  
  // Position tail tips relative to base movement
  foxy.tailMid.position.x = Math.sin(time * 3) * 0.1;
  foxy.tailTip.position.x = Math.sin(time * 3) * 0.2;
  
  // Idle animations when not moving
  if (!moving && !foxy.animationState.isInAir) {
    // Breathing animation
    foxy.torsoUpper.scale.y = 1 + Math.sin(time * 1.2) * 0.03;
    foxy.torsoUpper.scale.z = 1 - Math.sin(time * 1.2) * 0.01;
    foxy.torsoLower.scale.y = 1 - Math.sin(time * 1.2) * 0.02;
    
    // Subtle arm movements
    foxy.leftUpperArm.rotation.x = Math.sin(time * 0.7) * 0.1;
    foxy.rightUpperArm.rotation.x = Math.sin(time * 0.7 + 0.5) * 0.1;
    foxy.leftShoulder.position.y = 1.25 + Math.sin(time * 0.7) * 0.02;
    foxy.rightShoulder.position.y = 1.25 + Math.sin(time * 0.7 + 0.5) * 0.02;
    
    // Reset legs
    foxy.leftUpperLeg.rotation.x = 0;
    foxy.rightUpperLeg.rotation.x = 0;
    foxy.leftLowerLeg.rotation.x = 0;
    foxy.rightLowerLeg.rotation.x = 0;
  }
  
  // Walking animations
  if (foxy.animationState.isWalking) {
    // Leg animations
    foxy.leftUpperLeg.rotation.x = Math.sin(time * 10) * 0.7;
    foxy.rightUpperLeg.rotation.x = Math.sin(time * 10 + Math.PI) * 0.7;
    
    // Mid legs follow
    foxy.leftMidLeg.rotation.x = Math.sin(time * 10 - Math.PI/6) * 0.6;
    foxy.rightMidLeg.rotation.x = Math.sin(time * 10 + Math.PI - Math.PI/6) * 0.6;
    
 // Lower legs follow with a delay
    foxy.leftLowerLeg.rotation.x = Math.sin(time * 10 - Math.PI/3) * 0.5;
    foxy.rightLowerLeg.rotation.x = Math.sin(time * 10 + Math.PI - Math.PI/3) * 0.5;
    
    // Arm swing animations
    foxy.leftUpperArm.rotation.x = Math.sin(time * 10 + Math.PI) * 0.5;
    foxy.rightUpperArm.rotation.x = Math.sin(time * 10) * 0.5;
    foxy.leftLowerArm.rotation.x = Math.sin(time * 10 + Math.PI + Math.PI/4) * 0.3;
    foxy.rightLowerArm.rotation.x = Math.sin(time * 10 + Math.PI/4) * 0.3;
    
    // Body movement
    foxy.torso.rotation.y = Math.sin(time * 5) * 0.05;
    
    // Tail swings faster while walking
    foxy.tailBase.rotation.y = Math.sin(time * 5) * 0.3;
  }
  
  // Jump animation
  if (foxy.animationState.isInAir) {
    // Different poses for rising and falling
    if (foxy.animationState.jumpVelocity > 0) {
      // Rising
      foxy.leftUpperLeg.rotation.x = -0.4;
      foxy.rightUpperLeg.rotation.x = -0.4;
      foxy.leftMidLeg.rotation.x = 0.2;
      foxy.rightMidLeg.rotation.x = 0.2;
      foxy.leftLowerLeg.rotation.x = 0.6;
      foxy.rightLowerLeg.rotation.x = 0.6;
      
      // Arms raised
      foxy.leftUpperArm.rotation.x = -0.7;
      foxy.rightUpperArm.rotation.x = -0.7;
      foxy.leftLowerArm.rotation.x = -0.4;
      foxy.rightLowerArm.rotation.x = -0.4;
      
      // Tail up
      foxy.tailBase.rotation.x = -0.5;
    } else {
      // Falling
      foxy.leftUpperLeg.rotation.x = 0.2;
      foxy.rightUpperLeg.rotation.x = 0.2;
      foxy.leftMidLeg.rotation.x = 0.4;
      foxy.rightMidLeg.rotation.x = 0.4;
      foxy.leftLowerLeg.rotation.x = 0.6;
      foxy.rightLowerLeg.rotation.x = 0.6;
      
      // Arms out for balance
      foxy.leftUpperArm.rotation.x = 0;
      foxy.rightUpperArm.rotation.x = 0;
      foxy.leftUpperArm.rotation.z = -0.6;
      foxy.rightUpperArm.rotation.z = 0.6;
      
      // Tail down for balance
      foxy.tailBase.rotation.x = 0.3;
    }
  } else {
    // Reset arm rotation when not jumping
    foxy.leftUpperArm.rotation.z = -0.3;
    foxy.rightUpperArm.rotation.z = 0.3;
    foxy.tailBase.rotation.x = 0;
  }
}

 
    // Check for collectible gems
    function checkCollectibles() {
      gems.forEach((gem, index) => {
        if (gem.visible) {
          const distance = panda.position.distanceTo(gem.position);
          if (distance < 1.5) {
            // Collect the gem
            gem.visible = false;
            score++;
            gemCountElement.textContent = score;
            
            // Collection effect
            particleSystem.spawn(gem.position, 15, 'sparkle');
            
            // Respawn gem in a new location after delay
            setTimeout(() => {
              const distance = 5 + Math.random() * 15;
              const angle = Math.random() * Math.PI * 2;
              const x = Math.sin(angle) * distance;
              const z = Math.cos(angle) * distance;
              gem.position.set(x, 0.8, z);
              gem.visible = true;
            }, 5000);
          }
        }
      });
    }
    
    // Main rendering loop
    const clock = new THREE.Clock();
    
// Function to add character selection UI and functionality
function addCharacterSelection() {
  // Create a character selection UI
  const selectionUI = document.createElement('div');
  selectionUI.style.position = 'absolute';
  selectionUI.style.top = '20px';
  selectionUI.style.left = '50%';
  selectionUI.style.transform = 'translateX(-50%)';
  selectionUI.style.display = 'flex';
  selectionUI.style.gap = '20px';
  selectionUI.style.backgroundColor = 'rgba(0,0,0,0.6)';
  selectionUI.style.padding = '10px';
  selectionUI.style.borderRadius = '10px';
  selectionUI.style.zIndex = '1000';
  
  // Create character buttons
  const characters = [
    { id: 'panda', name: 'Panda' },
    { id: 'foxy', name: 'Foxy' }
  ];
  
  characters.forEach(char => {
    const button = document.createElement('button');
    button.textContent = char.name;
    button.id = `select-${char.id}`;
    button.style.padding = '10px 20px';
    button.style.borderRadius = '5px';
    button.style.border = 'none';
    button.style.backgroundColor = '#4CAF50';
    button.style.color = 'white';
    button.style.cursor = 'pointer';
    button.style.fontWeight = 'bold';
    button.style.fontSize = '16px';
    button.style.transition = 'background-color 0.3s';
    
    // Hover effect
    button.onmouseover = () => {
      button.style.backgroundColor = '#45a049';
    };
    button.onmouseout = () => {
      button.style.backgroundColor = '#4CAF50';
    };
    
    // Active character indicator
    if (char.id === 'panda') {
      button.style.backgroundColor = '#45a049';
      button.style.boxShadow = '0 0 10px rgba(255,255,255,0.5)';
    }
    
    selectionUI.appendChild(button);
  });
  
  document.body.appendChild(selectionUI);
  
  // Character switching functionality
  let currentCharacter = panda;
  let foxyCharacter = null;
  
  document.getElementById('select-panda').addEventListener('click', () => {
    if (currentCharacter !== panda) {
      // Store foxy position and rotation
      const position = { ...currentCharacter.position };
      const rotation = { ...currentCharacter.rotation };
      
      // Hide foxy
      currentCharacter.visible = false;
      
      // Show panda
      panda.position.copy(position);
      panda.rotation.copy(rotation);
      panda.visible = true;
      
      // Update current character
      currentCharacter = panda;
      
      // Update button styles
      document.getElementById('select-panda').style.backgroundColor = '#45a049';
      document.getElementById('select-panda').style.boxShadow = '0 0 10px rgba(255,255,255,0.5)';
      document.getElementById('select-foxy').style.backgroundColor = '#4CAF50';
      document.getElementById('select-foxy').style.boxShadow = 'none';
    }
  });
  
  document.getElementById('select-foxy').addEventListener('click', () => {
    if (currentCharacter !== foxyCharacter) {
      // Create Foxy if not already created
      if (!foxyCharacter) {
        foxyCharacter = createPS2Foxy();
        scene.add(foxyCharacter);
      }
      
      // Store panda position and rotation
      const position = { ...currentCharacter.position };
      const rotation = { ...currentCharacter.rotation };
      
      // Hide panda
      currentCharacter.visible = false;
      
      // Show foxy at panda's position
      foxyCharacter.position.copy(position);
      foxyCharacter.rotation.copy(rotation);
      foxyCharacter.visible = true;
      
      // Update current character
      currentCharacter = foxyCharacter;
      
      // Update button styles
      document.getElementById('select-foxy').style.backgroundColor = '#45a049';
      document.getElementById('select-foxy').style.boxShadow = '0 0 10px rgba(255,255,255,0.5)';
      document.getElementById('select-panda').style.backgroundColor = '#4CAF50';
      document.getElementById('select-panda').style.boxShadow = 'none';
    }
  });
  
  // Return references to update in the game loop
  return {
    getCurrentCharacter: () => currentCharacter,
    getFoxyCharacter: () => foxyCharacter
  };
}

// Update the main animate function to handle both characters
function updateMainAnimationLoop() {
  // Add character selection UI and get character references
  const characterManager = addCharacterSelection();
  
  // Store the original animate function
  const originalAnimate = animate;
  
  // Override the animate function
  animate = function() {
    requestAnimationFrame(animate);
    
    // Get delta time and elapsed time
    const delta = Math.min(clock.getDelta(), 0.1);
    const time = clock.getElapsedTime();
    
    // Get current character
    const currentCharacter = characterManager.getCurrentCharacter();
    const foxyCharacter = characterManager.getFoxyCharacter();
    
    // Update FPS counter
    updateFPS();
    
    // Update current character controller
    const moving = updateCharacter(delta);
    
    // Update appropriate character animations
    if (currentCharacter === panda) {
      updateCharacterAnimations(time, delta, moving);
    } else if (currentCharacter === foxyCharacter) {
      updateFoxyAnimations(foxyCharacter, time, delta, moving);
    }
    
    // Update camera position
    updateCamera(delta);
    
    // Update skybox (day/night cycle)
    sky.update(time);
    
    // Update water effects
    water.update(time);
    
    // Update particle system
    particleSystem.update(delta);
    
    // Update collectible gems
    gems.forEach(gem => {
      if (gem.update) gem.update(time);
    });
    
    // Check for collectibles
    checkCollectibles();
    
    // Render the scene
    renderer.render(scene, camera);
  };
  
  // Modify the updateCharacter function to use the current character
  const originalUpdateCharacter = updateCharacter;
  updateCharacter = function(delta) {
    // Get current character
    const currentCharacter = characterManager.getCurrentCharacter();
    
    // Process jump input
    if (controls.jump && !currentCharacter.animationState.isInAir) {
      currentCharacter.animationState.isJumping = true;
      currentCharacter.animationState.isInAir = true;
      currentCharacter.animationState.jumpVelocity = 8;
    }
    
    // Apply gravity
    if (currentCharacter.animationState.isInAir) {
      currentCharacter.animationState.jumpVelocity -= gravity * delta;
      currentCharacter.position.y += currentCharacter.animationState.jumpVelocity * delta;
      
      if (currentCharacter.position.y <= currentCharacter.animationState.groundY) {
        currentCharacter.position.y = currentCharacter.animationState.groundY;
        currentCharacter.animationState.isInAir = false;
        currentCharacter.animationState.isJumping = false;
        
        // Spawn dust particles on landing
        particleSystem.spawn(
          new THREE.Vector3(
            currentCharacter.position.x,
            currentCharacter.position.y - 0.5,
            currentCharacter.position.z
          ),
          10,
          'dust'
        );
      }
    }
    
    // Handle movement
    let moving = false;
    const moveSpeed = 5.0 * delta;
    
    // Get camera direction for relative movement
    let cameraForward = new THREE.Vector3(0, 0, -1);
    cameraForward.applyQuaternion(camera.quaternion);
    cameraForward.y = 0; // Project onto XZ plane
    cameraForward.normalize();
    
    // Get the right vector
    let cameraRight = new THREE.Vector3(cameraForward.z, 0, -cameraForward.x);
    
    // Initialize movement vector
    let moveVector = new THREE.Vector3(0, 0, 0);
    let targetRotationY = currentCharacter.rotation.y;
    
    // Calculate movement based on camera orientation
    if (controls.moveForward) {
      moveVector.add(cameraForward);
      targetRotationY = Math.atan2(cameraForward.x, cameraForward.z);
      moving = true;
    }
    if (controls.moveBackward) {
      moveVector.sub(cameraForward);
      targetRotationY = Math.atan2(-cameraForward.x, -cameraForward.z);
      moving = true;
    }
    if (controls.moveLeft) {
      moveVector.sub(cameraRight);
      targetRotationY = Math.atan2(-cameraRight.x, -cameraRight.z);
      moving = true;
    }
    if (controls.moveRight) {
      moveVector.add(cameraRight);
      targetRotationY = Math.atan2(cameraRight.x, cameraRight.z);
      moving = true;
    }
    
    // Calculate diagonal movement
    if (controls.moveForwardLeft) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight.clone().multiplyScalar(-1)).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveForwardRight) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward, cameraRight).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveBackwardLeft) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight.clone().multiplyScalar(-1)).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    if (controls.moveBackwardRight) {
      let diagonalDir = new THREE.Vector3().addVectors(cameraForward.clone().multiplyScalar(-1), cameraRight).normalize();
      moveVector.add(diagonalDir);
      targetRotationY = Math.atan2(diagonalDir.x, diagonalDir.z);
      moving = true;
    }
    
    // Normalize and apply movement
    if (moving) {
      moveVector.normalize();
      
      // Apply movement speed
      currentCharacter.position.x += moveVector.x * moveSpeed;
      currentCharacter.position.z += moveVector.z * moveSpeed;
      
      // Smoothly rotate character to face movement direction
      const rotationSpeed = 10 * delta;
      currentCharacter.rotation.y = THREE.MathUtils.lerp(
        currentCharacter.rotation.y,
        targetRotationY,
        rotationSpeed
      );
      
      // Generate footstep particles
      if (!currentCharacter.animationState.isInAir && Math.sin(performance.now() * 0.01) > 0.9) {
        particleSystem.spawn(
          new THREE.Vector3(
            currentCharacter.position.x,
            currentCharacter.position.y - 0.5,
            currentCharacter.position.z
          ),
          3,
          'dust'
        );
      }
    }
    
    // Check if character is near water and add ripples
    const distanceToWater = new THREE.Vector2(currentCharacter.position.x - water.position.x, currentCharacter.position.z - water.position.z).length();
    if (distanceToWater < 20 && moving && Math.random() < 0.03) {
      water.addRipple({
        x: currentCharacter.position.x,
        z: currentCharacter.position.z
      });
    }
    
    // Set animation state
    currentCharacter.animationState.isWalking = moving && !currentCharacter.animationState.isInAir;
    
    // Return movement status
    return moving;
  };
  
  // Modify the updateCamera function to use the current character
  const originalUpdateCamera = updateCamera;
  updateCamera = function(delta) {
    const currentCharacter = characterManager.getCurrentCharacter();
    
    // Camera controls
    if (controls.cameraTurnLeft) {
      cameraAngle += 2 * delta;
    }
    if (controls.cameraTurnRight) {
      cameraAngle -= 2 * delta;
    }
    if (controls.cameraTiltUp) {
      cameraHeight += 2 * delta;
      cameraHeight = Math.min(6, cameraHeight);
    }
    if (controls.cameraTiltDown) {
      cameraHeight -= 2 * delta;
      cameraHeight = Math.max(1.5, cameraHeight);
    }
    if (controls.cameraZoomIn) {
      cameraDistance -= 3 * delta;
      cameraDistance = Math.max(3, cameraDistance);
    }
    if (controls.cameraZoomOut) {
      cameraDistance += 3 * delta;
      cameraDistance = Math.min(10, cameraDistance);
    }
    
    // Smoothly update camera position based on current character
    const targetX = currentCharacter.position.x + Math.sin(cameraAngle) * cameraDistance;
    const targetZ = currentCharacter.position.z + Math.cos(cameraAngle) * cameraDistance;
    const targetY = currentCharacter.position.y + cameraHeight;
    
    camera.position.x += (targetX - camera.position.x) * 5 * delta;
    camera.position.z += (targetZ - camera.position.z) * 5 * delta;
    camera.position.y += (targetY - camera.position.y) * 5 * delta;
    
    // Look at current character with slight offset
    camera.lookAt(
      currentCharacter.position.x,
      currentCharacter.position.y + 1,
      currentCharacter.position.z
    );
  };
  
  // Modify the checkCollectibles function to use the current character
  const originalCheckCollectibles = checkCollectibles;
  checkCollectibles = function() {
    const currentCharacter = characterManager.getCurrentCharacter();
    
    gems.forEach((gem, index) => {
      if (gem.visible) {
        const distance = currentCharacter.position.distanceTo(gem.position);
        if (distance < 1.5) {
          // Collect the gem
          gem.visible = false;
          score++;
          gemCountElement.textContent = score;
          
          // Collection effect
          particleSystem.spawn(gem.position, 15, 'sparkle');
          
          // Respawn gem in a new location after delay
          setTimeout(() => {
            const distance = 5 + Math.random() * 15;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.sin(angle) * distance;
            const z = Math.cos(angle) * distance;
            gem.position.set(x, 0.8, z);
            gem.visible = true;
          }, 5000);
        }
      }
    });
  };
  
  // Restart animation loop
  animate();
}

    function animate() {
      requestAnimationFrame(animate);
      
      // Get delta time and elapsed time
      const delta = Math.min(clock.getDelta(), 0.1);
      const time = clock.getElapsedTime();
      
      // Update FPS counter
      updateFPS();
      
      // Update character controller
      const moving = updateCharacter(delta);
      
      // Update character animations
      updateCharacterAnimations(time, delta, moving);
      
      // Update camera position
      updateCamera(delta);
      
      // Update skybox (day/night cycle)
      sky.update(time);
      
      // Update water effects
      water.update(time);
      
      // Update particle system
      particleSystem.update(delta);
      
      // Update collectible gems
      gems.forEach(gem => {
        if (gem.update) gem.update(time);
      });
      
      // Check for collectibles
      checkCollectibles();
      
      // Render the scene
      renderer.render(scene, camera);
    }
    
    // Start the animation loop
    animate();
    // Call this function to initialize character selection and update the game loop
updateMainAnimationLoop();

    // Hide instructions after 10 seconds
    setTimeout(() => {
      const instructions = document.querySelector('.instructions');
      if (instructions) {
        instructions.style.opacity = '0';
        instructions.style.transition = 'opacity 1s';
      }
    }, 10000);
  </script>
</body>
</html>