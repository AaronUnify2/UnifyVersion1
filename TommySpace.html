<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Titan Scale: Textured</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Michroma&family=Share+Tech+Mono&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { overflow: hidden; background: #000; font-family: 'Michroma', sans-serif; }
        
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* Planet Labels */
        .planet-label {
            position: absolute; transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8); font-size: 10px;
            text-align: center; pointer-events: none;
            text-shadow: 0 0 5px #000; transition: opacity 0.5s;
        }
        .label-name { font-weight: bold; color: #fff; letter-spacing: 1px; }
        .label-dist { font-size: 9px; color: #00ffcc; margin-top: 2px; }

        /* HUD */
        #hud-top { position: absolute; top: 30px; width: 100%; text-align: center; pointer-events: none; }
        #hud-bottom { position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none; }
        .hud-text { color: #00ffcc; font-size: 12px; letter-spacing: 2px; text-shadow: 0 0 10px rgba(0, 255, 204, 0.3); }
        .sub-text { color: #666; font-size: 10px; margin-top: 5px; text-transform: uppercase; }

        /* Action Button */
        #action-btn {
            position: absolute; top: 50%; right: 30px; transform: translateY(-50%);
            width: 80px; height: 80px; border-radius: 50%;
            border: 2px solid #00ffcc; color: #00ffcc;
            display: none; align-items: center; justify-content: center;
            font-size: 12px; font-weight: bold; background: rgba(0, 30, 30, 0.9);
            cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
            animation: pulse 3s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 10px rgba(0,255,204,0.3); }
            50% { box-shadow: 0 0 20px rgba(0,255,204,0.6); }
            100% { box-shadow: 0 0 10px rgba(0,255,204,0.3); }
        }

        /* Controls */
        #controls { pointer-events: auto; }
        #stick-area {
            position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px;
            border-radius: 50%; border: 1px dashed rgba(255, 255, 255, 0.15);
        }
        #stick-thumb {
            width: 50px; height: 50px; background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .btn {
            position: absolute; width: 70px; height: 70px; border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2); color: #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 16px; background: rgba(0,0,0,0.5); backdrop-filter: blur(4px);
        }
        #btn-up { bottom: 130px; right: 30px; }
        #btn-down { bottom: 40px; right: 30px; }

        /* ============================== */
        /* SPACESHIP COCKPIT HUD          */
        /* ============================== */
        #cockpit-hud {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 9;
            opacity: 0; transition: opacity 0.6s ease;
        }
        #cockpit-hud.active { opacity: 1; }

        #hud-toggle {
            position: fixed; top: 16px; right: 16px; z-index: 20;
            width: 44px; height: 44px; border-radius: 8px;
            border: 1px solid rgba(0,255,204,0.25); color: #00ffcc;
            display: none; align-items: center; justify-content: center;
            font-size: 18px; background: rgba(0,20,20,0.7);
            cursor: pointer; pointer-events: auto;
            backdrop-filter: blur(4px); transition: all 0.3s;
            font-family: 'Share Tech Mono', monospace;
        }
        #hud-toggle:hover { background: rgba(0,40,40,0.9); border-color: rgba(0,255,204,0.5); }
        #hud-toggle.hud-on { border-color: rgba(0,255,204,0.6); box-shadow: 0 0 8px rgba(0,255,204,0.3); }

        #cockpit-hud.active #scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,180,0.008) 2px, rgba(0,255,180,0.008) 4px);
            pointer-events: none;
        }

        #reticle { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80px; height: 80px; }
        .hud-inst { font-family: 'Share Tech Mono', monospace; color: #00ffcc; text-shadow: 0 0 6px rgba(0,255,204,0.4); letter-spacing: 1px; }
        .hud-inst-warn { font-family: 'Share Tech Mono', monospace; color: #ff6633; text-shadow: 0 0 6px rgba(255,100,50,0.4); letter-spacing: 1px; }

        #hud-left-panel { position: absolute; left: 20px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 8px; }
        #speed-gauge { width: 36px; height: 180px; position: relative; }
        #speed-gauge-bg { position: absolute; top: 0; left: 8px; width: 20px; height: 100%; border: 1px solid rgba(0,255,204,0.2); border-radius: 3px; overflow: hidden; }
        #speed-gauge-fill { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: linear-gradient(to top, #00ffcc, #00cc99); border-radius: 2px; transition: height 0.15s; box-shadow: 0 0 8px rgba(0,255,204,0.3); }
        #speed-gauge-label { position: absolute; bottom: -18px; left: 0; width: 36px; text-align: center; font-size: 8px; }
        #speed-gauge-value { position: absolute; top: -18px; left: 0; width: 36px; text-align: center; font-size: 10px; }
        .gauge-tick { position: absolute; left: 0; width: 6px; height: 1px; background: rgba(0,255,204,0.3); }



        #hud-right-panel { position: absolute; right: 20px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 6px; align-items: flex-end; }
        #target-readout { text-align: right; font-size: 9px; margin-top: 4px; }
        #target-label { font-size: 7px; opacity: 0.6; }
        #target-dist { font-size: 11px; margin-top: 2px; }
        #target-name { font-size: 12px; margin-top: 2px; color: #ffcc00; text-shadow: 0 0 6px rgba(255,204,0,0.3); }

        #radar-container { position: absolute; bottom: 24px; left: 50%; transform: translateX(-50%); width: 140px; height: 140px; }
        #radar-canvas { width: 140px; height: 140px; }
        #radar-label { text-align: center; font-size: 7px; margin-top: 2px; opacity: 0.5; }

        #hud-top-bar { position: absolute; top: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 30px; align-items: center; }
        #heading-readout { font-size: 11px; letter-spacing: 3px; }

        .corner-bracket { position: absolute; width: 60px; height: 60px; border-color: rgba(0,255,204,0.12); border-style: solid; }
        .corner-tl { top: 8px; left: 8px; border-width: 2px 0 0 2px; }
        .corner-tr { top: 8px; right: 8px; border-width: 2px 2px 0 0; }
        .corner-bl { bottom: 8px; left: 8px; border-width: 0 0 2px 2px; }
        .corner-br { bottom: 8px; right: 8px; border-width: 0 2px 2px 0; }

        #cockpit-vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, transparent 55%, rgba(0,0,0,0.35) 85%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
        }

        #proximity-warning {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, 60px);
            font-size: 11px; letter-spacing: 3px;
            opacity: 0; transition: opacity 0.3s;
        }
        #proximity-warning.visible { opacity: 1; animation: warnBlink 1s infinite; }
        @keyframes warnBlink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- COCKPIT HUD -->
    <div id="cockpit-hud">
        <div id="cockpit-vignette"></div>
        <svg id="canopy-struts" viewBox="0 0 1000 600" preserveAspectRatio="none" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none">
            <path d="M0,0 L80,60 L80,540 L0,600" fill="rgba(10,12,15,0.85)"/>
            <path d="M1000,0 L920,60 L920,540 L1000,600" fill="rgba(10,12,15,0.85)"/>
            <path d="M0,0 L80,60 L920,60 L1000,0" fill="rgba(10,12,15,0.75)"/>
            <path d="M0,600 L80,540 L920,540 L1000,600" fill="rgba(10,12,15,0.85)"/>
            <line x1="500" y1="0" x2="500" y2="58" stroke="rgba(10,12,15,0.7)" stroke-width="3"/>
            <line x1="80" y1="60" x2="200" y2="0" stroke="rgba(20,25,30,0.5)" stroke-width="2.5"/>
            <line x1="920" y1="60" x2="800" y2="0" stroke="rgba(20,25,30,0.5)" stroke-width="2.5"/>
            <line x1="80" y1="540" x2="200" y2="600" stroke="rgba(20,25,30,0.5)" stroke-width="2.5"/>
            <line x1="920" y1="540" x2="800" y2="600" stroke="rgba(20,25,30,0.5)" stroke-width="2.5"/>
            <line x1="80" y1="460" x2="920" y2="460" stroke="rgba(15,18,22,0.35)" stroke-width="1.5"/>
            <line x1="82" y1="62" x2="82" y2="538" stroke="rgba(0,255,204,0.06)" stroke-width="1"/>
            <line x1="918" y1="62" x2="918" y2="538" stroke="rgba(0,255,204,0.06)" stroke-width="1"/>
            <line x1="82" y1="62" x2="918" y2="62" stroke="rgba(0,255,204,0.06)" stroke-width="1"/>
            <line x1="82" y1="538" x2="918" y2="538" stroke="rgba(0,255,204,0.06)" stroke-width="1"/>
        </svg>
        <div id="scanlines"></div>
        <div class="corner-bracket corner-tl"></div>
        <div class="corner-bracket corner-tr"></div>
        <div class="corner-bracket corner-bl"></div>
        <div class="corner-bracket corner-br"></div>
        <svg id="reticle" viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="30" fill="none" stroke="rgba(0,255,204,0.2)" stroke-width="1" stroke-dasharray="4 8"/>
            <path d="M25,40 L32,40" stroke="#00ffcc" stroke-width="1.5" opacity="0.7"/>
            <path d="M48,40 L55,40" stroke="#00ffcc" stroke-width="1.5" opacity="0.7"/>
            <path d="M40,25 L40,32" stroke="#00ffcc" stroke-width="1.5" opacity="0.7"/>
            <path d="M40,48 L40,55" stroke="#00ffcc" stroke-width="1.5" opacity="0.7"/>
            <circle cx="40" cy="40" r="1.5" fill="#00ffcc" opacity="0.6"/>
            <path d="M20,28 L20,20 L28,20" fill="none" stroke="rgba(0,255,204,0.35)" stroke-width="1"/>
            <path d="M52,20 L60,20 L60,28" fill="none" stroke="rgba(0,255,204,0.35)" stroke-width="1"/>
            <path d="M20,52 L20,60 L28,60" fill="none" stroke="rgba(0,255,204,0.35)" stroke-width="1"/>
            <path d="M52,60 L60,60 L60,52" fill="none" stroke="rgba(0,255,204,0.35)" stroke-width="1"/>
            <circle cx="40" cy="40" r="36" fill="none" stroke="rgba(0,255,204,0.1)" stroke-width="0.5" stroke-dasharray="2 14" id="reticle-spin"/>
        </svg>
        <div id="proximity-warning" class="hud-inst-warn">⚠ PROXIMITY ALERT ⚠</div>
        <div id="hud-top-bar">
            <span id="heading-readout" class="hud-inst">HDG 000</span>
        </div>
        <div id="hud-left-panel">
            <div id="speed-gauge">
                <div id="speed-gauge-value" class="hud-inst">0</div>
                <div id="speed-gauge-bg"><div id="speed-gauge-fill"></div></div>
                <div class="gauge-tick" style="bottom:25%"></div>
                <div class="gauge-tick" style="bottom:50%"></div>
                <div class="gauge-tick" style="bottom:75%"></div>
                <div id="speed-gauge-label" class="hud-inst" style="font-size:7px;opacity:0.5">THR</div>
            </div>
        </div>
        <div id="hud-right-panel">
            <div id="target-readout"><div id="target-label" class="hud-inst">TARGET</div><div id="target-name" class="hud-inst">---</div><div id="target-dist" class="hud-inst">---</div></div>
        </div>
        <div id="radar-container"><canvas id="radar-canvas" width="280" height="280"></canvas><div id="radar-label" class="hud-inst">SCANNER</div></div>
        <svg style="position:absolute;bottom:0;left:0;width:100%;height:70px;pointer-events:none" viewBox="0 0 1000 70" preserveAspectRatio="none">
            <path d="M0,70 L0,30 Q100,0 250,15 L400,20 Q500,25 600,20 L750,15 Q900,0 1000,30 L1000,70 Z" fill="rgba(8,10,14,0.8)"/>
            <path d="M0,30 Q100,0 250,15 L400,20 Q500,25 600,20 L750,15 Q900,0 1000,30" fill="none" stroke="rgba(0,255,204,0.08)" stroke-width="1"/>
            <circle cx="150" cy="45" r="3" fill="rgba(0,255,140,0.4)"/><circle cx="170" cy="45" r="3" fill="rgba(0,255,140,0.4)"/>
            <circle cx="190" cy="45" r="3" fill="rgba(0,180,255,0.3)"/>
            <circle cx="810" cy="45" r="3" fill="rgba(0,255,140,0.4)"/><circle cx="830" cy="45" r="3" fill="rgba(0,255,140,0.4)"/>
            <circle cx="850" cy="45" r="3" fill="rgba(0,180,255,0.3)"/>
            <line x1="280" y1="38" x2="380" y2="38" stroke="rgba(30,35,40,0.6)" stroke-width="3"/>
            <line x1="280" y1="44" x2="380" y2="44" stroke="rgba(30,35,40,0.6)" stroke-width="3"/>
            <line x1="280" y1="50" x2="380" y2="50" stroke="rgba(30,35,40,0.6)" stroke-width="3"/>
            <line x1="620" y1="38" x2="720" y2="38" stroke="rgba(30,35,40,0.6)" stroke-width="3"/>
            <line x1="620" y1="44" x2="720" y2="44" stroke="rgba(30,35,40,0.6)" stroke-width="3"/>
            <line x1="620" y1="50" x2="720" y2="50" stroke="rgba(30,35,40,0.6)" stroke-width="3"/>
        </svg>
    </div>

    <button id="hud-toggle" title="Toggle Cockpit HUD (H)">⬡</button>

    <div id="ui-layer">
        <div id="labels-container"></div>
        <div id="hud-top">
            <div id="system-status" class="hud-text">EXPLORE</div>
            <div id="proximity-alert" class="sub-text">WALK TO THE ROCKET</div>
        </div>
        <div id="hud-bottom" style="display:none;">
            <div id="speed-readout" class="hud-text">THRUST: 0%</div>
        </div>
        <div id="action-btn">LAUNCH</div>
        <div id="controls">
            <div id="stick-area"><div id="stick-thumb"></div></div>
            <div id="btn-up" class="btn">▲</div>
            <div id="btn-down" class="btn">▼</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    /* ================================================================
       TITAN SCALE: TEXTURED EDITION — WITH COCKPIT HUD
       ================================================================ */

    const config = {
        renderDist: 3000000000,
        lockDist: 40000,
        deepSpaceSpeed: 2500,
        minSpeed: 5,
        sunRadius: 5000
    };

    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, logarithmicDepthBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x4a90d9);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, config.renderDist);
    camera.up.set(0, 1, 0);

    scene.add(new THREE.AmbientLight(0x404040, 1.0));
    scene.add(new THREE.PointLight(0xffffff, 1.3, 0));

    const raycaster = new THREE.Raycaster();
    const systemGroup = new THREE.Group();
    scene.add(systemGroup);

    /* ================================================================
       COCKPIT HUD SYSTEM
       ================================================================ */
    let hudEnabled = false;
    const hudEl = document.getElementById('cockpit-hud');
    const hudToggle = document.getElementById('hud-toggle');
    const radarCanvas = document.getElementById('radar-canvas');
    const radarCtx = radarCanvas.getContext('2d');
    const reticleSpin = document.getElementById('reticle-spin');

    hudToggle.addEventListener('click', () => {
        hudEnabled = !hudEnabled;
        hudEl.classList.toggle('active', hudEnabled);
        hudToggle.classList.toggle('hud-on', hudEnabled);
        hudToggle.textContent = hudEnabled ? '⬢' : '⬡';
    });

    const hudData = {
        speed: 0, maxSpeed: 2500, altitude: 0, heading: 0,
        targetName: '---', targetDist: 0,
        nearPlanet: false, planets: [],
        maxOrbitDist: 2600000, // Neptune's orbit
        playerRadarAngle: 0, playerSunDist: 0
    };

    function updateHUD() {
        if (!hudEnabled) return;

        // Speed gauge
        const speedPct = Math.min(100, (hudData.speed / hudData.maxSpeed) * 100);
        document.getElementById('speed-gauge-fill').style.height = speedPct + '%';
        document.getElementById('speed-gauge-value').textContent = Math.floor(hudData.speed);

        // Heading
        const hdg = ((hudData.heading % 360) + 360) % 360;
        document.getElementById('heading-readout').textContent = 'HDG ' + String(Math.floor(hdg)).padStart(3, '0');

        // Target info
        document.getElementById('target-name').textContent = hudData.targetName;
        if (hudData.targetDist > 0) {
            const d = hudData.targetDist;
            const distStr = d > 1000000 ? (d / 1000000).toFixed(1) + 'M u'
                : d > 1000 ? (d / 1000).toFixed(1) + 'K u'
                : Math.floor(d) + ' u';
            document.getElementById('target-dist').textContent = distStr;
        } else {
            document.getElementById('target-dist').textContent = '---';
        }

        // Proximity warning
        document.getElementById('proximity-warning').classList.toggle('visible', hudData.nearPlanet);

        // Reticle spin
        const rot = (Date.now() * 0.02) % 360;
        reticleSpin.setAttribute('transform', 'rotate(' + rot + ' 40 40)');

        drawRadar();
    }

    function drawRadar() {
        const w = radarCanvas.width, h = radarCanvas.height;
        const cx = w / 2, cy = h / 2, r = cx - 10;
        radarCtx.clearRect(0, 0, w, h);

        // Background circle
        radarCtx.strokeStyle = 'rgba(0,255,204,0.12)';
        radarCtx.lineWidth = 1;
        radarCtx.beginPath(); radarCtx.arc(cx, cy, r, 0, Math.PI * 2); radarCtx.stroke();

        // Orbit rings (faint concentric circles for scale)
        radarCtx.strokeStyle = 'rgba(0,255,204,0.04)';
        for (let i = 1; i <= 5; i++) {
            radarCtx.beginPath(); radarCtx.arc(cx, cy, r * (i / 5), 0, Math.PI * 2); radarCtx.stroke();
        }

        // Cross hairs
        radarCtx.strokeStyle = 'rgba(0,255,204,0.06)';
        radarCtx.beginPath(); radarCtx.moveTo(cx, cy - r); radarCtx.lineTo(cx, cy + r); radarCtx.stroke();
        radarCtx.beginPath(); radarCtx.moveTo(cx - r, cy); radarCtx.lineTo(cx + r, cy); radarCtx.stroke();

        // Sweep line
        const sweepAngle = (Date.now() * 0.001) % (Math.PI * 2);
        radarCtx.strokeStyle = 'rgba(0,255,204,0.25)';
        radarCtx.lineWidth = 1.5;
        radarCtx.beginPath();
        radarCtx.moveTo(cx, cy);
        radarCtx.lineTo(cx + Math.cos(sweepAngle) * r, cy + Math.sin(sweepAngle) * r);
        radarCtx.stroke();

        // Sun at center (gold dot)
        radarCtx.fillStyle = '#ffcc00';
        radarCtx.shadowColor = '#ffcc00';
        radarCtx.shadowBlur = 8;
        radarCtx.beginPath(); radarCtx.arc(cx, cy, 4, 0, Math.PI * 2); radarCtx.fill();
        radarCtx.shadowBlur = 0;

        // Planet blips — positioned by their orbit around the sun
        hudData.planets.forEach(p => {
            if (p.isSun || p.dist <= 0) return;

            const normDist = Math.min(1, p.dist / hudData.maxOrbitDist);
            const px = cx + Math.cos(p.angle) * normDist * (r - 6);
            const py = cy + Math.sin(p.angle) * normDist * (r - 6);

            // Check within radar circle
            const dx2 = px - cx, dy2 = py - cy;
            if (Math.sqrt(dx2 * dx2 + dy2 * dy2) > r - 4) return;

            // Brightness based on sweep line proximity
            const blipAngle = Math.atan2(py - cy, px - cx);
            let angleDiff = sweepAngle - blipAngle;
            while (angleDiff < 0) angleDiff += Math.PI * 2;
            while (angleDiff > Math.PI * 2) angleDiff -= Math.PI * 2;
            const fade = angleDiff < Math.PI ? Math.max(0.15, 1 - angleDiff / Math.PI) : 0.15;

            // Draw blip
            const isNearest = p.name === hudData.targetName;
            const blipSize = isNearest ? 3.5 : 2.5;
            const blipColor = isNearest ? 'rgba(255,204,0,' + fade + ')' : 'rgba(0,255,180,' + fade + ')';
            radarCtx.fillStyle = blipColor;
            radarCtx.beginPath(); radarCtx.arc(px, py, blipSize, 0, Math.PI * 2); radarCtx.fill();

            // Labels for all visible planets
            if (fade > 0.3) {
                radarCtx.fillStyle = 'rgba(0,255,204,' + (fade * 0.6) + ')';
                radarCtx.font = '7px Share Tech Mono';
                radarCtx.fillText(p.name.slice(0, 3), px + 5, py - 3);
            }
        });

        // Player position indicator (small triangle on the edge pointing inward)
        if (hudData.playerRadarAngle !== undefined) {
            const pa = hudData.playerRadarAngle;
            const playerDist = Math.min(1, hudData.playerSunDist / hudData.maxOrbitDist);
            const ppx = cx + Math.cos(pa) * playerDist * (r - 6);
            const ppy = cy + Math.sin(pa) * playerDist * (r - 6);

            // Check within radar
            const pdx = ppx - cx, pdy = ppy - cy;
            if (Math.sqrt(pdx * pdx + pdy * pdy) <= r - 2) {
                radarCtx.fillStyle = 'rgba(0,255,204,0.7)';
                radarCtx.beginPath();
                const triSize = 4;
                const ta = Math.atan2(ppy - cy, ppx - cx) + Math.PI; // point toward sun
                radarCtx.moveTo(ppx + Math.cos(ta) * triSize, ppy + Math.sin(ta) * triSize);
                radarCtx.lineTo(ppx + Math.cos(ta + 2.4) * triSize * 0.7, ppy + Math.sin(ta + 2.4) * triSize * 0.7);
                radarCtx.lineTo(ppx + Math.cos(ta - 2.4) * triSize * 0.7, ppy + Math.sin(ta - 2.4) * triSize * 0.7);
                radarCtx.closePath(); radarCtx.fill();
            }
        }
    }

    /* ================================================================
       STAR FIELD
       ================================================================ */
    function createStarField() {
        const starCount = 6000;
        const positions = new Float32Array(starCount * 3);
        const colors = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 800000000 + Math.random() * 200000000;
            positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = r * Math.cos(phi);
            const colorRoll = Math.random();
            if (colorRoll < 0.5) {
                colors[i * 3] = 0.9 + Math.random() * 0.1;
                colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
                colors[i * 3 + 2] = 0.9 + Math.random() * 0.1;
            } else if (colorRoll < 0.7) {
                colors[i * 3] = 0.7 + Math.random() * 0.1;
                colors[i * 3 + 1] = 0.8 + Math.random() * 0.1;
                colors[i * 3 + 2] = 1.0;
            } else if (colorRoll < 0.85) {
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
                colors[i * 3 + 2] = 0.7 + Math.random() * 0.1;
            } else {
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.6 + Math.random() * 0.2;
                colors[i * 3 + 2] = 0.4 + Math.random() * 0.2;
            }
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        scene.add(new THREE.Points(geo, new THREE.PointsMaterial({
            size: 500000, sizeAttenuation: true, vertexColors: true, transparent: true, opacity: 0.9
        })));

        // Background dimmer stars
        const bgCount = 4000;
        const bgPos = new Float32Array(bgCount * 3);
        const bgCol = new Float32Array(bgCount * 3);
        for (let i = 0; i < bgCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 900000000 + Math.random() * 100000000;
            bgPos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            bgPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            bgPos[i * 3 + 2] = r * Math.cos(phi);
            bgCol[i * 3] = 0.7 + Math.random() * 0.3;
            bgCol[i * 3 + 1] = 0.7 + Math.random() * 0.3;
            bgCol[i * 3 + 2] = 0.8 + Math.random() * 0.1;
        }
        const bgGeo = new THREE.BufferGeometry();
        bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
        bgGeo.setAttribute('color', new THREE.BufferAttribute(bgCol, 3));
        scene.add(new THREE.Points(bgGeo, new THREE.PointsMaterial({
            size: 400000, sizeAttenuation: true, vertexColors: true, transparent: true, opacity: 0.6
        })));
    }
    createStarField();

    /* ================================================================
       TEXTURE GENERATORS
       ================================================================ */
    function makeTexture(w, h, drawFn) {
        const c = document.createElement('canvas'); c.width = w; c.height = h;
        const ctx = c.getContext('2d');
        drawFn(ctx, w, h);
        const t = new THREE.CanvasTexture(c);
        t.magFilter = THREE.LinearFilter;
        return t;
    }

    function sunTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#ffcc00'); grad.addColorStop(0.3, '#ff9900');
            grad.addColorStop(0.5, '#ff8c00'); grad.addColorStop(0.7, '#ff6600');
            grad.addColorStop(1, '#ffaa00');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 500; i++) {
                ctx.fillStyle = ['#ffaa00', '#ff6600', '#ffcc00', '#ffe066', '#ff5500'][Math.floor(Math.random() * 5)];
                ctx.globalAlpha = 0.15 + Math.random() * 0.2;
                ctx.fillRect(Math.random() * w, Math.random() * h, 2 + Math.random() * 6, 2 + Math.random() * 4);
            }
            ctx.globalAlpha = 1;
            for (let i = 0; i < 8; i++) {
                ctx.fillStyle = 'rgba(120,50,0,0.3)';
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 2 + Math.random() * 5, 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    function mercuryTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#8a8a8a'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = 'rgba(60,60,60,' + (0.3 + Math.random() * 0.4) + ')';
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 1 + Math.random() * 3, 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    function venusTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#d4a537'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = 'rgba(' + (180 + Math.random() * 40) + ',' + (140 + Math.random() * 40) + ',' + (30 + Math.random() * 30) + ',0.3)';
                ctx.fillRect(Math.random() * w, Math.random() * h, 4 + Math.random() * 8, 1 + Math.random() * 2);
            }
        });
    }

    function earthTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            // Ocean gradient
            const oceanGrad = ctx.createLinearGradient(0, 0, 0, h);
            oceanGrad.addColorStop(0, '#1a3a5c'); oceanGrad.addColorStop(0.15, '#1e5799');
            oceanGrad.addColorStop(0.3, '#1a6baa'); oceanGrad.addColorStop(0.5, '#1565a0');
            oceanGrad.addColorStop(0.7, '#1a6baa'); oceanGrad.addColorStop(0.85, '#1e5799');
            oceanGrad.addColorStop(1, '#1a3a5c');
            ctx.fillStyle = oceanGrad; ctx.fillRect(0, 0, w, h);

            // Ocean variation
            for (let i = 0; i < 200; i++) {
                ctx.fillStyle = 'rgba(' + (10 + Math.random() * 20) + ',' + (60 + Math.random() * 40) + ',' + (120 + Math.random() * 40) + ',0.15)';
                ctx.fillRect(Math.random() * w, Math.random() * h, 5 + Math.random() * 20, 2 + Math.random() * 6);
            }

            // Continent drawing helper
            function drawContinent(cx, cy, sx, sy, color, rot) {
                ctx.save(); ctx.translate(cx, cy); ctx.rotate(rot || 0);
                ctx.fillStyle = color; ctx.beginPath();
                const points = 12 + Math.floor(Math.random() * 6);
                for (let i = 0; i <= points; i++) {
                    const a = (i / points) * Math.PI * 2, rr = 1 + Math.random() * 0.35;
                    if (i === 0) ctx.moveTo(Math.cos(a) * sx * rr, Math.sin(a) * sy * rr);
                    else ctx.lineTo(Math.cos(a) * sx * rr, Math.sin(a) * sy * rr);
                }
                ctx.closePath(); ctx.fill(); ctx.restore();
            }

            // North America
            drawContinent(w * 0.18, h * 0.28, 38, 28, '#2d6b30', -0.2);
            drawContinent(w * 0.15, h * 0.22, 20, 15, '#3a7a3d', 0.3);
            drawContinent(w * 0.22, h * 0.35, 15, 20, '#2d6b30', -0.1);
            drawContinent(w * 0.20, h * 0.42, 8, 12, '#3a7a3d', 0.5);
            // South America
            drawContinent(w * 0.26, h * 0.55, 18, 30, '#2d6b30', 0.15);
            drawContinent(w * 0.28, h * 0.62, 14, 22, '#3a7a3d', 0.1);
            // Europe
            drawContinent(w * 0.48, h * 0.22, 18, 12, '#4a8a40', -0.1);
            drawContinent(w * 0.50, h * 0.18, 12, 8, '#3a7a3d', 0.2);
            drawContinent(w * 0.44, h * 0.18, 4, 6, '#4a8a40', 0.3);
            drawContinent(w * 0.52, h * 0.14, 5, 10, '#3a7a3d', 0.1);
            // Africa
            drawContinent(w * 0.50, h * 0.42, 22, 30, '#8B7235', 0.05);
            drawContinent(w * 0.48, h * 0.38, 18, 16, '#6b8a30', -0.1);
            drawContinent(w * 0.53, h * 0.52, 14, 18, '#9a8040', 0.1);
            drawContinent(w * 0.49, h * 0.35, 20, 8, '#c4a555', 0);
            // Asia
            drawContinent(w * 0.62, h * 0.25, 40, 22, '#3a7a3d', -0.05);
            drawContinent(w * 0.70, h * 0.28, 28, 18, '#4a8a40', 0.1);
            drawContinent(w * 0.58, h * 0.20, 20, 14, '#567a45', 0.15);
            drawContinent(w * 0.62, h * 0.40, 10, 14, '#6b8a30', 0.2);
            drawContinent(w * 0.72, h * 0.42, 12, 10, '#4a8a40', -0.2);
            // Australia
            drawContinent(w * 0.78, h * 0.62, 18, 14, '#9a7a30', 0.1);
            drawContinent(w * 0.80, h * 0.60, 14, 10, '#8a6a28', -0.15);

            // Ice caps
            ctx.fillStyle = '#e8e8f0'; ctx.fillRect(0, h - 18, w, 18);
            ctx.fillStyle = 'rgba(220,230,240,0.6)'; ctx.fillRect(0, 0, w, 10);

            // Terrain noise
            for (let i = 0; i < 150; i++) {
                ctx.fillStyle = 'rgba(' + (Math.random() < 0.5 ? '30,80,30' : '80,60,30') + ',' + (0.06 + Math.random() * 0.12) + ')';
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 1 + Math.random() * 3, 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    function earthCloudTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            ctx.clearRect(0, 0, w, h);
            for (let b = 0; b < 8; b++) {
                const bandY = (b / 8) * h + Math.random() * 20 - 10;
                const bandWidth = 15 + Math.random() * 30;
                for (let i = 0; i < 40; i++) {
                    ctx.fillStyle = 'rgba(255,255,255,' + (0.02 + Math.random() * 0.06) + ')';
                    ctx.beginPath();
                    ctx.ellipse(Math.random() * w, bandY + (Math.random() - 0.5) * bandWidth,
                        8 + Math.random() * 25, 3 + Math.random() * 10, Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            for (let i = 0; i < 60; i++) {
                const cx = Math.random() * w, cy = Math.random() * h, sz = 5 + Math.random() * 20;
                for (let j = 0; j < 5; j++) {
                    ctx.fillStyle = 'rgba(255,255,255,' + (0.015 + Math.random() * 0.04) + ')';
                    ctx.beginPath();
                    ctx.ellipse(cx + (Math.random() - 0.5) * sz * 2, cy + (Math.random() - 0.5) * sz,
                        sz * (0.5 + Math.random()), sz * (0.3 + Math.random() * 0.4), Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        });
    }

    function marsTexture() {
        return makeTexture(256, 128, (ctx, w, h) => {
            const g = ctx.createLinearGradient(0, 0, 0, h);
            g.addColorStop(0, '#a0522d'); g.addColorStop(0.5, '#b5513a'); g.addColorStop(1, '#803520');
            ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 80; i++) {
                ctx.fillStyle = 'rgba(' + (130 + Math.random() * 40) + ',' + (50 + Math.random() * 30) + ',' + (20 + Math.random() * 20) + ',0.2)';
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 1 + Math.random() * 4, 0, Math.PI * 2); ctx.fill();
            }
            ctx.fillStyle = 'rgba(230,220,210,0.4)'; ctx.fillRect(0, 0, w, 8); ctx.fillRect(0, h - 8, w, 8);
        });
    }

    function jupiterTexture() {
        return makeTexture(256, 128, (ctx, w, h) => {
            const g = ctx.createLinearGradient(0, 0, 0, h);
            g.addColorStop(0, '#c4956a'); g.addColorStop(0.25, '#b8845a');
            g.addColorStop(0.45, '#c4956a'); g.addColorStop(0.65, '#d4a87a');
            g.addColorStop(1, '#c4956a');
            ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 120; i++) {
                ctx.fillStyle = 'rgba(' + (160 + Math.random() * 60) + ',' + (100 + Math.random() * 60) + ',' + (60 + Math.random() * 40) + ',0.15)';
                ctx.fillRect(0, Math.random() * h, w, 1 + Math.random() * 3);
            }
            // Great Red Spot
            ctx.fillStyle = 'rgba(180,70,40,0.5)';
            ctx.beginPath(); ctx.ellipse(w * 0.6, h * 0.55, 14, 9, 0.1, 0, Math.PI * 2); ctx.fill();
        });
    }

    function saturnTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            const g = ctx.createLinearGradient(0, 0, 0, h);
            g.addColorStop(0, '#5a7a8e'); g.addColorStop(0.15, '#b5aa8a');
            g.addColorStop(0.35, '#ddd2b5'); g.addColorStop(0.5, '#d8c8a0');
            g.addColorStop(0.65, '#ddd0b0'); g.addColorStop(0.85, '#a0a5a0');
            g.addColorStop(1, '#5a7080');
            ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 200; i++) {
                const y = Math.random() * h;
                ctx.fillStyle = 'rgba(170,155,100,' + (0.06 + Math.random() * 0.1) + ')';
                ctx.fillRect(0, y, w, 0.5 + Math.random() * 2);
            }
        });
    }

    function uranusTexture() {
        return makeTexture(256, 128, (ctx, w, h) => {
            const g = ctx.createLinearGradient(0, 0, 0, h);
            g.addColorStop(0, '#6aacb8'); g.addColorStop(0.45, '#96dae4'); g.addColorStop(1, '#6aacb8');
            ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 80; i++) {
                ctx.fillStyle = 'rgba(' + (100 + Math.random() * 40) + ',' + (190 + Math.random() * 30) + ',' + (200 + Math.random() * 30) + ',' + (0.03 + Math.random() * 0.04) + ')';
                ctx.fillRect(0, Math.random() * h, w, 0.5 + Math.random() * 2);
            }
        });
    }

    function neptuneTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            const g = ctx.createLinearGradient(0, 0, 0, h);
            g.addColorStop(0, '#1a2a6a'); g.addColorStop(0.3, '#2a5cc8');
            g.addColorStop(0.5, '#4588e4'); g.addColorStop(0.7, '#2a5cc8');
            g.addColorStop(1, '#1a2a6a');
            ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 150; i++) {
                const y = Math.random() * h;
                ctx.fillStyle = 'rgba(20,' + (50 + Math.random() * 50) + ',' + (150 + Math.random() * 80) + ',' + (0.06 + Math.random() * 0.08) + ')';
                ctx.fillRect(0, y, w, 0.5 + Math.random() * 2.5);
            }
            // Great Dark Spot
            ctx.fillStyle = 'rgba(10,18,60,0.35)';
            ctx.beginPath(); ctx.ellipse(w * 0.35, h * 0.58, 22, 14, -0.15, 0, Math.PI * 2); ctx.fill();
        });
    }

    function moonTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            ctx.fillStyle = '#aba8a0'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 400; i++) {
                const g = 130 + Math.random() * 50;
                ctx.fillStyle = 'rgba(' + g + ',' + g + ',' + (g - 5) + ',' + (0.05 + Math.random() * 0.08) + ')';
                ctx.fillRect(Math.random() * w, Math.random() * h, 1 + Math.random() * 4, 1 + Math.random() * 4);
            }
            // Maria (dark patches)
            ctx.fillStyle = 'rgba(65,63,58,0.45)';
            ctx.beginPath(); ctx.ellipse(w * 0.18, h * 0.32, 32, 28, -0.2, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'rgba(62,60,55,0.4)';
            ctx.beginPath(); ctx.ellipse(w * 0.35, h * 0.40, 20, 18, 0.3, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'rgba(72,70,65,0.35)';
            ctx.beginPath(); ctx.ellipse(w * 0.08, h * 0.40, 22, 35, 0.1, 0, Math.PI * 2); ctx.fill();
            // Small craters
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = 'rgba(80,78,73,' + (0.1 + Math.random() * 0.15) + ')';
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 0.5 + Math.random() * 2, 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    function ioTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#d8c040'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 12; i++) {
                ctx.fillStyle = 'rgba(40,30,10,' + (0.3 + Math.random() * 0.3) + ')';
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 1.5 + Math.random() * 3, 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    function europaTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#d8d4c8'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 25; i++) {
                ctx.strokeStyle = 'rgba(' + (120 + Math.random() * 40) + ',' + (70 + Math.random() * 30) + ',' + (40 + Math.random() * 20) + ',' + (0.15 + Math.random() * 0.2) + ')';
                ctx.lineWidth = 0.3 + Math.random() * 0.8;
                ctx.beginPath(); ctx.moveTo(Math.random() * w, Math.random() * h); ctx.lineTo(Math.random() * w, Math.random() * h); ctx.stroke();
            }
        });
    }

    function ganymedeTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#908880'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 8; i++) {
                ctx.fillStyle = 'rgba(60,55,50,' + (0.15 + Math.random() * 0.15) + ')';
                ctx.beginPath(); ctx.ellipse(Math.random() * w, Math.random() * h, 6 + Math.random() * 12, 4 + Math.random() * 8, Math.random() * Math.PI, 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    function callistoTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#504840'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 40; i++) {
                const cx = Math.random() * w, cy = Math.random() * h, r = 0.5 + Math.random() * 3;
                ctx.strokeStyle = 'rgba(130,125,115,' + (0.15 + Math.random() * 0.15) + ')';
                ctx.lineWidth = 0.5;
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke();
            }
        });
    }

    function tritonTexture() {
        return makeTexture(256, 128, (ctx, w, h) => {
            const g = ctx.createLinearGradient(0, 0, 0, h);
            g.addColorStop(0, '#a8988a'); g.addColorStop(0.5, '#c0aa95'); g.addColorStop(1, '#e8ddd5');
            ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = 'rgba(130,115,100,' + (0.1 + Math.random() * 0.1) + ')';
                ctx.beginPath(); ctx.ellipse(Math.random() * w, Math.random() * h * 0.75, 2 + Math.random() * 4, (2 + Math.random() * 4) * 0.8, Math.random(), 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    function proteusTexture() {
        return makeTexture(64, 32, (ctx, w, h) => {
            ctx.fillStyle = '#484040'; ctx.fillRect(0, 0, w, h);
        });
    }

    /* ================================================================
       PLANET SYSTEM
       ================================================================ */
    const planets = [];
    const labelsContainer = document.getElementById('labels-container');
    const MOON_ORBIT_RADIUS_MULT = 11;

    function createPlanet(name, radius, dist, texFn, isSun) {
        isSun = isSun || false;
        const grp = new THREE.Group();
        grp.position.set(dist, 0, 0);
        const geo = new THREE.SphereGeometry(radius, 64, 64);
        const mat = isSun
            ? new THREE.MeshBasicMaterial({ map: texFn(), fog: false })
            : new THREE.MeshStandardMaterial({ map: texFn(), roughness: 0.9, metalness: 0.1 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.name = "PM_" + name;
        grp.add(mesh);

        let moonMesh = null, cloudMesh = null;

        if (name === "EARTH") {
            // Moon
            const mGeo = new THREE.SphereGeometry(radius * 0.27, 32, 32);
            moonMesh = new THREE.Mesh(mGeo, new THREE.MeshStandardMaterial({ map: moonTexture(), roughness: 0.95, fog: false }));
            moonMesh.position.set(radius * MOON_ORBIT_RADIUS_MULT, 0, 0);
            grp.add(moonMesh);
            // Clouds
            cloudMesh = new THREE.Mesh(
                new THREE.SphereGeometry(radius * 1.015, 64, 64),
                new THREE.MeshStandardMaterial({ map: earthCloudTexture(), transparent: true, opacity: 0.45, depthWrite: false, roughness: 1.0 })
            );
            grp.add(cloudMesh);
            // Atmosphere glow
            grp.add(new THREE.Mesh(new THREE.SphereGeometry(radius * 1.08, 64, 64),
                new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.12, side: THREE.BackSide })));
            grp.add(new THREE.Mesh(new THREE.SphereGeometry(radius * 1.04, 64, 64),
                new THREE.MeshBasicMaterial({ color: 0x88bbff, transparent: true, opacity: 0.08, side: THREE.BackSide })));
        }

        if (isSun) {
            [{ s: 1.15, c: 0xff8c00, o: 0.12 }, { s: 1.35, c: 0xff6600, o: 0.06 }, { s: 1.6, c: 0xff4400, o: 0.025 }].forEach(l => {
                grp.add(new THREE.Mesh(new THREE.SphereGeometry(radius * l.s, 32, 32),
                    new THREE.MeshBasicMaterial({ color: l.c, transparent: true, opacity: l.o, side: THREE.BackSide, fog: false })));
            });
        }

        systemGroup.add(grp);
        const label = document.createElement('div');
        label.className = 'planet-label';
        label.innerHTML = '<div class="label-name">' + name + '</div><div class="label-dist"></div>';
        labelsContainer.appendChild(label);

        planets.push({
            name, grp, mesh, radius, dist, label, moonMesh, cloudMesh,
            moons: [], angle: Math.random() * 10,
            orbitSpeed: dist === 0 ? 0 : (20000 / dist) * 0.0001
        });
    }

    createPlanet("SUN", config.sunRadius, 0, sunTexture, true);
    createPlanet("MERCURY", 400, 80000, mercuryTexture);
    createPlanet("VENUS", 900, 140000, venusTexture);
    createPlanet("EARTH", 1000, 200000, earthTexture);
    createPlanet("MARS", 500, 300000, marsTexture);
    createPlanet("JUPITER", 5000, 600000, jupiterTexture);
    createPlanet("SATURN", 4500, 1000000, saturnTexture);
    createPlanet("URANUS", 2000, 1800000, uranusTexture);
    createPlanet("NEPTUNE", 1900, 2600000, neptuneTexture);

    /* Saturn rings + tilt */
    const saturnP = planets.find(p => p.name === "SATURN");
    if (saturnP) {
        const R = saturnP.radius;
        function addSaturnRing(inner, outer, color, opacity) {
            const g = new THREE.RingGeometry(R * inner, R * outer, 128);
            const m = new THREE.Mesh(g, new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide, transparent: true, opacity: opacity, depthWrite: false }));
            m.rotation.x = Math.PI / 2;
            saturnP.grp.add(m);
        }
        addSaturnRing(1.11, 1.24, 0x8a8580, 0.06);
        addSaturnRing(1.24, 1.44, 0xa09a8e, 0.18);
        addSaturnRing(1.44, 1.92, 0xd5ccb5, 0.65);
        addSaturnRing(1.92, 2.02, 0x1a1816, 0.04);
        addSaturnRing(2.02, 2.32, 0xbcb498, 0.42);
        addSaturnRing(2.36, 2.39, 0xc8c0a8, 0.28);
        saturnP.grp.add(new THREE.Mesh(new THREE.SphereGeometry(R * 1.06, 48, 48),
            new THREE.MeshBasicMaterial({ color: 0xd4c8a0, transparent: true, opacity: 0.06, side: THREE.BackSide })));
        saturnP.grp.rotation.z = 0.466;
    }

    /* Jupiter moons */
    const jupiterP = planets.find(p => p.name === "JUPITER");
    if (jupiterP) {
        const jR = jupiterP.radius;
        [
            { r: jR * 0.073, t: ioTexture, oR: jR * 1.68, s: 0.00012, n: 'IO' },
            { r: jR * 0.062, t: europaTexture, oR: jR * 2.68, s: 0.00006, n: 'EUROPA' },
            { r: jR * 0.105, t: ganymedeTexture, oR: jR * 4.28, s: 0.00003, n: 'GANYMEDE' },
            { r: jR * 0.096, t: callistoTexture, oR: jR * 7.52, s: 0.000013, n: 'CALLISTO' }
        ].forEach(m => {
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(m.r, 24, 24),
                new THREE.MeshStandardMaterial({ map: m.t(), roughness: 0.9 }));
            jupiterP.grp.add(mesh);
            jupiterP.moons.push({ mesh, orbitR: m.oR, speed: m.s, name: m.n });
        });
        // Faint ring
        jupiterP.grp.add(new THREE.Mesh(new THREE.RingGeometry(jR * 1.29, jR * 1.36, 64),
            new THREE.MeshBasicMaterial({ color: 0x8a7a60, side: THREE.DoubleSide, transparent: true, opacity: 0.04, depthWrite: false })));
        jupiterP.grp.rotation.z = 0.054;
    }

    /* Uranus */
    const uranusP = planets.find(p => p.name === "URANUS");
    if (uranusP) {
        const uR = uranusP.radius;
        uranusP.grp.add(new THREE.Mesh(new THREE.SphereGeometry(uR * 1.07, 48, 48),
            new THREE.MeshBasicMaterial({ color: 0x80d0d8, transparent: true, opacity: 0.08, side: THREE.BackSide })));
        [1.64, 1.75, 1.85].forEach((mult, i) => {
            const m = new THREE.Mesh(new THREE.RingGeometry(uR * mult, uR * (mult + 0.02), 64),
                new THREE.MeshBasicMaterial({ color: [0x8a9aa0, 0x909898, 0x8a9098][i], side: THREE.DoubleSide, transparent: true, opacity: 0.04, depthWrite: false }));
            m.rotation.x = Math.PI / 2;
            uranusP.grp.add(m);
        });
        uranusP.grp.rotation.z = 1.706;
    }

    /* Neptune moons */
    const neptuneP = planets.find(p => p.name === "NEPTUNE");
    if (neptuneP) {
        const nR = neptuneP.radius;
        const triMesh = new THREE.Mesh(new THREE.SphereGeometry(nR * 0.14, 24, 24),
            new THREE.MeshStandardMaterial({ map: tritonTexture(), roughness: 0.9 }));
        neptuneP.grp.add(triMesh);
        neptuneP.moons.push({ mesh: triMesh, orbitR: nR * 5.6, speed: -0.00008, name: 'TRITON' });
        const proMesh = new THREE.Mesh(new THREE.SphereGeometry(nR * 0.044, 16, 16),
            new THREE.MeshStandardMaterial({ map: proteusTexture(), roughness: 0.95 }));
        neptuneP.grp.add(proMesh);
        neptuneP.moons.push({ mesh: proMesh, orbitR: nR * 2.1, speed: 0.00018, name: 'PROTEUS' });
        // Atmosphere
        neptuneP.grp.add(new THREE.Mesh(new THREE.SphereGeometry(nR * 1.08, 48, 48),
            new THREE.MeshBasicMaterial({ color: 0x3070e0, transparent: true, opacity: 0.10, side: THREE.BackSide })));
        neptuneP.grp.add(new THREE.Mesh(new THREE.SphereGeometry(nR * 1.04, 48, 48),
            new THREE.MeshBasicMaterial({ color: 0x5090ff, transparent: true, opacity: 0.06, side: THREE.BackSide })));
        // Rings
        const nRM = new THREE.MeshBasicMaterial({ color: 0x607090, side: THREE.DoubleSide, transparent: true, opacity: 0.03, depthWrite: false });
        const nr1 = new THREE.Mesh(new THREE.RingGeometry(nR * 1.69, nR * 1.72, 64), nRM);
        nr1.rotation.x = Math.PI / 2; neptuneP.grp.add(nr1);
        const nr2 = new THREE.Mesh(new THREE.RingGeometry(nR * 2.08, nR * 2.11, 64), nRM.clone());
        nr2.rotation.x = Math.PI / 2; neptuneP.grp.add(nr2);
        neptuneP.grp.rotation.z = 0.494;
    }

    /* ================================================================
       GROUND / LAUNCH SCENE
       ================================================================ */
    let gamePhase = 'ground';
    let launchTimer = 0;
    const LAUNCH_DURATION = 5000;
    const GROUND_TILT = 1.45;
    systemGroup.rotation.x = GROUND_TILT;

    const earthSpawn = planets.find(p => p.name === "EARTH");
    const spawnTime = Date.now();
    if (earthSpawn && earthSpawn.dist > 0) {
        earthSpawn.grp.position.x = Math.cos(earthSpawn.angle + spawnTime * earthSpawn.orbitSpeed) * earthSpawn.dist;
        earthSpawn.grp.position.z = Math.sin(earthSpawn.angle + spawnTime * earthSpawn.orbitSpeed) * earthSpawn.dist;
    }
    if (earthSpawn) {
        earthSpawn.mesh.visible = false;
        if (earthSpawn.cloudMesh) earthSpawn.cloudMesh.visible = false;
        earthSpawn.grp.children.forEach(child => {
            if (child !== earthSpawn.mesh && child !== earthSpawn.moonMesh && child !== earthSpawn.cloudMesh
                && child.material && child.material.side === THREE.BackSide) {
                child.userData.isAtmosphere = true;
                child.visible = false;
            }
        });
    }

    systemGroup.updateMatrixWorld(true);
    const earthInitWorld = new THREE.Vector3();
    earthSpawn.grp.getWorldPosition(earthInitWorld);
    const GROUND_Y_OFFSET = -40000;

    const groundGroup = new THREE.Group();
    groundGroup.position.set(earthInitWorld.x, earthInitWorld.y + GROUND_Y_OFFSET, earthInitWorld.z);
    scene.add(groundGroup);

    // Grass texture
    const grassCanvas = document.createElement('canvas');
    grassCanvas.width = 256; grassCanvas.height = 256;
    const grassCtx = grassCanvas.getContext('2d');
    const grassGrad = grassCtx.createRadialGradient(128, 128, 20, 128, 128, 180);
    grassGrad.addColorStop(0, '#2e5a24'); grassGrad.addColorStop(0.5, '#264d1e'); grassGrad.addColorStop(1, '#1f4218');
    grassCtx.fillStyle = grassGrad; grassCtx.fillRect(0, 0, 256, 256);
    for (let i = 0; i < 2000; i++) {
        grassCtx.fillStyle = 'rgba(' + (20 + Math.random() * 30) + ',' + (60 + Math.random() * 40) + ',' + (15 + Math.random() * 20) + ',' + (0.15 + Math.random() * 0.15) + ')';
        grassCtx.fillRect(Math.random() * 256, Math.random() * 256, 1, 1 + Math.random() * 2);
    }
    const grassTex = new THREE.CanvasTexture(grassCanvas);
    grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
    grassTex.repeat.set(40, 40);
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000),
        new THREE.MeshStandardMaterial({ map: grassTex, roughness: 0.95 }));
    ground.rotation.x = -Math.PI / 2;
    groundGroup.add(ground);

    // Trees
    function makeTreeTexture(variant) {
        const c = document.createElement('canvas'); c.width = 64; c.height = 96;
        const ctx = c.getContext('2d'); ctx.clearRect(0, 0, 64, 96);
        const tw = 4 + variant * 2;
        ctx.fillStyle = '#5a3a1a'; ctx.fillRect(32 - tw / 2, 55, tw, 41);
        if (variant < 2) {
            for (let i = 0; i < 5; i++) {
                ctx.fillStyle = ['#2a6e2a', '#267326', '#308030', '#1e5e1e'][Math.floor(Math.random() * 4)];
                ctx.beginPath(); ctx.arc(28 + (Math.random() - 0.5) * 20, 30 + (Math.random() - 0.5) * 22, 12 + Math.random() * 8, 0, Math.PI * 2); ctx.fill();
            }
        } else {
            for (let i = 0; i < 4; i++) {
                const y = 12 + i * 13, hw = 20 - i * 3;
                ctx.fillStyle = i % 2 === 0 ? '#1a5a1a' : '#1e661e';
                ctx.beginPath(); ctx.moveTo(32, y - 8); ctx.lineTo(32 + hw, y + 12); ctx.lineTo(32 - hw, y + 12); ctx.closePath(); ctx.fill();
            }
        }
        return new THREE.CanvasTexture(c);
    }
    const treeTextures = [makeTreeTexture(0), makeTreeTexture(1), makeTreeTexture(2), makeTreeTexture(3)];
    for (let i = 0; i < 120; i++) {
        const angle = (i / 120) * Math.PI * 2 + (Math.random() - 0.5) * 0.08;
        const dist = 700 + Math.random() * 250;
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
            map: treeTextures[Math.floor(Math.random() * treeTextures.length)], transparent: true, fog: true, depthWrite: false
        }));
        const s = 40 + Math.random() * 30;
        sprite.position.set(Math.cos(angle) * dist, s * 0.5, Math.sin(angle) * dist);
        sprite.scale.set(s * 0.67, s, 1);
        groundGroup.add(sprite);
    }

    // Launchpad
    const padMesh = new THREE.Mesh(new THREE.CylinderGeometry(25, 25, 1, 32),
        new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 }));
    padMesh.position.set(0, 0.5, -80);
    groundGroup.add(padMesh);

    const markMat = new THREE.MeshBasicMaterial({ color: 0xcccc00, side: THREE.DoubleSide });
    const markRing = new THREE.Mesh(new THREE.RingGeometry(18, 20, 32), markMat);
    markRing.rotation.x = -Math.PI / 2; markRing.position.set(0, 1.1, -80);
    groundGroup.add(markRing);
    const cross1 = new THREE.Mesh(new THREE.PlaneGeometry(30, 1.5), markMat);
    cross1.rotation.x = -Math.PI / 2; cross1.position.set(0, 1.1, -80);
    groundGroup.add(cross1);
    const cross2 = new THREE.Mesh(new THREE.PlaneGeometry(30, 1.5), markMat);
    cross2.rotation.x = -Math.PI / 2; cross2.rotation.z = Math.PI / 2; cross2.position.set(0, 1.1, -80);
    groundGroup.add(cross2);

    // Rocket
    const rocketGroup = new THREE.Group();
    rocketGroup.position.set(0, 0, -80);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xe8e8e8, roughness: 0.3, metalness: 0.2 });
    const rocketBody = new THREE.Mesh(new THREE.CylinderGeometry(3, 3.5, 30, 16), bodyMat);
    rocketBody.position.set(0, 16, 0); rocketGroup.add(rocketBody);
    const rocketNose = new THREE.Mesh(new THREE.ConeGeometry(3, 8, 16),
        new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.4, metalness: 0.3 }));
    rocketNose.position.set(0, 35, 0); rocketGroup.add(rocketNose);
    const rocketWindow = new THREE.Mesh(new THREE.CircleGeometry(1.2, 16),
        new THREE.MeshBasicMaterial({ color: 0x4488cc }));
    rocketWindow.position.set(0, 26, 3.1); rocketGroup.add(rocketWindow);
    const rocketEngine = new THREE.Mesh(new THREE.CylinderGeometry(2, 3.5, 4, 16),
        new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.6, metalness: 0.5 }));
    rocketEngine.position.set(0, -1, 0); rocketGroup.add(rocketEngine);

    // Fins
    const finShape = new THREE.Shape();
    finShape.moveTo(0, 0); finShape.lineTo(6, 0); finShape.lineTo(0, 10); finShape.closePath();
    const finMat = new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.5, side: THREE.DoubleSide });
    for (let i = 0; i < 4; i++) {
        const fin = new THREE.Mesh(new THREE.ShapeGeometry(finShape), finMat);
        const a = (i / 4) * Math.PI * 2;
        fin.position.set(Math.sin(a) * 3.5, 1, Math.cos(a) * 3.5);
        fin.rotation.y = -a; fin.rotation.x = -0.1;
        rocketGroup.add(fin);
    }

    // Launch tower
    const towerMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.7 });
    const tower = new THREE.Mesh(new THREE.BoxGeometry(1, 35, 1), towerMat);
    tower.position.set(8, 17.5, -80); groundGroup.add(tower);
    for (let i = 0; i < 4; i++) {
        const arm = new THREE.Mesh(new THREE.BoxGeometry(7, 0.5, 0.5), towerMat);
        arm.position.set(4.5, 5 + i * 9, -80); groundGroup.add(arm);
    }
    groundGroup.add(rocketGroup);

    // Ground lighting
    const groundSun = new THREE.DirectionalLight(0xfffbe6, 1.5);
    groundSun.position.set(50, 100, -30);
    groundGroup.add(groundSun);
    groundGroup.add(new THREE.HemisphereLight(0x87ceeb, 0x264d1e, 0.6));

    // Camera initial position
    camera.position.set(earthInitWorld.x, earthInitWorld.y + GROUND_Y_OFFSET + 5, earthInitWorld.z + 40);
    let camYaw = Math.PI, camPitch = 0;
    const WALK_SPEED = 0.4, ROCKET_INTERACT_DIST = 35;
    let nearRocket = false;
    let groundLocalPos = new THREE.Vector3(0, 5, 40);

    /* Speed lines for launch */
    const speedLineGroup = new THREE.Group();
    speedLineGroup.visible = false;
    scene.add(speedLineGroup);
    const SPEED_LINE_HEIGHT = 200, speedLineData = [];
    for (let i = 0; i < 80; i++) {
        const x = (Math.random() - 0.5) * 120, z = (Math.random() - 0.5) * 120;
        if (Math.abs(x) < 8 && Math.abs(z) < 8) continue;
        const y = Math.random() * SPEED_LINE_HEIGHT - SPEED_LINE_HEIGHT / 2;
        const len = 8 + Math.random() * 25;
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([x, y, z, x, y - len, z]), 3));
        const b = 0.7 + Math.random() * 0.3;
        const line = new THREE.Line(geo, new THREE.LineBasicMaterial({
            color: new THREE.Color(b, b, b * 1.1), transparent: true, opacity: 0.3 + Math.random() * 0.5, fog: false
        }));
        speedLineGroup.add(line);
        speedLineData.push({ line, len });
    }

    const skyBlue = new THREE.Color(0x4a90d9), skyHorizon = new THREE.Color(0x87ceeb), spaceBlack = new THREE.Color(0x000008);
    const atmosphereHeight = 3000, skyFullHeight = 300;

    const actionBtn = document.getElementById('action-btn');
    const lockText = document.getElementById('system-status');
    const proxText = document.getElementById('proximity-alert');
    let landedPlanet = null, nearestPlanet = null;
    const input = { x: 0, y: 0, up: false, down: false };
    const earthWorldPos = new THREE.Vector3();
    let currentSpeed = 0;

    /* ================================================================
       ACTION BUTTON
       ================================================================ */
    actionBtn.addEventListener('click', () => {
        if (gamePhase === 'ground' && nearRocket) {
            gamePhase = 'launching'; launchTimer = Date.now();
            actionBtn.style.display = 'none';
            lockText.innerText = "LAUNCH SEQUENCE"; lockText.style.color = "#ff4400";
            proxText.innerText = "3... 2... 1... LIFTOFF!";
        } else if (landedPlanet) {
            camera.position.addScaledVector(new THREE.Vector3(0, 1, 0), landedPlanet.radius * 0.5);
            landedPlanet = null;
        } else if (nearestPlanet) {
            const dir = new THREE.Vector3();
            nearestPlanet.mesh.getWorldPosition(dir);
            dir.sub(camera.position).normalize();
            const wp = new THREE.Vector3();
            nearestPlanet.mesh.getWorldPosition(wp);
            camera.position.copy(wp).addScaledVector(dir.negate(), nearestPlanet.radius + 100);
            landedPlanet = nearestPlanet;
        }
    });

    /* ================================================================
       CONTROLS
       ================================================================ */
    const stickArea = document.getElementById('stick-area');
    const stick = document.getElementById('stick-thumb');

    stickArea.addEventListener('touchstart', e => e.preventDefault());
    stickArea.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0], r = stickArea.getBoundingClientRect();
        const dx = t.clientX - (r.left + r.width / 2);
        const dy = t.clientY - (r.top + r.height / 2);
        const dist = Math.min(Math.sqrt(dx * dx + dy * dy), 60);
        const ang = Math.atan2(dy, dx);
        stick.style.transform = 'translate(calc(-50% + ' + Math.cos(ang) * dist + 'px), calc(-50% + ' + Math.sin(ang) * dist + 'px))';
        input.x = (Math.cos(ang) * dist) / 60;
        input.y = (Math.sin(ang) * dist) / 60;
    });
    stickArea.addEventListener('touchend', () => {
        stick.style.transform = 'translate(-50%, -50%)';
        input.x = 0; input.y = 0;
    });

    let lastLook = { x: 0, y: 0 };
    document.addEventListener('touchstart', e => {
        if (e.target.id === 'gameCanvas') lastLook = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    });
    document.addEventListener('touchmove', e => {
        if (e.target.id === 'gameCanvas') {
            e.preventDefault();
            camYaw -= (e.touches[0].clientX - lastLook.x) * 0.003;
            camPitch -= (e.touches[0].clientY - lastLook.y) * 0.003;
            camPitch = Math.max(-1.5, Math.min(1.5, camPitch));
            lastLook = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
    });

    document.addEventListener('keydown', e => {
        if (e.key === 'w' || e.key === 'ArrowUp') input.y = -1;
        if (e.key === 's' || e.key === 'ArrowDown') input.y = 1;
        if (e.key === 'a' || e.key === 'ArrowLeft') input.x = -1;
        if (e.key === 'd' || e.key === 'ArrowRight') input.x = 1;
        if (e.key === 'q') input.up = true;
        if (e.key === 'e') input.down = true;
        if (e.key === 'h') hudToggle.click();
    });
    document.addEventListener('keyup', e => {
        if (e.key === 'w' || e.key === 'ArrowUp' || e.key === 's' || e.key === 'ArrowDown') input.y = 0;
        if (e.key === 'a' || e.key === 'ArrowLeft' || e.key === 'd' || e.key === 'ArrowRight') input.x = 0;
        if (e.key === 'q') input.up = false;
        if (e.key === 'e') input.down = false;
    });

    canvas.addEventListener('mousemove', e => {
        if (e.buttons === 1) {
            camYaw -= e.movementX * 0.003;
            camPitch -= e.movementY * 0.003;
            camPitch = Math.max(-1.5, Math.min(1.5, camPitch));
        }
    });

    const btnUp = document.getElementById('btn-up'), btnDown = document.getElementById('btn-down');
    btnUp.addEventListener('touchstart', e => { e.preventDefault(); input.up = true; });
    btnUp.addEventListener('touchend', e => { e.preventDefault(); input.up = false; });
    btnDown.addEventListener('touchstart', e => { e.preventDefault(); input.down = true; });
    btnDown.addEventListener('touchend', e => { e.preventDefault(); input.down = false; });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    /* ================================================================
       GAME LOOP
       ================================================================ */
    const tempVec = new THREE.Vector3(), screenVec = new THREE.Vector3();

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now();

        // Show/hide HUD toggle
        hudToggle.style.display = (gamePhase === 'space' || gamePhase === 'launching') ? 'flex' : 'none';
        if (gamePhase === 'ground') {
            hudEl.classList.remove('active'); hudEnabled = false;
            hudToggle.classList.remove('hud-on'); hudToggle.textContent = '⬡';
        }

        /* ======== GROUND PHASE ======== */
        if (gamePhase === 'ground') {
            systemGroup.rotation.x = GROUND_TILT;
            planets.forEach(p => p.label.style.opacity = '0');

            const walkFwd = new THREE.Vector3(-Math.sin(camYaw), 0, -Math.cos(camYaw));
            const walkRight = new THREE.Vector3(Math.cos(camYaw), 0, -Math.sin(camYaw));
            if (Math.abs(input.y) > 0.05) groundLocalPos.addScaledVector(walkFwd, -input.y * WALK_SPEED);
            if (Math.abs(input.x) > 0.05) groundLocalPos.addScaledVector(walkRight, input.x * WALK_SPEED);
            groundLocalPos.y = 5;
            groundLocalPos.x = Math.max(-850, Math.min(850, groundLocalPos.x));
            groundLocalPos.z = Math.max(-850, Math.min(850, groundLocalPos.z));

            // Orbit planets
            planets.forEach(p => {
                if (p.dist > 0) {
                    p.grp.position.x = Math.cos(p.angle + time * p.orbitSpeed) * p.dist;
                    p.grp.position.z = Math.sin(p.angle + time * p.orbitSpeed) * p.dist;
                }
                p.mesh.rotation.y += 0.001;
                if (p.cloudMesh) p.cloudMesh.rotation.y += 0.0013;
                if (p.moonMesh) {
                    const md = p.radius * MOON_ORBIT_RADIUS_MULT, ms = -time * 0.00005;
                    p.moonMesh.position.x = Math.cos(ms) * md;
                    p.moonMesh.position.z = Math.sin(ms) * md;
                    p.moonMesh.rotation.y = -ms + Math.PI;
                }
            });

            earthSpawn.grp.getWorldPosition(earthWorldPos);
            groundGroup.position.set(earthWorldPos.x, earthWorldPos.y + GROUND_Y_OFFSET, earthWorldPos.z);
            camera.position.set(earthWorldPos.x + groundLocalPos.x, earthWorldPos.y + GROUND_Y_OFFSET + groundLocalPos.y, earthWorldPos.z + groundLocalPos.z);
            camera.rotation.order = "YXZ"; camera.rotation.y = camYaw; camera.rotation.x = camPitch;

            const dtr = Math.sqrt(groundLocalPos.x * groundLocalPos.x + (groundLocalPos.z + 80) * (groundLocalPos.z + 80));
            nearRocket = dtr < ROCKET_INTERACT_DIST;
            if (nearRocket) {
                actionBtn.style.display = 'flex'; actionBtn.innerText = "LAUNCH";
                lockText.innerText = "ROCKET READY"; lockText.style.color = "#00ffcc";
                proxText.innerText = "BOARD & LAUNCH";
            } else {
                actionBtn.style.display = 'none';
                lockText.innerText = "EXPLORE"; lockText.style.color = "#00aa88";
                proxText.innerText = "WALK TO THE ROCKET";
            }

            // Eclipse check
            let groundEclipse = 0;
            const sunP = planets.find(p => p.name === "SUN");
            if (sunP && earthSpawn.moonMesh) {
                const sw = new THREE.Vector3(); sunP.mesh.getWorldPosition(sw);
                const mw = new THREE.Vector3(); earthSpawn.moonMesh.getWorldPosition(mw);
                const toSun = sw.clone().sub(camera.position).normalize();
                const toMoon = mw.clone().sub(camera.position).normalize();
                const alignment = toSun.dot(toMoon);
                const moonDist = camera.position.distanceTo(mw);
                const sunDist = camera.position.distanceTo(sw);
                const moonAngSize = (earthSpawn.moonMesh.geometry.parameters.radius || 270) / moonDist;
                const sunAngSize = sunP.radius / sunDist;
                const totalAng = moonAngSize + sunAngSize;
                const overlapThresh = 1 - (totalAng * totalAng) / 2;
                if (alignment > overlapThresh && moonDist < sunDist) {
                    const totalityThresh = 1 - ((moonAngSize - sunAngSize) * (moonAngSize - sunAngSize)) / 2;
                    const coverage = (alignment - overlapThresh) / (totalityThresh - overlapThresh);
                    groundEclipse = Math.min(1, Math.max(0, coverage));
                    groundEclipse = groundEclipse * groundEclipse;
                }
            }
            if (groundEclipse > 0.01) {
                const eclipseSpace = new THREE.Color(0x0a0a18);
                const newSky = new THREE.Color().copy(skyBlue); newSky.lerp(eclipseSpace, groundEclipse);
                scene.background = newSky;
                const eclipseFog = new THREE.Color(0x080810);
                const newFog = new THREE.Color().copy(skyHorizon); newFog.lerp(eclipseFog, groundEclipse);
                const fogMult = 1 + groundEclipse * 8;
                scene.fog = new THREE.Fog(newFog, 400 * fogMult, 1200 * fogMult);
            } else {
                scene.background = skyBlue;
                scene.fog = new THREE.Fog(skyHorizon, 400, 1200);
            }

            renderer.render(scene, camera);
            return;
        }

        /* ======== LAUNCH PHASE ======== */
        if (gamePhase === 'launching') {
            planets.forEach(p => p.label.style.opacity = '0');
            const elapsed = time - launchTimer;
            const t = Math.min(1, elapsed / LAUNCH_DURATION);
            systemGroup.rotation.x = GROUND_TILT * (1 - t * t);

            planets.forEach(p => {
                if (p.dist > 0) {
                    p.grp.position.x = Math.cos(p.angle + time * p.orbitSpeed) * p.dist;
                    p.grp.position.z = Math.sin(p.angle + time * p.orbitSpeed) * p.dist;
                }
                p.mesh.rotation.y += 0.001;
                if (p.cloudMesh) p.cloudMesh.rotation.y += 0.0013;
            });

            earthSpawn.grp.getWorldPosition(earthWorldPos);
            const launchAccel = t * t * t;
            const launchStartY = earthWorldPos.y + GROUND_Y_OFFSET + 5;
            const launchEndY = earthWorldPos.y + earthSpawn.radius + 5000;
            camera.position.set(earthWorldPos.x, launchStartY + launchAccel * (launchEndY - launchStartY), earthWorldPos.z);
            camPitch = Math.PI / 2;
            camera.rotation.order = "YXZ"; camera.rotation.y = camYaw; camera.rotation.x = camPitch;

            // Speed lines
            speedLineGroup.visible = true;
            speedLineGroup.position.copy(camera.position);
            const scrollSpeed = (0.5 + launchAccel * 20) * 2;
            speedLineData.forEach(sd => {
                const pos = sd.line.geometry.attributes.position.array;
                pos[1] -= scrollSpeed; pos[4] -= scrollSpeed;
                if (pos[1] < -SPEED_LINE_HEIGHT) { pos[1] += SPEED_LINE_HEIGHT * 2; pos[4] = pos[1] - sd.len; }
                sd.line.geometry.attributes.position.needsUpdate = true;
                sd.line.material.opacity = Math.min(0.8, t * 2) * (0.3 + launchAccel * 0.7);
            });

            // Sky transition
            const skyColor = new THREE.Color();
            skyColor.copy(skyBlue).lerp(spaceBlack, t * t);
            scene.background = skyColor;
            if (t < 0.8) {
                const fogColor = new THREE.Color();
                fogColor.copy(skyHorizon).lerp(spaceBlack, t);
                scene.fog = new THREE.Fog(fogColor, 400 + t * 10000, 1200 + t * 50000);
            } else {
                scene.fog = null;
            }

            // Status text
            if (t < 0.3) proxText.innerText = "3... 2... 1... LIFTOFF!";
            else if (t < 0.5) { proxText.innerText = "MAX THRUST"; lockText.innerText = "ASCENDING"; lockText.style.color = "#ff8800"; }
            else if (t < 0.8) { proxText.innerText = "LEAVING ATMOSPHERE"; lockText.innerText = "ALTITUDE WARNING"; lockText.style.color = "#ffcc00"; }
            else { proxText.innerText = "ORBIT ACHIEVED"; lockText.innerText = "SYSTEM ONLINE"; lockText.style.color = "#00ffcc"; }

            // HUD data during launch
            hudData.speed = launchAccel * config.deepSpaceSpeed;
            hudData.altitude = launchAccel * (earthSpawn.radius + 5000);
            hudData.heading = camYaw * 180 / Math.PI;
            hudData.targetName = 'ORBIT'; hudData.targetDist = 0;
            hudData.nearPlanet = false; hudData.planets = [];
            updateHUD();

            // Transition to space
            if (t >= 1) {
                gamePhase = 'space';
                systemGroup.rotation.x = 0;
                speedLineGroup.visible = false;
                scene.remove(speedLineGroup);
                speedLineGroup.traverse(c => { if (c.material) c.material.dispose(); if (c.geometry) c.geometry.dispose(); });

                if (earthSpawn) {
                    earthSpawn.mesh.visible = true;
                    if (earthSpawn.cloudMesh) earthSpawn.cloudMesh.visible = true;
                    earthSpawn.grp.children.forEach(c => { if (c.userData && c.userData.isAtmosphere) c.visible = true; });
                }
                scene.remove(groundGroup);
                groundGroup.traverse(c => {
                    if (c.material) { if (c.material.map) c.material.map.dispose(); c.material.dispose(); }
                    if (c.geometry) c.geometry.dispose();
                });

                const ep = earthSpawn.grp.position;
                camera.position.set(ep.x, ep.y + earthSpawn.radius + 5000, ep.z);
                camPitch = -0.3; landedPlanet = null;
                scene.fog = null; scene.background = spaceBlack;
            }

            renderer.render(scene, camera);
            return;
        }

        /* ======== SPACE PHASE ======== */
        systemGroup.rotation.x = 0;
        let closestDist = Infinity, closestP = null, isLocked = false;

        planets.forEach(p => {
            const prev = p.grp.position.clone();
            if (p.dist > 0) {
                p.grp.position.x = Math.cos(p.angle + time * p.orbitSpeed) * p.dist;
                p.grp.position.z = Math.sin(p.angle + time * p.orbitSpeed) * p.dist;
            }
            p.mesh.rotation.y += 0.001;
            if (p.cloudMesh) p.cloudMesh.rotation.y += 0.0013;
            if (p.moonMesh) {
                const md = p.radius * MOON_ORBIT_RADIUS_MULT, ms = -time * 0.00005;
                p.moonMesh.position.x = Math.cos(ms) * md;
                p.moonMesh.position.z = Math.sin(ms) * md;
                p.moonMesh.rotation.y = -ms + Math.PI;
            }
            if (p.moons && p.moons.length > 0) {
                p.moons.forEach(moon => {
                    const ma = time * moon.speed;
                    moon.mesh.position.x = Math.cos(ma) * moon.orbitR;
                    moon.mesh.position.z = Math.sin(ma) * moon.orbitR;
                    moon.mesh.rotation.y = -ma + Math.PI;
                });
            }

            p.mesh.getWorldPosition(tempVec);
            const dc = camera.position.distanceTo(tempVec);
            const ds = dc - p.radius;
            if (ds < closestDist) { closestDist = ds; closestP = p; }

            const delta = p.grp.position.clone().sub(prev);
            if (!isNaN(delta.x) && (landedPlanet === p || (!landedPlanet && ds < config.lockDist))) {
                camera.position.add(delta); isLocked = true;
            }

            // Labels
            if (ds < 80000) {
                p.label.style.opacity = '0';
            } else {
                tempVec.project(camera);
                if (tempVec.z < 1 && Math.abs(tempVec.x) < 1 && Math.abs(tempVec.y) < 1) {
                    screenVec.set(tempVec.x, tempVec.y, 0.5);
                    raycaster.setFromCamera(screenVec, camera);
                    const its = raycaster.intersectObjects(systemGroup.children, true);
                    if (its.length > 0 && its[0].object.name === "PM_" + p.name) {
                        p.label.style.left = (tempVec.x * 0.5 + 0.5) * canvas.clientWidth + 'px';
                        p.label.style.top = (tempVec.y * -0.5 + 0.5) * canvas.clientHeight + 'px';
                        p.label.style.opacity = '1';
                        p.label.querySelector('.label-dist').innerText = Math.floor(ds).toLocaleString() + ' u';
                    } else { p.label.style.opacity = '0'; }
                } else { p.label.style.opacity = '0'; }
            }
        });

        nearestPlanet = (closestDist < 1200 && !landedPlanet) ? closestP : null;

        if (landedPlanet) {
            actionBtn.style.display = 'flex'; actionBtn.innerText = "TAKEOFF";
            lockText.innerText = "SURFACE LOCK"; lockText.style.color = "#00ffcc";
            proxText.innerText = 'LOCATION: ' + landedPlanet.name;
        } else if (nearestPlanet) {
            actionBtn.style.display = 'flex'; actionBtn.innerText = "LAND";
            lockText.innerText = "ORBITAL INSERTION"; lockText.style.color = "#ffff00";
            proxText.innerText = 'READY TO LAND ON ' + nearestPlanet.name;
        } else {
            actionBtn.style.display = 'none';
            if (isLocked) {
                lockText.innerText = "GRAVITY WELL"; lockText.style.color = "#00ffcc";
                proxText.innerText = 'APPROACHING ' + closestP.name;
            } else {
                lockText.innerText = "SYSTEM ONLINE"; lockText.style.color = "#00aa88";
                proxText.innerText = "DEEP SPACE CRUISE";
            }
        }

        // Speed
        let targetSpeed = 0;
        if (landedPlanet) targetSpeed = config.minSpeed;
        else {
            targetSpeed = closestDist * 0.005;
            if (targetSpeed > config.deepSpaceSpeed) targetSpeed = config.deepSpaceSpeed;
            if (targetSpeed < config.minSpeed) targetSpeed = config.minSpeed;
        }
        if (isNaN(targetSpeed)) targetSpeed = config.minSpeed;
        currentSpeed = targetSpeed;

        // Movement
        const fwd = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
        const right = new THREE.Vector3(1, 0, 0).applyEuler(camera.rotation);
        const up = new THREE.Vector3(0, 1, 0);
        if (Math.abs(input.y) > 0.05) camera.position.addScaledVector(fwd, -input.y * targetSpeed);
        if (Math.abs(input.x) > 0.05) camera.position.addScaledVector(right, input.x * targetSpeed);
        if (input.up) camera.position.addScaledVector(up, targetSpeed);
        if (input.down) camera.position.addScaledVector(up, -targetSpeed);
        camera.rotation.order = "YXZ"; camera.rotation.y = camYaw; camera.rotation.x = camPitch;

        // Earth atmosphere effect
        const earthP = planets.find(p => p.name === "EARTH");
        if (earthP) {
            const ew = new THREE.Vector3(); earthP.mesh.getWorldPosition(ew);
            const ed = camera.position.distanceTo(ew) - earthP.radius;

            // Eclipse in space
            let eclipse = 0;
            const sunPlanet = planets.find(p => p.name === "SUN");
            if (sunPlanet && earthP.moonMesh && ed < atmosphereHeight) {
                const sw = new THREE.Vector3(); sunPlanet.mesh.getWorldPosition(sw);
                const mw = new THREE.Vector3(); earthP.moonMesh.getWorldPosition(mw);
                const toSun = sw.clone().sub(camera.position).normalize();
                const toMoon = mw.clone().sub(camera.position).normalize();
                const alignment = toSun.dot(toMoon);
                const moonDist = camera.position.distanceTo(mw);
                const sunDist = camera.position.distanceTo(sw);
                const moonAng = (earthP.moonMesh.geometry.parameters.radius || 270) / moonDist;
                const sunAng = sunPlanet.radius / sunDist;
                const totalAng = moonAng + sunAng;
                const overlapThresh = 1 - (totalAng * totalAng) / 2;
                if (alignment > overlapThresh && moonDist < sunDist) {
                    const totalityThresh = 1 - ((moonAng - sunAng) * (moonAng - sunAng)) / 2;
                    const coverage = (alignment - overlapThresh) / (totalityThresh - overlapThresh);
                    eclipse = Math.min(1, Math.max(0, coverage));
                    eclipse = eclipse * eclipse;
                }
            }

            if (ed < atmosphereHeight) {
                let t2;
                if (ed <= skyFullHeight) t2 = 0;
                else { t2 = (ed - skyFullHeight) / (atmosphereHeight - skyFullHeight); t2 = Math.min(1, Math.max(0, t2)); t2 = t2 * t2; }

                const skyCol = new THREE.Color();
                if (eclipse > 0.01) {
                    skyCol.copy(skyBlue).lerp(spaceBlack, t2);
                    skyCol.lerp(new THREE.Color(0x0a0a18), eclipse);
                } else {
                    skyCol.copy(skyBlue).lerp(spaceBlack, t2);
                }
                scene.background = skyCol;

                if (t2 < 0.95) {
                    const fogCol = new THREE.Color();
                    fogCol.copy(skyHorizon).lerp(spaceBlack, t2);
                    if (eclipse > 0.01) fogCol.lerp(new THREE.Color(0x080810), eclipse);
                    const eclipseMult = 1 + eclipse * 8;
                    scene.fog = new THREE.Fog(fogCol, (500 + t2 * 50000) * eclipseMult, (50000 + t2 * 500000) * eclipseMult);
                } else { scene.fog = null; }
            } else {
                scene.background = spaceBlack;
                scene.fog = null;
            }
        }

        // Update HUD data
        hudData.speed = (Math.abs(input.y) > 0.05 || Math.abs(input.x) > 0.05 || input.up || input.down) ? currentSpeed : currentSpeed * 0.1;
        hudData.maxSpeed = config.deepSpaceSpeed;
        hudData.altitude = closestDist;
        hudData.heading = camYaw * 180 / Math.PI;
        hudData.targetName = closestP ? closestP.name : '---';
        hudData.targetDist = closestDist;
        hudData.nearPlanet = nearestPlanet !== null;

        // Radar data — sun-centered: planet positions relative to sun
        const sunWorld = new THREE.Vector3();
        planets[0].mesh.getWorldPosition(sunWorld); // SUN is index 0
        hudData.planets = planets.map(p => {
            const wp = new THREE.Vector3(); p.mesh.getWorldPosition(wp);
            const dx = wp.x - sunWorld.x, dz = wp.z - sunWorld.z;
            return { name: p.name, angle: Math.atan2(dz, dx), dist: Math.sqrt(dx * dx + dz * dz), isSun: p.name === 'SUN' };
        });
        // Player position relative to sun for radar triangle
        const camDx = camera.position.x - sunWorld.x, camDz = camera.position.z - sunWorld.z;
        hudData.playerRadarAngle = Math.atan2(camDz, camDx);
        hudData.playerSunDist = Math.sqrt(camDx * camDx + camDz * camDz);

        updateHUD();
        renderer.render(scene, camera);
    }

    animate();
    </script>
</body>
</html>
