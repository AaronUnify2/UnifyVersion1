<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Titan Scale: Nav Systems</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { overflow: hidden; background: #000; font-family: 'Share Tech Mono', monospace; }
        
        /* HUD Layer */
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        #hud-header {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #00ffcc; text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }
        
        /* Planet Markers (HTML Overlay) */
        .planet-marker {
            position: absolute; transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8); font-size: 10px; text-align: center;
            white-space: nowrap; pointer-events: none;
            text-shadow: 1px 1px 2px #000;
            transition: opacity 0.2s;
        }
        .marker-icon {
            width: 8px; height: 8px; border: 1px solid #00ffcc; border-radius: 50%;
            margin: 0 auto 2px auto; background: rgba(0,0,0,0.5);
        }
        .marker-dist { font-size: 8px; color: #aaaaaa; }

        /* Controls */
        #controls { pointer-events: auto; }
        #stick-area {
            position: absolute; bottom: 40px; left: 40px; width: 140px; height: 140px;
            background: rgba(0, 255, 204, 0.05); border-radius: 50%;
            border: 1px dashed rgba(0, 255, 204, 0.2);
        }
        #stick-thumb {
            width: 50px; height: 50px; background: rgba(0, 255, 204, 0.2);
            border: 1px solid #00ffcc; border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
        }

        .btn {
            position: absolute; width: 70px; height: 70px; border-radius: 50%;
            border: 1px solid rgba(0, 255, 204, 0.4); color: #00ffcc;
            display: flex; align-items: center; justify-content: center;
            font-size: 12px; background: rgba(0,0,0,0.5); cursor: pointer;
        }
        .btn:active { background: rgba(0, 255, 204, 0.2); }
        #btn-up { bottom: 120px; right: 30px; }
        #btn-down { bottom: 30px; right: 30px; }

        /* Speedometer */
        #speed-readout {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: #00ffcc; font-size: 12px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="hud-header">SYSTEM NAVIGATION ONLINE</div>
        <div id="speed-readout">VELOCITY: 0 km/s</div>
        
        <div id="markers-container"></div>

        <div id="controls">
            <div id="stick-area"><div id="stick-thumb"></div></div>
            <div id="btn-up" class="btn">ASCEND</div>
            <div id="btn-down" class="btn">DESCEND</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    /* ================================================================
       TITAN SCALE v3: VISIBILITY UPDATE
       ================================================================ */

    const config = {
        sunRadius: 20000, 
        maxSpeed: 8000,
        renderDist: 2000000000 // 2 Billion units
    };

    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, logarithmicDepthBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000005);
    // Add Fog to fade distant stars, but keep it very sparse
    scene.fog = new THREE.FogExp2(0x000005, 0.00000005);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, config.renderDist);

    // ================= LIGHTING & STARS =================
    const sunLight = new THREE.PointLight(0xffffff, 1.5, 0);
    scene.add(sunLight);
    const ambient = new THREE.AmbientLight(0x404040);
    scene.add(ambient);

    // Starfield (Massive)
    const starGeo = new THREE.BufferGeometry();
    const starPos = [];
    for(let i=0; i<15000; i++) {
        const r = 5000000 + Math.random() * 5000000; // Background stars
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        starPos.push(r * Math.sin(phi) * Math.cos(theta));
        starPos.push(r * Math.sin(phi) * Math.sin(theta));
        starPos.push(r * Math.cos(phi));
    }
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 800, sizeAttenuation: true });
    scene.add(new THREE.Points(starGeo, starMat));

    // ================= HELPER FUNCTIONS =================
    function createTexture(color, type) {
        const c = document.createElement('canvas'); c.width=256; c.height=128;
        const ctx = c.getContext('2d');
        ctx.fillStyle = color; ctx.fillRect(0,0,256,128);
        if(type==='noise'){
            ctx.globalAlpha = 0.1;
            for(let i=0;i<50;i++) {
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(Math.random()*256, Math.random()*128, Math.random()*10,0,Math.PI*2); ctx.fill();
            }
        }
        return new THREE.CanvasTexture(c);
    }

    // ================= PLANET SYSTEM =================
    const planets = [];
    const markersContainer = document.getElementById('markers-container');

    function createPlanet(name, radius, dist, color) {
        // 3D Object
        const grp = new THREE.Group();
        grp.position.set(dist, 0, 0); // Start position
        
        const geo = new THREE.SphereGeometry(radius, 48, 48);
        const mat = new THREE.MeshStandardMaterial({ map: createTexture(color, 'noise'), roughness: 0.7 });
        const mesh = new THREE.Mesh(geo, mat);
        grp.add(mesh);

        // Orbit Ring (Visual Guide)
        if(dist > 0) {
            const ringGeo = new THREE.RingGeometry(dist-100, dist+100, 128);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI/2;
            scene.add(ring);
        }

        scene.add(grp);

        // HUD Marker (HTML Element)
        const el = document.createElement('div');
        el.className = 'planet-marker';
        el.innerHTML = `<div class="marker-icon" style="border-color:${color}"></div><div style="color:${color}">${name}</div><div class="marker-dist"></div>`;
        markersContainer.appendChild(el);

        planets.push({
            name, grp, mesh, radius, dist, el, 
            angle: Math.random()*Math.PI*2,
            orbitSpeed: (10000 / (dist || 1)) * 0.0001
        });
    }

    // 1. SUN (Special treatment for visibility)
    // The "Sun Halo" - A sprite that is always visible regardless of distance
    const sunSpriteMat = new THREE.SpriteMaterial({ 
        map: new THREE.CanvasTexture((function(){
            const c=document.createElement('canvas');c.width=64;c.height=64;
            const x=c.getContext('2d');
            const g=x.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,200,0,1)');
            g.addColorStop(0.5,'rgba(255,100,0,0.5)');
            g.addColorStop(1,'rgba(255,0,0,0)');
            x.fillStyle=g;x.fillRect(0,0,64,64);
            return c;
        })()), 
        color: 0xffaa00, transparent: true, blending: THREE.AdditiveBlending 
    });
    const sunSprite = new THREE.Sprite(sunSpriteMat);
    sunSprite.scale.set(100000, 100000, 1); // Huge sprite
    scene.add(sunSprite);

    // Sun Mesh
    createPlanet("SUN", config.sunRadius, 0, '#ffaa00');

    // Planets (Distances are scaled for "Game Feel" but huge)
    createPlanet("MERCURY", 400,   60000,  '#aaaaaa');
    createPlanet("VENUS",   900,   110000, '#eec1ad');
    createPlanet("EARTH",   1000,  170000, '#4488ff');
    createPlanet("MARS",    500,   250000, '#ff4400');
    createPlanet("JUPITER", 12000, 500000, '#d8ca9d'); // Big jump
    createPlanet("SATURN",  10000, 900000, '#ead6b8');
    createPlanet("URANUS",  4000,  1500000,'#00ffff');
    createPlanet("NEPTUNE", 3900,  2200000,'#4b70dd');

    // ================= PLAYER START =================
    // Spawn at Earth
    camera.position.set(170000, 1200, 0); // Just above Earth
    camera.lookAt(175000, 0, 0); // Look towards Mars/Jupiter direction

    // ================= NAVIGATION ARROW =================
    // A simple cone attached to camera to point to Sun
    const arrowGeo = new THREE.ConeGeometry(0.2, 1, 8);
    const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
    const navArrow = new THREE.Mesh(arrowGeo, arrowMat);
    navArrow.position.set(0, -1.5, -3); // In front of camera, bottom
    navArrow.rotation.x = Math.PI/2;
    camera.add(navArrow);
    scene.add(camera);

    // ================= INPUT =================
    const input = { x:0, y:0, up:false, down:false };
    let camYaw = -Math.PI/2, camPitch = 0;
    
    // Joystick
    const stick = document.getElementById('stick-thumb');
    const stickArea = document.getElementById('stick-area');
    let touchId = null;

    stickArea.addEventListener('touchstart', e => { e.preventDefault(); touchId=e.changedTouches[0].identifier; updateStick(e.changedTouches[0]); });
    stickArea.addEventListener('touchmove', e => { 
        e.preventDefault(); 
        for(let i=0;i<e.changedTouches.length;i++) {
            if(e.changedTouches[i].identifier === touchId) updateStick(e.changedTouches[i]);
        }
    });
    stickArea.addEventListener('touchend', () => { touchId=null; stick.style.transform='translate(-50%,-50%)'; input.x=0; input.y=0; });

    function updateStick(t) {
        const r = stickArea.getBoundingClientRect();
        const dx = t.clientX - (r.left + r.width/2);
        const dy = t.clientY - (r.top + r.height/2);
        const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 40);
        const ang = Math.atan2(dy, dx);
        stick.style.transform = `translate(calc(-50% + ${Math.cos(ang)*dist}px), calc(-50% + ${Math.sin(ang)*dist}px))`;
        input.x = (Math.cos(ang)*dist)/40; input.y = (Math.sin(ang)*dist)/40;
    }

    // Look
    let lastLook = {x:0,y:0};
    document.addEventListener('touchstart', e => { if(e.target.id==='gameCanvas') lastLook={x:e.touches[0].clientX, y:e.touches[0].clientY}; });
    document.addEventListener('touchmove', e => {
        if(e.target.id==='gameCanvas') {
            const dx = e.touches[0].clientX - lastLook.x;
            const dy = e.touches[0].clientY - lastLook.y;
            camYaw -= dx*0.004; camPitch -= dy*0.004;
            camPitch = Math.max(-1.5, Math.min(1.5, camPitch));
            lastLook={x:e.touches[0].clientX, y:e.touches[0].clientY};
        }
    });

    document.getElementById('btn-up').addEventListener('touchstart', (e)=>{e.preventDefault();input.up=true});
    document.getElementById('btn-up').addEventListener('touchend', (e)=>{e.preventDefault();input.up=false});
    document.getElementById('btn-down').addEventListener('touchstart', (e)=>{e.preventDefault();input.down=true});
    document.getElementById('btn-down').addEventListener('touchend', (e)=>{e.preventDefault();input.down=false});

    // ================= LOOP =================
    const speedReadout = document.getElementById('speed-readout');
    const tempVec = new THREE.Vector3();

    function animate() {
        requestAnimationFrame(animate);

        // 1. Update Planets
        const time = Date.now();
        planets.forEach(p => {
            if(p.dist > 0) {
                p.grp.position.x = Math.cos(p.angle + time * p.orbitSpeed) * p.dist;
                p.grp.position.z = Math.sin(p.angle + time * p.orbitSpeed) * p.dist;
            }
            // Update HUD Marker Position
            // Project world position to screen coordinates
            p.mesh.getWorldPosition(tempVec);
            const distToCam = camera.position.distanceTo(tempVec);
            
            // Only show if in front of camera
            tempVec.project(camera);
            
            if(tempVec.z < 1) { // -1 to 1 is visible
                 const x = (tempVec.x * .5 + .5) * canvas.clientWidth;
                 const y = (tempVec.y * -.5 + .5) * canvas.clientHeight;
                 
                 p.el.style.display = 'block';
                 p.el.style.left = x + 'px';
                 p.el.style.top = y + 'px';
                 p.el.querySelector('.marker-dist').innerText = Math.floor(distToCam).toLocaleString();
                 
                 // Fade out if very close (so it doesn't block view)
                 p.el.style.opacity = distToCam < p.radius*2 ? 0.3 : 0.8;
            } else {
                 p.el.style.display = 'none';
            }
        });

        // 2. Nav Arrow Logic (Point to Sun)
        // Convert Sun position (0,0,0) to local camera space to rotate arrow
        // Actually simpler: Make arrow LookAt Sun, but parented to camera is tricky.
        // Alternative: Calculate angle to sun relative to camera heading.
        // We'll skip complex math and just use world rotation? No, camera moves.
        // Easy hack: LookAt 0,0,0
        navArrow.lookAt(0,0,0);


        // 3. Movement Physics (Logarithmic Drag)
        // Calculate nearest surface
        let closestD = Infinity;
        planets.forEach(p => {
            p.mesh.getWorldPosition(tempVec);
            const d = camera.position.distanceTo(tempVec) - p.radius;
            if(d < closestD) closestD = d;
        });

        // Speed Logic:
        // Deep space (1,000,000 units) -> Speed 5000
        // Near Earth (200 units) -> Speed 10
        let targetSpeed = 5 + (closestD / 150);
        if(targetSpeed > config.maxSpeed) targetSpeed = config.maxSpeed;
        
        speedReadout.innerText = `VELOCITY: ${Math.floor(targetSpeed)} km/s | NEAREST OBJ: ${Math.floor(closestD)}`;

        const fwd = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
        const right = new THREE.Vector3(1, 0, 0).applyEuler(camera.rotation);
        const up = new THREE.Vector3(0, 1, 0).applyEuler(camera.rotation);

        if(Math.abs(input.y)>0.1) camera.position.addScaledVector(fwd, -input.y * targetSpeed);
        if(Math.abs(input.x)>0.1) camera.position.addScaledVector(right, input.x * targetSpeed);
        if(input.up) camera.position.addScaledVector(up, targetSpeed);
        if(input.down) camera.position.addScaledVector(up, -targetSpeed);

        camera.rotation.order = "YXZ";
        camera.rotation.y = camYaw;
        camera.rotation.x = camPitch;

        renderer.render(scene, camera);
    }
    animate();
    </script>
</body>
</html>
