<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Titan Scale: Full System</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { overflow: hidden; background: #000; font-family: 'Rajdhani', sans-serif; }
        
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* HUD Elements */
        #hud-top {
            position: absolute; top: 20px; left: 0; width: 100%; text-align: center;
            text-shadow: 0 0 10px rgba(0, 150, 255, 0.8);
        }
        h1 { color: #fff; font-size: 16px; letter-spacing: 4px; text-transform: uppercase; font-weight: 600; }
        #location-readout { color: #00eaff; font-size: 12px; margin-top: 5px; }

        #radar {
            position: absolute; top: 20px; right: 20px;
            text-align: right; color: rgba(255,255,255,0.4); font-size: 10px;
        }

        /* Controls */
        #controls { pointer-events: auto; }
        
        #stick-area {
            position: absolute; bottom: 40px; left: 40px;
            width: 140px; height: 140px;
        }
        .stick-base {
            width: 100%; height: 100%; border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.15);
            background: radial-gradient(circle, rgba(255,255,255,0.05), transparent);
        }
        .stick-thumb {
            width: 50px; height: 50px; background: rgba(0, 234, 255, 0.3);
            border: 1px solid rgba(0, 234, 255, 0.6);
            border-radius: 50%; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(0, 234, 255, 0.2);
        }

        .thruster-btn {
            position: absolute; width: 80px; height: 80px; border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.2); 
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; color: rgba(255,255,255,0.8);
            backdrop-filter: blur(5px); cursor: pointer;
        }
        .thruster-btn:active { background: rgba(255,255,255,0.2); transform: scale(0.95); }
        
        #btn-up { bottom: 130px; right: 30px; background: radial-gradient(circle, rgba(50,255,50,0.1), transparent); }
        #btn-down { bottom: 30px; right: 30px; background: radial-gradient(circle, rgba(50,100,255,0.1), transparent); }

        #speed-bar-container {
            position: absolute; bottom: 10px; left: 0; width: 100%; height: 4px;
            background: rgba(255,255,255,0.1); display: flex; justify-content: center;
        }
        #speed-bar {
            width: 0%; height: 100%; background: #00eaff;
            box-shadow: 0 0 10px #00eaff; transition: width 0.1s;
        }
        
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="hud-top">
            <h1>Solar System Explorer</h1>
            <div id="location-readout">LOCATION: EARTH ORBIT</div>
        </div>
        
        <div id="radar">
            NEAREST BODY<br>
            <span id="nearest-target" style="color:white; font-size:14px">EARTH</span><br>
            <span id="nearest-dist">0 km</span>
        </div>

        <div id="speed-bar-container"><div id="speed-bar"></div></div>

        <div id="controls">
            <div id="stick-area"><div class="stick-base"><div class="stick-thumb" id="stick"></div></div></div>
            <div id="btn-up" class="thruster-btn">ASC</div>
            <div id="btn-down" class="thruster-btn">DESC</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    /* ================================================================
       TITAN SCALE ENGINE v2
       ================================================================ */

    // Config: 1 Unit = ~1000km relative feel
    const config = {
        sunRadius: 10900, // Reduced slightly to make planets relative pop more, still massive
        speedDampener: 250, // Higher number = Slower "Deep Space" travel
        maxSpeed: 5000 // Hard cap on speed
    };

    const canvas = document.getElementById('gameCanvas');
    // Logarithmic Depth Buffer is MANDATORY for seeing Sun and Pluto in same scene
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, logarithmicDepthBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    
    // Camera: Near 0.1, Far 1 Billion (To see Neptune from Sun)
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000000000);

    // Light
    const ambient = new THREE.AmbientLight(0x404040, 0.5); // Slightly brighter ambient to see planets in dark
    scene.add(ambient);
    const sunLight = new THREE.PointLight(0xffffff, 2.0, 0); // Infinite decay
    scene.add(sunLight);

    // ================= TEXTURE GENERATORS =================
    function createTexture(colorA, colorB, type) {
        const c = document.createElement('canvas'); c.width = 512; c.height = 256;
        const ctx = c.getContext('2d');
        const grd = ctx.createLinearGradient(0,0,0,256);
        grd.addColorStop(0, colorA); grd.addColorStop(1, colorB);
        ctx.fillStyle = grd; ctx.fillRect(0,0,512,256);
        
        // Noise
        if(type === 'gas') {
             ctx.globalAlpha = 0.1;
             for(let i=0; i<20; i++) {
                 ctx.fillStyle = i%2==0 ? '#fff' : '#000';
                 ctx.fillRect(0, Math.random()*256, 512, Math.random()*20);
             }
        } else if (type === 'rock') {
            ctx.globalAlpha = 0.2;
            for(let i=0; i<100; i++) {
                ctx.beginPath(); ctx.arc(Math.random()*512, Math.random()*256, Math.random()*10, 0, Math.PI*2);
                ctx.fillStyle = '#000'; ctx.fill();
            }
        }
        return new THREE.CanvasTexture(c);
    }

    const texSun = createTexture('#ffaa00', '#ff4400', 'gas');
    const texMercury = createTexture('#aaaaaa', '#555555', 'rock');
    const texVenus = createTexture('#eec1ad', '#db9073', 'gas');
    
    // Custom Earth
    const cE = document.createElement('canvas'); cE.width=512; cE.height=256;
    const ctxE = cE.getContext('2d');
    ctxE.fillStyle = '#102040'; ctxE.fillRect(0,0,512,256);
    ctxE.fillStyle = '#306030'; 
    for(let i=0; i<40; i++) { ctxE.beginPath(); ctxE.arc(Math.random()*512, Math.random()*256, Math.random()*40, 0, Math.PI*2); ctxE.fill(); }
    const texEarth = new THREE.CanvasTexture(cE);

    const texMars = createTexture('#c1440e', '#602010', 'rock');
    const texJupiter = createTexture('#d8ca9d', '#a59186', 'gas');
    const texSaturn = createTexture('#ead6b8', '#bfb38f', 'gas');
    const texUranus = createTexture('#d1e7e7', '#83b8d6', 'gas');
    const texNeptune = createTexture('#4b70dd', '#304890', 'gas');

    // ================= SOLAR SYSTEM SETUP =================
    const planets = [];

    function createPlanet(name, radius, distance, texture, tilt) {
        // Orbit Ring
        const ringGeo = new THREE.RingGeometry(distance - 50, distance + 50, 128);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
        const orbitRing = new THREE.Mesh(ringGeo, ringMat);
        orbitRing.rotation.x = Math.PI / 2;
        scene.add(orbitRing);

        // Planet Group (for rotation/orbit)
        const grp = new THREE.Group();
        grp.position.set(distance, 0, 0);
        
        // Mesh
        const geo = new THREE.SphereGeometry(radius, 64, 64);
        const mat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8 });
        const mesh = new THREE.Mesh(geo, mat);
        if(tilt) mesh.rotation.z = tilt;
        
        grp.add(mesh);
        scene.add(grp);

        // Save for logic
        planets.push({ name, mesh: grp, body: mesh, radius, distance, angle: Math.random() * Math.PI * 2, speed: 10000 / (distance || 1) });
        return grp;
    }

    // SUN
    const sunGeo = new THREE.SphereGeometry(config.sunRadius, 64, 64);
    const sunMat = new THREE.MeshBasicMaterial({ map: texSun });
    const sun = new THREE.Mesh(sunGeo, sunMat);
    scene.add(sun);
    planets.push({ name: 'SUN', mesh: sun, body: sun, radius: config.sunRadius, distance: 0, angle: 0, speed: 0 });

    // PLANETS (Scaled Distances - Not 1:1 real life or it would be unplayable, but "Game Scale Huge")
    // Earth is at 200,000 units.
    createPlanet("MERCURY", 380,  80000, texMercury);
    createPlanet("VENUS",   950,  140000, texVenus);
    const earthGrp = createPlanet("EARTH",   1000, 200000, texEarth);
    createPlanet("MARS",    530,  300000, texMars);
    createPlanet("JUPITER", 11000, 700000, texJupiter); // Massive
    const saturnGrp = createPlanet("SATURN",  9000,  1200000, texSaturn, 0.4);
    createPlanet("URANUS",  4000,  1800000, texUranus);
    createPlanet("NEPTUNE", 3900,  2500000, texNeptune);

    // Saturn Rings
    const sRingGeo = new THREE.RingGeometry(12000, 20000, 64);
    const sRingMat = new THREE.MeshBasicMaterial({ color: 0xcbb698, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
    const sRing = new THREE.Mesh(sRingGeo, sRingMat);
    sRing.rotation.x = Math.PI / 2; // Flat relative to planet
    saturnGrp.children[0].add(sRing); // Add to the mesh inside the group

    // Moon (Added manually to Earth Group)
    const moonGeo = new THREE.SphereGeometry(270, 32, 32);
    const moonMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
    const moon = new THREE.Mesh(moonGeo, moonMat);
    const moonDist = 5000;
    moon.position.set(moonDist, 0, 0);
    earthGrp.add(moon);
    // Add Moon to physics tracking (absolute distance tricky here, we'll cheat logic)
    
    // STARS
    const starGeo = new THREE.BufferGeometry();
    const starPos = [];
    for(let i=0; i<10000; i++) {
        const r = 3000000 + Math.random() * 2000000;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        starPos.push(r * Math.sin(phi) * Math.cos(theta));
        starPos.push(r * Math.sin(phi) * Math.sin(theta));
        starPos.push(r * Math.cos(phi));
    }
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 800, sizeAttenuation: true });
    scene.add(new THREE.Points(starGeo, starMat));

    // ================= PLAYER START =================
    // Start ON EARTH SURFACE
    // Earth is at x=200000. Radius 1000.
    camera.position.set(200000, 1010, 0); // 10 units above ground
    camera.lookAt(200000 + 5000, 0, 0); // Look at Moon

    // ================= CONTROLS & LOGIC =================
    let input = { x: 0, y: 0, up: false, down: false };
    let camYaw = -Math.PI/2, camPitch = 0;
    
    // Joystick
    const stick = document.getElementById('stick');
    const stickArea = document.getElementById('stick-area');
    let touchId = null;

    stickArea.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.changedTouches[0]; touchId = t.identifier;
        updateStick(t.clientX, t.clientY);
    });
    stickArea.addEventListener('touchmove', e => {
        e.preventDefault();
        for(let i=0; i<e.changedTouches.length; i++) {
            if(e.changedTouches[i].identifier === touchId) updateStick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
        }
    });
    stickArea.addEventListener('touchend', () => {
        touchId = null; stick.style.transform = `translate(-50%, -50%)`;
        input.x = 0; input.y = 0;
    });

    function updateStick(cx, cy) {
        const rect = stickArea.getBoundingClientRect();
        const x = cx - rect.left - 70; const y = cy - rect.top - 70;
        const dist = Math.min(Math.sqrt(x*x+y*y), 40);
        const ang = Math.atan2(y, x);
        stick.style.transform = `translate(calc(-50% + ${Math.cos(ang)*dist}px), calc(-50% + ${Math.sin(ang)*dist}px))`;
        input.x = (Math.cos(ang)*dist)/40; input.y = (Math.sin(ang)*dist)/40;
    }

    // Look
    let lastLook = { x:0, y:0 };
    document.addEventListener('touchstart', e => {
        if(e.target.id === 'gameCanvas') {
            lastLook = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
    });
    document.addEventListener('touchmove', e => {
        if(e.target.id === 'gameCanvas') {
            const dx = e.touches[0].clientX - lastLook.x;
            const dy = e.touches[0].clientY - lastLook.y;
            camYaw -= dx * 0.003; camPitch -= dy * 0.003;
            camPitch = Math.max(-1.5, Math.min(1.5, camPitch));
            lastLook = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
    });

    const btnUp = document.getElementById('btn-up');
    const btnDown = document.getElementById('btn-down');
    btnUp.addEventListener('touchstart', (e)=>{e.preventDefault(); input.up=true});
    btnUp.addEventListener('touchend', (e)=>{e.preventDefault(); input.up=false});
    btnDown.addEventListener('touchstart', (e)=>{e.preventDefault(); input.down=true});
    btnDown.addEventListener('touchend', (e)=>{e.preventDefault(); input.down=false});

    // ================= LOOP =================
    const readoutName = document.getElementById('nearest-target');
    const readoutDist = document.getElementById('nearest-dist');
    const speedBar = document.getElementById('speed-bar');
    const worldPos = new THREE.Vector3();

    function animate() {
        requestAnimationFrame(animate);

        // 1. Find Nearest Planet & Calculate Gravity Drag
        let closestDist = Infinity;
        let closestName = "VOID";
        let closestRadius = 0;

        planets.forEach(p => {
            p.mesh.getWorldPosition(worldPos);
            const d = camera.position.distanceTo(worldPos) - p.radius;
            if(d < closestDist) {
                closestDist = d; closestName = p.name; closestRadius = p.radius;
            }
        });

        // Update HUD
        readoutName.innerText = closestName;
        readoutDist.innerText = Math.floor(closestDist).toLocaleString() + " Units";

        // 2. Speed Calculation (The Fix)
        // Formula: Base + (Distance / Dampener)
        // If dist is 1,000,000 (Mars gap), speed is 1,000,000 / 250 = 4000.
        // If dist is 100 (Surface), speed is 100 / 250 = 0.4.
        // Plus a base walking speed.
        
        let targetSpeed = 2 + (closestDist / config.speedDampener);
        
        // Clamp speed so we don't go lightspeed instantly
        if(targetSpeed > config.maxSpeed) targetSpeed = config.maxSpeed;
        
        // Show speed in UI bar
        speedBar.style.width = Math.min((targetSpeed / config.maxSpeed) * 100, 100) + "%";

        // 3. Move
        const fwd = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
        const right = new THREE.Vector3(1, 0, 0).applyEuler(camera.rotation);
        const up = new THREE.Vector3(0, 1, 0).applyEuler(camera.rotation);

        if(Math.abs(input.y) > 0.05) camera.position.addScaledVector(fwd, -input.y * targetSpeed);
        if(Math.abs(input.x) > 0.05) camera.position.addScaledVector(right, input.x * targetSpeed);
        if(input.up) camera.position.addScaledVector(up, targetSpeed * 0.8);
        if(input.down) camera.position.addScaledVector(up, -targetSpeed * 0.8);

        camera.rotation.order = "YXZ";
        camera.rotation.y = camYaw;
        camera.rotation.x = camPitch;

        // 4. Orbit Animation
        const time = Date.now() * 0.00005; // Very slow orbits
        planets.forEach(p => {
            if(p.distance > 0) { // Don't move sun
                p.mesh.position.x = Math.cos(p.angle + time * (10000/p.distance)) * p.distance;
                p.mesh.position.z = Math.sin(p.angle + time * (10000/p.distance)) * p.distance;
                p.body.rotation.y += 0.001; // Spin
            }
        });

        renderer.render(scene, camera);
    }
    animate();
    </script>
</body>
</html>
