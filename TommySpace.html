<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Titan Scale: Textured</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Michroma&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { overflow: hidden; background: #000; font-family: 'Michroma', sans-serif; }
        
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* Planet Labels */
        .planet-label {
            position: absolute; transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8); font-size: 10px;
            text-align: center; pointer-events: none;
            text-shadow: 0 0 5px #000; transition: opacity 0.5s;
        }
        .label-name { font-weight: bold; color: #fff; letter-spacing: 1px; }
        .label-dist { font-size: 9px; color: #00ffcc; margin-top: 2px; }

        /* HUD */
        #hud-top { position: absolute; top: 30px; width: 100%; text-align: center; pointer-events: none; }
        #hud-bottom { position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none; }
        
        .hud-text { color: #00ffcc; font-size: 12px; letter-spacing: 2px; text-shadow: 0 0 10px rgba(0, 255, 204, 0.3); }
        .sub-text { color: #666; font-size: 10px; margin-top: 5px; text-transform: uppercase; }

        /* Action Button */
        #action-btn {
            position: absolute; top: 50%; right: 30px; transform: translateY(-50%);
            width: 80px; height: 80px; border-radius: 50%;
            border: 2px solid #00ffcc; color: #00ffcc;
            display: none; align-items: center; justify-content: center;
            font-size: 12px; font-weight: bold; background: rgba(0, 30, 30, 0.9);
            cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
            animation: pulse 3s infinite;
        }
        @keyframes pulse { 0% { box-shadow: 0 0 10px rgba(0,255,204,0.3); } 50% { box-shadow: 0 0 20px rgba(0,255,204,0.6); } 100% { box-shadow: 0 0 10px rgba(0,255,204,0.3); } }

        /* Controls */
        #controls { pointer-events: auto; }
        #stick-area {
            position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px;
            border-radius: 50%; border: 1px dashed rgba(255, 255, 255, 0.15);
        }
        #stick-thumb {
            width: 50px; height: 50px; background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .btn {
            position: absolute; width: 70px; height: 70px; border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2); color: #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 16px; background: rgba(0,0,0,0.5); backdrop-filter: blur(4px);
        }
        #btn-up { bottom: 130px; right: 30px; }
        #btn-down { bottom: 40px; right: 30px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="labels-container"></div>
        
        <div id="hud-top">
            <div id="system-status" class="hud-text">SYSTEM ONLINE</div>
            <div id="proximity-alert" class="sub-text">CRUISE MODE</div>
        </div>
        <div id="hud-bottom">
            <div id="speed-readout" class="hud-text">THRUST: 0%</div>
        </div>

        <div id="action-btn">LAND</div>

        <div id="controls">
            <div id="stick-area"><div id="stick-thumb"></div></div>
            <div id="btn-up" class="btn">▲</div>
            <div id="btn-down" class="btn">▼</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    /* ================================================================
       TITAN SCALE: TEXTURED EDITION
       ================================================================ */

    const config = {
        renderDist: 3000000000,
        lockDist: 40000,
        deepSpaceSpeed: 2500,
        minSpeed: 5,
        sunRadius: 50000
    };

    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, logarithmicDepthBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000008);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, config.renderDist);
    camera.up.set(0, 1, 0); 

    scene.add(new THREE.AmbientLight(0x404040, 1.5)); // Slightly brighter for textures
    scene.add(new THREE.PointLight(0xffffff, 2.0, 0));

    const raycaster = new THREE.Raycaster();
    const systemGroup = new THREE.Group();
    scene.add(systemGroup);

    // ================= TEXTURE GENERATORS (From Original) =================
    function makeTexture(w, h, drawFn) {
        const c = document.createElement('canvas'); c.width = w; c.height = h;
        const ctx = c.getContext('2d'); drawFn(ctx, w, h);
        const t = new THREE.CanvasTexture(c); t.magFilter = THREE.LinearFilter; return t;
    }

    function sunTexture() {
        return makeTexture(256, 128, (ctx, w, h) => {
            ctx.fillStyle = '#ff8c00'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 200; i++) {
                ctx.fillStyle = ['#ffaa00', '#ff6600', '#ffcc00', '#ffe066'][Math.floor(Math.random() * 4)];
                ctx.fillRect(Math.random() * w, Math.random() * h, 3 + Math.random() * 5, 2 + Math.random() * 3);
            }
        });
    }

    function mercuryTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#8a8a8a'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = `rgba(60,60,60,${0.3 + Math.random() * 0.4})`;
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 1 + Math.random() * 3, 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    function venusTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#d4a537'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(${180 + Math.random()*40}, ${140 + Math.random()*40}, ${30 + Math.random()*30}, 0.3)`;
                ctx.fillRect(Math.random() * w, Math.random() * h, 4 + Math.random() * 8, 1 + Math.random() * 2);
            }
        });
    }

    function earthTexture() {
        return makeTexture(256, 128, (ctx, w, h) => {
            ctx.fillStyle = '#1a5276'; ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = '#27ae60';
            ctx.beginPath(); ctx.ellipse(60, 50, 24, 36, 0.2, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(110, 40, 30, 24, -0.1, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(170, 60, 36, 20, 0.3, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#d4ac6e';
            ctx.beginPath(); ctx.ellipse(116, 56, 12, 8, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#ecf0f1'; ctx.fillRect(0, 0, w, 10); ctx.fillRect(0, h - 10, w, 10);
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            for (let i = 0; i < 20; i++) { ctx.fillRect(Math.random() * w, Math.random() * h, 16 + Math.random() * 30, 4); }
        });
    }

    function marsTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#c0392b'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 40; i++) {
                ctx.fillStyle = `rgba(${150 + Math.random()*60}, ${50 + Math.random()*30}, ${20 + Math.random()*20}, 0.4)`;
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 2 + Math.random() * 6, 0, Math.PI * 2); ctx.fill();
            }
            ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillRect(0, 0, w, 6);
        });
    }

    function jupiterTexture() {
        return makeTexture(256, 128, (ctx, w, h) => {
            const bands = ['#c4956a', '#d4a574', '#a07850', '#e8c090', '#b08860', '#c8a870', '#906840'];
            for (let y = 0; y < h; y++) { ctx.fillStyle = bands[y % bands.length]; ctx.fillRect(0, y, w, 1); }
            ctx.fillStyle = '#c05030'; ctx.beginPath(); ctx.ellipse(160, 70, 20, 12, 0, 0, Math.PI * 2); ctx.fill();
        });
    }

    function saturnTexture() {
        return makeTexture(256, 128, (ctx, w, h) => {
            const bands = ['#d4b896', '#c4a878', '#e0c8a0', '#b89868', '#d0b888', '#c8a070'];
            for (let y = 0; y < h; y++) { ctx.fillStyle = bands[y % bands.length]; ctx.fillRect(0, y, w, 1); }
        });
    }

    function uranusTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#5dade2'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(${70 + Math.random()*40}, ${180 + Math.random()*30}, ${220 + Math.random()*30}, 0.2)`;
                ctx.fillRect(0, Math.random() * h, w, 2 + Math.random() * 4);
            }
        });
    }

    function neptuneTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#2e4482'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(${40 + Math.random()*30}, ${60 + Math.random()*40}, ${150 + Math.random()*50}, 0.3)`;
                ctx.fillRect(0, Math.random() * h, w, 2 + Math.random() * 4);
            }
        });
    }

    function moonTexture() {
        return makeTexture(64, 32, (ctx, w, h) => {
            ctx.fillStyle = '#b0b0a8'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 25; i++) {
                ctx.fillStyle = `rgba(80,80,75,${0.2 + Math.random()*0.3})`;
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 1 + Math.random() * 4, 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    // ================= PLANET SYSTEM =================
    const planets = [];
    const labelsContainer = document.getElementById('labels-container');

    function createPlanet(name, radius, dist, texFn, isSun=false) {
        const grp = new THREE.Group();
        grp.position.set(dist, 0, 0);
        
        const geo = new THREE.SphereGeometry(radius, 64, 64);
        
        // Sun uses Basic (Unlit) to glow, others use Standard (Lit)
        const mat = isSun 
            ? new THREE.MeshBasicMaterial({ map: texFn() }) 
            : new THREE.MeshStandardMaterial({ map: texFn(), roughness: 0.9, metalness: 0.1 });
            
        const mesh = new THREE.Mesh(geo, mat);
        mesh.name = "PM_" + name;
        grp.add(mesh);

        // Orbit Ring
        if(dist > 0) {
            const rGeo = new THREE.RingGeometry(dist-300, dist+300, 128);
            const rMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.03, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(rGeo, rMat);
            ring.rotation.x = Math.PI/2;
            scene.add(ring);
        }

        // --- EARTH SPECIFIC: ADD MOON ---
        let moonMesh = null;
        if(name === "EARTH") {
            const mGeo = new THREE.SphereGeometry(radius * 0.27, 32, 32);
            const mMat = new THREE.MeshStandardMaterial({ map: moonTexture(), roughness: 0.9 });
            moonMesh = new THREE.Mesh(mGeo, mMat);
            // Place Moon relative to Earth (scaled up distance for visibility)
            moonMesh.position.set(radius * 4, 0, 0); 
            grp.add(moonMesh);
        }
        
        systemGroup.add(grp);

        const label = document.createElement('div');
        label.className = 'planet-label';
        label.innerHTML = `<div class="label-name">${name}</div><div class="label-dist"></div>`;
        labelsContainer.appendChild(label);

        planets.push({
            name, grp, mesh, radius, dist, label, moonMesh,
            angle: Math.random()*10,
            orbitSpeed: dist === 0 ? 0 : (20000 / dist) * 0.0001
        });
    }

    // Titan Scale Distances + Custom Textures
    createPlanet("SUN", config.sunRadius, 0, sunTexture, true);
    createPlanet("MERCURY", 400,   80000,  mercuryTexture);
    createPlanet("VENUS",   900,   140000, venusTexture);
    createPlanet("EARTH",   1000,  200000, earthTexture);
    createPlanet("MARS",    500,   300000, marsTexture);
    createPlanet("JUPITER", 12000, 600000, jupiterTexture);
    createPlanet("SATURN",  10000, 1000000, saturnTexture);
    createPlanet("URANUS",  4000,  1800000, uranusTexture);
    createPlanet("NEPTUNE", 3900,  2600000, neptuneTexture);

    // Saturn Ring (Manual Add)
    const saturnP = planets.find(p => p.name === "SATURN");
    if(saturnP) {
        const sRingGeo = new THREE.RingGeometry(14000, 22000, 64);
        const sRingMat = new THREE.MeshBasicMaterial({ color: 0xd4c8a0, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
        const sRing = new THREE.Mesh(sRingGeo, sRingMat);
        sRing.rotation.x = Math.PI / 2;
        saturnP.grp.add(sRing);
    }

    // ================= SPAWN =================
    // Spawn 500 units above Earth
    camera.position.set(200000, 1500, 500); 
    let camYaw = Math.PI; 
    let camPitch = 0;

    // ================= CONTROLS & ACTIONS =================
    const actionBtn = document.getElementById('action-btn');
    const lockText = document.getElementById('system-status');
    const proxText = document.getElementById('proximity-alert');
    let landedPlanet = null;
    let nearestPlanet = null;

    actionBtn.addEventListener('click', () => {
        if(landedPlanet) {
            // TAKEOFF
            const p = landedPlanet;
            const worldPos = new THREE.Vector3();
            p.grp.getWorldPosition(worldPos);
            camera.position.set(worldPos.x, worldPos.y + p.radius + 500, worldPos.z);
            camPitch = -Math.PI/2; // Look down
            landedPlanet = null;
            actionBtn.style.display = 'none';
        } else if (nearestPlanet) {
            // LAND
            const p = nearestPlanet;
            const worldPos = new THREE.Vector3();
            p.grp.getWorldPosition(worldPos);
            camera.position.set(worldPos.x, worldPos.y, worldPos.z + p.radius + 2);
            camYaw = Math.PI;
            camPitch = 0.1;
            landedPlanet = p;
            actionBtn.innerText = "TAKEOFF";
        }
    });

    const input = { x:0, y:0, up:false, down:false };
    const stick = document.getElementById('stick-thumb');
    const stickArea = document.getElementById('stick-area');
    let touchId = null;

    stickArea.addEventListener('touchstart', e => { e.preventDefault(); touchId=e.changedTouches[0].identifier; updateStick(e.changedTouches[0]); });
    stickArea.addEventListener('touchmove', e => { e.preventDefault(); for(let i=0;i<e.changedTouches.length;i++) if(e.changedTouches[i].identifier === touchId) updateStick(e.changedTouches[i]); });
    stickArea.addEventListener('touchend', () => { touchId=null; stick.style.transform='translate(-50%,-50%)'; input.x=0; input.y=0; });

    function updateStick(t) {
        const r = stickArea.getBoundingClientRect();
        const dx = t.clientX - (r.left + r.width/2);
        const dy = t.clientY - (r.top + r.height/2);
        const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 60);
        const ang = Math.atan2(dy, dx);
        stick.style.transform = `translate(calc(-50% + ${Math.cos(ang)*dist}px), calc(-50% + ${Math.sin(ang)*dist}px))`;
        input.x = (Math.cos(ang)*dist)/60; input.y = (Math.sin(ang)*dist)/60;
    }

    let lastLook = {x:0, y:0};
    document.addEventListener('touchstart', e => { if(e.target.id==='gameCanvas') lastLook={x:e.touches[0].clientX, y:e.touches[0].clientY}; });
    document.addEventListener('touchmove', e => {
        if(e.target.id==='gameCanvas') {
            e.preventDefault();
            const dx = e.touches[0].clientX - lastLook.x;
            const dy = e.touches[0].clientY - lastLook.y;
            camYaw -= dx * 0.003; camPitch -= dy * 0.003;
            camPitch = Math.max(-1.5, Math.min(1.5, camPitch));
            lastLook={x:e.touches[0].clientX, y:e.touches[0].clientY};
        }
    });

    const btnUp = document.getElementById('btn-up');
    const btnDown = document.getElementById('btn-down');
    btnUp.addEventListener('touchstart', (e)=>{e.preventDefault();input.up=true});
    btnUp.addEventListener('touchend', (e)=>{e.preventDefault();input.up=false});
    btnDown.addEventListener('touchstart', (e)=>{e.preventDefault();input.down=true});
    btnDown.addEventListener('touchend', (e)=>{e.preventDefault();input.down=false});

    // ================= PHYSICS LOOP =================
    const speedText = document.getElementById('speed-readout');
    const tempVec = new THREE.Vector3();
    const screenVec = new THREE.Vector3();

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now();
        
        let closestDist = Infinity;
        let closestP = null;
        let isLocked = false;

        // 1. UPDATE PLANETS
        planets.forEach(p => {
            const prevPos = p.grp.position.clone();

            // Orbit
            if(p.dist > 0) {
                p.grp.position.x = Math.cos(p.angle + time * p.orbitSpeed) * p.dist;
                p.grp.position.z = Math.sin(p.angle + time * p.orbitSpeed) * p.dist;
            }
            
            // Spin Planet
            p.mesh.rotation.y += 0.001;

            // Moon Logic (Earth only)
            if(p.moonMesh) {
                p.moonMesh.rotation.y += 0.01; // Spin moon
                // Simple orbit around Earth (Static relative to group is fine since group moves, but let's rotate it)
                const mSpeed = time * 0.00005;
                p.moonMesh.position.x = Math.cos(mSpeed) * (p.radius * 4);
                p.moonMesh.position.z = Math.sin(mSpeed) * (p.radius * 4);
            }

            // Dist calc
            p.mesh.getWorldPosition(tempVec);
            const distCenter = camera.position.distanceTo(tempVec);
            const distSurface = distCenter - p.radius;

            if(distSurface < closestDist) {
                closestDist = distSurface;
                closestP = p;
            }

            // Gravity Lock
            const delta = p.grp.position.clone().sub(prevPos);
            if (!isNaN(delta.x)) {
                if(landedPlanet === p || (!landedPlanet && distSurface < config.lockDist)) {
                    camera.position.add(delta);
                    isLocked = true;
                }
            }

            // Raycast Labels
            if(distSurface < 80000) {
                p.label.style.opacity = '0';
            } else {
                tempVec.project(camera);
                if(tempVec.z < 1 && Math.abs(tempVec.x)<1 && Math.abs(tempVec.y)<1) {
                    screenVec.set(tempVec.x, tempVec.y, 0.5);
                    raycaster.setFromCamera(screenVec, camera);
                    const intersects = raycaster.intersectObjects(systemGroup.children, true);
                    if(intersects.length > 0 && intersects[0].object.name === "PM_" + p.name) {
                        const x = (tempVec.x * .5 + .5) * canvas.clientWidth;
                        const y = (tempVec.y * -.5 + .5) * canvas.clientHeight;
                        p.label.style.left = x + 'px';
                        p.label.style.top = y + 'px';
                        p.label.style.opacity = '1';
                        p.label.querySelector('.label-dist').innerText = Math.floor(distSurface).toLocaleString() + ' u';
                    } else {
                        p.label.style.opacity = '0';
                    }
                } else {
                    p.label.style.opacity = '0';
                }
            }
        });

        // 2. STATE UPDATES
        nearestPlanet = (closestDist < 1200 && !landedPlanet) ? closestP : null;

        if (landedPlanet) {
            actionBtn.style.display = 'flex'; actionBtn.innerText = "TAKEOFF";
            lockText.innerText = "SURFACE LOCK"; lockText.style.color = "#00ffcc";
            proxText.innerText = `LOCATION: ${landedPlanet.name}`;
        } else if (nearestPlanet) {
            actionBtn.style.display = 'flex'; actionBtn.innerText = "LAND";
            lockText.innerText = "ORBITAL INSERTION"; lockText.style.color = "#ffff00";
            proxText.innerText = `READY TO LAND ON ${nearestPlanet.name}`;
        } else {
            actionBtn.style.display = 'none';
            if(isLocked) {
                 lockText.innerText = "GRAVITY WELL"; lockText.style.color = "#00ffcc";
                 proxText.innerText = `APPROACHING ${closestP.name}`;
            } else {
                 lockText.innerText = "SYSTEM ONLINE"; lockText.style.color = "#00aa88";
                 proxText.innerText = "DEEP SPACE CRUISE";
            }
        }

        // 3. HEAVY GRAVITY SPEED LOGIC
        let targetSpeed = 0;

        if (landedPlanet) {
            targetSpeed = config.minSpeed; 
        } else {
            // Logarithmic drag based on distance
            targetSpeed = closestDist * 0.005; 
            if(targetSpeed > config.deepSpaceSpeed) targetSpeed = config.deepSpaceSpeed;
            if(targetSpeed < config.minSpeed) targetSpeed = config.minSpeed;
        }

        if(isNaN(targetSpeed)) targetSpeed = config.minSpeed;
        speedText.innerText = `THRUST: ${Math.floor((targetSpeed/config.deepSpaceSpeed)*100)}% (${Math.floor(targetSpeed)} u/s)`;

        // 4. APPLY MOVEMENT
        const fwd = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
        const right = new THREE.Vector3(1, 0, 0).applyEuler(camera.rotation);
        const up = new THREE.Vector3(0, 1, 0); 

        if(Math.abs(input.y)>0.05) camera.position.addScaledVector(fwd, -input.y * targetSpeed);
        if(Math.abs(input.x)>0.05) camera.position.addScaledVector(right, input.x * targetSpeed);
        if(input.up) camera.position.addScaledVector(up, targetSpeed);
        if(input.down) camera.position.addScaledVector(up, -targetSpeed);

        camera.rotation.order = "YXZ";
        camera.rotation.y = camYaw;
        camera.rotation.x = camPitch;

        renderer.render(scene, camera);
    }
    animate();
    </script>
</body>
</html>
