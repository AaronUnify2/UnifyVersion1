<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Titan Scale: Textured</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Michroma&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { overflow: hidden; background: #000; font-family: 'Michroma', sans-serif; }
        
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* Planet Labels */
        .planet-label {
            position: absolute; transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8); font-size: 10px;
            text-align: center; pointer-events: none;
            text-shadow: 0 0 5px #000; transition: opacity 0.5s;
        }
        .label-name { font-weight: bold; color: #fff; letter-spacing: 1px; }
        .label-dist { font-size: 9px; color: #00ffcc; margin-top: 2px; }

        /* HUD */
        #hud-top { position: absolute; top: 30px; width: 100%; text-align: center; pointer-events: none; }
        #hud-bottom { position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none; }
        
        .hud-text { color: #00ffcc; font-size: 12px; letter-spacing: 2px; text-shadow: 0 0 10px rgba(0, 255, 204, 0.3); }
        .sub-text { color: #666; font-size: 10px; margin-top: 5px; text-transform: uppercase; }

        /* Action Button */
        #action-btn {
            position: absolute; top: 50%; right: 30px; transform: translateY(-50%);
            width: 80px; height: 80px; border-radius: 50%;
            border: 2px solid #00ffcc; color: #00ffcc;
            display: none; align-items: center; justify-content: center;
            font-size: 12px; font-weight: bold; background: rgba(0, 30, 30, 0.9);
            cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
            animation: pulse 3s infinite;
        }
        @keyframes pulse { 0% { box-shadow: 0 0 10px rgba(0,255,204,0.3); } 50% { box-shadow: 0 0 20px rgba(0,255,204,0.6); } 100% { box-shadow: 0 0 10px rgba(0,255,204,0.3); } }

        /* Controls */
        #controls { pointer-events: auto; }
        #stick-area {
            position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px;
            border-radius: 50%; border: 1px dashed rgba(255, 255, 255, 0.15);
        }
        #stick-thumb {
            width: 50px; height: 50px; background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .btn {
            position: absolute; width: 70px; height: 70px; border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2); color: #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 16px; background: rgba(0,0,0,0.5); backdrop-filter: blur(4px);
        }
        #btn-up { bottom: 130px; right: 30px; }
        #btn-down { bottom: 40px; right: 30px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="labels-container"></div>
        
        <div id="hud-top">
            <div id="system-status" class="hud-text">SYSTEM ONLINE</div>
            <div id="proximity-alert" class="sub-text">CRUISE MODE</div>
        </div>
        <!-- Thrust readout hidden -->
        <div id="hud-bottom" style="display:none;">
            <div id="speed-readout" class="hud-text">THRUST: 0%</div>
        </div>

        <div id="action-btn">LAND</div>

        <div id="controls">
            <div id="stick-area"><div id="stick-thumb"></div></div>
            <div id="btn-up" class="btn">▲</div>
            <div id="btn-down" class="btn">▼</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    /* ================================================================
       TITAN SCALE: TEXTURED EDITION
       ================================================================ */

    const config = {
        renderDist: 3000000000,
        lockDist: 40000,
        deepSpaceSpeed: 2500,
        minSpeed: 5,
        sunRadius: 5000
    };

    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, logarithmicDepthBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000008);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, config.renderDist);
    camera.up.set(0, 1, 0); 

    scene.add(new THREE.AmbientLight(0x404040, 1.5));
    scene.add(new THREE.PointLight(0xffffff, 2.0, 0));

    const raycaster = new THREE.Raycaster();
    const systemGroup = new THREE.Group();
    scene.add(systemGroup);

    // ================= STAR FIELD =================
    function createStarField() {
        const starCount = 6000;
        const positions = new Float32Array(starCount * 3);
        const colors = new Float32Array(starCount * 3);
        const sizes = new Float32Array(starCount);

        for (let i = 0; i < starCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 800000000 + Math.random() * 200000000;

            positions[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = r * Math.cos(phi);

            const colorRoll = Math.random();
            if (colorRoll < 0.5) {
                colors[i * 3] = 0.9 + Math.random() * 0.1;
                colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
                colors[i * 3 + 2] = 0.9 + Math.random() * 0.1;
            } else if (colorRoll < 0.7) {
                colors[i * 3] = 0.7 + Math.random() * 0.1;
                colors[i * 3 + 1] = 0.8 + Math.random() * 0.1;
                colors[i * 3 + 2] = 1.0;
            } else if (colorRoll < 0.85) {
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
                colors[i * 3 + 2] = 0.7 + Math.random() * 0.1;
            } else {
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.6 + Math.random() * 0.2;
                colors[i * 3 + 2] = 0.4 + Math.random() * 0.2;
            }
            sizes[i] = 200000 + Math.random() * 600000;
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const mat = new THREE.PointsMaterial({
            size: 500000,
            sizeAttenuation: true,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
        });
        scene.add(new THREE.Points(geo, mat));

        // Background dim layer
        const bgCount = 4000;
        const bgPos = new Float32Array(bgCount * 3);
        const bgCol = new Float32Array(bgCount * 3);
        for (let i = 0; i < bgCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 900000000 + Math.random() * 100000000;
            bgPos[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
            bgPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            bgPos[i * 3 + 2] = r * Math.cos(phi);
            bgCol[i * 3] = 0.7 + Math.random() * 0.3;
            bgCol[i * 3 + 1] = 0.7 + Math.random() * 0.3;
            bgCol[i * 3 + 2] = 0.8 + Math.random() * 0.1;
        }
        const bgGeo = new THREE.BufferGeometry();
        bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
        bgGeo.setAttribute('color', new THREE.BufferAttribute(bgCol, 3));
        const bgMat = new THREE.PointsMaterial({
            size: 400000,
            sizeAttenuation: true,
            vertexColors: true,
            transparent: true,
            opacity: 0.6,
        });
        scene.add(new THREE.Points(bgGeo, bgMat));
    }
    createStarField();

    // ================= TEXTURE GENERATORS =================
    function makeTexture(w, h, drawFn) {
        const c = document.createElement('canvas'); c.width = w; c.height = h;
        const ctx = c.getContext('2d'); drawFn(ctx, w, h);
        const t = new THREE.CanvasTexture(c); t.magFilter = THREE.LinearFilter; return t;
    }

    function sunTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            // Base orange-yellow gradient
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#ffcc00');
            grad.addColorStop(0.3, '#ff9900');
            grad.addColorStop(0.5, '#ff8c00');
            grad.addColorStop(0.7, '#ff6600');
            grad.addColorStop(1, '#ffaa00');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);
            // Granulation
            for (let i = 0; i < 500; i++) {
                ctx.fillStyle = ['#ffaa00', '#ff6600', '#ffcc00', '#ffe066', '#ff5500'][Math.floor(Math.random() * 5)];
                ctx.globalAlpha = 0.15 + Math.random() * 0.2;
                ctx.fillRect(Math.random() * w, Math.random() * h, 2 + Math.random() * 6, 2 + Math.random() * 4);
            }
            ctx.globalAlpha = 1;
            // Sunspots
            for (let i = 0; i < 8; i++) {
                ctx.fillStyle = 'rgba(120,50,0,0.3)';
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 2 + Math.random() * 5, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }

    function mercuryTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#8a8a8a'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = `rgba(60,60,60,${0.3 + Math.random() * 0.4})`;
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 1 + Math.random() * 3, 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    function venusTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#d4a537'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(${180 + Math.random()*40}, ${140 + Math.random()*40}, ${30 + Math.random()*30}, 0.3)`;
                ctx.fillRect(Math.random() * w, Math.random() * h, 4 + Math.random() * 8, 1 + Math.random() * 2);
            }
        });
    }

    // ============ REALISTIC EARTH TEXTURE ============
    function earthTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            // Deep ocean base
            const oceanGrad = ctx.createLinearGradient(0, 0, 0, h);
            oceanGrad.addColorStop(0, '#1a3a5c');
            oceanGrad.addColorStop(0.15, '#1e5799');
            oceanGrad.addColorStop(0.3, '#1a6baa');
            oceanGrad.addColorStop(0.5, '#1565a0');
            oceanGrad.addColorStop(0.7, '#1a6baa');
            oceanGrad.addColorStop(0.85, '#1e5799');
            oceanGrad.addColorStop(1, '#1a3a5c');
            ctx.fillStyle = oceanGrad;
            ctx.fillRect(0, 0, w, h);

            // Ocean depth variation
            for (let i = 0; i < 200; i++) {
                ctx.fillStyle = `rgba(${10 + Math.random()*20}, ${60 + Math.random()*40}, ${120 + Math.random()*40}, 0.15)`;
                ctx.fillRect(Math.random() * w, Math.random() * h, 5 + Math.random() * 20, 2 + Math.random() * 6);
            }

            // --- CONTINENTS ---
            // Helper to draw a landmass blob
            function drawContinent(cx, cy, scaleX, scaleY, color, rotation) {
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(rotation || 0);
                ctx.fillStyle = color;
                ctx.beginPath();
                const points = 12 + Math.floor(Math.random() * 6);
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const rr = 1 + Math.random() * 0.35;
                    const px = Math.cos(angle) * scaleX * rr;
                    const py = Math.sin(angle) * scaleY * rr;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // North America (upper left area)
            drawContinent(w * 0.18, h * 0.28, 38, 28, '#2d6b30', -0.2);
            drawContinent(w * 0.15, h * 0.22, 20, 15, '#3a7a3d', 0.3);
            drawContinent(w * 0.22, h * 0.35, 15, 20, '#2d6b30', -0.1);
            // Central America
            drawContinent(w * 0.20, h * 0.42, 8, 12, '#3a7a3d', 0.5);

            // South America (lower left)
            drawContinent(w * 0.26, h * 0.55, 18, 30, '#2d6b30', 0.15);
            drawContinent(w * 0.28, h * 0.62, 14, 22, '#3a7a3d', 0.1);

            // Europe (upper middle)
            drawContinent(w * 0.48, h * 0.22, 18, 12, '#4a8a40', -0.1);
            drawContinent(w * 0.50, h * 0.18, 12, 8, '#3a7a3d', 0.2);
            // UK/Scandinavia fragments
            drawContinent(w * 0.44, h * 0.18, 4, 6, '#4a8a40', 0.3);
            drawContinent(w * 0.52, h * 0.14, 5, 10, '#3a7a3d', 0.1);

            // Africa (middle)
            drawContinent(w * 0.50, h * 0.42, 22, 30, '#8B7235', 0.05);
            drawContinent(w * 0.48, h * 0.38, 18, 16, '#6b8a30', -0.1);
            drawContinent(w * 0.53, h * 0.52, 14, 18, '#9a8040', 0.1);
            // Sahara desert region  
            drawContinent(w * 0.49, h * 0.35, 20, 8, '#c4a555', 0);

            // Asia (upper right area)
            drawContinent(w * 0.62, h * 0.25, 40, 22, '#3a7a3d', -0.05);
            drawContinent(w * 0.70, h * 0.28, 28, 18, '#4a8a40', 0.1);
            drawContinent(w * 0.58, h * 0.20, 20, 14, '#567a45', 0.15);
            // India
            drawContinent(w * 0.62, h * 0.40, 10, 14, '#6b8a30', 0.2);
            // SE Asia
            drawContinent(w * 0.72, h * 0.42, 12, 10, '#4a8a40', -0.2);

            // Australia (lower right)
            drawContinent(w * 0.78, h * 0.62, 18, 14, '#9a7a30', 0.1);
            drawContinent(w * 0.80, h * 0.60, 14, 10, '#8a6a28', -0.15);

            // Antarctica (bottom strip)
            ctx.fillStyle = '#e8e8f0';
            ctx.fillRect(0, h - 18, w, 18);
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = `rgba(200,210,230,${0.3 + Math.random()*0.4})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, h - 12 + Math.random() * 10, 3 + Math.random() * 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // Arctic (top strip)
            ctx.fillStyle = 'rgba(220,230,240,0.6)';
            ctx.fillRect(0, 0, w, 10);
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(210,220,240,${0.2 + Math.random()*0.3})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * 12, 2 + Math.random() * 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // Mountain ranges and terrain details on continents
            for (let i = 0; i < 150; i++) {
                const shade = Math.random();
                if (shade < 0.5) {
                    ctx.fillStyle = `rgba(30,80,30,${0.08 + Math.random()*0.12})`;
                } else {
                    ctx.fillStyle = `rgba(80,60,30,${0.06 + Math.random()*0.1})`;
                }
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 1 + Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Coastal shallows (lighter blue near land)
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(40,120,180,${0.05 + Math.random()*0.08})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 2 + Math.random() * 5, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }

    // ============ EARTH CLOUD TEXTURE ============
    function earthCloudTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            ctx.clearRect(0, 0, w, h);
            
            // Wispy cloud bands
            for (let band = 0; band < 8; band++) {
                const bandY = (band / 8) * h + Math.random() * 20 - 10;
                const bandWidth = 15 + Math.random() * 30;
                for (let i = 0; i < 40; i++) {
                    ctx.fillStyle = `rgba(255,255,255,${0.02 + Math.random() * 0.06})`;
                    ctx.beginPath();
                    ctx.ellipse(
                        Math.random() * w,
                        bandY + (Math.random() - 0.5) * bandWidth,
                        8 + Math.random() * 25,
                        3 + Math.random() * 10,
                        Math.random() * Math.PI,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            // Scattered cloud clusters
            for (let i = 0; i < 60; i++) {
                const cx = Math.random() * w;
                const cy = Math.random() * h;
                const size = 5 + Math.random() * 20;
                for (let j = 0; j < 5; j++) {
                    ctx.fillStyle = `rgba(255,255,255,${0.015 + Math.random() * 0.04})`;
                    ctx.beginPath();
                    ctx.ellipse(
                        cx + (Math.random() - 0.5) * size * 2,
                        cy + (Math.random() - 0.5) * size,
                        size * (0.5 + Math.random()),
                        size * (0.3 + Math.random() * 0.4),
                        Math.random() * Math.PI,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            // Tropical storm-like spiral patches
            for (let s = 0; s < 3; s++) {
                const sx = Math.random() * w;
                const sy = h * 0.3 + Math.random() * h * 0.4;
                for (let a = 0; a < 20; a++) {
                    const angle = a * 0.5 + Math.random();
                    const dist = 3 + a * 1.5;
                    ctx.fillStyle = `rgba(255,255,255,${0.02 + Math.random()*0.03})`;
                    ctx.beginPath();
                    ctx.ellipse(
                        sx + Math.cos(angle) * dist,
                        sy + Math.sin(angle) * dist * 0.6,
                        4 + Math.random() * 6,
                        2 + Math.random() * 3,
                        angle, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
        });
    }

    function marsTexture() {
        return makeTexture(256, 128, (ctx, w, h) => {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#a0522d');
            grad.addColorStop(0.3, '#c0603d');
            grad.addColorStop(0.5, '#b5513a');
            grad.addColorStop(0.7, '#a0452d');
            grad.addColorStop(1, '#803520');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);
            // Surface features
            for (let i = 0; i < 80; i++) {
                ctx.fillStyle = `rgba(${130 + Math.random()*40}, ${50 + Math.random()*30}, ${20 + Math.random()*20}, 0.2)`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 1 + Math.random() * 4, 0, Math.PI * 2);
                ctx.fill();
            }
            // Polar caps
            ctx.fillStyle = 'rgba(230,220,210,0.4)';
            ctx.fillRect(0, 0, w, 8);
            ctx.fillRect(0, h - 8, w, 8);
            // Valles Marineris-like feature
            ctx.strokeStyle = 'rgba(80,30,10,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(w * 0.3, h * 0.45);
            ctx.bezierCurveTo(w * 0.4, h * 0.42, w * 0.6, h * 0.48, w * 0.7, h * 0.44);
            ctx.stroke();
        });
    }

    function jupiterTexture() {
        return makeTexture(256, 128, (ctx, w, h) => {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#c4956a');
            grad.addColorStop(0.15, '#d4a87a');
            grad.addColorStop(0.25, '#b8845a');
            grad.addColorStop(0.35, '#e8c8a0');
            grad.addColorStop(0.45, '#c4956a');
            grad.addColorStop(0.55, '#b07550');
            grad.addColorStop(0.65, '#d4a87a');
            grad.addColorStop(0.75, '#c08060');
            grad.addColorStop(0.85, '#d4b08a');
            grad.addColorStop(1, '#c4956a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);
            // Band details
            for (let i = 0; i < 120; i++) {
                ctx.fillStyle = `rgba(${160 + Math.random()*60}, ${100 + Math.random()*60}, ${60 + Math.random()*40}, 0.15)`;
                ctx.fillRect(0, Math.random() * h, w, 1 + Math.random() * 3);
            }
            // Great Red Spot
            ctx.fillStyle = 'rgba(180,70,40,0.5)';
            ctx.beginPath();
            ctx.ellipse(w * 0.6, h * 0.55, 14, 9, 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(200,90,50,0.3)';
            ctx.beginPath();
            ctx.ellipse(w * 0.6, h * 0.55, 10, 6, 0.1, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function saturnTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            // Base gradient - muted golds, tans, with blue-grey poles (Cassini palette)
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            // North pole - blue-grey hexagonal storm region
            grad.addColorStop(0,    '#5a7a8e');  // Deep blue-grey at top
            grad.addColorStop(0.04, '#6a8a9a');  // Blue polar cap
            grad.addColorStop(0.10, '#8a9da8');  // Transitioning from blue
            grad.addColorStop(0.15, '#b5aa8a');  // Pale gold
            grad.addColorStop(0.22, '#c8b898');  // Warm cream
            grad.addColorStop(0.28, '#d5c8a5');  // Light gold band
            grad.addColorStop(0.33, '#c0ad85');  // Darker tan band
            grad.addColorStop(0.38, '#ddd2b5');  // Bright cream
            grad.addColorStop(0.42, '#c8b590');  // Medium gold
            grad.addColorStop(0.48, '#e0d5ba');  // Pale warm white
            grad.addColorStop(0.52, '#d8c8a0');  // Classic Saturn gold
            grad.addColorStop(0.58, '#c5b28a');  // Darker band
            grad.addColorStop(0.62, '#ddd0b0');  // Light band
            grad.addColorStop(0.68, '#c0a878');  // Warm amber
            grad.addColorStop(0.72, '#d5c8a0');  // Light gold
            grad.addColorStop(0.78, '#bfb090');  // Muted tan
            grad.addColorStop(0.85, '#a0a5a0');  // Grey-blue southern transition
            grad.addColorStop(0.92, '#7a8e8a');  // Blue-grey south
            grad.addColorStop(1,    '#5a7080');  // South pole blue-grey
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // --- ATMOSPHERIC BANDS (subtle, horizontal) ---
            // Fine band structure across the whole planet
            for (let i = 0; i < 200; i++) {
                const y = Math.random() * h;
                const normalizedY = y / h;
                let r, g, b, a;
                
                if (normalizedY < 0.12 || normalizedY > 0.88) {
                    // Polar regions - blue-grey tones
                    r = 80 + Math.random() * 30;
                    g = 100 + Math.random() * 30;
                    b = 120 + Math.random() * 30;
                    a = 0.08 + Math.random() * 0.12;
                } else {
                    // Mid-latitudes - golds, creams, tans
                    r = 170 + Math.random() * 50;
                    g = 155 + Math.random() * 50;
                    b = 100 + Math.random() * 50;
                    a = 0.06 + Math.random() * 0.1;
                }
                ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
                ctx.fillRect(0, y, w, 0.5 + Math.random() * 2);
            }

            // --- NORTH POLAR HEXAGON ---
            // The famous hexagonal storm at Saturn's north pole
            // On an equirectangular texture, the north pole is the top edge
            const hexCenterX = w / 2;
            const hexCenterY = h * 0.04;
            const hexRadius = 28;
            
            // Hexagon outline (dark blue storm boundary)
            ctx.strokeStyle = 'rgba(40,60,90,0.5)';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                const px = hexCenterX + Math.cos(angle) * hexRadius;
                const py = hexCenterY + Math.sin(angle) * hexRadius * 0.4; // Squished due to projection
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.stroke();

            // Fill hexagon interior with darker blue
            ctx.fillStyle = 'rgba(35,55,85,0.35)';
            ctx.fill();

            // Inner vortex eye
            ctx.fillStyle = 'rgba(25,45,75,0.4)';
            ctx.beginPath();
            ctx.ellipse(hexCenterX, hexCenterY, 8, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Spiral arms inside hexagon
            for (let arm = 0; arm < 3; arm++) {
                ctx.strokeStyle = `rgba(50,70,100,${0.15 + Math.random()*0.1})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let t = 0; t < 20; t++) {
                    const angle = arm * Math.PI * 2 / 3 + t * 0.4;
                    const dist = 3 + t * 1.1;
                    const px = hexCenterX + Math.cos(angle) * dist;
                    const py = hexCenterY + Math.sin(angle) * dist * 0.4;
                    if (t === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            }

            // --- STORM FEATURES ---
            // White storm spots (like the Great White Spot that appears periodically)
            for (let s = 0; s < 5; s++) {
                const sx = Math.random() * w;
                const sy = h * 0.25 + Math.random() * h * 0.5;
                ctx.fillStyle = `rgba(230,225,210,${0.08 + Math.random()*0.06})`;
                ctx.beginPath();
                ctx.ellipse(sx, sy, 3 + Math.random() * 6, 1.5 + Math.random() * 3, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Darker storm eddies
            for (let s = 0; s < 8; s++) {
                const sx = Math.random() * w;
                const sy = h * 0.2 + Math.random() * h * 0.6;
                ctx.fillStyle = `rgba(120,100,70,${0.06 + Math.random()*0.05})`;
                ctx.beginPath();
                ctx.ellipse(sx, sy, 2 + Math.random() * 5, 1 + Math.random() * 2.5, Math.random(), 0, Math.PI * 2);
                ctx.fill();
            }

            // --- SUBTLE WIND SHEAR STREAKS ---
            // These give the impression of high-speed jet streams
            for (let i = 0; i < 40; i++) {
                const y = h * 0.15 + Math.random() * h * 0.7;
                const x = Math.random() * w;
                const len = 15 + Math.random() * 40;
                ctx.strokeStyle = `rgba(200,190,160,${0.03 + Math.random()*0.04})`;
                ctx.lineWidth = 0.5 + Math.random();
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.bezierCurveTo(
                    x + len * 0.3, y + (Math.random() - 0.5) * 3,
                    x + len * 0.6, y + (Math.random() - 0.5) * 3,
                    x + len, y + (Math.random() - 0.5) * 2
                );
                ctx.stroke();
            }

            // --- SOUTH POLAR VORTEX ---
            ctx.fillStyle = 'rgba(40,60,75,0.3)';
            ctx.beginPath();
            ctx.ellipse(w / 2, h - h * 0.03, 15, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(30,50,65,0.25)';
            ctx.beginPath();
            ctx.ellipse(w / 2, h - h * 0.03, 6, 3, 0, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function uranusTexture() {
        return makeTexture(256, 128, (ctx, w, h) => {
            // Uranus: pale blue-green, very uniform compared to other giants
            // The methane in its atmosphere absorbs red light, giving it that distinctive cyan
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0,    '#6aacb8');  // Slightly grey-green pole
            grad.addColorStop(0.1,  '#78c0cc');
            grad.addColorStop(0.2,  '#82ccd8');
            grad.addColorStop(0.35, '#8ed4de');
            grad.addColorStop(0.45, '#96dae4');  // Brighter equatorial
            grad.addColorStop(0.55, '#96dae4');
            grad.addColorStop(0.65, '#8ed4de');
            grad.addColorStop(0.8,  '#82ccd8');
            grad.addColorStop(0.9,  '#78c0cc');
            grad.addColorStop(1,    '#6aacb8');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Very subtle banding (Uranus looks almost featureless)
            for (let i = 0; i < 80; i++) {
                const y = Math.random() * h;
                const r = 100 + Math.random() * 40;
                const g = 190 + Math.random() * 30;
                const b = 200 + Math.random() * 30;
                ctx.fillStyle = `rgba(${r},${g},${b},${0.03 + Math.random() * 0.04})`;
                ctx.fillRect(0, y, w, 0.5 + Math.random() * 2);
            }

            // Faint south polar brightening (Hubble observed this)
            for (let i = 0; i < 12; i++) {
                ctx.fillStyle = `rgba(170, 220, 230, ${0.02+Math.random()*0.03})`;
                ctx.beginPath();
                ctx.ellipse(Math.random()*w, h - Math.random()*15, 5+Math.random()*10, 2+Math.random()*4, Math.random(), 0, Math.PI*2);
                ctx.fill();
            }

            // Very faint cloud features
            for (let i = 0; i < 6; i++) {
                ctx.fillStyle = `rgba(180, 230, 240, ${0.03+Math.random()*0.03})`;
                ctx.beginPath();
                ctx.ellipse(Math.random()*w, h*0.2+Math.random()*h*0.6, 3+Math.random()*8, 1.5+Math.random()*3, 0, 0, Math.PI*2);
                ctx.fill();
            }
        });
    }

    function neptuneTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            // Rich deep blue gradient - Neptune is the deepest blue planet
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            // Poles are slightly darker/greyer
            grad.addColorStop(0,    '#1a2a6a');
            grad.addColorStop(0.08, '#2040a0');
            grad.addColorStop(0.15, '#2858c0');
            grad.addColorStop(0.22, '#3068d0');
            grad.addColorStop(0.30, '#2a5cc8');
            grad.addColorStop(0.38, '#3570d8');
            grad.addColorStop(0.45, '#4080e0'); // Bright equatorial band
            grad.addColorStop(0.50, '#4588e4');
            grad.addColorStop(0.55, '#4080e0');
            grad.addColorStop(0.62, '#3570d8');
            grad.addColorStop(0.70, '#2a5cc8');
            grad.addColorStop(0.78, '#3068d0');
            grad.addColorStop(0.85, '#2858c0');
            grad.addColorStop(0.92, '#2040a0');
            grad.addColorStop(1,    '#1a2a6a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Atmospheric banding - subtle horizontal bands
            for (let i = 0; i < 150; i++) {
                const y = Math.random() * h;
                const normalY = y / h;
                // Vary the blue tones
                const r = 20 + Math.random() * 30;
                const g = 50 + Math.random() * 50 + (0.5 - Math.abs(normalY - 0.5)) * 40;
                const b = 150 + Math.random() * 80;
                ctx.fillStyle = `rgba(${r},${g},${b},${0.06 + Math.random() * 0.08})`;
                ctx.fillRect(0, y, w, 0.5 + Math.random() * 2.5);
            }

            // Brighter equatorial zone (lighter blue-cyan band)
            for (let i = 0; i < 40; i++) {
                const y = h * 0.42 + Math.random() * h * 0.16;
                ctx.fillStyle = `rgba(${60+Math.random()*30}, ${130+Math.random()*40}, ${220+Math.random()*35}, ${0.04+Math.random()*0.05})`;
                ctx.fillRect(0, y, w, 1 + Math.random() * 2);
            }

            // Dark storm bands in southern hemisphere
            for (let i = 0; i < 20; i++) {
                const y = h * 0.55 + Math.random() * h * 0.2;
                ctx.fillStyle = `rgba(15, 25, ${80+Math.random()*40}, ${0.05+Math.random()*0.06})`;
                ctx.fillRect(0, y, w, 1 + Math.random() * 3);
            }

            // Great Dark Spot (like Voyager 2 observed) — southern hemisphere
            const gdsx = w * 0.35;
            const gdsy = h * 0.58;
            // Outer dark region
            ctx.fillStyle = 'rgba(10, 18, 60, 0.35)';
            ctx.beginPath();
            ctx.ellipse(gdsx, gdsy, 22, 14, -0.15, 0, Math.PI * 2);
            ctx.fill();
            // Inner darker core
            ctx.fillStyle = 'rgba(8, 12, 45, 0.3)';
            ctx.beginPath();
            ctx.ellipse(gdsx, gdsy, 14, 8, -0.15, 0, Math.PI * 2);
            ctx.fill();
            // Bright companion cloud (white streak south of the dark spot)
            ctx.fillStyle = 'rgba(180, 210, 255, 0.2)';
            ctx.beginPath();
            ctx.ellipse(gdsx + 5, gdsy + 16, 18, 4, 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(220, 240, 255, 0.15)';
            ctx.beginPath();
            ctx.ellipse(gdsx + 8, gdsy + 17, 10, 2.5, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Scooter (small bright cloud feature)
            ctx.fillStyle = 'rgba(200, 230, 255, 0.18)';
            ctx.beginPath();
            ctx.ellipse(w * 0.6, h * 0.52, 6, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Small Dark Spot 2 (southern)
            ctx.fillStyle = 'rgba(10, 15, 50, 0.2)';
            ctx.beginPath();
            ctx.ellipse(w * 0.7, h * 0.68, 8, 5, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // High-altitude bright cloud streaks (methane ice clouds)
            for (let i = 0; i < 15; i++) {
                const sx = Math.random() * w;
                const sy = h * 0.25 + Math.random() * h * 0.5;
                const len = 10 + Math.random() * 30;
                ctx.strokeStyle = `rgba(${180+Math.random()*60}, ${210+Math.random()*40}, 255, ${0.04+Math.random()*0.06})`;
                ctx.lineWidth = 0.5 + Math.random() * 1.5;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.bezierCurveTo(
                    sx + len*0.3, sy + (Math.random()-0.5)*4,
                    sx + len*0.7, sy + (Math.random()-0.5)*4,
                    sx + len, sy + (Math.random()-0.5)*2
                );
                ctx.stroke();
            }

            // Bright south polar region
            for (let i = 0; i < 15; i++) {
                ctx.fillStyle = `rgba(60, 100, 200, ${0.03+Math.random()*0.04})`;
                ctx.beginPath();
                ctx.ellipse(Math.random()*w, h - Math.random()*15, 5+Math.random()*10, 2+Math.random()*4, Math.random(), 0, Math.PI*2);
                ctx.fill();
            }
        });
    }

    // ============ REALISTIC MOON TEXTURE ============
    function moonTexture() {
        return makeTexture(512, 256, (ctx, w, h) => {
            // Base grey with subtle variation
            const baseGrad = ctx.createLinearGradient(0, 0, w, h);
            baseGrad.addColorStop(0, '#b0ada5');
            baseGrad.addColorStop(0.3, '#a8a59d');
            baseGrad.addColorStop(0.5, '#b5b2aa');
            baseGrad.addColorStop(0.7, '#a0a098');
            baseGrad.addColorStop(1, '#aba8a0');
            ctx.fillStyle = baseGrad;
            ctx.fillRect(0, 0, w, h);

            // Surface noise / regolith texture
            for (let i = 0; i < 400; i++) {
                const grey = 130 + Math.random() * 50;
                ctx.fillStyle = `rgba(${grey},${grey},${grey - 5},${0.05 + Math.random()*0.08})`;
                ctx.fillRect(Math.random() * w, Math.random() * h, 1 + Math.random() * 4, 1 + Math.random() * 4);
            }

            // --- NEAR SIDE MARIA (dark volcanic plains) ---
            // These are positioned on the left half of the texture (near side facing Earth)
            
            // Mare Imbrium (Sea of Showers) - large dark patch upper left
            ctx.fillStyle = 'rgba(65,63,58,0.45)';
            ctx.beginPath();
            ctx.ellipse(w * 0.18, h * 0.32, 32, 28, -0.2, 0, Math.PI * 2);
            ctx.fill();
            // Lighter inner
            ctx.fillStyle = 'rgba(75,72,67,0.25)';
            ctx.beginPath();
            ctx.ellipse(w * 0.18, h * 0.33, 22, 18, -0.1, 0, Math.PI * 2);
            ctx.fill();

            // Mare Serenitatis (Sea of Serenity) - right of Imbrium
            ctx.fillStyle = 'rgba(68,65,60,0.42)';
            ctx.beginPath();
            ctx.ellipse(w * 0.30, h * 0.28, 18, 16, 0.15, 0, Math.PI * 2);
            ctx.fill();

            // Mare Tranquillitatis (Sea of Tranquility) - where Apollo 11 landed
            ctx.fillStyle = 'rgba(62,60,55,0.4)';
            ctx.beginPath();
            ctx.ellipse(w * 0.35, h * 0.40, 20, 18, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Mare Crisium (Sea of Crises) - isolated dark oval
            ctx.fillStyle = 'rgba(70,67,62,0.4)';
            ctx.beginPath();
            ctx.ellipse(w * 0.42, h * 0.30, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Mare Fecunditatis (Sea of Fertility)
            ctx.fillStyle = 'rgba(65,63,58,0.35)';
            ctx.beginPath();
            ctx.ellipse(w * 0.40, h * 0.50, 16, 14, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Mare Nubium (Sea of Clouds) - southern
            ctx.fillStyle = 'rgba(68,65,60,0.38)';
            ctx.beginPath();
            ctx.ellipse(w * 0.22, h * 0.55, 18, 12, -0.1, 0, Math.PI * 2);
            ctx.fill();

            // Oceanus Procellarum (Ocean of Storms) - large western patch
            ctx.fillStyle = 'rgba(72,70,65,0.35)';
            ctx.beginPath();
            ctx.ellipse(w * 0.08, h * 0.40, 22, 35, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // --- FAR SIDE: much fewer maria, more highlands ---
            // Far side is mostly bright highland terrain with only a couple small dark patches
            ctx.fillStyle = 'rgba(75,73,68,0.2)';
            ctx.beginPath();
            ctx.ellipse(w * 0.72, h * 0.35, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // --- CRATERS ---
            // Large named craters
            function drawCrater(cx, cy, radius, depth) {
                // Crater rim (lighter ring)
                ctx.strokeStyle = `rgba(180,175,168,${0.3 + depth * 0.2})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.stroke();
                // Shadow inside (darker on one side)
                ctx.fillStyle = `rgba(50,48,45,${0.15 + depth * 0.15})`;
                ctx.beginPath();
                ctx.arc(cx + 1, cy + 1, radius * 0.8, 0, Math.PI * 2);
                ctx.fill();
                // Bright rim highlight
                ctx.fillStyle = `rgba(190,185,178,${0.1 + depth * 0.1})`;
                ctx.beginPath();
                ctx.arc(cx - 1, cy - 1, radius * 0.9, Math.PI * 0.8, Math.PI * 1.8);
                ctx.fill();
                // Central peak for larger craters
                if (radius > 5) {
                    ctx.fillStyle = `rgba(160,155,148,${0.2})`;
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Tycho (bright rayed crater, southern)
            drawCrater(w * 0.22, h * 0.72, 8, 0.8);
            // Rays from Tycho
            for (let r = 0; r < 8; r++) {
                const angle = r * Math.PI / 4 + Math.random() * 0.3;
                ctx.strokeStyle = 'rgba(200,195,188,0.08)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(w * 0.22, h * 0.72);
                ctx.lineTo(
                    w * 0.22 + Math.cos(angle) * (40 + Math.random() * 30),
                    h * 0.72 + Math.sin(angle) * (40 + Math.random() * 30)
                );
                ctx.stroke();
            }

            // Copernicus
            drawCrater(w * 0.15, h * 0.42, 7, 0.7);
            // Kepler
            drawCrater(w * 0.06, h * 0.42, 4, 0.5);
            // Aristarchus (brightest crater)
            drawCrater(w * 0.04, h * 0.30, 4, 0.9);
            // Plato
            drawCrater(w * 0.17, h * 0.20, 6, 0.4);
            // Clavius (large southern)
            drawCrater(w * 0.20, h * 0.78, 9, 0.5);

            // Medium craters
            for (let i = 0; i < 30; i++) {
                drawCrater(
                    Math.random() * w,
                    Math.random() * h,
                    2 + Math.random() * 5,
                    0.3 + Math.random() * 0.4
                );
            }

            // Small craters
            for (let i = 0; i < 100; i++) {
                const cx = Math.random() * w;
                const cy = Math.random() * h;
                const r = 0.5 + Math.random() * 2;
                ctx.fillStyle = `rgba(80,78,73,${0.1 + Math.random()*0.15})`;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();
            }

            // Subtle highland brightness variation
            for (let i = 0; i < 60; i++) {
                ctx.fillStyle = `rgba(180,175,168,${0.02 + Math.random()*0.04})`;
                ctx.beginPath();
                ctx.ellipse(
                    Math.random() * w, Math.random() * h,
                    5 + Math.random() * 15, 5 + Math.random() * 10,
                    Math.random() * Math.PI, 0, Math.PI * 2
                );
                ctx.fill();
            }
        });
    }

    // ============ GALILEAN MOON TEXTURES ============
    function ioTexture() {
        // Io: volcanic, yellow-orange with dark volcanic spots
        return makeTexture(128, 64, (ctx, w, h) => {
            // Yellow-orange sulphur base
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#d4c44a');
            grad.addColorStop(0.3, '#e0b830');
            grad.addColorStop(0.5, '#d8c040');
            grad.addColorStop(0.7, '#c8a828');
            grad.addColorStop(1, '#d0b838');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);
            // Sulphur plains variation
            for (let i = 0; i < 60; i++) {
                ctx.fillStyle = `rgba(${200 + Math.random()*40}, ${160 + Math.random()*40}, ${20 + Math.random()*30}, 0.15)`;
                ctx.beginPath();
                ctx.ellipse(Math.random()*w, Math.random()*h, 2+Math.random()*5, 1+Math.random()*3, Math.random()*Math.PI, 0, Math.PI*2);
                ctx.fill();
            }
            // Dark volcanic calderas (Loki, Pele, etc.)
            for (let i = 0; i < 12; i++) {
                ctx.fillStyle = `rgba(${40+Math.random()*30}, ${30+Math.random()*20}, ${10+Math.random()*10}, ${0.3+Math.random()*0.3})`;
                ctx.beginPath();
                ctx.arc(Math.random()*w, Math.random()*h, 1.5+Math.random()*3, 0, Math.PI*2);
                ctx.fill();
            }
            // Bright red volcanic deposits around vents
            for (let i = 0; i < 8; i++) {
                ctx.fillStyle = `rgba(200, ${60+Math.random()*40}, 20, ${0.15+Math.random()*0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random()*w, Math.random()*h, 2+Math.random()*4, 0, Math.PI*2);
                ctx.fill();
            }
            // White SO2 frost patches
            for (let i = 0; i < 10; i++) {
                ctx.fillStyle = `rgba(240, 235, 210, ${0.1+Math.random()*0.1})`;
                ctx.beginPath();
                ctx.ellipse(Math.random()*w, Math.random()*h, 2+Math.random()*4, 1+Math.random()*2, Math.random(), 0, Math.PI*2);
                ctx.fill();
            }
        });
    }

    function europaTexture() {
        // Europa: icy white/cream with brown-red crack lines
        return makeTexture(128, 64, (ctx, w, h) => {
            // Icy white-cream base
            ctx.fillStyle = '#d8d4c8';
            ctx.fillRect(0, 0, w, h);
            // Subtle ice variation
            for (let i = 0; i < 80; i++) {
                const grey = 200 + Math.random() * 40;
                ctx.fillStyle = `rgba(${grey}, ${grey-2}, ${grey-8}, 0.08)`;
                ctx.fillRect(Math.random()*w, Math.random()*h, 1+Math.random()*4, 1+Math.random()*3);
            }
            // Linea (brown-red crack lines across the surface)
            for (let i = 0; i < 25; i++) {
                ctx.strokeStyle = `rgba(${120+Math.random()*40}, ${70+Math.random()*30}, ${40+Math.random()*20}, ${0.15+Math.random()*0.2})`;
                ctx.lineWidth = 0.3 + Math.random() * 0.8;
                ctx.beginPath();
                const sx = Math.random() * w;
                const sy = Math.random() * h;
                ctx.moveTo(sx, sy);
                // Curved crack lines
                const segments = 3 + Math.floor(Math.random() * 4);
                for (let j = 0; j < segments; j++) {
                    ctx.lineTo(
                        sx + (Math.random()-0.3) * 40,
                        sy + (Math.random()-0.5) * 25
                    );
                }
                ctx.stroke();
            }
            // Slight blue-tinted regions (fresher ice)
            for (let i = 0; i < 6; i++) {
                ctx.fillStyle = `rgba(180, 195, 210, ${0.06+Math.random()*0.06})`;
                ctx.beginPath();
                ctx.ellipse(Math.random()*w, Math.random()*h, 4+Math.random()*8, 3+Math.random()*5, Math.random(), 0, Math.PI*2);
                ctx.fill();
            }
        });
    }

    function ganymedeTexture() {
        // Ganymede: two-toned - dark ancient terrain + bright grooved terrain
        return makeTexture(128, 64, (ctx, w, h) => {
            // Medium grey base
            ctx.fillStyle = '#908880';
            ctx.fillRect(0, 0, w, h);
            // Dark regions (older terrain)
            for (let i = 0; i < 8; i++) {
                ctx.fillStyle = `rgba(60, 55, 50, ${0.15+Math.random()*0.15})`;
                ctx.beginPath();
                ctx.ellipse(Math.random()*w, Math.random()*h, 6+Math.random()*12, 4+Math.random()*8, Math.random()*Math.PI, 0, Math.PI*2);
                ctx.fill();
            }
            // Bright grooved terrain (lighter patches)
            for (let i = 0; i < 10; i++) {
                ctx.fillStyle = `rgba(170, 165, 155, ${0.15+Math.random()*0.12})`;
                ctx.beginPath();
                ctx.ellipse(Math.random()*w, Math.random()*h, 5+Math.random()*10, 3+Math.random()*6, Math.random()*Math.PI, 0, Math.PI*2);
                ctx.fill();
            }
            // Groove lines on bright terrain
            for (let i = 0; i < 20; i++) {
                ctx.strokeStyle = `rgba(140, 135, 125, ${0.1+Math.random()*0.1})`;
                ctx.lineWidth = 0.3 + Math.random() * 0.4;
                ctx.beginPath();
                ctx.moveTo(Math.random()*w, Math.random()*h);
                ctx.lineTo(Math.random()*w, Math.random()*h);
                ctx.stroke();
            }
            // Craters
            for (let i = 0; i < 15; i++) {
                ctx.fillStyle = `rgba(70,65,60,${0.1+Math.random()*0.1})`;
                ctx.beginPath();
                ctx.arc(Math.random()*w, Math.random()*h, 0.5+Math.random()*2, 0, Math.PI*2);
                ctx.fill();
            }
            // Polar cap (slight brightening)
            ctx.fillStyle = 'rgba(200,195,190,0.1)';
            ctx.fillRect(0, 0, w, 5);
            ctx.fillRect(0, h-5, w, 5);
        });
    }

    function callistoTexture() {
        // Callisto: heavily cratered dark surface
        return makeTexture(128, 64, (ctx, w, h) => {
            // Dark grey-brown base
            ctx.fillStyle = '#504840';
            ctx.fillRect(0, 0, w, h);
            // Surface variation
            for (let i = 0; i < 60; i++) {
                const v = 60 + Math.random() * 30;
                ctx.fillStyle = `rgba(${v+5}, ${v}, ${v-5}, ${0.08+Math.random()*0.08})`;
                ctx.fillRect(Math.random()*w, Math.random()*h, 1+Math.random()*3, 1+Math.random()*3);
            }
            // Many impact craters (Callisto is the most cratered body in solar system)
            for (let i = 0; i < 40; i++) {
                const cx = Math.random() * w;
                const cy = Math.random() * h;
                const r = 0.5 + Math.random() * 3;
                // Bright ejecta ring
                ctx.strokeStyle = `rgba(130,125,115, ${0.15+Math.random()*0.15})`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI*2);
                ctx.stroke();
                // Dark interior
                ctx.fillStyle = `rgba(35,32,28,${0.15+Math.random()*0.15})`;
                ctx.beginPath();
                ctx.arc(cx, cy, r*0.7, 0, Math.PI*2);
                ctx.fill();
            }
            // Valhalla multi-ring impact basin (bright concentric rings)
            const vx = w * 0.3, vy = h * 0.4;
            for (let ring = 0; ring < 5; ring++) {
                ctx.strokeStyle = `rgba(140,135,125, ${0.08 - ring*0.012})`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.arc(vx, vy, 3 + ring * 3, 0, Math.PI*2);
                ctx.stroke();
            }
            ctx.fillStyle = 'rgba(150,145,135,0.12)';
            ctx.beginPath();
            ctx.arc(vx, vy, 3, 0, Math.PI*2);
            ctx.fill();
        });
    }

    // ============ NEPTUNE MOON TEXTURES ============
    function tritonTexture() {
        // Triton: pinkish-tan cantaloupe terrain with bright south polar cap and dark plume streaks
        return makeTexture(256, 128, (ctx, w, h) => {
            // Pinkish-tan base (nitrogen/methane ice)
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#a8988a');
            grad.addColorStop(0.3, '#b8a898');
            grad.addColorStop(0.5, '#c0aa95');
            grad.addColorStop(0.7, '#c8b0a0');
            grad.addColorStop(0.85, '#d8c8b8');
            grad.addColorStop(1, '#e8ddd5');  // Bright south polar cap
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Cantaloupe terrain (dimpled, like melon rind) — unique to Triton
            for (let i = 0; i < 50; i++) {
                const cx = Math.random() * w;
                const cy = Math.random() * h * 0.75;
                const r = 2 + Math.random() * 4;
                // Depressed dimple
                ctx.fillStyle = `rgba(130,115,100, ${0.1+Math.random()*0.1})`;
                ctx.beginPath();
                ctx.ellipse(cx, cy, r, r*0.8, Math.random(), 0, Math.PI*2);
                ctx.fill();
                // Raised rim
                ctx.strokeStyle = `rgba(180,165,150, ${0.08+Math.random()*0.06})`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.ellipse(cx, cy, r*1.1, r*0.9, Math.random(), 0, Math.PI*2);
                ctx.stroke();
            }

            // Pink/salmon tinted regions
            for (let i = 0; i < 15; i++) {
                ctx.fillStyle = `rgba(${190+Math.random()*30}, ${140+Math.random()*30}, ${130+Math.random()*20}, ${0.06+Math.random()*0.06})`;
                ctx.beginPath();
                ctx.ellipse(Math.random()*w, Math.random()*h*0.7, 5+Math.random()*12, 3+Math.random()*8, Math.random(), 0, Math.PI*2);
                ctx.fill();
            }

            // South polar cap (bright, pinkish-white) — nitrogen ice
            ctx.fillStyle = 'rgba(230,220,212,0.3)';
            ctx.fillRect(0, h*0.82, w, h*0.18);
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(240,230,225, ${0.05+Math.random()*0.08})`;
                ctx.beginPath();
                ctx.ellipse(Math.random()*w, h*0.85+Math.random()*h*0.12, 4+Math.random()*10, 2+Math.random()*5, Math.random(), 0, Math.PI*2);
                ctx.fill();
            }

            // Dark windblown plume streaks from cryovolcanoes (pointing NE from polar cap)
            for (let i = 0; i < 8; i++) {
                const sx = Math.random() * w;
                const sy = h * 0.78 + Math.random() * h * 0.12;
                ctx.strokeStyle = `rgba(50,40,35, ${0.1+Math.random()*0.1})`;
                ctx.lineWidth = 0.5 + Math.random() * 1;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.bezierCurveTo(
                    sx + 10 + Math.random()*10, sy - 5 - Math.random()*8,
                    sx + 20 + Math.random()*15, sy - 10 - Math.random()*10,
                    sx + 30 + Math.random()*20, sy - 8 - Math.random()*12
                );
                ctx.stroke();
            }

            // Craters
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(90,80,72,${0.08+Math.random()*0.08})`;
                ctx.beginPath();
                ctx.arc(Math.random()*w, Math.random()*h, 0.5+Math.random()*2, 0, Math.PI*2);
                ctx.fill();
            }
        });
    }

    function proteusTexture() {
        // Proteus: irregular dark grey body, heavily cratered
        return makeTexture(64, 32, (ctx, w, h) => {
            ctx.fillStyle = '#484040';
            ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 20; i++) {
                const v = 50 + Math.random() * 30;
                ctx.fillStyle = `rgba(${v},${v-3},${v-5},${0.1+Math.random()*0.12})`;
                ctx.beginPath();
                ctx.arc(Math.random()*w, Math.random()*h, 0.5+Math.random()*2, 0, Math.PI*2);
                ctx.fill();
            }
        });
    }

    // ================= PLANET SYSTEM =================
    const planets = [];
    const labelsContainer = document.getElementById('labels-container');

    // Moon orbit config
    const MOON_ORBIT_RADIUS_MULT = 11;

    function createPlanet(name, radius, dist, texFn, isSun=false) {
        const grp = new THREE.Group();
        grp.position.set(dist, 0, 0);
        
        const geo = new THREE.SphereGeometry(radius, 64, 64);
        
        const mat = isSun 
            ? new THREE.MeshBasicMaterial({ map: texFn(), fog: false }) 
            : new THREE.MeshStandardMaterial({ map: texFn(), roughness: 0.9, metalness: 0.1 });
            
        const mesh = new THREE.Mesh(geo, mat);
        mesh.name = "PM_" + name;
        grp.add(mesh);

        // --- EARTH SPECIFIC: ADD MOON + CLOUDS + ATMOSPHERE ---
        let moonMesh = null;
        let cloudMesh = null;
        let atmosphereMesh = null;
        if(name === "EARTH") {
            // MOON
            const moonRadius = radius * 0.27;
            const mGeo = new THREE.SphereGeometry(moonRadius, 32, 32);
            const mMat = new THREE.MeshStandardMaterial({ map: moonTexture(), roughness: 0.95 });
            moonMesh = new THREE.Mesh(mGeo, mMat);
            moonMesh.position.set(radius * MOON_ORBIT_RADIUS_MULT, 0, 0); 
            grp.add(moonMesh);

            // CLOUD LAYER - slightly larger transparent sphere
            const cloudGeo = new THREE.SphereGeometry(radius * 1.015, 64, 64);
            const cloudMat = new THREE.MeshStandardMaterial({
                map: earthCloudTexture(),
                transparent: true,
                opacity: 0.45,
                depthWrite: false,
                roughness: 1.0,
                metalness: 0.0
            });
            cloudMesh = new THREE.Mesh(cloudGeo, cloudMat);
            grp.add(cloudMesh);

            // ATMOSPHERE GLOW - backside rendered blue haze
            const atmosGeo = new THREE.SphereGeometry(radius * 1.08, 64, 64);
            const atmosMat = new THREE.MeshBasicMaterial({
                color: 0x4488ff,
                transparent: true,
                opacity: 0.12,
                side: THREE.BackSide
            });
            atmosphereMesh = new THREE.Mesh(atmosGeo, atmosMat);
            grp.add(atmosphereMesh);

            // Thin bright atmosphere rim
            const rimGeo = new THREE.SphereGeometry(radius * 1.04, 64, 64);
            const rimMat = new THREE.MeshBasicMaterial({
                color: 0x88bbff,
                transparent: true,
                opacity: 0.08,
                side: THREE.BackSide
            });
            grp.add(new THREE.Mesh(rimGeo, rimMat));
        }
        
        // --- SUN SPECIFIC: ADD CORONA GLOW ---
        if(isSun) {
            const coronaLayers = [
                { scale: 1.15, color: 0xff8c00, opacity: 0.12 },
                { scale: 1.35, color: 0xff6600, opacity: 0.06 },
                { scale: 1.6,  color: 0xff4400, opacity: 0.025 }
            ];
            coronaLayers.forEach(layer => {
                const gGeo = new THREE.SphereGeometry(radius * layer.scale, 32, 32);
                const gMat = new THREE.MeshBasicMaterial({
                    color: layer.color,
                    transparent: true,
                    opacity: layer.opacity,
                    side: THREE.BackSide,
                    fog: false
                });
                grp.add(new THREE.Mesh(gGeo, gMat));
            });
        }

        systemGroup.add(grp);

        const label = document.createElement('div');
        label.className = 'planet-label';
        label.innerHTML = `<div class="label-name">${name}</div><div class="label-dist"></div>`;
        labelsContainer.appendChild(label);

        planets.push({
            name, grp, mesh, radius, dist, label, moonMesh, cloudMesh,
            moons: [],
            angle: Math.random()*10,
            orbitSpeed: dist === 0 ? 0 : (20000 / dist) * 0.0001
        });
    }

    // ==========================================
    // SCALED PLANET SIZES & DISTANCES
    // ==========================================
    createPlanet("SUN",     config.sunRadius, 0,        sunTexture, true);
    createPlanet("MERCURY", 400,    80000,   mercuryTexture);
    createPlanet("VENUS",   900,    140000,  venusTexture);
    createPlanet("EARTH",   1000,   200000,  earthTexture);
    createPlanet("MARS",    500,    300000,  marsTexture);
    createPlanet("JUPITER", 5000,   600000,  jupiterTexture);
    createPlanet("SATURN",  4500,   1000000, saturnTexture);
    createPlanet("URANUS",  2000,   1800000, uranusTexture);
    createPlanet("NEPTUNE", 1900,   2600000, neptuneTexture);

    // Saturn Ring System — concentric rings with Cassini Division
    const saturnP = planets.find(p => p.name === "SATURN");
    if(saturnP) {
        const R = saturnP.radius; // 4500
        const segs = 128;

        // Helper to add a ring band
        function addRingBand(inner, outer, color, opacity) {
            const geo = new THREE.RingGeometry(R * inner, R * outer, segs);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: opacity,
                depthWrite: false
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = Math.PI / 2;
            saturnP.grp.add(mesh);
        }

        // D Ring — very faint innermost
        addRingBand(1.11, 1.24, 0x8a8580, 0.06);

        // C Ring (Crepe Ring) — semi-transparent, warm grey
        addRingBand(1.24, 1.29, 0x9a9488, 0.14);
        addRingBand(1.29, 1.32, 0xa09a8e, 0.18);
        // Maxwell Gap
        addRingBand(1.32, 1.33, 0x000000, 0.01);
        addRingBand(1.33, 1.39, 0xa89e90, 0.20);
        addRingBand(1.39, 1.44, 0xb0a898, 0.22);

        // B Ring — brightest and densest, warm cream/gold
        addRingBand(1.44, 1.50, 0xc8bea5, 0.55);
        addRingBand(1.50, 1.56, 0xd0c8b0, 0.65);
        addRingBand(1.56, 1.62, 0xd5ccb5, 0.70);
        addRingBand(1.62, 1.68, 0xd8d0ba, 0.72); // Peak brightness
        addRingBand(1.68, 1.74, 0xd5ccb5, 0.68);
        addRingBand(1.74, 1.80, 0xcec5ad, 0.62);
        addRingBand(1.80, 1.86, 0xc8bea5, 0.55);
        addRingBand(1.86, 1.92, 0xc0b89e, 0.50);

        // === CASSINI DIVISION === (the famous dark gap ~4800 km wide)
        addRingBand(1.92, 2.02, 0x1a1816, 0.04);

        // A Ring — outer bright ring, slightly less dense than B
        addRingBand(2.02, 2.08, 0xbcb498, 0.42);
        addRingBand(2.08, 2.14, 0xc4bca0, 0.45);
        addRingBand(2.14, 2.20, 0xc0b89c, 0.43);
        // Encke Gap
        addRingBand(2.20, 2.215, 0x0a0a08, 0.02);
        addRingBand(2.215, 2.27, 0xb8b094, 0.38);
        // Keeler Gap
        addRingBand(2.27, 2.28, 0x0a0a08, 0.02);
        addRingBand(2.28, 2.32, 0xb0a890, 0.32);

        // F Ring — thin, bright, separate
        addRingBand(2.36, 2.39, 0xc8c0a8, 0.28);

        // G Ring — very faint
        addRingBand(2.55, 2.70, 0xa0a098, 0.03);

        // Saturn atmosphere glow
        const satAtmosGeo = new THREE.SphereGeometry(R * 1.06, 48, 48);
        const satAtmosMat = new THREE.MeshBasicMaterial({
            color: 0xd4c8a0,
            transparent: true,
            opacity: 0.06,
            side: THREE.BackSide
        });
        saturnP.grp.add(new THREE.Mesh(satAtmosGeo, satAtmosMat));

        // Saturn's axial tilt (~26.7 degrees) - gives the iconic angled ring view
        saturnP.grp.rotation.z = 0.466;
    }

    // ================= JUPITER'S GALILEAN MOONS =================
    const jupiterP = planets.find(p => p.name === "JUPITER");
    if(jupiterP) {
        const jR = jupiterP.radius; // 5000

        // Io — innermost, volcanic yellow-orange, radius ~1821km (Earth Moon ~1737km)
        const ioR = jR * 0.073; // ~365
        const ioGeo = new THREE.SphereGeometry(ioR, 24, 24);
        const ioMat = new THREE.MeshStandardMaterial({ map: ioTexture(), roughness: 0.9 });
        const ioMesh = new THREE.Mesh(ioGeo, ioMat);
        jupiterP.grp.add(ioMesh);
        jupiterP.moons.push({ mesh: ioMesh, orbitR: jR * 1.68, speed: 0.00012, name: 'IO' });

        // Europa — icy, slightly smaller than Moon, smoothest body in solar system
        const euR = jR * 0.062; // ~310
        const euGeo = new THREE.SphereGeometry(euR, 24, 24);
        const euMat = new THREE.MeshStandardMaterial({ map: europaTexture(), roughness: 0.85 });
        const euMesh = new THREE.Mesh(euGeo, euMat);
        jupiterP.grp.add(euMesh);
        jupiterP.moons.push({ mesh: euMesh, orbitR: jR * 2.68, speed: 0.00006, name: 'EUROPA' });

        // Ganymede — largest moon in solar system, bigger than Mercury
        const gaR = jR * 0.105; // ~525
        const gaGeo = new THREE.SphereGeometry(gaR, 24, 24);
        const gaMat = new THREE.MeshStandardMaterial({ map: ganymedeTexture(), roughness: 0.9 });
        const gaMesh = new THREE.Mesh(gaGeo, gaMat);
        jupiterP.grp.add(gaMesh);
        jupiterP.moons.push({ mesh: gaMesh, orbitR: jR * 4.28, speed: 0.00003, name: 'GANYMEDE' });

        // Callisto — heavily cratered, outermost Galilean moon
        const caR = jR * 0.096; // ~480
        const caGeo = new THREE.SphereGeometry(caR, 24, 24);
        const caMat = new THREE.MeshStandardMaterial({ map: callistoTexture(), roughness: 0.95 });
        const caMesh = new THREE.Mesh(caGeo, caMat);
        jupiterP.grp.add(caMesh);
        jupiterP.moons.push({ mesh: caMesh, orbitR: jR * 7.52, speed: 0.000013, name: 'CALLISTO' });

        // Jupiter's faint ring (yes, Jupiter has rings!)
        const jRingGeo = new THREE.RingGeometry(jR * 1.29, jR * 1.36, 64);
        const jRingMat = new THREE.MeshBasicMaterial({
            color: 0x8a7a60,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.04,
            depthWrite: false
        });
        const jRing = new THREE.Mesh(jRingGeo, jRingMat);
        jRing.rotation.x = Math.PI / 2;
        jupiterP.grp.add(jRing);

        // Jupiter slight axial tilt (~3.1°)
        jupiterP.grp.rotation.z = 0.054;
    }

    // ================= URANUS — THE SIDEWAYS PLANET =================
    const uranusP = planets.find(p => p.name === "URANUS");
    if(uranusP) {
        const uR = uranusP.radius; // 2000

        // Atmosphere glow — pale cyan
        const uAtmGeo = new THREE.SphereGeometry(uR * 1.07, 48, 48);
        const uAtmMat = new THREE.MeshBasicMaterial({
            color: 0x80d0d8,
            transparent: true,
            opacity: 0.08,
            side: THREE.BackSide
        });
        uranusP.grp.add(new THREE.Mesh(uAtmGeo, uAtmMat));

        // Uranus's faint ring system (discovered 1977)
        const uRingColors = [0x8a9aa0, 0x909898, 0x8a9098];
        [1.64, 1.75, 1.85].forEach((mult, i) => {
            const rGeo = new THREE.RingGeometry(uR * mult, uR * (mult + 0.02), 64);
            const rMat = new THREE.MeshBasicMaterial({
                color: uRingColors[i],
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.04,
                depthWrite: false
            });
            const rMesh = new THREE.Mesh(rGeo, rMat);
            rMesh.rotation.x = Math.PI / 2;
            uranusP.grp.add(rMesh);
        });

        // Uranus's extreme axial tilt — 97.8°! It rolls on its side
        uranusP.grp.rotation.z = 1.706;
    }

    // ================= NEPTUNE'S MOONS + ATMOSPHERE =================
    const neptuneP = planets.find(p => p.name === "NEPTUNE");
    if(neptuneP) {
        const nR = neptuneP.radius; // 1900

        // Triton — largest moon, retrograde orbit (orbits opposite direction!)
        // 7th largest moon in solar system, geologically active with cryovolcanoes
        const triR = nR * 0.14; // ~266
        const triGeo = new THREE.SphereGeometry(triR, 24, 24);
        const triMat = new THREE.MeshStandardMaterial({ map: tritonTexture(), roughness: 0.9 });
        const triMesh = new THREE.Mesh(triGeo, triMat);
        neptuneP.grp.add(triMesh);
        // Triton has a RETROGRADE orbit — negative speed (clockwise, opposite to others)
        neptuneP.moons.push({ mesh: triMesh, orbitR: nR * 5.6, speed: -0.00008, name: 'TRITON' });

        // Proteus — second largest, irregular dark body
        const proR = nR * 0.044; // ~83
        const proGeo = new THREE.SphereGeometry(proR, 16, 16);
        const proMat = new THREE.MeshStandardMaterial({ map: proteusTexture(), roughness: 0.95 });
        const proMesh = new THREE.Mesh(proGeo, proMat);
        neptuneP.grp.add(proMesh);
        neptuneP.moons.push({ mesh: proMesh, orbitR: nR * 2.1, speed: 0.00018, name: 'PROTEUS' });

        // Neptune atmosphere glow — deep blue
        const nAtmGeo = new THREE.SphereGeometry(nR * 1.08, 48, 48);
        const nAtmMat = new THREE.MeshBasicMaterial({
            color: 0x3070e0,
            transparent: true,
            opacity: 0.10,
            side: THREE.BackSide
        });
        neptuneP.grp.add(new THREE.Mesh(nAtmGeo, nAtmMat));

        // Thin bright atmosphere rim
        const nRimGeo = new THREE.SphereGeometry(nR * 1.04, 48, 48);
        const nRimMat = new THREE.MeshBasicMaterial({
            color: 0x5090ff,
            transparent: true,
            opacity: 0.06,
            side: THREE.BackSide
        });
        neptuneP.grp.add(new THREE.Mesh(nRimGeo, nRimMat));

        // Neptune's faint rings
        const nRing1Geo = new THREE.RingGeometry(nR * 1.69, nR * 1.72, 64);
        const nRingMat = new THREE.MeshBasicMaterial({
            color: 0x607090,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.03,
            depthWrite: false
        });
        const nRing1 = new THREE.Mesh(nRing1Geo, nRingMat);
        nRing1.rotation.x = Math.PI / 2;
        neptuneP.grp.add(nRing1);

        // Adams ring (outermost, with arcs)
        const nRing2Geo = new THREE.RingGeometry(nR * 2.08, nR * 2.11, 64);
        const nRing2 = new THREE.Mesh(nRing2Geo, nRingMat.clone());
        nRing2.rotation.x = Math.PI / 2;
        neptuneP.grp.add(nRing2);

        // Neptune's axial tilt (~28.3° — similar to Earth!)
        neptuneP.grp.rotation.z = 0.494;
    }

    // ================= SPAWN ON EARTH =================
    const earthSpawn = planets.find(p => p.name === "EARTH");
    const spawnTime = Date.now();
    if(earthSpawn && earthSpawn.dist > 0) {
        // Set Earth's initial orbit position
        earthSpawn.grp.position.x = Math.cos(earthSpawn.angle + spawnTime * earthSpawn.orbitSpeed) * earthSpawn.dist;
        earthSpawn.grp.position.z = Math.sin(earthSpawn.angle + spawnTime * earthSpawn.orbitSpeed) * earthSpawn.dist;
    }
    // Place camera on Earth's equator (Z offset = equatorial surface)
    camera.position.set(
        earthSpawn.grp.position.x,
        earthSpawn.grp.position.y,
        earthSpawn.grp.position.z + earthSpawn.radius + 100
    );
    let camYaw = Math.PI; 
    let camPitch = 0; // Looking straight ahead at the horizon

    // ================= ATMOSPHERE SYSTEM =================
    // Blue sky colors for Earth atmosphere
    const skyBlue = new THREE.Color(0x4a90d9);    // Bright blue sky
    const skyHorizon = new THREE.Color(0x87ceeb);  // Lighter horizon
    const spaceBlack = new THREE.Color(0x000008);   // Deep space
    const atmosphereHeight = 3000; // Altitude above surface where atmosphere fades completely
    const skyFullHeight = 300;     // Below this altitude, sky is fully blue

    // ================= CONTROLS & ACTIONS =================
    const actionBtn = document.getElementById('action-btn');
    const lockText = document.getElementById('system-status');
    const proxText = document.getElementById('proximity-alert');

    let landedPlanet = earthSpawn; // Start landed on Earth
    let nearestPlanet = null;
    const input = { x: 0, y: 0, up: false, down: false };

    // ACTION BUTTON
    actionBtn.addEventListener('click', () => {
        if (landedPlanet) {
            // Takeoff
            const fwd = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
            camera.position.addScaledVector(new THREE.Vector3(0,1,0), landedPlanet.radius * 0.5);
            landedPlanet = null;
        } else if (nearestPlanet) {
            // Land
            const dir = new THREE.Vector3();
            nearestPlanet.mesh.getWorldPosition(dir);
            dir.sub(camera.position).normalize();
            const worldPos = new THREE.Vector3();
            nearestPlanet.mesh.getWorldPosition(worldPos);
            camera.position.copy(worldPos).addScaledVector(dir.negate(), nearestPlanet.radius + 100);
            landedPlanet = nearestPlanet;
        }
    });

    // JOYSTICK
    const stickArea = document.getElementById('stick-area');
    const stick = document.getElementById('stick-thumb');
    stickArea.addEventListener('touchstart', e => e.preventDefault());
    stickArea.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        const r = stickArea.getBoundingClientRect();
        const dx = t.clientX - (r.left + r.width/2);
        const dy = t.clientY - (r.top + r.height/2);
        const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 60);
        const ang = Math.atan2(dy, dx);
        stick.style.transform = `translate(calc(-50% + ${Math.cos(ang)*dist}px), calc(-50% + ${Math.sin(ang)*dist}px))`;
        input.x = (Math.cos(ang)*dist)/60; input.y = (Math.sin(ang)*dist)/60;
    });
    stickArea.addEventListener('touchend', () => {
        stick.style.transform = 'translate(-50%, -50%)';
        input.x = 0; input.y = 0;
    });

    // LOOK (touch on canvas)
    let lastLook = {x:0, y:0};
    document.addEventListener('touchstart', e => { if(e.target.id==='gameCanvas') lastLook={x:e.touches[0].clientX, y:e.touches[0].clientY}; });
    document.addEventListener('touchmove', e => {
        if(e.target.id==='gameCanvas') {
            e.preventDefault();
            const dx = e.touches[0].clientX - lastLook.x;
            const dy = e.touches[0].clientY - lastLook.y;
            camYaw -= dx * 0.003; camPitch -= dy * 0.003;
            camPitch = Math.max(-1.5, Math.min(1.5, camPitch));
            lastLook={x:e.touches[0].clientX, y:e.touches[0].clientY};
        }
    });

    // KEYBOARD
    document.addEventListener('keydown', e => {
        if(e.key === 'w' || e.key === 'ArrowUp') input.y = -1;
        if(e.key === 's' || e.key === 'ArrowDown') input.y = 1;
        if(e.key === 'a' || e.key === 'ArrowLeft') input.x = -1;
        if(e.key === 'd' || e.key === 'ArrowRight') input.x = 1;
        if(e.key === 'q') input.up = true;
        if(e.key === 'e') input.down = true;
    });
    document.addEventListener('keyup', e => {
        if(e.key === 'w' || e.key === 'ArrowUp' || e.key === 's' || e.key === 'ArrowDown') input.y = 0;
        if(e.key === 'a' || e.key === 'ArrowLeft' || e.key === 'd' || e.key === 'ArrowRight') input.x = 0;
        if(e.key === 'q') input.up = false;
        if(e.key === 'e') input.down = false;
    });

    // MOUSE LOOK
    canvas.addEventListener('mousemove', e => {
        if(e.buttons === 1) {
            camYaw -= e.movementX * 0.003;
            camPitch -= e.movementY * 0.003;
            camPitch = Math.max(-1.5, Math.min(1.5, camPitch));
        }
    });

    // UP/DOWN BUTTONS
    const btnUp = document.getElementById('btn-up');
    const btnDown = document.getElementById('btn-down');
    btnUp.addEventListener('touchstart', (e)=>{e.preventDefault();input.up=true});
    btnUp.addEventListener('touchend', (e)=>{e.preventDefault();input.up=false});
    btnDown.addEventListener('touchstart', (e)=>{e.preventDefault();input.down=true});
    btnDown.addEventListener('touchend', (e)=>{e.preventDefault();input.down=false});

    // RESIZE
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ================= PHYSICS LOOP =================
    const speedText = document.getElementById('speed-readout');
    const tempVec = new THREE.Vector3();
    const screenVec = new THREE.Vector3();

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now();
        
        let closestDist = Infinity;
        let closestP = null;
        let isLocked = false;

        // 1. UPDATE PLANETS
        planets.forEach(p => {
            const prevPos = p.grp.position.clone();

            // Orbit around Sun
            if(p.dist > 0) {
                p.grp.position.x = Math.cos(p.angle + time * p.orbitSpeed) * p.dist;
                p.grp.position.z = Math.sin(p.angle + time * p.orbitSpeed) * p.dist;
            }
            
            // Spin Planet
            p.mesh.rotation.y += 0.001;

            // Rotate clouds slightly differently than Earth surface
            if(p.cloudMesh) {
                p.cloudMesh.rotation.y += 0.0013;
            }

            // Moon Logic (Earth only) — TIDALLY LOCKED, COUNTER-CLOCKWISE
            if(p.moonMesh) {
                const moonOrbitDist = p.radius * MOON_ORBIT_RADIUS_MULT;
                // NEGATIVE speed = counter-clockwise when viewed from above (north pole)
                const mSpeed = -time * 0.00005;
                
                // Position moon in orbit (counter-clockwise)
                p.moonMesh.position.x = Math.cos(mSpeed) * moonOrbitDist;
                p.moonMesh.position.z = Math.sin(mSpeed) * moonOrbitDist;
                
                // Tidal locking: Moon rotation matches orbit so same face always points to Earth
                p.moonMesh.rotation.y = -mSpeed + Math.PI;
            }

            // Jupiter/Neptune moons array
            if(p.moons && p.moons.length > 0) {
                p.moons.forEach(moon => {
                    // Speed sign controls direction: positive = counter-clockwise (prograde), negative = clockwise (retrograde)
                    const mAngle = time * moon.speed;
                    moon.mesh.position.x = Math.cos(mAngle) * moon.orbitR;
                    moon.mesh.position.z = Math.sin(mAngle) * moon.orbitR;
                    // Tidal locking
                    moon.mesh.rotation.y = -mAngle + Math.PI;
                });
            }

            // Dist calc
            p.mesh.getWorldPosition(tempVec);
            const distCenter = camera.position.distanceTo(tempVec);
            const distSurface = distCenter - p.radius;

            if(distSurface < closestDist) {
                closestDist = distSurface;
                closestP = p;
            }

            // Gravity Lock
            const delta = p.grp.position.clone().sub(prevPos);
            if (!isNaN(delta.x)) {
                if(landedPlanet === p || (!landedPlanet && distSurface < config.lockDist)) {
                    camera.position.add(delta);
                    isLocked = true;
                }
            }

            // Raycast Labels — hide all when landed on Earth (you'd see sky, not labels)
            if(landedPlanet && landedPlanet.name === "EARTH") {
                p.label.style.opacity = '0';
            } else if(distSurface < 80000) {
                p.label.style.opacity = '0';
            } else {
                tempVec.project(camera);
                if(tempVec.z < 1 && Math.abs(tempVec.x)<1 && Math.abs(tempVec.y)<1) {
                    screenVec.set(tempVec.x, tempVec.y, 0.5);
                    raycaster.setFromCamera(screenVec, camera);
                    const intersects = raycaster.intersectObjects(systemGroup.children, true);
                    if(intersects.length > 0 && intersects[0].object.name === "PM_" + p.name) {
                        const x = (tempVec.x * .5 + .5) * canvas.clientWidth;
                        const y = (tempVec.y * -.5 + .5) * canvas.clientHeight;
                        p.label.style.left = x + 'px';
                        p.label.style.top = y + 'px';
                        p.label.style.opacity = '1';
                        p.label.querySelector('.label-dist').innerText = Math.floor(distSurface).toLocaleString() + ' u';
                    } else {
                        p.label.style.opacity = '0';
                    }
                } else {
                    p.label.style.opacity = '0';
                }
            }
        });

        // 2. STATE UPDATES
        nearestPlanet = (closestDist < 1200 && !landedPlanet) ? closestP : null;

        if (landedPlanet) {
            actionBtn.style.display = 'flex'; actionBtn.innerText = "TAKEOFF";
            lockText.innerText = "SURFACE LOCK"; lockText.style.color = "#00ffcc";
            proxText.innerText = `LOCATION: ${landedPlanet.name}`;
        } else if (nearestPlanet) {
            actionBtn.style.display = 'flex'; actionBtn.innerText = "LAND";
            lockText.innerText = "ORBITAL INSERTION"; lockText.style.color = "#ffff00";
            proxText.innerText = `READY TO LAND ON ${nearestPlanet.name}`;
        } else {
            actionBtn.style.display = 'none';
            if(isLocked) {
                 lockText.innerText = "GRAVITY WELL"; lockText.style.color = "#00ffcc";
                 proxText.innerText = `APPROACHING ${closestP.name}`;
            } else {
                 lockText.innerText = "SYSTEM ONLINE"; lockText.style.color = "#00aa88";
                 proxText.innerText = "DEEP SPACE CRUISE";
            }
        }

        // 3. SPEED LOGIC
        let targetSpeed = 0;

        if (landedPlanet) {
            targetSpeed = config.minSpeed; 
        } else {
            targetSpeed = closestDist * 0.005; 
            if(targetSpeed > config.deepSpaceSpeed) targetSpeed = config.deepSpaceSpeed;
            if(targetSpeed < config.minSpeed) targetSpeed = config.minSpeed;
        }

        if(isNaN(targetSpeed)) targetSpeed = config.minSpeed;

        // 4. APPLY MOVEMENT
        const fwd = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
        const right = new THREE.Vector3(1, 0, 0).applyEuler(camera.rotation);
        const up = new THREE.Vector3(0, 1, 0); 

        if(Math.abs(input.y)>0.05) camera.position.addScaledVector(fwd, -input.y * targetSpeed);
        if(Math.abs(input.x)>0.05) camera.position.addScaledVector(right, input.x * targetSpeed);
        if(input.up) camera.position.addScaledVector(up, targetSpeed);
        if(input.down) camera.position.addScaledVector(up, -targetSpeed);

        camera.rotation.order = "YXZ";
        camera.rotation.y = camYaw;
        camera.rotation.x = camPitch;

        // 5. EARTH ATMOSPHERE EFFECT + SOLAR ECLIPSE
        const earthP = planets.find(p => p.name === "EARTH");
        if(earthP) {
            const earthWPos = new THREE.Vector3();
            earthP.mesh.getWorldPosition(earthWPos);
            const earthDist = camera.position.distanceTo(earthWPos) - earthP.radius;

            // --- SOLAR ECLIPSE DETECTION ---
            // Check if the Moon is between camera and Sun
            let eclipseDarkness = 0; // 0 = no eclipse, 1 = total eclipse
            const sunP = planets.find(p => p.name === "SUN");
            if(sunP && earthP.moonMesh && earthDist < atmosphereHeight) {
                const sunWPos = new THREE.Vector3();
                sunP.mesh.getWorldPosition(sunWPos);
                const moonWPos = new THREE.Vector3();
                earthP.moonMesh.getWorldPosition(moonWPos);

                // Direction from camera to Sun and Moon
                const toSun = sunWPos.clone().sub(camera.position).normalize();
                const toMoon = moonWPos.clone().sub(camera.position).normalize();

                // Angular alignment (dot product: 1 = perfectly aligned)
                const alignment = toSun.dot(toMoon);

                // Moon's apparent angular size from camera
                const moonDist = camera.position.distanceTo(moonWPos);
                const moonAngularSize = (earthP.moonMesh.geometry.parameters.radius || 270) / moonDist;

                // Sun's apparent angular size from camera
                const sunDist = camera.position.distanceTo(sunWPos);
                const sunAngularSize = sunP.radius / sunDist;

                // Eclipse occurs when Moon aligns with Sun and is close enough to cover it
                // alignment > 0.9999 is very tight (~0.8° arc) — scale based on angular sizes
                const eclipseThreshold = 1 - (moonAngularSize * 1.5); // How close alignment needs to be
                if(alignment > eclipseThreshold && moonDist < sunDist) {
                    // How much of the Sun is covered
                    const coverFactor = (alignment - eclipseThreshold) / (1 - eclipseThreshold);
                    eclipseDarkness = Math.min(1, coverFactor * coverFactor);
                }
            }

            if(earthDist < atmosphereHeight) {
                let t; // 0 = on surface (full blue), 1 = in space (full black)
                if(earthDist <= skyFullHeight) {
                    t = 0;
                } else {
                    t = (earthDist - skyFullHeight) / (atmosphereHeight - skyFullHeight);
                    t = Math.min(1, Math.max(0, t));
                    t = t * t;
                }
                
                // Blend sky color — darken during eclipse
                const skyColor = new THREE.Color();
                if(eclipseDarkness > 0.01) {
                    // Eclipse: blend from blue sky toward dark twilight
                    const eclipseSky = new THREE.Color(0x0a0a18); // Near-black with slight blue
                    const normalSky = new THREE.Color().copy(skyBlue).lerp(spaceBlack, t);
                    skyColor.copy(normalSky).lerp(eclipseSky, eclipseDarkness);
                } else {
                    skyColor.copy(skyBlue).lerp(spaceBlack, t);
                }
                scene.background = skyColor;
                
                // Fog — thicker near surface, thins as you ascend; reduced during eclipse
                if(t < 0.95) {
                    const fogColor = new THREE.Color();
                    if(eclipseDarkness > 0.01) {
                        const eclipseFog = new THREE.Color(0x080810);
                        const normalFog = new THREE.Color().copy(skyHorizon).lerp(spaceBlack, t);
                        fogColor.copy(normalFog).lerp(eclipseFog, eclipseDarkness);
                    } else {
                        fogColor.copy(skyHorizon).lerp(spaceBlack, t);
                    }
                    // During eclipse, push fog back so stars become visible
                    const eclipseFogMult = 1 + eclipseDarkness * 8;
                    const fogNear = (500 + t * 50000) * eclipseFogMult;
                    const fogFar = (50000 + t * 500000) * eclipseFogMult;
                    scene.fog = new THREE.Fog(fogColor, fogNear, fogFar);
                } else {
                    scene.fog = null;
                }
            } else {
                // Deep space
                scene.background = spaceBlack;
                scene.fog = null;
            }
        }

        renderer.render(scene, camera);
    }
    animate();
    </script>
</body>
</html>
