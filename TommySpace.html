<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Titan Scale: Fixed</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@300;600&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { overflow: hidden; background: #000; font-family: 'Teko', sans-serif; }
        
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* Planet Labels */
        .planet-label {
            position: absolute; transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.9); font-size: 14px;
            text-align: center; pointer-events: none;
            text-shadow: 0 0 5px #000; transition: opacity 0.3s;
        }
        .label-name { font-weight: 600; letter-spacing: 1px; color: #fff; line-height: 1; }
        .label-dist { font-size: 12px; color: #00ffcc; line-height: 1; }
        .label-dot { width: 6px; height: 6px; background: #fff; border-radius: 50%; margin: 0 auto 4px auto; box-shadow: 0 0 8px #fff; }

        /* HUD */
        #hud-bottom {
            position: absolute; bottom: 10px; width: 100%; text-align: center; pointer-events: none;
        }
        #speed-readout { color: #00ffcc; font-size: 16px; letter-spacing: 2px; }
        #lock-status { 
            color: #555; font-size: 18px; font-weight: bold; letter-spacing: 2px; 
            margin-top: 4px; display: inline-block; padding: 2px 10px;
        }
        #lock-status.active { color: #fff; background: rgba(0, 255, 204, 0.2); border: 1px solid #00ffcc; }

        /* Controls */
        #controls { pointer-events: auto; }
        #stick-area {
            position: absolute; bottom: 40px; left: 40px; width: 140px; height: 140px;
            border-radius: 50%; border: 2px dashed rgba(255, 255, 255, 0.1);
        }
        #stick-thumb {
            width: 60px; height: 60px; background: rgba(0, 255, 204, 0.1);
            border: 1px solid rgba(0, 255, 204, 0.5); border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }

        .btn {
            position: absolute; width: 80px; height: 80px; border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2); color: #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; background: rgba(0,0,0,0.4); backdrop-filter: blur(4px);
        }
        .btn:active { background: rgba(0, 255, 204, 0.2); transform: scale(0.95); }
        #btn-up { bottom: 140px; right: 30px; }
        #btn-down { bottom: 40px; right: 30px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div id="labels-container"></div>
        <div id="hud-bottom">
            <div id="lock-status">GRAVITY LOCK OFF</div>
            <div id="speed-readout">VELOCITY: 0 u/s</div>
        </div>
        <div id="controls">
            <div id="stick-area"><div id="stick-thumb"></div></div>
            <div id="btn-up" class="btn">▲</div>
            <div id="btn-down" class="btn">▼</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    /* ================================================================
       TITAN SCALE v6: FIXED ORIENTATION & SUN
       ================================================================ */

    const config = {
        renderDist: 3000000000, // 3 Billion units
        lockDist: 100000, 
        maxSpeed: 15000,
        sunRadius: 40000
    };

    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, logarithmicDepthBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000005);

    // CAMERA SETUP
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, config.renderDist);
    camera.up.set(0, 1, 0); // FORCE UP VECTOR TO Y-AXIS (Fixes sideways spawn)

    // LIGHTING
    scene.add(new THREE.AmbientLight(0x404040, 1.0)); // Brighter ambient
    const sunLight = new THREE.PointLight(0xffffff, 2.0, 0);
    scene.add(sunLight);

    // ================= HELPERS =================
    function createTexture(color) {
        const c = document.createElement('canvas'); c.width=256; c.height=128;
        const ctx = c.getContext('2d');
        ctx.fillStyle = color; ctx.fillRect(0,0,256,128);
        ctx.globalAlpha = 0.2; // Noise
        for(let i=0;i<50;i++){
            ctx.fillStyle = Math.random()>0.5 ? '#fff' : '#000'; 
            ctx.beginPath(); ctx.arc(Math.random()*256, Math.random()*128, Math.random()*20, 0, Math.PI*2); ctx.fill();
        }
        return new THREE.CanvasTexture(c);
    }

    // ================= PLANET SYSTEM =================
    const planets = [];
    const labelsContainer = document.getElementById('labels-container');

    function createPlanet(name, radius, dist, color, isSun = false) {
        const grp = new THREE.Group();
        grp.position.set(dist, 0, 0);
        
        const geo = new THREE.SphereGeometry(radius, 64, 64);
        
        let mat;
        if(isSun) {
            // SUN IS UNLIT (BasicMaterial) so it is always visible
            mat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        } else {
            mat = new THREE.MeshStandardMaterial({ map: createTexture(color), roughness: 0.8 });
        }
        
        const mesh = new THREE.Mesh(geo, mat);
        grp.add(mesh);

        // Orbit Ring
        if(dist > 0) {
            const rGeo = new THREE.RingGeometry(dist-100, dist+100, 128);
            const rMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.05, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(rGeo, rMat);
            ring.rotation.x = Math.PI/2; // Horizontal Ring
            scene.add(ring);
        }
        scene.add(grp);

        // Label
        const label = document.createElement('div');
        label.className = 'planet-label';
        label.innerHTML = `<div class="label-dot" style="background:${color}"></div><div class="label-name">${name}</div><div class="label-dist"></div>`;
        labelsContainer.appendChild(label);

        planets.push({
            name, grp, mesh, radius, dist, label,
            angle: Math.random()*10,
            orbitSpeed: dist === 0 ? 0 : (20000 / dist) * 0.0001
        });
    }

    // Create Solar System
    createPlanet("SUN", config.sunRadius, 0, '#ffaa00', true); // TRUE = IS SUN
    createPlanet("MERCURY", 400,   70000,  '#aaaaaa');
    createPlanet("VENUS",   900,   120000, '#ffccaa');
    createPlanet("EARTH",   1000,  180000, '#4488ff');
    createPlanet("MARS",    500,   260000, '#ff4422');
    createPlanet("JUPITER", 12000, 550000, '#d8ca9d');
    createPlanet("SATURN",  10000, 950000, '#eaddb8');
    createPlanet("URANUS",  4000,  1600000,'#44ffff');
    createPlanet("NEPTUNE", 3900,  2300000,'#4466ff');

    // Starfield
    const sGeo = new THREE.BufferGeometry();
    const sPos = [];
    for(let i=0; i<8000; i++) {
        const r = 5000000 + Math.random()*5000000;
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos(2*Math.random()-1);
        sPos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
    }
    sGeo.setAttribute('position', new THREE.Float32BufferAttribute(sPos, 3));
    scene.add(new THREE.Points(sGeo, new THREE.PointsMaterial({color: 0xffffff, size: 1000, sizeAttenuation: true})));


    // ================= INITIAL SPAWN (Looking at Sun) =================
    // Spawn slightly offset from Earth, looking at Origin (0,0,0)
    camera.position.set(180000, 2000, 10000); 
    
    // Look Vector Calculation to ensure 0 Roll
    // We manually set Yaw/Pitch to look at sun
    // Sun is at 0,0,0. We are at 180000, 2000, 10000
    // Vector to sun is (-180000, -2000, -10000)
    // Approximately Yaw = PI/2 (Left)
    
    let camYaw = Math.PI / 2 + 0.2; // Look Left towards center
    let camPitch = 0;


    // ================= INPUT SYSTEM =================
    const input = { x:0, y:0, up:false, down:false };
    
    // Joystick
    const stick = document.getElementById('stick-thumb');
    const stickArea = document.getElementById('stick-area');
    let touchId = null;

    stickArea.addEventListener('touchstart', e => { e.preventDefault(); touchId=e.changedTouches[0].identifier; updateStick(e.changedTouches[0]); });
    stickArea.addEventListener('touchmove', e => { e.preventDefault(); for(let i=0;i<e.changedTouches.length;i++) if(e.changedTouches[i].identifier === touchId) updateStick(e.changedTouches[i]); });
    stickArea.addEventListener('touchend', () => { touchId=null; stick.style.transform='translate(-50%,-50%)'; input.x=0; input.y=0; });

    function updateStick(t) {
        const r = stickArea.getBoundingClientRect();
        const dx = t.clientX - (r.left + r.width/2);
        const dy = t.clientY - (r.top + r.height/2);
        const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 60);
        const ang = Math.atan2(dy, dx);
        stick.style.transform = `translate(calc(-50% + ${Math.cos(ang)*dist}px), calc(-50% + ${Math.sin(ang)*dist}px))`;
        input.x = (Math.cos(ang)*dist)/60; input.y = (Math.sin(ang)*dist)/60;
    }

    // Look Logic (Swipe)
    let lastLook = {x:0, y:0};
    document.addEventListener('touchstart', e => { if(e.target.id==='gameCanvas') lastLook={x:e.touches[0].clientX, y:e.touches[0].clientY}; });
    document.addEventListener('touchmove', e => {
        if(e.target.id==='gameCanvas') {
            e.preventDefault();
            const dx = e.touches[0].clientX - lastLook.x;
            const dy = e.touches[0].clientY - lastLook.y;
            
            // Standard Mapping:
            // Drag Left/Right (dx) -> Yaw (Rotate around Y)
            // Drag Up/Down (dy) -> Pitch (Rotate around X)
            camYaw -= dx * 0.003; 
            camPitch -= dy * 0.003;
            camPitch = Math.max(-1.5, Math.min(1.5, camPitch)); // Limit vertical look
            
            lastLook={x:e.touches[0].clientX, y:e.touches[0].clientY};
        }
    });

    const btnUp = document.getElementById('btn-up');
    const btnDown = document.getElementById('btn-down');
    btnUp.addEventListener('touchstart', (e)=>{e.preventDefault();input.up=true});
    btnUp.addEventListener('touchend', (e)=>{e.preventDefault();input.up=false});
    btnDown.addEventListener('touchstart', (e)=>{e.preventDefault();input.down=true});
    btnDown.addEventListener('touchend', (e)=>{e.preventDefault();input.down=false});

    // ================= LOOP =================
    const speedText = document.getElementById('speed-readout');
    const lockText = document.getElementById('lock-status');
    const tempVec = new THREE.Vector3();

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now();
        let isLocked = false;

        // 1. Planet Mechanics
        planets.forEach(p => {
            const prevPos = p.grp.position.clone();

            if(p.dist > 0) {
                // Orbit in XZ plane (Horizontal)
                p.grp.position.x = Math.cos(p.angle + time * p.orbitSpeed) * p.dist;
                p.grp.position.z = Math.sin(p.angle + time * p.orbitSpeed) * p.dist;
            }

            // Gravity Lock Logic
            const delta = p.grp.position.clone().sub(prevPos);
            p.mesh.getWorldPosition(tempVec);
            const distToCam = camera.position.distanceTo(tempVec);

            if(distToCam - p.radius < config.lockDist) {
                camera.position.add(delta);
                isLocked = true;
                lockText.innerHTML = `GRAVITY LOCK: ${p.name}`;
            }

            // UI Labels
            if (distToCam < 200000) {
                p.label.style.opacity = '0';
            } else {
                tempVec.project(camera); // 3D to 2D
                if(tempVec.z < 1) { // In front of camera
                    const x = (tempVec.x * .5 + .5) * canvas.clientWidth;
                    const y = (tempVec.y * -.5 + .5) * canvas.clientHeight;
                    p.label.style.left = x + 'px';
                    p.label.style.top = y + 'px';
                    p.label.style.opacity = '1';
                    p.label.querySelector('.label-dist').innerText = Math.floor(distToCam).toLocaleString() + ' u';
                } else {
                    p.label.style.opacity = '0';
                }
            }
        });

        if(isLocked) lockText.classList.add('active');
        else { lockText.innerHTML = "GRAVITY LOCK OFF"; lockText.classList.remove('active'); }

        // 2. Player Movement
        let closestSurfaceD = Infinity;
        planets.forEach(p => {
            p.mesh.getWorldPosition(tempVec);
            const d = camera.position.distanceTo(tempVec) - p.radius;
            if(d < closestSurfaceD) closestSurfaceD = d;
        });

        let targetSpeed = 5 + (closestSurfaceD / 200);
        if(targetSpeed > config.maxSpeed) targetSpeed = config.maxSpeed;
        speedText.innerText = `VELOCITY: ${Math.floor(targetSpeed)} u/s`;

        // Movement Vector Math (Relative to Camera View)
        // Forward/Back
        const fwd = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation); 
        fwd.y = 0; // Flatten movement to XZ plane usually, but in space we fly where we look? 
        // Let's fly where we look for true space flight
        const fwdFull = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
        
        // Strafe
        const right = new THREE.Vector3(1, 0, 0).applyEuler(camera.rotation);
        
        // Vertical (World Up)
        const up = new THREE.Vector3(0, 1, 0); 

        if(Math.abs(input.y)>0.05) camera.position.addScaledVector(fwdFull, -input.y * targetSpeed);
        if(Math.abs(input.x)>0.05) camera.position.addScaledVector(right, input.x * targetSpeed);
        if(input.up) camera.position.addScaledVector(up, targetSpeed);
        if(input.down) camera.position.addScaledVector(up, -targetSpeed);

        // Apply Rotation
        camera.rotation.order = "YXZ";
        camera.rotation.y = camYaw;
        camera.rotation.x = camPitch;

        renderer.render(scene, camera);
    }
    animate();
    </script>
</body>
</html>
