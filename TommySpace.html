<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üöÄ Space Explorer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; -webkit-user-select: none; user-select: none; }
        body { overflow: hidden; background: #000; font-family: 'Press Start 2P', cursive; }
        #gameCanvas { display: block; }

        #ui {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        #label {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 10px; text-shadow: 0 0 20px rgba(100, 200, 255, 0.8);
            text-align: center; opacity: 0.7;
        }

        #planetLabel {
            position: absolute; top: 45px; left: 50%; transform: translateX(-50%);
            color: #ffd700; font-size: 14px; text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            text-align: center; transition: opacity 0.5s;
        }

        #joystickArea {
            position: fixed; bottom: 20px; left: 20px;
            width: 160px; height: 160px; pointer-events: auto; z-index: 20;
        }
        #joystickBase {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            width: 130px; height: 130px; border-radius: 50%;
            background: radial-gradient(circle, rgba(100,200,255,0.12), rgba(100,200,255,0.04));
            border: 2px solid rgba(100, 200, 255, 0.25);
        }
        #joystickThumb {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            width: 50px; height: 50px; border-radius: 50%;
            background: radial-gradient(circle, rgba(100,200,255,0.35), rgba(100,200,255,0.1));
            border: 2px solid rgba(100, 200, 255, 0.4);
        }

        .flyBtn {
            position: fixed; right: 25px; width: 85px; height: 85px;
            border-radius: 50%; border: 3px solid; pointer-events: auto; z-index: 20;
            display: flex; align-items: center; justify-content: center;
            font-size: 32px; cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        #flyUp {
            bottom: 130px;
            background: radial-gradient(circle at 40% 35%, #7c4dff, #4a148c);
            border-color: rgba(179, 136, 255, 0.6);
            box-shadow: 0 0 25px rgba(124, 77, 255, 0.4);
        }
        #flyDown {
            bottom: 30px;
            background: radial-gradient(circle at 40% 35%, #00bcd4, #006064);
            border-color: rgba(0, 229, 255, 0.6);
            box-shadow: 0 0 25px rgba(0, 188, 212, 0.4);
        }
        .flyBtn:active { transform: scale(0.9); }

        #speedLines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 5; opacity: 0; transition: opacity 0.3s;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(100,200,255,0.03) 100%);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div id="label">üöÄ SPACE EXPLORER</div>
        <div id="planetLabel"></div>
    </div>
    <div id="joystickArea">
        <div id="joystickBase"><div id="joystickThumb"></div></div>
    </div>
    <div id="flyUp" class="flyBtn">üöÄ</div>
    <div id="flyDown" class="flyBtn">üåç</div>
    <div id="speedLines"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // ============================================================
    // SPACE EXPLORER ‚Äî A toy for little astronauts
    // ============================================================

    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000005);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
    camera.position.set(0, 50, 200);

    // Lighting
    const ambient = new THREE.AmbientLight(0x222244, 0.4);
    scene.add(ambient);

    // Point light from sun
    const sunLight = new THREE.PointLight(0xffffff, 2, 5000);
    sunLight.position.set(0, 0, 0);
    scene.add(sunLight);

    // Extra directional for visibility
    const dirLight = new THREE.DirectionalLight(0xffeedd, 0.3);
    dirLight.position.set(100, 200, 100);
    scene.add(dirLight);

    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    });

    // ===================== STARFIELD =============================
    // Thousands of distant stars as points
    const starGeo = new THREE.BufferGeometry();
    const starCount = 8000;
    const starPositions = new Float32Array(starCount * 3);
    const starColors = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
        const r = 3000 + Math.random() * 7000;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        starPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        starPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        starPositions[i * 3 + 2] = r * Math.cos(phi);
        // Color variety
        const temp = Math.random();
        if (temp < 0.6) { starColors[i*3]=1; starColors[i*3+1]=1; starColors[i*3+2]=1; }
        else if (temp < 0.75) { starColors[i*3]=1; starColors[i*3+1]=0.9; starColors[i*3+2]=0.7; }
        else if (temp < 0.9) { starColors[i*3]=0.7; starColors[i*3+1]=0.8; starColors[i*3+2]=1; }
        else { starColors[i*3]=1; starColors[i*3+1]=0.7; starColors[i*3+2]=0.7; }
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    starGeo.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
    const starMat = new THREE.PointsMaterial({ size: 3, vertexColors: true, sizeAttenuation: true });
    scene.add(new THREE.Points(starGeo, starMat));

    // ===================== PLANET TEXTURES ========================
    function makeTexture(w, h, drawFn) {
        const c = document.createElement('canvas'); c.width = w; c.height = h;
        const ctx = c.getContext('2d'); drawFn(ctx, w, h);
        const t = new THREE.CanvasTexture(c); t.magFilter = THREE.LinearFilter; return t;
    }

    function sunTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            ctx.fillStyle = '#ff8c00'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 200; i++) {
                ctx.fillStyle = ['#ffaa00', '#ff6600', '#ffcc00', '#ffe066'][Math.floor(Math.random() * 4)];
                ctx.fillRect(Math.random() * w, Math.random() * h, 3 + Math.random() * 5, 2 + Math.random() * 3);
            }
        });
    }

    function mercuryTexture() {
        return makeTexture(64, 32, (ctx, w, h) => {
            ctx.fillStyle = '#8a8a8a'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = `rgba(60,60,60,${0.3 + Math.random() * 0.4})`;
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 1 + Math.random() * 3, 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    function venusTexture() {
        return makeTexture(64, 32, (ctx, w, h) => {
            ctx.fillStyle = '#d4a537'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(${180 + Math.random()*40}, ${140 + Math.random()*40}, ${30 + Math.random()*30}, 0.3)`;
                ctx.fillRect(Math.random() * w, Math.random() * h, 4 + Math.random() * 8, 1 + Math.random() * 2);
            }
        });
    }

    function earthTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            // Ocean
            ctx.fillStyle = '#1a5276'; ctx.fillRect(0, 0, w, h);
            // Continents
            ctx.fillStyle = '#27ae60';
            ctx.beginPath(); ctx.ellipse(30, 25, 12, 18, 0.2, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(55, 20, 15, 12, -0.1, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(85, 30, 18, 10, 0.3, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(70, 50, 10, 6, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(110, 25, 8, 12, 0, 0, Math.PI * 2); ctx.fill();
            // Desert
            ctx.fillStyle = '#d4ac6e';
            ctx.beginPath(); ctx.ellipse(58, 28, 6, 4, 0, 0, Math.PI * 2); ctx.fill();
            // Ice caps
            ctx.fillStyle = '#ecf0f1'; ctx.fillRect(0, 0, w, 5); ctx.fillRect(0, h - 5, w, 5);
            // Clouds
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            for (let i = 0; i < 15; i++) {
                ctx.fillRect(Math.random() * w, Math.random() * h, 8 + Math.random() * 15, 2);
            }
        });
    }

    function marsTexture() {
        return makeTexture(64, 32, (ctx, w, h) => {
            ctx.fillStyle = '#c0392b'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 40; i++) {
                ctx.fillStyle = `rgba(${150 + Math.random()*60}, ${50 + Math.random()*30}, ${20 + Math.random()*20}, 0.4)`;
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 1 + Math.random() * 3, 0, Math.PI * 2); ctx.fill();
            }
            // Polar cap
            ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillRect(0, 0, w, 3);
        });
    }

    function jupiterTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            const bands = ['#c4956a', '#d4a574', '#a07850', '#e8c090', '#b08860', '#c8a870', '#906840'];
            for (let y = 0; y < h; y++) {
                ctx.fillStyle = bands[y % bands.length];
                ctx.fillRect(0, y, w, 1);
            }
            // Great red spot
            ctx.fillStyle = '#c05030';
            ctx.beginPath(); ctx.ellipse(80, 35, 10, 6, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#d06040';
            ctx.beginPath(); ctx.ellipse(80, 35, 7, 4, 0, 0, Math.PI * 2); ctx.fill();
        });
    }

    function saturnTexture() {
        return makeTexture(128, 64, (ctx, w, h) => {
            const bands = ['#d4b896', '#c4a878', '#e0c8a0', '#b89868', '#d0b888', '#c8a070'];
            for (let y = 0; y < h; y++) {
                ctx.fillStyle = bands[y % bands.length];
                ctx.fillRect(0, y, w, 1);
            }
        });
    }

    function uranusTexture() {
        return makeTexture(64, 32, (ctx, w, h) => {
            ctx.fillStyle = '#5dade2'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(${70 + Math.random()*40}, ${180 + Math.random()*30}, ${220 + Math.random()*30}, 0.2)`;
                ctx.fillRect(0, Math.random() * h, w, 1 + Math.random() * 2);
            }
        });
    }

    function neptuneTexture() {
        return makeTexture(64, 32, (ctx, w, h) => {
            ctx.fillStyle = '#2e4482'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(${40 + Math.random()*30}, ${60 + Math.random()*40}, ${150 + Math.random()*50}, 0.3)`;
                ctx.fillRect(0, Math.random() * h, w, 1 + Math.random() * 2);
            }
            // Dark spot
            ctx.fillStyle = 'rgba(20, 30, 80, 0.5)';
            ctx.beginPath(); ctx.ellipse(40, 18, 6, 4, 0, 0, Math.PI * 2); ctx.fill();
        });
    }

    function moonTexture() {
        return makeTexture(64, 32, (ctx, w, h) => {
            ctx.fillStyle = '#b0b0a8'; ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 25; i++) {
                ctx.fillStyle = `rgba(80,80,75,${0.2 + Math.random()*0.3})`;
                ctx.beginPath(); ctx.arc(Math.random() * w, Math.random() * h, 1 + Math.random() * 4, 0, Math.PI * 2); ctx.fill();
            }
        });
    }

    // ===================== SOLAR SYSTEM ===========================
    const planets = [];

    function addPlanet(name, radius, orbitR, orbitSpeed, spinSpeed, texFn, color, tilt) {
        const geo = new THREE.SphereGeometry(radius, 32, 24);
        const mat = new THREE.MeshStandardMaterial({ map: texFn(), roughness: 0.8, metalness: 0.1 });
        const mesh = new THREE.Mesh(geo, mat);
        scene.add(mesh);

        // Orbit ring visual
        const ringGeo = new THREE.RingGeometry(orbitR - 0.3, orbitR + 0.3, 128);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x334455, side: THREE.DoubleSide, transparent: true, opacity: 0.15 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI / 2;
        scene.add(ring);

        planets.push({ name, mesh, radius, orbitR, orbitSpeed, spinSpeed, angle: Math.random() * Math.PI * 2, tilt: tilt || 0 });
        return mesh;
    }

    // Sun
    const sunGeo = new THREE.SphereGeometry(30, 48, 32);
    const sunMat = new THREE.MeshBasicMaterial({ map: sunTexture() });
    const sun = new THREE.Mesh(sunGeo, sunMat);
    scene.add(sun);
    // Sun glow
    const glowGeo = new THREE.SphereGeometry(35, 32, 24);
    const glowMat = new THREE.MeshBasicMaterial({ color: 0xff8c00, transparent: true, opacity: 0.15 });
    scene.add(new THREE.Mesh(glowGeo, glowMat));
    const glow2Geo = new THREE.SphereGeometry(45, 32, 24);
    const glow2Mat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.06 });
    scene.add(new THREE.Mesh(glow2Geo, glow2Mat));

    // Planets ‚Äî distances compressed for fun exploration
    //                  name       radius  orbit  orbitSpd  spinSpd   texture
    addPlanet('Mercury',   3,      80,    0.008,   0.02,    mercuryTexture, 0x8a8a8a);
    addPlanet('Venus',     5,     130,    0.005,   0.005,   venusTexture,   0xd4a537);
    const earthMesh = addPlanet('Earth', 6, 200, 0.003, 0.015, earthTexture, 0x1a5276);
    addPlanet('Mars',      4,     280,    0.002,   0.014,   marsTexture,    0xc0392b);
    addPlanet('Jupiter',  16,     420,    0.001,   0.03,    jupiterTexture, 0xc4956a);
    const saturnMesh = addPlanet('Saturn', 13, 580, 0.0007, 0.025, saturnTexture, 0xd4b896, 0.4);
    addPlanet('Uranus',    9,     740,    0.0004,  0.02,    uranusTexture,  0x5dade2, 1.4);
    addPlanet('Neptune',   8,     900,    0.0003,  0.018,   neptuneTexture, 0x2e4482);

    // Saturn rings
    const sRingGeo = new THREE.RingGeometry(18, 28, 64);
    const sRingMat = new THREE.MeshBasicMaterial({
        color: 0xd4c8a0, side: THREE.DoubleSide, transparent: true, opacity: 0.5
    });
    const saturnRing = new THREE.Mesh(sRingGeo, sRingMat);
    saturnRing.rotation.x = Math.PI / 2 + 0.4;
    scene.add(saturnRing);

    // Earth's moon
    const moonGeo = new THREE.SphereGeometry(1.5, 24, 16);
    const moonMat = new THREE.MeshStandardMaterial({ map: moonTexture(), roughness: 0.9 });
    const moonMesh = new THREE.Mesh(moonGeo, moonMat);
    scene.add(moonMesh);
    let moonAngle = 0;

    // ===================== GROUND (starting surface) =============
    const gCanvas = document.createElement('canvas'); gCanvas.width = 128; gCanvas.height = 128;
    const gctx = gCanvas.getContext('2d');
    gctx.fillStyle = '#1a3a1a'; gctx.fillRect(0, 0, 128, 128);
    for (let i = 0; i < 300; i++) {
        gctx.fillStyle = ['#162e16', '#1e4420', '#15301a'][Math.floor(Math.random() * 3)];
        gctx.fillRect(Math.random() * 128, Math.random() * 128, 3, 3);
    }
    const gTex = new THREE.CanvasTexture(gCanvas);
    gTex.wrapS = gTex.wrapT = THREE.RepeatWrapping; gTex.repeat.set(100, 100);
    const groundMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(2000, 2000),
        new THREE.MeshLambertMaterial({ map: gTex })
    );
    groundMesh.rotation.x = -Math.PI / 2; groundMesh.position.y = -1;
    scene.add(groundMesh);

    // ===================== INPUT ==================================
    const input = { moveX: 0, moveZ: 0, lookDX: 0, lookDY: 0, flyUp: false, flyDown: false };
    let yaw = 0, pitch = -0.1;
    const pos = new THREE.Vector3(0, 50, 200);
    const speed = 1.2;
    const flySpeed = 0.8;

    // Joystick
    const joystickArea = document.getElementById('joystickArea');
    const joystickThumb = document.getElementById('joystickThumb');
    let jTouch = null, jCenter = { x: 0, y: 0 };

    joystickArea.addEventListener('touchstart', (e) => {
        const t = e.changedTouches[0]; jTouch = t.identifier;
        const r = document.getElementById('joystickBase').getBoundingClientRect();
        jCenter = { x: r.left + r.width / 2, y: r.top + r.height / 2 };
    });
    joystickArea.addEventListener('touchmove', (e) => {
        e.preventDefault();
        for (const t of e.changedTouches) {
            if (t.identifier === jTouch) {
                const dx = t.clientX - jCenter.x, dy = t.clientY - jCenter.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxR = 50;
                const nx = dist > maxR ? dx / dist * maxR : dx;
                const ny = dist > maxR ? dy / dist * maxR : dy;
                joystickThumb.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
                input.moveX = nx / maxR;
                input.moveZ = ny / maxR;
            }
        }
    });
    joystickArea.addEventListener('touchend', () => {
        jTouch = null; joystickThumb.style.transform = 'translate(-50%, -50%)';
        input.moveX = 0; input.moveZ = 0;
    });

    // Look ‚Äî touch on canvas area
    const viewArea = canvas;
    let viewTouch = null, lastTouchX = 0, lastTouchY = 0;
    viewArea.addEventListener('touchstart', (e) => {
        // Only grab touches not on buttons/joystick
        for (const t of e.changedTouches) {
            if (t.clientX > 180 && t.clientX < window.innerWidth - 120) {
                viewTouch = t.identifier; lastTouchX = t.clientX; lastTouchY = t.clientY;
            }
        }
    });
    viewArea.addEventListener('touchmove', (e) => {
        for (const t of e.changedTouches) {
            if (t.identifier === viewTouch) {
                input.lookDX = (t.clientX - lastTouchX) * 0.003;
                input.lookDY = (t.clientY - lastTouchY) * 0.003;
                lastTouchX = t.clientX; lastTouchY = t.clientY;
            }
        }
    });
    viewArea.addEventListener('touchend', (e) => {
        for (const t of e.changedTouches) { if (t.identifier === viewTouch) viewTouch = null; }
    });

    // Fly buttons
    const flyUpBtn = document.getElementById('flyUp');
    const flyDownBtn = document.getElementById('flyDown');
    flyUpBtn.addEventListener('touchstart', () => input.flyUp = true);
    flyUpBtn.addEventListener('touchend', () => input.flyUp = false);
    flyDownBtn.addEventListener('touchstart', () => input.flyDown = true);
    flyDownBtn.addEventListener('touchend', () => input.flyDown = false);

    // Keyboard fallback
    const keys = {};
    window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
    canvas.addEventListener('click', () => canvas.requestPointerLock && canvas.requestPointerLock());
    document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === canvas) {
            input.lookDX = e.movementX * 0.002;
            input.lookDY = e.movementY * 0.002;
        }
    });

    // ===================== PLANET LABEL ===========================
    const planetLabel = document.getElementById('planetLabel');
    let labelTimer = 0;

    function checkNearPlanet() {
        for (const p of planets) {
            const d = pos.distanceTo(p.mesh.position);
            if (d < p.radius * 4) {
                planetLabel.textContent = `ü™ê ${p.name}`;
                planetLabel.style.opacity = '1';
                labelTimer = 120;
                return;
            }
        }
        // Check sun
        if (pos.length() < 80) {
            planetLabel.textContent = '‚òÄÔ∏è The Sun';
            planetLabel.style.opacity = '1';
            labelTimer = 120;
        }
    }

    // ===================== GAME LOOP ==============================
    const speedLines = document.getElementById('speedLines');
    let frame = 0;

    function animate() {
        requestAnimationFrame(animate);
        frame++;

        // Keyboard input
        let kx = 0, kz = 0;
        if (keys['w'] || keys['arrowup']) kz = -1;
        if (keys['s'] || keys['arrowdown']) kz = 1;
        if (keys['a'] || keys['arrowleft']) kx = -1;
        if (keys['d'] || keys['arrowright']) kx = 1;
        const flyUpK = keys[' '] || keys['shift'];
        const flyDownK = keys['control'];

        const mx = input.moveX || kx;
        const mz = input.moveZ || kz;

        // Look
        yaw -= input.lookDX;
        pitch -= input.lookDY;
        pitch = Math.max(-1.4, Math.min(1.4, pitch));
        input.lookDX = 0; input.lookDY = 0;

        // Movement ‚Äî forward/right relative to camera
        const fwdX = -Math.sin(yaw), fwdZ = -Math.cos(yaw);
        const rightX = Math.cos(yaw), rightZ = -Math.sin(yaw);

        const curSpeed = pos.y > 100 ? speed * 2.5 : speed; // faster in space
        if (Math.abs(mx) > 0.1 || Math.abs(mz) > 0.1) {
            const wx = rightX * mx + fwdX * (-mz);
            const wz = rightZ * mx + fwdZ * (-mz);
            const len = Math.sqrt(wx * wx + wz * wz) || 1;
            pos.x += (wx / len) * curSpeed;
            pos.z += (wz / len) * curSpeed;
        }

        // Fly up/down
        if (input.flyUp || flyUpK) pos.y += flySpeed * (pos.y > 100 ? 3 : 1);
        if (input.flyDown || flyDownK) pos.y -= flySpeed * (pos.y > 100 ? 3 : 1);
        if (pos.y < 2) pos.y = 2;

        // Speed lines effect when flying fast
        speedLines.style.opacity = (input.flyUp || flyUpK) && pos.y > 30 ? '1' : '0';

        // Camera
        const camBack = pos.y < 20 ? 1.5 : 0;
        camera.position.set(pos.x - fwdX * camBack, pos.y + 1, pos.z - fwdZ * camBack);
        camera.rotation.order = 'YXZ';
        camera.rotation.y = yaw;
        camera.rotation.x = pitch;

        // Update planets
        for (const p of planets) {
            p.angle += p.orbitSpeed;
            p.mesh.position.x = Math.cos(p.angle) * p.orbitR;
            p.mesh.position.z = Math.sin(p.angle) * p.orbitR;
            p.mesh.position.y = Math.sin(p.angle * 0.3) * p.orbitR * 0.05; // slight vertical wobble
            p.mesh.rotation.y += p.spinSpeed;
            if (p.tilt) p.mesh.rotation.x = p.tilt;
        }

        // Saturn ring follows Saturn
        const saturn = planets.find(p => p.name === 'Saturn');
        if (saturn) {
            saturnRing.position.copy(saturn.mesh.position);
        }

        // Moon orbits Earth
        const earth = planets.find(p => p.name === 'Earth');
        if (earth) {
            moonAngle += 0.01;
            moonMesh.position.set(
                earth.mesh.position.x + Math.cos(moonAngle) * 15,
                earth.mesh.position.y + Math.sin(moonAngle * 0.3) * 2,
                earth.mesh.position.z + Math.sin(moonAngle) * 15
            );
            moonMesh.rotation.y += 0.005;
        }

        // Sun rotation
        sun.rotation.y += 0.002;

        // Ground fades out as you fly up
        groundMesh.material.opacity = Math.max(0, 1 - (pos.y - 10) / 150);
        groundMesh.material.transparent = true;

        // Planet label
        if (frame % 30 === 0) checkNearPlanet();
        if (labelTimer > 0) {
            labelTimer--;
            if (labelTimer <= 0) planetLabel.style.opacity = '0';
        }

        renderer.render(scene, camera);
    }

    animate();
    </script>
</body>
</html>
