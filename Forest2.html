<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mystic Forest Walker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            overflow: hidden;
            background: #0a0a12;
            font-family: 'Press Start 2P', cursive;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 10px;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
            line-height: 1.8;
            z-index: 100;
        }
        
        #stats .level {
            color: #ffd700;
            font-size: 14px;
        }
        
        #healthBar {
            width: 150px;
            height: 16px;
            background: #333;
            border: 3px solid #222;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(180deg, #ff6b6b, #c0392b);
            transition: width 0.3s;
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3);
        }
        
        #xpBar {
            width: 150px;
            height: 10px;
            background: #333;
            border: 2px solid #222;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        #xpFill {
            height: 100%;
            background: linear-gradient(180deg, #9b59b6, #8e44ad);
            transition: width 0.3s;
        }
        
        #dpad {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }
        
        .dpad-btn {
            position: absolute;
            width: 46px;
            height: 46px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: rgba(255,255,255,0.7);
            transition: all 0.1s;
            backdrop-filter: blur(4px);
        }
        
        .dpad-btn:active, .dpad-btn.active {
            background: rgba(255,255,255,0.35);
            transform: scale(0.95);
            border-color: rgba(255,255,255,0.6);
        }
        
        #dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
        #dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
        #dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
        #dpad-right { right: 0; top: 50%; transform: translateY(-50%); }
        
        #magicBtn {
            position: absolute;
            bottom: 50px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #9b59b6, #6c3483);
            border: 4px solid #bb8fce;
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #9b59b6;
            box-shadow: 0 0 20px rgba(155,89,182,0.5), inset 0 -4px 10px rgba(0,0,0,0.3);
            transition: all 0.1s;
        }
        
        #magicBtn:active {
            transform: scale(0.9);
            box-shadow: 0 0 30px rgba(155,89,182,0.8), inset 0 -4px 10px rgba(0,0,0,0.3);
        }
        
        #viewArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            z-index: 1;
        }
        
        #dpad {
            z-index: 10;
        }
        
        #magicBtn {
            z-index: 10;
        }
        
        #damageFlash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,0,0,0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
        
        #levelUp {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 24px;
            text-shadow: 0 0 20px #ffd700, 0 0 40px #ff8c00;
            opacity: 0;
            pointer-events: none;
            animation: none;
        }
        
        @keyframes levelUpAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1) translateY(-50px); }
        }
        
        #killCount {
            position: absolute;
            top: 80px;
            right: 10px;
            color: #ff6b6b;
            font-size: 12px;
            text-shadow: 2px 2px 0 #000;
        }
        
        #stats .gold {
            color: #ffd700;
            margin-top: 8px;
            font-size: 12px;
        }
        
        #menuBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 60px;
            height: 60px;
            background: linear-gradient(180deg, rgba(108,92,231,0.9), rgba(68,52,191,0.9));
            border: 3px solid #bb8fce;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            color: #fff;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(108,92,231,0.5);
            z-index: 100;
        }
        
        #menuBtn .btn-label {
            font-size: 8px;
            margin-top: 2px;
            font-family: 'Press Start 2P', cursive;
        }
        
        #menuBtn:active {
            background: linear-gradient(180deg, rgba(138,122,255,0.9), rgba(98,82,221,0.9));
            transform: scale(0.95);
        }
        
        #upgradeMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(25,20,45,0.98), rgba(40,30,60,0.98));
            border: 4px solid #9b59b6;
            border-radius: 16px;
            padding: 30px;
            color: #fff;
            min-width: 350px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(155,89,182,0.6), inset 0 0 30px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
            pointer-events: auto;
        }
        
        #upgradeMenu.active {
            display: block;
        }
        
        #upgradeMenu h2 {
            text-align: center;
            font-size: 18px;
            margin-bottom: 25px;
            color: #ffd700;
            text-shadow: 0 0 15px #ffd700;
        }
        
        .upgrade-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .upgrade-item {
            background: rgba(108,92,231,0.2);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(155,89,182,0.4);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .upgrade-item:hover {
            border-color: #9b59b6;
            background: rgba(108,92,231,0.3);
            transform: translateY(-2px);
        }
        
        .upgrade-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .upgrade-item.disabled:hover {
            transform: none;
        }
        
        .upgrade-name {
            font-size: 12px;
            color: #bb8fce;
            margin-bottom: 8px;
        }
        
        .upgrade-desc {
            font-size: 8px;
            line-height: 1.6;
            margin-bottom: 8px;
            color: #ddd;
        }
        
        .upgrade-cost {
            font-size: 10px;
            color: #ffd700;
        }
        
        .upgrade-level {
            font-size: 8px;
            color: #9b59b6;
            margin-top: 5px;
        }
        
        #closeMenuBtn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(180deg, #c0392b, #8e2a1a);
            border: 3px solid #e74c3c;
            border-radius: 8px;
            color: #fff;
            font-size: 12px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #closeMenuBtn:hover {
            background: linear-gradient(180deg, #e74c3c, #c0392b);
            transform: scale(1.02);
        }
        
        #playerGold {
            text-align: center;
            font-size: 14px;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ffd700;
        }
        
        #dialogueBox {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(20,15,35,0.95), rgba(30,20,50,0.95));
            border: 3px solid #9b59b6;
            border-radius: 12px;
            padding: 20px 25px;
            max-width: 80vw;
            width: 500px;
            color: #fff;
            font-size: 11px;
            line-height: 1.8;
            box-shadow: 0 0 30px rgba(155,89,182,0.5);
            display: none;
            z-index: 500;
            pointer-events: auto;
        }
        
        #dialogueBox.active {
            display: block;
        }
        
        .dialogue-speaker {
            color: #ffd700;
            font-size: 12px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ffd700;
        }
        
        .dialogue-text {
            margin-bottom: 15px;
        }
        
        #dialogueBtn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(180deg, #9b59b6, #7d3c98);
            border: 2px solid #bb8fce;
            border-radius: 6px;
            color: #fff;
            font-size: 10px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #dialogueBtn:hover {
            background: linear-gradient(180deg, #bb8fce, #9b59b6);
        }
        
        #compass {
            position: absolute;
            top: 90px;
            left: 10px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at center, rgba(20,20,40,0.9), rgba(10,10,20,0.95));
            border: 3px solid rgba(155,89,182,0.5);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(155,89,182,0.3), inset 0 0 20px rgba(0,0,0,0.5);
        }
        
        #compass.active {
            display: flex;
        }
        
        .compass-arrow {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 35px solid #ffd700;
            filter: drop-shadow(0 0 8px #ffd700);
            transition: transform 0.2s;
        }
        
        .compass-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #ffd700;
            white-space: nowrap;
            text-shadow: 0 0 8px #ffd700;
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 190px;
            left: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
            z-index: 10;
        }
        
        .zoom-btn {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            transition: all 0.1s;
            backdrop-filter: blur(4px);
        }
        
        .zoom-btn:active {
            background: rgba(255,255,255,0.35);
            transform: scale(0.95);
            border-color: rgba(255,255,255,0.6);
        }
        
        #boomCooldown {
            position: absolute;
            bottom: 140px;
            right: 30px;
            font-size: 10px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            display: none;
        }
        
        #boomCooldown.active {
            display: block;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="stats">
            <div class="level">LEVEL <span id="levelDisplay">1</span></div>
            <div>HP: <span id="hpDisplay">100</span>/100</div>
            <div id="healthBar"><div id="healthFill" style="width: 100%;"></div></div>
            <div id="xpBar"><div id="xpFill" style="width: 0%;"></div></div>
            <div class="gold">üí∞ <span id="goldDisplay">0</span></div>
        </div>
        
        <div id="killCount">
            üíÄ Kills: <span id="killDisplay">0</span>
        </div>
        
        <div id="menuBtn">
            <div>‚öôÔ∏è</div>
            <div class="btn-label">MENU</div>
        </div>
        
        <div id="compass">
            <div class="compass-arrow"></div>
            <div class="compass-label">Portal</div>
        </div>
        
        <div class="zoom-controls">
            <div class="zoom-btn" id="zoomIn">+</div>
            <div class="zoom-btn" id="zoomOut">‚àí</div>
        </div>
        
        <div id="dpad">
            <div class="dpad-btn" id="dpad-up">‚ñ≤</div>
            <div class="dpad-btn" id="dpad-down">‚ñº</div>
            <div class="dpad-btn" id="dpad-left">‚óÑ</div>
            <div class="dpad-btn" id="dpad-right">‚ñ∫</div>
        </div>
        
        <div id="magicBtn">‚ú®</div>
        <div id="boomCooldown">Boom: <span id="boomTimer">0</span>s</div>
        
        <div id="viewArea"></div>
    </div>
    
    <div id="damageFlash"></div>
    <div id="levelUp">LEVEL UP!</div>
    
    <div id="upgradeMenu">
        <h2>‚ö° UPGRADES ‚ö°</h2>
        <div id="playerGold">üí∞ Gold: <span id="menuGoldDisplay">0</span></div>
        <div class="upgrade-grid" id="upgradeGrid"></div>
        <button id="closeMenuBtn">CLOSE</button>
    </div>
    
    <div id="dialogueBox">
        <div class="dialogue-speaker" id="dialogueSpeaker"></div>
        <div class="dialogue-text" id="dialogueText"></div>
        <button id="dialogueBtn">Continue</button>
    </div>
    
    <script>
        // ============================================
        // SETUP
        // ============================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x1a1a2e, 20, 80);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;
        document.body.appendChild(renderer.domElement);

        // ============================================
        // CONFIG
        // ============================================
        const CONFIG = {
            playerSpeed: 0.15,
            enemySpeed: 0.06,
            enemySpawnInterval: 3000,
            projectileSpeed: 0.4,
            projectileDamage: 10,
            enemyHealth: 30,
            enemyDamage: 10,
            xpPerEnemy: 15,
            goldPerEnemy: 3,
            enemySpawnDistance: 40,
            chunkSize: 30,
            renderDistance: 2,
            treeCount: 8,
            rockCount: 4,
            grassCount: 12,
            swordDamage: 25,
            swordDuration: 500,
            swordCount: 8,
            swordRadius: 3,
            boomDamage: 50,
            boomRadius: 15,
            boomCooldown: 30000,
            bossHealth: 200,
            bossDamage: 25,
            bossSpeed: 0.04,
            bossXP: 100,
            bossGold: 50,
            encounterSpawnChance: 0.05,
            chestSpawnChance: 0.03,
            chestGold: 30,
            portalSpawnChance: 0.02
        };

        // ============================================
        // GAME STATE
        // ============================================
        const gameState = {
            player: {
                position: new THREE.Vector3(0, 0, 0),
                rotation: 0,
                health: 100,
                maxHealth: 100,
                level: 1,
                xp: 0,
                xpToLevel: 100,
                gold: 0,
                kills: 0
            },
            enemies: [],
            bosses: [],
            projectiles: [],
            xpOrbs: [],
            goldOrbs: [],
            chunks: new Map(),
            isGameOver: false,
            swords: [],
            boomProjectiles: [],
            lastBoomTime: 0,
            boomCooldownRemaining: 0,
            menuOpen: false,
            upgrades: {
                damage: 0,
                health: 0,
                speed: 0,
                fireRate: 0,
                projectileSpeed: 0
            },
            lastProjectileTime: 0,
            encounters: [],
            dialogueTimer: 0,
            currentDialogue: null,
            treasureChests: [],
            cloudPortals: [],
            targetPortal: null,
            inCloudArena: false,
            arenaWave: 0,
            arenaKills: 0,
            arenaEnemies: [],
            cameraZoom: 1.0
        };

        const controls = {
            up: false,
            down: false,
            left: false,
            right: false
        };

        // ============================================
        // UPGRADE SYSTEM
        // ============================================
        const UPGRADES = {
            damage: {
                name: "‚öîÔ∏è Damage",
                desc: "Increase projectile damage",
                baseCost: 10,
                maxLevel: 10,
                effect: (level) => CONFIG.projectileDamage + (level * 5)
            },
            health: {
                name: "‚ù§Ô∏è Max Health",
                desc: "Increase maximum health",
                baseCost: 15,
                maxLevel: 10,
                effect: (level) => 100 + (level * 20)
            },
            speed: {
                name: "üèÉ Movement Speed",
                desc: "Move faster",
                baseCost: 12,
                maxLevel: 8,
                effect: (level) => CONFIG.playerSpeed + (level * 0.02)
            },
            fireRate: {
                name: "‚ö° Fire Rate",
                desc: "Shoot more frequently",
                baseCost: 20,
                maxLevel: 7,
                effect: (level) => Math.max(100, 500 - (level * 50))
            },
            projectileSpeed: {
                name: "üöÄ Projectile Speed",
                desc: "Faster projectiles",
                baseCost: 18,
                maxLevel: 6,
                effect: (level) => CONFIG.projectileSpeed + (level * 0.1)
            }
        };

        function getUpgradeCost(upgradeKey) {
            const upgrade = UPGRADES[upgradeKey];
            const currentLevel = gameState.upgrades[upgradeKey];
            return Math.floor(upgrade.baseCost * Math.pow(1.5, currentLevel));
        }

        function canAffordUpgrade(upgradeKey) {
            return gameState.player.gold >= getUpgradeCost(upgradeKey);
        }

        function purchaseUpgrade(upgradeKey) {
            const upgrade = UPGRADES[upgradeKey];
            const cost = getUpgradeCost(upgradeKey);
            const currentLevel = gameState.upgrades[upgradeKey];
            
            if (currentLevel >= upgrade.maxLevel) return false;
            if (!canAffordUpgrade(upgradeKey)) return false;
            
            gameState.player.gold -= cost;
            gameState.upgrades[upgradeKey]++;
            
            // Apply health upgrade immediately
            if (upgradeKey === 'health') {
                const newMaxHealth = upgrade.effect(gameState.upgrades[upgradeKey]);
                const healthDiff = newMaxHealth - gameState.player.maxHealth;
                gameState.player.maxHealth = newMaxHealth;
                gameState.player.health += healthDiff;
            }
            
            updateUpgradeMenu();
            updateUI();
            return true;
        }

        function updateUpgradeMenu() {
            const grid = document.getElementById('upgradeGrid');
            grid.innerHTML = '';
            
            Object.keys(UPGRADES).forEach(key => {
                const upgrade = UPGRADES[key];
                const level = gameState.upgrades[key];
                const cost = getUpgradeCost(key);
                const canAfford = canAffordUpgrade(key);
                const maxed = level >= upgrade.maxLevel;
                
                const item = document.createElement('div');
                item.className = 'upgrade-item' + (!canAfford || maxed ? ' disabled' : '');
                
                item.innerHTML = `
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                    <div class="upgrade-level">Level: ${level}/${upgrade.maxLevel}</div>
                    <div class="upgrade-cost">${maxed ? 'MAX LEVEL' : 'üí∞ ' + cost + ' Gold'}</div>
                `;
                
                if (!maxed) {
                    item.addEventListener('click', () => purchaseUpgrade(key));
                    item.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        purchaseUpgrade(key);
                    });
                }
                
                grid.appendChild(item);
            });
            
            document.getElementById('menuGoldDisplay').textContent = gameState.player.gold;
        }

        // ============================================
        // MENU CONTROLS
        // ============================================
        function openMenu() {
            gameState.menuOpen = true;
            document.getElementById('upgradeMenu').classList.add('active');
            updateUpgradeMenu();
        }

        function closeMenu() {
            gameState.menuOpen = false;
            document.getElementById('upgradeMenu').classList.remove('active');
        }

        function setupMenuControls() {
            document.getElementById('menuBtn').addEventListener('click', openMenu);
            document.getElementById('menuBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                openMenu();
            });
            
            document.getElementById('closeMenuBtn').addEventListener('click', closeMenu);
            document.getElementById('closeMenuBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                closeMenu();
            });
        }

        // ============================================
        // LIGHTING
        // ============================================
        const ambientLight = new THREE.AmbientLight(0x4a4a6a, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0x9999cc, 0.8);
        directionalLight.position.set(10, 20, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

        // ============================================
        // GROUND
        // ============================================
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x1a3a1a,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // ============================================
        // PLAYER
        // ============================================
        const playerGroup = new THREE.Group();

        const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.5);
        const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x6c5ce7 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1.25;
        body.castShadow = true;
        playerGroup.add(body);

        const headGeometry = new THREE.SphereGeometry(0.4, 8, 8);
        const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 2.3;
        head.castShadow = true;
        playerGroup.add(head);

        const eyeGeometry = new THREE.SphereGeometry(0.08, 4, 4);
        const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.15, 2.4, 0.35);
        playerGroup.add(leftEye);
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.15, 2.4, 0.35);
        playerGroup.add(rightEye);

        scene.add(playerGroup);

        // ============================================
        // CHUNK SYSTEM
        // ============================================
        function getChunkKey(x, z) {
            const chunkX = Math.floor(x / CONFIG.chunkSize);
            const chunkZ = Math.floor(z / CONFIG.chunkSize);
            return `${chunkX},${chunkZ}`;
        }

        function createTree(x, z) {
            const treeGroup = new THREE.Group();
            
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 3, 6);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1.5;
            trunk.castShadow = true;
            treeGroup.add(trunk);
            
            const foliageGeometry = new THREE.ConeGeometry(1.5, 3, 6);
            const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5016 });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 4;
            foliage.castShadow = true;
            treeGroup.add(foliage);
            
            treeGroup.position.set(x, 0, z);
            return treeGroup;
        }

        function createRock(x, z) {
            const rockGeometry = new THREE.DodecahedronGeometry(0.5 + Math.random() * 0.3, 0);
            const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(x, 0.3, z);
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rock.castShadow = true;
            return rock;
        }

        function createGrass(x, z) {
            const grassGeometry = new THREE.ConeGeometry(0.1, 0.4, 3);
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x3a5a2a });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.position.set(x, 0.2, z);
            return grass;
        }

        function createChunk(chunkX, chunkZ) {
            const chunkGroup = new THREE.Group();
            const baseX = chunkX * CONFIG.chunkSize;
            const baseZ = chunkZ * CONFIG.chunkSize;
            
            for (let i = 0; i < CONFIG.treeCount; i++) {
                const x = baseX + Math.random() * CONFIG.chunkSize;
                const z = baseZ + Math.random() * CONFIG.chunkSize;
                chunkGroup.add(createTree(x, z));
            }
            
            for (let i = 0; i < CONFIG.rockCount; i++) {
                const x = baseX + Math.random() * CONFIG.chunkSize;
                const z = baseZ + Math.random() * CONFIG.chunkSize;
                chunkGroup.add(createRock(x, z));
            }
            
            for (let i = 0; i < CONFIG.grassCount; i++) {
                const x = baseX + Math.random() * CONFIG.chunkSize;
                const z = baseZ + Math.random() * CONFIG.chunkSize;
                chunkGroup.add(createGrass(x, z));
            }
            
            scene.add(chunkGroup);
            return chunkGroup;
        }

        function updateChunks() {
            const playerChunkX = Math.floor(gameState.player.position.x / CONFIG.chunkSize);
            const playerChunkZ = Math.floor(gameState.player.position.z / CONFIG.chunkSize);
            
            const chunksToKeep = new Set();
            
            for (let x = -CONFIG.renderDistance; x <= CONFIG.renderDistance; x++) {
                for (let z = -CONFIG.renderDistance; z <= CONFIG.renderDistance; z++) {
                    const chunkX = playerChunkX + x;
                    const chunkZ = playerChunkZ + z;
                    const key = `${chunkX},${chunkZ}`;
                    chunksToKeep.add(key);
                    
                    if (!gameState.chunks.has(key)) {
                        const chunk = createChunk(chunkX, chunkZ);
                        gameState.chunks.set(key, chunk);
                    }
                }
            }
            
            for (const [key, chunk] of gameState.chunks.entries()) {
                if (!chunksToKeep.has(key)) {
                    scene.remove(chunk);
                    gameState.chunks.delete(key);
                }
            }
        }

        // ============================================
        // PROJECTILES
        // ============================================
        function shootProjectile() {
            const fireRate = UPGRADES.fireRate.effect(gameState.upgrades.fireRate);
            const now = Date.now();
            if (now - gameState.lastProjectileTime < fireRate) return;
            gameState.lastProjectileTime = now;
            
            const geometry = new THREE.SphereGeometry(0.2, 6, 6);
            const material = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const projectile = new THREE.Mesh(geometry, material);
            
            projectile.position.copy(gameState.player.position);
            projectile.position.y = 1.5;
            
            const speed = UPGRADES.projectileSpeed.effect(gameState.upgrades.projectileSpeed);
            const velocity = new THREE.Vector3(
                -Math.sin(gameState.player.rotation) * speed,
                0,
                -Math.cos(gameState.player.rotation) * speed
            );
            
            scene.add(projectile);
            gameState.projectiles.push({ mesh: projectile, velocity });
        }

        function updateProjectiles() {
            const damage = UPGRADES.damage.effect(gameState.upgrades.damage);
            
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                proj.mesh.position.add(proj.velocity);
                
                const distFromPlayer = proj.mesh.position.distanceTo(gameState.player.position);
                if (distFromPlayer > 50) {
                    scene.remove(proj.mesh);
                    gameState.projectiles.splice(i, 1);
                    continue;
                }
                
                let hit = false;
                
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dist = proj.mesh.position.distanceTo(enemy.mesh.position);
                    if (dist < 1) {
                        enemy.health -= damage;
                        hit = true;
                        if (enemy.health <= 0) {
                            killEnemy(j);
                        }
                        break;
                    }
                }
                
                if (!hit) {
                    for (let j = gameState.bosses.length - 1; j >= 0; j--) {
                        const boss = gameState.bosses[j];
                        const dist = proj.mesh.position.distanceTo(boss.mesh.position);
                        if (dist < 2) {
                            boss.health -= damage;
                            hit = true;
                            if (boss.health <= 0) {
                                killBoss(j);
                            }
                            break;
                        }
                    }
                }
                
                if (!hit && gameState.inCloudArena) {
                    for (let j = gameState.arenaEnemies.length - 1; j >= 0; j--) {
                        const enemy = gameState.arenaEnemies[j];
                        const dist = proj.mesh.position.distanceTo(enemy.mesh.position);
                        if (dist < 1) {
                            enemy.health -= damage;
                            hit = true;
                            if (enemy.health <= 0) {
                                killArenaEnemy(j);
                            }
                            break;
                        }
                    }
                }
                
                if (hit) {
                    scene.remove(proj.mesh);
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        // ============================================
        // ENEMIES
        // ============================================
        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const distance = CONFIG.enemySpawnDistance;
            
            const enemyGroup = new THREE.Group();
            
            const bodyGeometry = new THREE.BoxGeometry(1, 1.2, 0.5);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff4444 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            body.castShadow = true;
            enemyGroup.add(body);
            
            const headGeometry = new THREE.SphereGeometry(0.3, 6, 6);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0x8b0000 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = true;
            enemyGroup.add(head);
            
            enemyGroup.position.set(
                gameState.player.position.x + Math.cos(angle) * distance,
                0,
                gameState.player.position.z + Math.sin(angle) * distance
            );
            
            scene.add(enemyGroup);
            
            gameState.enemies.push({
                mesh: enemyGroup,
                health: CONFIG.enemyHealth,
                lastAttackTime: 0
            });
        }

        function updateEnemies() {
            const currentTime = Date.now();
            
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                const dx = gameState.player.position.x - enemy.mesh.position.x;
                const dz = gameState.player.position.z - enemy.mesh.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance > 0.1) {
                    enemy.mesh.position.x += (dx / distance) * CONFIG.enemySpeed;
                    enemy.mesh.position.z += (dz / distance) * CONFIG.enemySpeed;
                }
                
                if (distance < 1.5 && currentTime - enemy.lastAttackTime > 1000) {
                    damagePlayer(CONFIG.enemyDamage);
                    enemy.lastAttackTime = currentTime;
                }
                
                if (distance > 100) {
                    scene.remove(enemy.mesh);
                    gameState.enemies.splice(i, 1);
                }
            }
        }

        function killEnemy(index) {
            const enemy = gameState.enemies[index];
            
            dropXPOrb(enemy.mesh.position);
            dropGoldOrb(enemy.mesh.position);
            
            scene.remove(enemy.mesh);
            gameState.enemies.splice(index, 1);
            gameState.player.kills++;
            updateUI();
        }

        // ============================================
        // XP & GOLD ORBS
        // ============================================
        function dropXPOrb(position) {
            const geometry = new THREE.SphereGeometry(0.3, 6, 6);
            const material = new THREE.MeshBasicMaterial({ color: 0x9b59b6 });
            const orb = new THREE.Mesh(geometry, material);
            orb.position.copy(position);
            orb.position.y = 0.5;
            scene.add(orb);
            gameState.xpOrbs.push(orb);
        }

        function dropGoldOrb(position) {
            const geometry = new THREE.SphereGeometry(0.25, 6, 6);
            const material = new THREE.MeshBasicMaterial({ color: 0xffd700 });
            const orb = new THREE.Mesh(geometry, material);
            orb.position.copy(position);
            orb.position.y = 0.5;
            scene.add(orb);
            gameState.goldOrbs.push(orb);
        }

        function updateXPOrbs() {
            for (let i = gameState.xpOrbs.length - 1; i >= 0; i--) {
                const orb = gameState.xpOrbs[i];
                const dist = orb.position.distanceTo(gameState.player.position);
                
                if (dist < 2) {
                    const dx = gameState.player.position.x - orb.position.x;
                    const dz = gameState.player.position.z - orb.position.z;
                    orb.position.x += dx * 0.1;
                    orb.position.z += dz * 0.1;
                }
                
                if (dist < 0.5) {
                    gameState.player.xp += CONFIG.xpPerEnemy;
                    checkLevelUp();
                    scene.remove(orb);
                    gameState.xpOrbs.splice(i, 1);
                    updateUI();
                }
            }
        }

        function updateGoldOrbs() {
            for (let i = gameState.goldOrbs.length - 1; i >= 0; i--) {
                const orb = gameState.goldOrbs[i];
                const dist = orb.position.distanceTo(gameState.player.position);
                
                if (dist < 2) {
                    const dx = gameState.player.position.x - orb.position.x;
                    const dz = gameState.player.position.z - orb.position.z;
                    orb.position.x += dx * 0.1;
                    orb.position.z += dz * 0.1;
                }
                
                if (dist < 0.5) {
                    gameState.player.gold += CONFIG.goldPerEnemy;
                    scene.remove(orb);
                    gameState.goldOrbs.splice(i, 1);
                    updateUI();
                }
            }
        }

        function checkLevelUp() {
            while (gameState.player.xp >= gameState.player.xpToLevel) {
                gameState.player.xp -= gameState.player.xpToLevel;
                gameState.player.level++;
                gameState.player.xpToLevel = Math.floor(gameState.player.xpToLevel * 1.5);
                
                const levelUpEl = document.getElementById('levelUp');
                levelUpEl.style.animation = 'none';
                setTimeout(() => {
                    levelUpEl.style.animation = 'levelUpAnim 2s';
                }, 10);
            }
        }

        // ============================================
        // PLAYER DAMAGE
        // ============================================
        function damagePlayer(amount) {
            gameState.player.health -= amount;
            if (gameState.player.health < 0) gameState.player.health = 0;
            
            const flash = document.getElementById('damageFlash');
            flash.style.opacity = '1';
            setTimeout(() => flash.style.opacity = '0', 200);
            
            updateUI();
            
            if (gameState.player.health <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            gameState.isGameOver = true;
            alert(`Game Over! Level: ${gameState.player.level}, Kills: ${gameState.player.kills}`);
        }

        function restartGame() {
            location.reload();
        }

        // ============================================
        // UI
        // ============================================
        function updateUI() {
            const maxHealth = UPGRADES.health.effect(gameState.upgrades.health);
            gameState.player.maxHealth = maxHealth;
            
            document.getElementById('levelDisplay').textContent = gameState.player.level;
            document.getElementById('hpDisplay').textContent = Math.ceil(gameState.player.health);
            document.getElementById('goldDisplay').textContent = gameState.player.gold;
            document.getElementById('killDisplay').textContent = gameState.player.kills;
            
            const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';
            
            const xpPercent = (gameState.player.xp / gameState.player.xpToLevel) * 100;
            document.getElementById('xpFill').style.width = xpPercent + '%';
        }

        // ============================================
        // SWORD ATTACK
        // ============================================
        function fireSwords() {
            const swordCount = CONFIG.swordCount;
            const radius = CONFIG.swordRadius;
            
            for (let i = 0; i < swordCount; i++) {
                const angle = (i / swordCount) * Math.PI * 2;
                
                const geometry = new THREE.BoxGeometry(0.3, 1.5, 0.1);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const sword = new THREE.Mesh(geometry, material);
                
                sword.position.copy(gameState.player.position);
                sword.position.x += Math.cos(angle) * radius;
                sword.position.z += Math.sin(angle) * radius;
                sword.position.y = 1;
                
                sword.rotation.y = angle;
                
                scene.add(sword);
                gameState.swords.push({
                    mesh: sword,
                    angle: angle,
                    birthTime: Date.now()
                });
            }
        }

        function updateSwords() {
            const now = Date.now();
            const damage = CONFIG.swordDamage;
            
            for (let i = gameState.swords.length - 1; i >= 0; i--) {
                const sword = gameState.swords[i];
                
                if (now - sword.birthTime > CONFIG.swordDuration) {
                    scene.remove(sword.mesh);
                    gameState.swords.splice(i, 1);
                    continue;
                }
                
                sword.angle += 0.1;
                sword.mesh.position.x = gameState.player.position.x + Math.cos(sword.angle) * CONFIG.swordRadius;
                sword.mesh.position.z = gameState.player.position.z + Math.sin(sword.angle) * CONFIG.swordRadius;
                sword.mesh.rotation.y = sword.angle;
                
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dist = sword.mesh.position.distanceTo(enemy.mesh.position);
                    if (dist < 1) {
                        enemy.health -= damage;
                        if (enemy.health <= 0) {
                            killEnemy(j);
                        }
                    }
                }
                
                for (let j = gameState.bosses.length - 1; j >= 0; j--) {
                    const boss = gameState.bosses[j];
                    const dist = sword.mesh.position.distanceTo(boss.mesh.position);
                    if (dist < 2) {
                        boss.health -= damage;
                        if (boss.health <= 0) {
                            killBoss(j);
                        }
                    }
                }
                
                if (gameState.inCloudArena) {
                    for (let j = gameState.arenaEnemies.length - 1; j >= 0; j--) {
                        const enemy = gameState.arenaEnemies[j];
                        const dist = sword.mesh.position.distanceTo(enemy.mesh.position);
                        if (dist < 1) {
                            enemy.health -= damage;
                            if (enemy.health <= 0) {
                                killArenaEnemy(j);
                            }
                        }
                    }
                }
            }
        }

        // ============================================
        // BOOM ATTACK
        // ============================================
        function fireBoom() {
            const now = Date.now();
            if (now - gameState.lastBoomTime < CONFIG.boomCooldown) return;
            
            gameState.lastBoomTime = now;
            
            const geometry = new THREE.SphereGeometry(1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff00ff,
                transparent: true,
                opacity: 0.7
            });
            const boom = new THREE.Mesh(geometry, material);
            boom.position.copy(gameState.player.position);
            boom.position.y = 1;
            
            scene.add(boom);
            gameState.boomProjectiles.push({
                mesh: boom,
                birthTime: now,
                scale: 1
            });
        }

        function updateBoomProjectiles() {
            const now = Date.now();
            const maxScale = CONFIG.boomRadius;
            const expandDuration = 1000;
            
            for (let i = gameState.boomProjectiles.length - 1; i >= 0; i--) {
                const boom = gameState.boomProjectiles[i];
                const age = now - boom.birthTime;
                
                if (age > expandDuration) {
                    scene.remove(boom.mesh);
                    gameState.boomProjectiles.splice(i, 1);
                    continue;
                }
                
                const progress = age / expandDuration;
                boom.scale = 1 + (maxScale - 1) * progress;
                boom.mesh.scale.set(boom.scale, boom.scale, boom.scale);
                boom.mesh.material.opacity = 0.7 * (1 - progress);
                
                const hitEnemies = new Set();
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    if (hitEnemies.has(enemy)) continue;
                    
                    const dist = boom.mesh.position.distanceTo(enemy.mesh.position);
                    if (dist < boom.scale) {
                        enemy.health -= CONFIG.boomDamage;
                        hitEnemies.add(enemy);
                        if (enemy.health <= 0) {
                            killEnemy(j);
                        }
                    }
                }
                
                for (let j = gameState.bosses.length - 1; j >= 0; j--) {
                    const boss = gameState.bosses[j];
                    const dist = boom.mesh.position.distanceTo(boss.mesh.position);
                    if (dist < boom.scale) {
                        boss.health -= CONFIG.boomDamage;
                        if (boss.health <= 0) {
                            killBoss(j);
                        }
                    }
                }
                
                if (gameState.inCloudArena) {
                    for (let j = gameState.arenaEnemies.length - 1; j >= 0; j--) {
                        const enemy = gameState.arenaEnemies[j];
                        if (hitEnemies.has(enemy)) continue;
                        
                        const dist = boom.mesh.position.distanceTo(enemy.mesh.position);
                        if (dist < boom.scale) {
                            enemy.health -= CONFIG.boomDamage;
                            hitEnemies.add(enemy);
                            if (enemy.health <= 0) {
                                killArenaEnemy(j);
                            }
                        }
                    }
                }
            }
        }

        function updateBoomCooldown() {
            const now = Date.now();
            const timeSinceBoom = now - gameState.lastBoomTime;
            
            if (timeSinceBoom < CONFIG.boomCooldown) {
                const remaining = Math.ceil((CONFIG.boomCooldown - timeSinceBoom) / 1000);
                document.getElementById('boomTimer').textContent = remaining;
                document.getElementById('boomCooldown').classList.add('active');
            } else {
                document.getElementById('boomCooldown').classList.remove('active');
            }
        }

        // ============================================
        // BOSSES
        // ============================================
        function shouldSpawnBoss() {
            return Math.random() < 0.02 && gameState.player.level >= 3;
        }

        function spawnBoss() {
            const angle = Math.random() * Math.PI * 2;
            const distance = CONFIG.enemySpawnDistance + 10;
            
            const bossGroup = new THREE.Group();
            
            const bodyGeometry = new THREE.BoxGeometry(2, 2.5, 1);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8b0000 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.25;
            body.castShadow = true;
            bossGroup.add(body);
            
            const headGeometry = new THREE.SphereGeometry(0.8, 8, 8);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0x4a0000 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 3;
            head.castShadow = true;
            bossGroup.add(head);
            
            const hornGeometry = new THREE.ConeGeometry(0.3, 1, 6);
            const hornMaterial = new THREE.MeshLambertMaterial({ color: 0x2a0000 });
            const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            leftHorn.position.set(-0.5, 3.8, 0);
            leftHorn.rotation.z = -0.3;
            bossGroup.add(leftHorn);
            const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            rightHorn.position.set(0.5, 3.8, 0);
            rightHorn.rotation.z = 0.3;
            bossGroup.add(rightHorn);
            
            bossGroup.position.set(
                gameState.player.position.x + Math.cos(angle) * distance,
                0,
                gameState.player.position.z + Math.sin(angle) * distance
            );
            
            scene.add(bossGroup);
            
            gameState.bosses.push({
                mesh: bossGroup,
                health: CONFIG.bossHealth,
                lastAttackTime: 0
            });
        }

        function updateBosses() {
            const currentTime = Date.now();
            
            for (let i = gameState.bosses.length - 1; i >= 0; i--) {
                const boss = gameState.bosses[i];
                const dx = gameState.player.position.x - boss.mesh.position.x;
                const dz = gameState.player.position.z - boss.mesh.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance > 0.1) {
                    boss.mesh.position.x += (dx / distance) * CONFIG.bossSpeed;
                    boss.mesh.position.z += (dz / distance) * CONFIG.bossSpeed;
                }
                
                if (distance < 2 && currentTime - boss.lastAttackTime > 1500) {
                    damagePlayer(CONFIG.bossDamage);
                    boss.lastAttackTime = currentTime;
                }
            }
        }

        function killBoss(index) {
            const boss = gameState.bosses[index];
            
            for (let i = 0; i < 5; i++) {
                dropXPOrb(boss.mesh.position);
            }
            for (let i = 0; i < 3; i++) {
                dropGoldOrb(boss.mesh.position);
            }
            
            scene.remove(boss.mesh);
            gameState.bosses.splice(index, 1);
            gameState.player.kills++;
            updateUI();
        }

        // ============================================
        // ENCOUNTERS
        // ============================================
        const ENCOUNTERS = [
            {
                speaker: "üßô Wise Hermit",
                text: "Greetings, traveler. The forest grows darker each day. Take this wisdom: strength comes not from power alone, but from knowing when to strike.",
                reward: { type: 'gold', amount: 20 }
            },
            {
                speaker: "ü¶â Ancient Owl",
                text: "Hoot hoot! I've seen many warriors pass through. Few survive. Here, take this token of guidance.",
                reward: { type: 'xp', amount: 50 }
            },
            {
                speaker: "üëª Forest Spirit",
                text: "The veil between worlds is thin here. Your courage has earned you a blessing from beyond.",
                reward: { type: 'gold', amount: 30 }
            },
            {
                speaker: "üçÑ Mushroom Circle",
                text: "You've discovered a fairy ring! The fae leave gifts for those pure of heart.",
                reward: { type: 'xp', amount: 75 }
            }
        ];

        function shouldSpawnEncounter() {
            return Math.random() < CONFIG.encounterSpawnChance && gameState.player.level >= 2;
        }

        function spawnEncounter() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 20;
            
            const encounter = ENCOUNTERS[Math.floor(Math.random() * ENCOUNTERS.length)];
            
            const geometry = new THREE.SphereGeometry(0.8, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffd700,
                transparent: true,
                opacity: 0.8
            });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.set(
                gameState.player.position.x + Math.cos(angle) * distance,
                1,
                gameState.player.position.z + Math.sin(angle) * distance
            );
            
            scene.add(marker);
            
            gameState.encounters.push({
                mesh: marker,
                data: encounter,
                triggered: false
            });
        }

        function updateEncounter() {
            for (let i = gameState.encounters.length - 1; i >= 0; i--) {
                const enc = gameState.encounters[i];
                
                enc.mesh.rotation.y += 0.02;
                enc.mesh.position.y = 1 + Math.sin(Date.now() * 0.003) * 0.3;
                
                const dist = enc.mesh.position.distanceTo(gameState.player.position);
                if (dist < 2 && !enc.triggered) {
                    enc.triggered = true;
                    triggerDialogue(enc.data);
                    scene.remove(enc.mesh);
                    gameState.encounters.splice(i, 1);
                }
            }
        }

        function triggerDialogue(encounter) {
            gameState.dialogueTimer = 5000;
            gameState.currentDialogue = encounter;
            
            document.getElementById('dialogueSpeaker').textContent = encounter.speaker;
            document.getElementById('dialogueText').textContent = encounter.text;
            document.getElementById('dialogueBox').classList.add('active');
        }

        function closeDialogue() {
            const encounter = gameState.currentDialogue;
            if (encounter && encounter.reward) {
                if (encounter.reward.type === 'gold') {
                    gameState.player.gold += encounter.reward.amount;
                } else if (encounter.reward.type === 'xp') {
                    gameState.player.xp += encounter.reward.amount;
                    checkLevelUp();
                }
                updateUI();
            }
            
            document.getElementById('dialogueBox').classList.remove('active');
            gameState.dialogueTimer = 0;
            gameState.currentDialogue = null;
        }

        function updateDialogue() {
            if (gameState.dialogueTimer > 0) {
                gameState.dialogueTimer -= 16;
            }
        }

        function setupDialogueButton() {
            document.getElementById('dialogueBtn').addEventListener('click', closeDialogue);
            document.getElementById('dialogueBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                closeDialogue();
            });
        }

        // ============================================
        // TREASURE CHESTS
        // ============================================
        function shouldSpawnChest() {
            return Math.random() < CONFIG.chestSpawnChance;
        }

        function spawnTreasureChest() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 25;
            
            const chestGroup = new THREE.Group();
            
            const baseGeometry = new THREE.BoxGeometry(1, 0.6, 0.8);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.3;
            chestGroup.add(base);
            
            const lidGeometry = new THREE.BoxGeometry(1, 0.3, 0.8);
            const lidMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const lid = new THREE.Mesh(lidGeometry, lidMaterial);
            lid.position.y = 0.75;
            chestGroup.add(lid);
            
            chestGroup.position.set(
                gameState.player.position.x + Math.cos(angle) * distance,
                0,
                gameState.player.position.z + Math.sin(angle) * distance
            );
            
            scene.add(chestGroup);
            
            gameState.treasureChests.push({
                mesh: chestGroup,
                opened: false
            });
        }

        function updateTreasureChests() {
            for (let i = gameState.treasureChests.length - 1; i >= 0; i--) {
                const chest = gameState.treasureChests[i];
                if (chest.opened) continue;
                
                const dist = chest.mesh.position.distanceTo(gameState.player.position);
                if (dist < 2) {
                    chest.opened = true;
                    gameState.player.gold += CONFIG.chestGold;
                    updateUI();
                    
                    chest.mesh.children[1].position.y = 1.2;
                    chest.mesh.children[1].rotation.x = -Math.PI / 3;
                    
                    for (let j = 0; j < 3; j++) {
                        dropGoldOrb(chest.mesh.position);
                    }
                }
            }
        }

        // ============================================
        // CLOUD PORTAL & ARENA
        // ============================================
        let portalTextures = [];

        function initPortalTextures() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            for (let f = 0; f < 8; f++) {
                ctx.clearRect(0, 0, 64, 64);
                const gradient = ctx.createRadialGradient(32, 32, 10, 32, 32, 32);
                const hue = (f * 45) % 360;
                gradient.addColorStop(0, `hsla(${hue}, 100%, 70%, 1)`);
                gradient.addColorStop(0.5, `hsla(${hue + 60}, 100%, 50%, 0.8)`);
                gradient.addColorStop(1, `hsla(${hue + 120}, 100%, 30%, 0)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                portalTextures.push(texture);
            }
        }

        function shouldSpawnPortal() {
            return gameState.player.level >= 12 && 
                   gameState.cloudPortals.length === 0 &&
                   !gameState.inCloudArena &&
                   Math.random() < CONFIG.portalSpawnChance;
        }

        function spawnCloudPortal() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 30;
            
            const geometry = new THREE.CylinderGeometry(2, 2, 0.1, 32);
            const material = new THREE.MeshBasicMaterial({
                map: portalTextures[0],
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            const portal = new THREE.Mesh(geometry, material);
            portal.rotation.x = Math.PI / 2;
            portal.position.set(
                gameState.player.position.x + Math.cos(angle) * distance,
                1,
                gameState.player.position.z + Math.sin(angle) * distance
            );
            
            scene.add(portal);
            
            gameState.cloudPortals.push({
                mesh: portal,
                frame: 0
            });
            
            gameState.targetPortal = portal.position.clone();
            document.getElementById('compass').classList.add('active');
        }

        function updateCloudPortal() {
            for (let i = gameState.cloudPortals.length - 1; i >= 0; i--) {
                const portal = gameState.cloudPortals[i];
                
                portal.frame = (portal.frame + 1) % portalTextures.length;
                portal.mesh.material.map = portalTextures[portal.frame];
                portal.mesh.rotation.z += 0.02;
                
                const dist = portal.mesh.position.distanceTo(gameState.player.position);
                if (dist < 3) {
                    enterCloudArena();
                    scene.remove(portal.mesh);
                    gameState.cloudPortals.splice(i, 1);
                    gameState.targetPortal = null;
                    document.getElementById('compass').classList.remove('active');
                }
            }
        }

        function enterCloudArena() {
            gameState.inCloudArena = true;
            gameState.arenaWave = 1;
            gameState.arenaKills = 0;
            
            for (const chunk of gameState.chunks.values()) {
                chunk.visible = false;
            }
            
            scene.fog = new THREE.Fog(0xe6f3ff, 10, 50);
            ground.material.color.setHex(0xffffff);
            
            const cloudGeometry = new THREE.SphereGeometry(40, 16, 16);
            const cloudMaterial = new THREE.MeshLambertMaterial({
                color: 0xe6f3ff,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const cloudDome = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloudDome.position.copy(gameState.player.position);
            cloudDome.position.y = 0;
            scene.add(cloudDome);
            gameState.arenaCloudDome = cloudDome;
            
            spawnArenaWave();
            
            triggerDialogue({
                speaker: "‚òÅÔ∏è Cloud Guardian",
                text: "Welcome to the Sky Arena! Defeat waves of enemies to claim your reward and return to the forest.",
                reward: null
            });
        }

        function spawnArenaWave() {
            const enemyCount = 3 + gameState.arenaWave * 2;
            
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    spawnArenaEnemy();
                }, i * 500);
            }
        }

        function spawnArenaEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 20;
            
            const enemyGroup = new THREE.Group();
            
            const bodyGeometry = new THREE.BoxGeometry(1, 1.2, 0.5);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4488ff });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            body.castShadow = true;
            enemyGroup.add(body);
            
            const headGeometry = new THREE.SphereGeometry(0.3, 6, 6);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0x2244aa });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = true;
            enemyGroup.add(head);
            
            enemyGroup.position.set(
                gameState.player.position.x + Math.cos(angle) * distance,
                0,
                gameState.player.position.z + Math.sin(angle) * distance
            );
            
            scene.add(enemyGroup);
            
            gameState.arenaEnemies.push({
                mesh: enemyGroup,
                health: CONFIG.enemyHealth * (1 + gameState.arenaWave * 0.5),
                lastAttackTime: 0
            });
        }

        function updateCloudArena() {
            const currentTime = Date.now();
            
            for (let i = gameState.arenaEnemies.length - 1; i >= 0; i--) {
                const enemy = gameState.arenaEnemies[i];
                const dx = gameState.player.position.x - enemy.mesh.position.x;
                const dz = gameState.player.position.z - enemy.mesh.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance > 0.1) {
                    enemy.mesh.position.x += (dx / distance) * CONFIG.enemySpeed;
                    enemy.mesh.position.z += (dz / distance) * CONFIG.enemySpeed;
                }
                
                if (distance < 1.5 && currentTime - enemy.lastAttackTime > 1000) {
                    damagePlayer(CONFIG.enemyDamage);
                    enemy.lastAttackTime = currentTime;
                }
            }
            
            if (gameState.arenaEnemies.length === 0) {
                if (gameState.arenaWave < 3) {
                    gameState.arenaWave++;
                    spawnArenaWave();
                } else {
                    exitCloudArena();
                }
            }
        }

        function killArenaEnemy(index) {
            const enemy = gameState.arenaEnemies[index];
            
            dropXPOrb(enemy.mesh.position);
            dropGoldOrb(enemy.mesh.position);
            
            scene.remove(enemy.mesh);
            gameState.arenaEnemies.splice(index, 1);
            gameState.arenaKills++;
            gameState.player.kills++;
            updateUI();
        }

        function exitCloudArena() {
            gameState.inCloudArena = false;
            
            const rewardGold = 100 + gameState.arenaWave * 50;
            const rewardXP = 200 + gameState.arenaWave * 100;
            
            gameState.player.gold += rewardGold;
            gameState.player.xp += rewardXP;
            checkLevelUp();
            updateUI();
            
            for (const chunk of gameState.chunks.values()) {
                chunk.visible = true;
            }
            
            scene.fog = new THREE.Fog(0x1a1a2e, 20, 80);
            ground.material.color.setHex(0x1a3a1a);
            
            if (gameState.arenaCloudDome) {
                scene.remove(gameState.arenaCloudDome);
                gameState.arenaCloudDome = null;
            }
            
            triggerDialogue({
                speaker: "‚òÅÔ∏è Cloud Guardian",
                text: `Victory! You've earned ${rewardGold} gold and ${rewardXP} XP. The forest awaits your return.`,
                reward: null
            });
        }

        function updateCompass() {
            if (!gameState.targetPortal) return;
            
            const dx = gameState.targetPortal.x - gameState.player.position.x;
            const dz = gameState.targetPortal.z - gameState.player.position.z;
            const angle = Math.atan2(dx, dz);
            
            const arrow = document.querySelector('.compass-arrow');
            const rotationDeg = (angle * 180 / Math.PI) - (gameState.player.rotation * 180 / Math.PI);
            arrow.style.transform = `rotate(${rotationDeg}deg)`;
        }

        // ============================================
        // CAMERA ZOOM
        // ============================================
        function updateCameraZoom() {
            gameState.cameraZoom = Math.max(0.5, Math.min(2.0, gameState.cameraZoom));
        }

        document.getElementById('zoomIn').addEventListener('click', () => {
            gameState.cameraZoom = Math.max(0.5, gameState.cameraZoom - 0.1);
        });
        document.getElementById('zoomIn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            gameState.cameraZoom = Math.max(0.5, gameState.cameraZoom - 0.1);
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            gameState.cameraZoom = Math.min(2.0, gameState.cameraZoom + 0.1);
        });
        document.getElementById('zoomOut').addEventListener('touchstart', (e) => {
            e.preventDefault();
            gameState.cameraZoom = Math.min(2.0, gameState.cameraZoom + 0.1);
        });

        // ============================================
        // CONTROLS
        // ============================================
        // D-Pad
        function setupDPad() {
            const dpadButtons = {
                'dpad-up': 'up',
                'dpad-down': 'down',
                'dpad-left': 'left',
                'dpad-right': 'right'
            };

            Object.keys(dpadButtons).forEach(btnId => {
                const btn = document.getElementById(btnId);
                const control = dpadButtons[btnId];

                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (gameState.dialogueTimer <= 0) {
                        controls[control] = true;
                        btn.classList.add('active');
                    }
                });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    controls[control] = false;
                    btn.classList.remove('active');
                });

                btn.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    controls[control] = false;
                    btn.classList.remove('active');
                });

                // Mouse support
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (gameState.dialogueTimer <= 0) {
                        controls[control] = true;
                        btn.classList.add('active');
                    }
                });

                btn.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    controls[control] = false;
                    btn.classList.remove('active');
                });

                btn.addEventListener('mouseleave', (e) => {
                    controls[control] = false;
                    btn.classList.remove('active');
                });
            });
        }

        // Magic button
        function setupMagicButton() {
            const magicBtn = document.getElementById('magicBtn');
            
            let lastTap = 0;
            
            magicBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState.dialogueTimer > 0) return;
                
                const now = Date.now();
                if (now - lastTap < 300) {
                    fireBoom();
                } else {
                    fireSwords();
                }
                lastTap = now;
            });

            magicBtn.addEventListener('click', (e) => {
                e.preventDefault();
                if (gameState.dialogueTimer > 0) return;
                fireSwords();
            });
        }

        // View controls - MODIFIED TO WORK WITH D-PAD
        function setupViewControl() {
            const viewArea = document.getElementById('viewArea');
            let touchStartX = 0;
            let touchStartY = 0;
            let isDragging = false;
            const activeTouches = new Map();

            // Helper function to check if touch is on a UI element
            function isTouchOnUI(x, y) {
                const elements = document.elementsFromPoint(x, y);
                return elements.some(el => 
                    el.closest('#dpad') || 
                    el.closest('#magicBtn') || 
                    el.closest('#menuBtn') ||
                    el.closest('.zoom-controls')
                );
            }

            viewArea.addEventListener('touchstart', (e) => {
                // Handle all touches, filtering out UI touches
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    if (!isTouchOnUI(touch.clientX, touch.clientY)) {
                        if (!isDragging) {
                            touchStartX = touch.clientX;
                            touchStartY = touch.clientY;
                            isDragging = true;
                            activeTouches.set(touch.identifier, {x: touch.clientX, y: touch.clientY});
                        }
                    }
                }
            });

            viewArea.addEventListener('touchmove', (e) => {
                if (gameState.dialogueTimer > 0) return;
                
                // Find a valid touch for camera rotation (not on UI)
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    if (activeTouches.has(touch.identifier)) {
                        const prevTouch = activeTouches.get(touch.identifier);
                        const dx = touch.clientX - prevTouch.x;
                        gameState.player.rotation += dx * 0.005;
                        activeTouches.set(touch.identifier, {x: touch.clientX, y: touch.clientY});
                        break; // Only use one touch for rotation
                    }
                }
            });

            viewArea.addEventListener('touchend', (e) => {
                // Remove ended touches from tracking
                const remainingTouches = new Set();
                for (let i = 0; i < e.touches.length; i++) {
                    remainingTouches.add(e.touches[i].identifier);
                }
                
                for (const id of activeTouches.keys()) {
                    if (!remainingTouches.has(id)) {
                        activeTouches.delete(id);
                    }
                }
                
                if (activeTouches.size === 0) {
                    isDragging = false;
                }
            });

            viewArea.addEventListener('touchcancel', (e) => {
                activeTouches.clear();
                isDragging = false;
            });

            // Mouse support
            viewArea.addEventListener('mousedown', (e) => {
                if (!isTouchOnUI(e.clientX, e.clientY)) {
                    touchStartX = e.clientX;
                    isDragging = true;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging && gameState.dialogueTimer <= 0) {
                    const dx = e.clientX - touchStartX;
                    gameState.player.rotation += dx * 0.005;
                    touchStartX = e.clientX;
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // Keyboard support
        function setupKeyboard() {
            document.addEventListener('keydown', (e) => {
                if (gameState.menuOpen) {
                    if (e.key === 'Escape') closeMenu();
                    return;
                }
                if (gameState.dialogueTimer > 0) return;
                switch(e.key.toLowerCase()) {
                    case 'w': case 'arrowup': controls.up = true; break;
                    case 's': case 'arrowdown': controls.down = true; break;
                    case 'a': case 'arrowleft': controls.left = true; break;
                    case 'd': case 'arrowright': controls.right = true; break;
                    case ' ': shootProjectile(); break;
                    case 'q': fireBoom(); break;
                    case 'e': case 'escape': 
                        if (gameState.menuOpen) closeMenu();
                        else openMenu();
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w': case 'arrowup': controls.up = false; break;
                    case 's': case 'arrowdown': controls.down = false; break;
                    case 'a': case 'arrowleft': controls.left = false; break;
                    case 'd': case 'arrowright': controls.right = false; break;
                }
            });
        }

        // Restart button
        document.getElementById('restartBtn').addEventListener('click', restartGame);
        document.getElementById('restartBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            restartGame();
        });

        // ============================================
        // GAME LOOP
        // ============================================
        let lastSpawnTime = 0;

        function updatePlayer() {
            if (gameState.isGameOver) return;
            if (gameState.dialogueTimer > 0) return;

            const moveSpeed = UPGRADES.speed.effect(gameState.upgrades.speed);
            let moved = false;

            if (controls.up) {
                gameState.player.position.x -= Math.sin(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z -= Math.cos(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.down) {
                gameState.player.position.x += Math.sin(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z += Math.cos(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.left) {
                gameState.player.position.x -= Math.cos(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z += Math.sin(gameState.player.rotation) * moveSpeed;
                moved = true;
            }
            if (controls.right) {
                gameState.player.position.x += Math.cos(gameState.player.rotation) * moveSpeed;
                gameState.player.position.z -= Math.sin(gameState.player.rotation) * moveSpeed;
                moved = true;
            }

            playerGroup.position.copy(gameState.player.position);

            const camDist = 12 * gameState.cameraZoom;
            const camHeight = 8 * gameState.cameraZoom;
            camera.position.x = gameState.player.position.x + Math.sin(gameState.player.rotation) * camDist;
            camera.position.z = gameState.player.position.z + Math.cos(gameState.player.rotation) * camDist;
            camera.position.y = camHeight;
            camera.lookAt(
                gameState.player.position.x,
                2,
                gameState.player.position.z
            );

            ground.position.x = gameState.player.position.x;
            ground.position.z = gameState.player.position.z;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!gameState.isGameOver && !gameState.menuOpen) {
                updatePlayer();
                
                if (!gameState.inCloudArena) {
                    updateChunks();
                    updateEnemies();
                    updateBosses();
                    updateEncounter();
                    updateTreasureChests();
                    updateCloudPortal();
                } else {
                    updateCloudArena();
                }
                
                updateProjectiles();
                updateXPOrbs();
                updateGoldOrbs();
                updateSwords();
                updateBoomProjectiles();
                updateBoomCooldown();
                updateDialogue();
                updateCompass();
                updateCameraZoom();

                if (!gameState.inCloudArena) {
                    const now = Date.now();
                    if (now - lastSpawnTime > CONFIG.enemySpawnInterval) {
                        spawnEnemy();
                        
                        if (shouldSpawnBoss()) {
                            spawnBoss();
                        }
                        else if (shouldSpawnEncounter()) {
                            spawnEncounter();
                        }
                        
                        if (shouldSpawnChest()) {
                            spawnTreasureChest();
                        }
                        
                        if (shouldSpawnPortal()) {
                            spawnCloudPortal();
                        }
                        
                        lastSpawnTime = now;
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            setupDPad();
            setupMagicButton();
            setupViewControl();
            setupKeyboard();
            setupMenuControls();
            setupDialogueButton();
            
            initPortalTextures();

            updateChunks();
            
            updateUpgradeMenu();

            animate();

            setTimeout(() => {
                for (let i = 0; i < 3; i++) {
                    spawnEnemy();
                }
            }, 1000);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
    
    <!-- Load modular game systems -->
    <script src="js/enemies.js"></script>
    <script src="js/bosses.js"></script>
</body>
    </html>
