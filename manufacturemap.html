<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Production Line Mapper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            height: 100vh;
            overflow: hidden;
        }

        .toolbar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 1000;
            box-shadow: 0 1px 20px rgba(0, 0, 0, 0.03);
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .toolbar-center {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .toolbar-right {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .toolbar button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 0.75rem 1.25rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 122, 255, 0.2);
            letter-spacing: -0.01em;
        }

        .toolbar button:hover {
            background: #0056CC;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.25);
        }

        .toolbar button.secondary {
            background: #F2F2F7;
            color: #1D1D1F;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .toolbar button.secondary:hover {
            background: #E5E5EA;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        }

        .toolbar button.active {
            background: #34C759;
        }

        .toolbar button.active:hover {
            background: #28A745;
        }

        .view-toggle {
            background: #34C759;
            padding: 0.75rem 1.5rem;
            font-weight: 700;
        }

        .view-toggle:hover {
            background: #28A745;
        }

        .canvas-container {
            position: relative;
            height: calc(100vh - 80px);
            overflow: auto;
            background: #F8F9FA;
        }

        .canvas {
            position: relative;
            min-width: 3000px;
            min-height: 3000px;
            background-image: 
                radial-gradient(circle, #E5E5EA 1px, transparent 1px);
            background-size: 24px 24px;
        }

        .canvas.timeline-mode {
            background: #FAFBFC;
            min-width: 4000px;
            min-height: 1500px;
            background-image: none;
        }

        .canvas.zoomed-out {
            transform: scale(0.3);
            transform-origin: top left;
        }

        .canvas.zoomed-out .card-title,
        .canvas.zoomed-out input,
        .canvas.zoomed-out button {
            pointer-events: none;
        }

        .grid-labels {
            position: absolute;
            pointer-events: none;
            color: #8E8E93;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .grid-label-x {
            top: 5px;
        }

        .grid-label-y {
            left: 5px;
            writing-mode: vertical-lr;
            text-orientation: mixed;
        }

        .production-card {
            position: absolute;
            width: 200px;
            min-height: 120px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 12px;
            padding: 1rem;
            cursor: move;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            transition: all 0.2s ease;
            z-index: 100;
        }

        .production-card:hover {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
            border-color: rgba(0, 122, 255, 0.3);
            transform: translateY(-2px);
        }

        .production-card.dragging {
            opacity: 0.95;
            transform: rotate(1deg) scale(1.02);
            z-index: 1000;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }

        .storage-card {
            position: absolute;
            background: rgba(255, 248, 220, 0.95);
            backdrop-filter: blur(20px);
            border: 2px solid #FF9500;
            border-radius: 12px;
            padding: 1rem;
            cursor: move;
            box-shadow: 0 4px 20px rgba(255, 149, 0, 0.15);
            transition: all 0.2s ease;
            z-index: 100;
            resize: both;
            overflow: auto;
        }

        .storage-card::after {
            content: "‚§°";
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 24px;
            height: 24px;
            background: #FF9500;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            cursor: nw-resize;
            border-radius: 4px 4px 8px 4px;
            line-height: 1;
            box-shadow: 0 2px 8px rgba(255, 149, 0, 0.3);
            transition: all 0.2s ease;
        }

        .storage-card::after:hover {
            background: #E8860A;
            transform: scale(1.1);
        }

        .storage-card .card-controls {
            position: absolute !important;
            top: -20px !important;
            right: -20px !important;
            display: flex;
            gap: 6px;
            z-index: 300;
            pointer-events: auto;
        }

        .storage-card:hover {
            box-shadow: 0 8px 30px rgba(255, 149, 0, 0.25);
            transform: translateY(-2px);
        }

        .storage-card.dragging {
            opacity: 0.95;
            transform: rotate(1deg) scale(1.02);
            z-index: 1000;
            box-shadow: 0 20px 40px rgba(255, 149, 0, 0.3);
        }

        .card-number {
            position: absolute;
            top: -10px;
            left: -10px;
            background: #007AFF;
            color: white;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);
        }

        .storage-card .card-number {
            background: #FF9500;
            box-shadow: 0 2px 8px rgba(255, 149, 0, 0.3);
        }

        
        .card-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(255, 255, 255, 0.8);
            width: 100%;
            font-size: 1rem;
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            color: #1D1D1F;
        }

        .card-title:focus {
            border-color: #007AFF;
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
            background: white;
        }

        .card-controls {
            position: absolute;
            top: -10px;
            right: -10px;
            display: flex;
            gap: 6px;
        }

        .card-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .delete-btn {
            background: #FF3B30;
            color: white;
        }

        .delete-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(255, 59, 48, 0.3);
        }

        .connect-btn {
            background: #34C759;
            color: white;
        }

        .connect-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(52, 199, 89, 0.3);
        }

        .safety-indicator {
            position: absolute;
            top: -5px;
            right: 30px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            font-size: 0.7rem;
            font-weight: bold;
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .safety-indicator.hazmat { background: #FF3B30; display: flex; }
        .safety-indicator.high-voltage { background: #FFD60A; color: black; display: flex; }
        .safety-indicator.confined-space { background: #8E44AD; display: flex; }
        .safety-indicator.dust { background: #95A5A6; display: flex; }
        .safety-indicator.noise { background: #E67E22; display: flex; }
        .safety-indicator.chemical { background: #27AE60; display: flex; }
        .safety-indicator.hot-surface { background: #E74C3C; display: flex; }

        .buffer-zone {
            position: absolute;
            border: 3px solid #34C759;
            background: rgba(52, 199, 89, 0.1);
            cursor: pointer;
            z-index: 50;
        }

        .buffer-zone:hover {
            background: rgba(52, 199, 89, 0.2);
            border-color: #28A745;
        }

        .buffer-label {
            position: absolute;
            background: #34C759;
            color: white;
            padding: 2px 6px;
            font-size: 0.7rem;
            border-radius: 4px;
            top: -12px;
            left: 5px;
            font-weight: 600;
        }

        .arrow {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }

        .arrow-line {
            stroke-width: 3;
            fill: none;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.1));
        }

        .production-card.source-card {
            border: 2px solid #34C759;
            box-shadow: 0 0 0 4px rgba(52, 199, 89, 0.15);
        }

        .production-card.can-connect, .storage-card.can-connect {
            border: 2px solid #FF9500;
            box-shadow: 0 0 0 4px rgba(255, 149, 0, 0.15);
        }

        .timeline-swimlane {
            position: absolute;
            left: 0;
            right: 0;
            height: 200px;
            border-bottom: 2px solid #E5E5EA;
            background: rgba(248, 249, 250, 0.5);
        }

        .swimlane-label {
            position: absolute;
            left: 20px;
            top: 20px;
            font-weight: 700;
            color: #1D1D1F;
            font-size: 1.1rem;
        }

        .timeline-card {
            height: 120px !important;
            width: 200px !important;
            min-width: 200px !important;
            margin: 40px 20px;
            resize: none !important;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(20px);
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            padding: 2.5rem;
            border-radius: 16px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .edit-modal {
            width: 600px;
        }

        .edit-modal h3 {
            color: #1D1D1F;
            margin-bottom: 1.5rem;
            font-size: 1.75rem;
            font-weight: 700;
            text-align: center;
            letter-spacing: -0.02em;
        }

        .edit-modal .form-group {
            margin-bottom: 1.5rem;
        }

        .edit-modal label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #1D1D1F;
            font-size: 0.95rem;
            letter-spacing: -0.01em;
        }

        .edit-modal input, .edit-modal textarea, .edit-modal select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.2s ease;
            background: rgba(255, 255, 255, 0.8);
            color: #1D1D1F;
        }

        .edit-modal input:focus, .edit-modal textarea:focus, .edit-modal select:focus {
            border-color: #007AFF;
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
            background: white;
        }

        .edit-modal textarea {
            height: 90px;
            resize: vertical;
        }

        .edit-modal .button-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }

        .edit-modal button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s ease;
            letter-spacing: -0.01em;
        }

        .edit-modal button:hover {
            background: #0056CC;
            transform: translateY(-1px);
        }

        .edit-modal button.secondary {
            background: #F2F2F7;
            color: #1D1D1F;
        }

        .edit-modal button.secondary:hover {
            background: #E5E5EA;
        }

        .form-row {
            display: flex;
            gap: 1rem;
        }

        .form-row .form-group {
            flex: 1;
        }

        .arrow-details-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 122, 255, 0.3);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            cursor: pointer;
            z-index: 200;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
            color: #007AFF;
            letter-spacing: -0.01em;
        }

        .arrow-details-btn:hover {
            background: white;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border-color: #007AFF;
            transform: translateY(-1px);
        }

        .file-input {
            display: none;
        }

        .drawing-mode {
            cursor: crosshair !important;
        }

        .drawing-mode * {
            cursor: crosshair !important;
        }

        .buffer-drawing {
            position: absolute;
            border: 2px dashed #34C759;
            background: rgba(52, 199, 89, 0.1);
            pointer-events: none;
            z-index: 500;
        }

        @media (max-width: 768px) {
            .toolbar {
                padding: 1rem;
                flex-wrap: wrap;
                gap: 1rem;
            }
            
            .toolbar-left, .toolbar-center, .toolbar-right {
                flex: 1;
                justify-content: center;
            }
            
            .toolbar-right {
                gap: 0.5rem;
            }
            
            .toolbar button {
                padding: 0.6rem 1rem;
                font-size: 0.85rem;
            }
            
            .production-card, .storage-card {
                width: 160px;
                min-height: 100px;
                padding: 0.8rem;
            }
            
            .canvas-container {
                height: calc(100vh - 120px);
            }
            
            .edit-modal {
                width: 95%;
                padding: 2rem 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <div class="toolbar-left">
            <button onclick="addProductionStation()">Add Station</button>
            <button onclick="addStorageCard()" class="secondary">Add Storage</button>
            <button onclick="toggleDrawingMode()" id="drawBufferBtn" class="secondary">Draw Buffer</button>
            <button onclick="zoomOut()" class="secondary" id="zoomBtn">üîç Zoom Out</button>
        </div>
        <div class="toolbar-center">
            <button onclick="toggleView()" class="view-toggle" id="viewToggle">
                üìä Switch to Timeline
            </button>
        </div>
        <div class="toolbar-right">
            <button onclick="exportProject()" class="secondary">Export JSON</button>
            <button onclick="document.getElementById('importFile').click()" class="secondary">Import JSON</button>
        </div>
        <input type="file" id="importFile" class="file-input" accept=".json" onchange="importProject(event)">
        <span id="modeIndicator"></span>
    </div>

    <div class="canvas-container">
        <div class="canvas" id="canvas">
            <svg style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
                <defs>
                    <marker id="arrowhead-blue" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#007AFF"/>
                    </marker>
                    <marker id="arrowhead-green" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#34C759"/>
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <!-- Production Station Modal -->
    <div class="modal" id="stationModal">
        <div class="modal-content edit-modal">
            <h3>Production Station Details</h3>
            <div class="form-group">
                <label>Station Name:</label>
                <input type="text" id="stationTitle" placeholder="e.g., Assembly Station 1">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Operator Responsible:</label>
                    <input type="text" id="stationOperator" placeholder="Primary operator name/role">
                </div>
                <div class="form-group">
                    <label>Operator Count:</label>
                    <input type="number" id="operatorCount" placeholder="1" min="1">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Cycle Time (minutes):</label>
                    <input type="number" id="cycleTime" placeholder="5" min="0" step="0.1">
                </div>
                <div class="form-group">
                    <label>Throughput (units/hour):</label>
                    <input type="number" id="throughputRate" placeholder="12" min="0">
                </div>
            </div>
            <div class="form-group">
                <label>Equipment/Machinery:</label>
                <textarea id="stationEquipment" placeholder="CNC Mill, Conveyor Belt, Assembly Jig..."></textarea>
            </div>
            <div class="form-group">
                <label>Work Method/Process:</label>
                <textarea id="stationMethod" placeholder="How this operation is performed..."></textarea>
            </div>
            <div class="form-group">
                <label>Quality Check/Completion Criteria:</label>
                <textarea id="stationQuality" placeholder="How to verify this step is complete and acceptable..."></textarea>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Safety Zone:</label>
                    <select id="safetyZone">
                        <option value="none">None</option>
                        <option value="hazmat">Hazmat</option>
                        <option value="high-voltage">High Voltage</option>
                        <option value="confined-space">Confined Space</option>
                        <option value="dust">Dust Control</option>
                        <option value="noise">Noise Zone</option>
                        <option value="chemical">Chemical Area</option>
                        <option value="hot-surface">Hot Surface</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Priority Level:</label>
                    <select id="priorityLevel">
                        <option value="low">Low Priority</option>
                        <option value="medium" selected>Medium Priority</option>
                        <option value="high">High Priority</option>
                        <option value="critical">Critical Priority</option>
                    </select>
                </div>
            </div>
            
            <div class="button-group">
                <button onclick="closeStationModal()" class="secondary">Cancel</button>
                <button onclick="saveStation()">Save</button>
            </div>
        </div>
    </div>

    <!-- Storage Modal -->
    <div class="modal" id="storageModal">
        <div class="modal-content edit-modal">
            <h3>Storage Area Details</h3>
            <div class="form-group">
                <label>Storage Name:</label>
                <input type="text" id="storageTitle" placeholder="e.g., Raw Materials Bin">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Storage Type:</label>
                    <select id="storageType">
                        <option value="raw-materials">Raw Materials</option>
                        <option value="wip">Work-in-Progress</option>
                        <option value="finished-goods">Finished Goods</option>
                        <option value="tools">Tools & Equipment</option>
                        <option value="chemicals">Chemicals & Consumables</option>
                        <option value="safety">Safety Equipment</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Current Quantity:</label>
                    <input type="number" id="currentQuantity" placeholder="100" min="0">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Maximum Capacity:</label>
                    <input type="number" id="maxCapacity" placeholder="500" min="1">
                </div>
                <div class="form-group">
                    <label>Unit of Measure:</label>
                    <input type="text" id="unitMeasure" placeholder="pieces, kg, liters...">
                </div>
            </div>
            <div class="form-group">
                <label>Contents Description:</label>
                <textarea id="storageContents" placeholder="What is stored here..."></textarea>
            </div>
            <div class="form-group">
                <label>Storage Requirements:</label>
                <textarea id="storageRequirements" placeholder="Temperature, humidity, safety requirements..."></textarea>
            </div>
            
            <div class="button-group">
                <button onclick="closeStorageModal()" class="secondary">Cancel</button>
                <button onclick="saveStorage()">Save</button>
            </div>
        </div>
    </div>

    <!-- Material Flow Modal -->
    <div class="modal" id="connectionModal">
        <div class="modal-content edit-modal">
            <h3>Material Flow Details</h3>
            
            <div class="form-group">
                <label>Transport Method:</label>
                <select id="transportMethod">
                    <option value="manual">Manual Transport</option>
                    <option value="conveyor">Conveyor Belt</option>
                    <option value="forklift">Forklift</option>
                    <option value="cart">Push Cart/Trolley</option>
                    <option value="pneumatic">Pneumatic System</option>
                    <option value="crane">Crane/Hoist</option>
                    <option value="automated">Automated System</option>
                </select>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label>Transfer Time (minutes):</label>
                    <input type="number" id="transferTime" placeholder="2" min="0" step="0.1">
                </div>
                <div class="form-group">
                    <label>Batch Size:</label>
                    <input type="number" id="batchSize" placeholder="1" min="1">
                </div>
            </div>

            <div class="form-group">
                <label>Quality Check Required:</label>
                <textarea id="qualityCheck" placeholder="Inspection, testing, or validation required during transfer..."></textarea>
            </div>

            <div class="form-group">
                <label>Safety Requirements:</label>
                <textarea id="safetyRequirements" placeholder="PPE, procedures, or precautions for this material flow..."></textarea>
            </div>

            <div class="form-group">
                <label>Special Handling:</label>
                <textarea id="specialHandling" placeholder="Fragile, hazardous, temperature-sensitive..."></textarea>
            </div>

            <div class="button-group">
                <button onclick="closeConnectionModal()" class="secondary">Cancel</button>
                <button onclick="saveConnection()">Save</button>
            </div>
        </div>
    </div>

    <!-- Buffer Zone Modal -->
    <div class="modal" id="bufferModal">
        <div class="modal-content edit-modal">
            <h3>Buffer Zone Details</h3>
            
            <div class="form-group">
                <label>Buffer Type:</label>
                <select id="bufferType">
                    <option value="wall">Physical Wall</option>
                    <option value="partition">Partition/Screen</option>
                    <option value="conveyor">Conveyor Section</option>
                    <option value="dust">Dust Collection Barrier</option>
                    <option value="temperature">Temperature Control Zone</option>
                    <option value="noise">Noise Dampening</option>
                    <option value="safety">Safety Perimeter</option>
                    <option value="storage">Storage Boundary</option>
                </select>
            </div>

            <div class="form-group">
                <label>Description:</label>
                <textarea id="bufferDescription" placeholder="Details about this buffer zone..."></textarea>
            </div>

            <div class="form-group">
                <label>Height (if applicable):</label>
                <input type="number" id="bufferHeight" placeholder="2.5" step="0.1" min="0">
                <small>meters</small>
            </div>

            <div class="button-group">
                <button onclick="deleteBuffer()" class="secondary" style="background: #FF3B30; color: white;">Delete</button>
                <button onclick="closeBufferModal()" class="secondary">Cancel</button>
                <button onclick="saveBuffer()">Save</button>
            </div>
        </div>
    </div>

    <script>
        let drawConnectionsTimeout = null;
        let isZoomedOut = false;
        let cardCounter = 0;
        let sourceCard = null;

        function drawConnectionsThrottled() {
            if (drawConnectionsTimeout) {
                clearTimeout(drawConnectionsTimeout);
            }
            drawConnectionsTimeout = setTimeout(drawConnections, 50);
        }

        function zoomOut() {
            const canvas = document.getElementById('canvas');
            const btn = document.getElementById('zoomBtn');
            
            isZoomedOut = !isZoomedOut;
            
            if (isZoomedOut) {
                canvas.classList.add('zoomed-out');
                btn.textContent = 'üîç Zoom In';
                btn.style.background = '#FF9500';
            } else {
                canvas.classList.remove('zoomed-out');
                btn.textContent = 'üîç Zoom Out';
                btn.style.background = '#F2F2F7';
            }
        }
        let productionStations = [];
        let storageCards = [];
        let connections = [];
        let bufferZones = [];
        let draggedCard = null;
        let dragOffset = { x: 0, y: 0 };
        let currentEditingStation = null;
        let currentEditingStorage = null;
        let currentEditingConnection = null;
        let currentEditingBuffer = null;
        let isTimelineMode = false;
        let isDrawingMode = false;
        let isDrawingBuffer = false;
        let bufferStartPoint = null;
        let currentBufferDrawing = null;

        // Comment out localStorage functions for artifact compatibility
        /*
        function saveToStorage() {
            localStorage.setItem('productionLineData', JSON.stringify({ 
                productionStations, storageCards, connections, bufferZones, cardCounter 
            }));
        }
        
        function loadFromStorage() {
            const saved = localStorage.getItem('productionLineData');
            if (saved) {
                const data = JSON.parse(saved);
                productionStations = data.productionStations || [];
                storageCards = data.storageCards || [];
                connections = data.connections || [];
                bufferZones = data.bufferZones || [];
                cardCounter = data.cardCounter || 0;
                renderAll();
            }
        }
        */

        function updateStationField(stationId, field, value) {
            const station = productionStations.find(s => s.id === stationId);
            if (station) {
                station[field] = value;
                // saveToStorage();
            }
        }

        function updateStorageField(storageId, field, value) {
            const storage = storageCards.find(s => s.id === storageId);
            if (storage) {
                storage[field] = value;
                // saveToStorage();
            }
        }

        function addProductionStation() {
            cardCounter++;
            const station = {
                id: `station-${cardCounter}`,
                type: 'production',
                title: `New Station`,
                operator: '',
                operatorCount: 1,
                cycleTime: '',
                throughputRate: '',
                equipment: '',
                method: '',
                quality: '',
                safetyZone: 'none',
                priorityLevel: 'medium',
                x: 100 + (cardCounter * 60) % 800,
                y: 100 + Math.floor(cardCounter / 14) * 150,
                number: ''
            };
            productionStations.push(station);
            renderProductionStation(station);
            calculateNumbers();
            // saveToStorage();
        }

        function addStorageCard() {
            cardCounter++;
            const storage = {
                id: `storage-${cardCounter}`,
                type: 'storage',
                title: `New Storage`,
                storageType: 'raw-materials',
                currentQuantity: '',
                maxCapacity: '',
                unitMeasure: 'pieces',
                contents: '',
                requirements: '',
                x: 150 + (cardCounter * 60) % 800,
                y: 200 + Math.floor(cardCounter / 14) * 150,
                width: 200,
                height: 120,
                number: ''
            };
            storageCards.push(storage);
            renderStorageCard(storage);
            // saveToStorage();
        }

        function renderProductionStation(station) {
            const stationEl = document.createElement('div');
            stationEl.className = 'production-card';
            stationEl.id = station.id;
            stationEl.style.left = station.x + 'px';
            stationEl.style.top = station.y + 'px';
            
            const safetyIndicator = station.safetyZone !== 'none' ? 
                `<div class="safety-indicator ${station.safetyZone}">!</div>` : '';
            
            stationEl.innerHTML = `
                <div class="card-number">${station.number}</div>
                ${safetyIndicator}
                <div class="card-controls">
                    <button class="card-btn connect-btn" onclick="startConnection('${station.id}')" title="Connect">‚Üí</button>
                    <button class="card-btn delete-btn" onclick="deleteCard('${station.id}')" title="Delete">√ó</button>
                </div>
                <input class="card-title" value="${station.title}" 
                       onchange="updateStationField('${station.id}', 'title', this.value)" 
                       placeholder="Station name">
                <div style="margin: 0.5rem 0;">
                    <input value="${station.operator}" 
                           onchange="updateStationField('${station.id}', 'operator', this.value)"
                           placeholder="Operator name" 
                           style="width: 100%; border: 1px solid rgba(0, 0, 0, 0.1); border-radius: 6px; padding: 0.4rem; font-size: 0.8rem; margin-bottom: 0.3rem; background: rgba(255, 255, 255, 0.8);">
                    <div style="display: flex; gap: 0.5rem; width: 100%; box-sizing: border-box;">
                        <input value="${station.cycleTime}" 
                               onchange="updateStationField('${station.id}', 'cycleTime', this.value)"
                               placeholder="Cycle (min)" 
                               style="flex: 1; min-width: 0; border: 1px solid rgba(0, 0, 0, 0.1); border-radius: 6px; padding: 0.4rem; font-size: 0.8rem; background: rgba(255, 255, 255, 0.8); box-sizing: border-box;">
                        <input value="${station.throughputRate}" 
                               onchange="updateStationField('${station.id}', 'throughputRate', this.value)"
                               placeholder="Rate/hr" 
                               style="flex: 1; min-width: 0; border: 1px solid rgba(0, 0, 0, 0.1); border-radius: 6px; padding: 0.4rem; font-size: 0.8rem; background: rgba(255, 255, 255, 0.8); box-sizing: border-box;">
                    </div>
                </div>
                <button onclick="editStation('${station.id}')" 
                        style="width: 100%; background: #007AFF; color: white; border: none; padding: 0.5rem; border-radius: 6px; font-size: 0.8rem; cursor: pointer; font-weight: 600; transition: all 0.2s ease;">
                    Edit Details
                </button>
            `;

            addDragFunctionality(stationEl, station);
            document.getElementById('canvas').appendChild(stationEl);
        }

        function renderStorageCard(storage) {
            const storageEl = document.createElement('div');
            storageEl.className = 'storage-card';
            storageEl.id = storage.id;
            storageEl.style.left = storage.x + 'px';
            storageEl.style.top = storage.y + 'px';
            
            // Ensure minimum size but allow larger if specified
            const width = Math.max(storage.width || 200, 200);
            const height = Math.max(storage.height || 120, 120);
            
            storageEl.style.width = width + 'px';
            storageEl.style.height = height + 'px';
            
            // Update the storage object with the actual size
            storage.width = width;
            storage.height = height;
            
            storageEl.innerHTML = `
                <div class="card-number">${storage.number || 'S'}</div>
                <div class="card-controls" style="position: absolute; top: -25px; right: -25px; z-index: 400; pointer-events: auto;">
                    <button class="card-btn connect-btn" onclick="startConnection('${storage.id}')" title="Connect">‚Üí</button>
                    <button class="card-btn delete-btn" onclick="deleteCard('${storage.id}')" title="Delete">√ó</button>
                </div>
                <input class="card-title" value="${storage.title}" 
                       onchange="updateStorageField('${storage.id}', 'title', this.value)" 
                       placeholder="Storage name">
                <div style="margin: 0.5rem 0; font-size: 0.8rem; color: #666;">
                    <div>${storage.storageType.replace('-', ' ').toUpperCase()}</div>
                    <div>${storage.currentQuantity}/${storage.maxCapacity} ${storage.unitMeasure}</div>
                </div>
                <button onclick="editStorage('${storage.id}')" 
                        style="width: 100%; background: #FF9500; color: white; border: none; padding: 0.5rem; border-radius: 6px; font-size: 0.8rem; cursor: pointer; font-weight: 600; transition: all 0.2s ease;">
                    Edit Storage
                </button>
            `;

            // Add resize observer to track size changes
            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    const rect = entry.contentRect;
                    storage.width = rect.width;
                    storage.height = rect.height;
                    // saveToStorage();
                }
            });
            resizeObserver.observe(storageEl);

            addDragFunctionality(storageEl, storage);
            document.getElementById('canvas').appendChild(storageEl);
        }

        function addDragFunctionality(cardEl, cardData) {
            let isDragging = false;
            
            cardEl.addEventListener('mousedown', startDrag);
            cardEl.addEventListener('touchstart', startDrag, { passive: false });

            function startDrag(e) {
                if (isDrawingMode) return;
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
                
                e.preventDefault();
                isDragging = true;
                draggedCard = cardData;
                cardEl.classList.add('dragging');
                
                const rect = cardEl.getBoundingClientRect();
                const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                
                dragOffset.x = clientX - rect.left;
                dragOffset.y = clientY - rect.top;

                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
                document.addEventListener('touchmove', drag, { passive: false });
                document.addEventListener('touchend', stopDrag);
            }

            function drag(e) {
                if (!isDragging) return;
                e.preventDefault();
                
                const canvas = document.getElementById('canvas');
                const canvasRect = canvas.getBoundingClientRect();
                const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                
                let x = clientX - canvasRect.left - dragOffset.x;
                let y = clientY - canvasRect.top - dragOffset.y;
                
                // Snap to grid in physical mode
                if (!isTimelineMode) {
                    x = Math.round(x / 24) * 24;
                    y = Math.round(y / 24) * 24;
                }
                
                cardData.x = Math.max(0, x);
                cardData.y = Math.max(0, y);
                
                cardEl.style.left = cardData.x + 'px';
                cardEl.style.top = cardData.y + 'px';
                
                drawConnectionsThrottled();
            }

            function stopDrag() {
                if (isDragging) {
                    isDragging = false;
                    draggedCard = null;
                    cardEl.classList.remove('dragging');
                    // saveToStorage();
                }
                
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('touchend', stopDrag);
            }
        }

        function editStation(stationId) {
            const station = productionStations.find(s => s.id === stationId);
            if (!station) return;
            
            currentEditingStation = station;
            document.getElementById('stationTitle').value = station.title || '';
            document.getElementById('stationOperator').value = station.operator || '';
            document.getElementById('operatorCount').value = station.operatorCount || 1;
            document.getElementById('cycleTime').value = station.cycleTime || '';
            document.getElementById('throughputRate').value = station.throughputRate || '';
            document.getElementById('stationEquipment').value = station.equipment || '';
            document.getElementById('stationMethod').value = station.method || '';
            document.getElementById('stationQuality').value = station.quality || '';
            document.getElementById('safetyZone').value = station.safetyZone || 'none';
            document.getElementById('priorityLevel').value = station.priorityLevel || 'medium';
            
            document.getElementById('stationModal').style.display = 'flex';
        }

        function editStorage(storageId) {
            const storage = storageCards.find(s => s.id === storageId);
            if (!storage) return;
            
            currentEditingStorage = storage;
            document.getElementById('storageTitle').value = storage.title || '';
            document.getElementById('storageType').value = storage.storageType || 'raw-materials';
            document.getElementById('currentQuantity').value = storage.currentQuantity || '';
            document.getElementById('maxCapacity').value = storage.maxCapacity || '';
            document.getElementById('unitMeasure').value = storage.unitMeasure || 'pieces';
            document.getElementById('storageContents').value = storage.contents || '';
            document.getElementById('storageRequirements').value = storage.requirements || '';
            
            document.getElementById('storageModal').style.display = 'flex';
        }

        function saveStation() {
            if (!currentEditingStation) return;
            
            currentEditingStation.title = document.getElementById('stationTitle').value;
            currentEditingStation.operator = document.getElementById('stationOperator').value;
            currentEditingStation.operatorCount = document.getElementById('operatorCount').value;
            currentEditingStation.cycleTime = document.getElementById('cycleTime').value;
            currentEditingStation.throughputRate = document.getElementById('throughputRate').value;
            currentEditingStation.equipment = document.getElementById('stationEquipment').value;
            currentEditingStation.method = document.getElementById('stationMethod').value;
            currentEditingStation.quality = document.getElementById('stationQuality').value;
            currentEditingStation.safetyZone = document.getElementById('safetyZone').value;
            currentEditingStation.priorityLevel = document.getElementById('priorityLevel').value;
            
            // Re-render the station to update the inline fields and safety indicator
            const stationEl = document.getElementById(currentEditingStation.id);
            if (stationEl) {
                stationEl.remove();
                renderProductionStation(currentEditingStation);
            }
            
            closeStationModal();
            drawConnections();
            // saveToStorage();
        }

        function saveStorage() {
            if (!currentEditingStorage) return;
            
            currentEditingStorage.title = document.getElementById('storageTitle').value;
            currentEditingStorage.storageType = document.getElementById('storageType').value;
            currentEditingStorage.currentQuantity = document.getElementById('currentQuantity').value;
            currentEditingStorage.maxCapacity = document.getElementById('maxCapacity').value;
            currentEditingStorage.unitMeasure = document.getElementById('unitMeasure').value;
            currentEditingStorage.contents = document.getElementById('storageContents').value;
            currentEditingStorage.requirements = document.getElementById('storageRequirements').value;
            
            // Re-render the storage card
            const storageEl = document.getElementById(currentEditingStorage.id);
            if (storageEl) {
                storageEl.remove();
                renderStorageCard(currentEditingStorage);
            }
            
            closeStorageModal();
            drawConnections();
            // saveToStorage();
        }

        function closeStationModal() {
            document.getElementById('stationModal').style.display = 'none';
            currentEditingStation = null;
        }

        function closeStorageModal() {
            document.getElementById('storageModal').style.display = 'none';
            currentEditingStorage = null;
        }

        function deleteCard(cardId) {
            // Remove from arrays
            productionStations = productionStations.filter(s => s.id !== cardId);
            storageCards = storageCards.filter(s => s.id !== cardId);
            connections = connections.filter(c => c.from !== cardId && c.to !== cardId);
            
            // Remove from DOM
            const cardEl = document.getElementById(cardId);
            if (cardEl) cardEl.remove();
            
            calculateNumbers();
            drawConnectionsThrottled();
            // saveToStorage();
        }

        function startConnection(cardId) {
            if (sourceCard && sourceCard !== cardId) {
                addConnection(sourceCard, cardId);
                sourceCard = null;
                document.querySelectorAll('.production-card, .storage-card').forEach(c => {
                    c.classList.remove('source-card', 'can-connect');
                });
                document.getElementById('modeIndicator').textContent = '';
            } else {
                document.querySelectorAll('.production-card, .storage-card').forEach(c => {
                    c.classList.remove('source-card', 'can-connect');
                });
                
                sourceCard = cardId;
                document.getElementById(cardId).classList.add('source-card');
                document.querySelectorAll('.production-card, .storage-card').forEach(c => {
                    if (c.id !== cardId) c.classList.add('can-connect');
                });
                document.getElementById('modeIndicator').textContent = 'Now click the arrow of the target card/storage';
            }
        }

        function addConnection(fromId, toId) {
            if (!connections.find(c => c.from === fromId && c.to === toId)) {
                connections.push({ 
                    from: fromId, 
                    to: toId, 
                    id: `conn-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    transportMethod: 'manual',
                    transferTime: '',
                    batchSize: '',
                    qualityCheck: '',
                    safetyRequirements: '',
                    specialHandling: ''
                });
                calculateNumbers();
                drawConnections();
                // saveToStorage();
            }
        }

        function calculateNumbers() {
            // Reset all numbers
            productionStations.forEach(station => station.number = '');
            
            // Only number production stations, not storage
            const startingStations = productionStations.filter(station => 
                !connections.some(conn => conn.to === station.id && 
                    productionStations.some(s => s.id === conn.from))
            );
            
            if (startingStations.length === 0 && productionStations.length > 0) {
                startingStations.push(...productionStations);
            }
            
            const levels = new Map();
            const queue = startingStations.map(station => ({ station, level: 1 }));
            
            startingStations.forEach(station => levels.set(station.id, 1));
            
            while (queue.length > 0) {
                const { station, level } = queue.shift();
                
                const nextStations = connections
                    .filter(conn => conn.from === station.id)
                    .map(conn => productionStations.find(s => s.id === conn.to))
                    .filter(s => s);
                
                nextStations.forEach(nextStation => {
                    const currentLevel = levels.get(nextStation.id) || 0;
                    const newLevel = Math.max(currentLevel, level + 1);
                    levels.set(nextStation.id, newLevel);
                    queue.push({ station: nextStation, level: newLevel });
                });
            }
            
            const levelGroups = new Map();
            productionStations.forEach(station => {
                const level = levels.get(station.id) || 1;
                if (!levelGroups.has(level)) {
                    levelGroups.set(level, []);
                }
                levelGroups.get(level).push(station);
            });
            
            levelGroups.forEach((stationsInLevel, level) => {
                if (stationsInLevel.length === 1) {
                    stationsInLevel[0].number = level.toString();
                } else {
                    stationsInLevel.forEach((station, index) => {
                        const letter = String.fromCharCode(97 + index);
                        station.number = `${level}${letter}`;
                    });
                }
            });
            
            // Update UI
            [...productionStations, ...storageCards].forEach(card => {
                const cardEl = document.getElementById(card.id);
                if (cardEl) {
                    const numberEl = cardEl.querySelector('.card-number');
                    if (numberEl) numberEl.textContent = card.number || (card.type === 'storage' ? 'S' : '');
                }
            });
        }

        function drawConnections() {
            const svg = document.querySelector('svg');
            const canvas = document.getElementById('canvas');
            
            const existingLines = svg.querySelectorAll('line');
            const existingBtns = canvas.querySelectorAll('.arrow-details-btn');
            existingLines.forEach(line => line.remove());
            existingBtns.forEach(btn => btn.remove());
            
            connections.forEach(conn => {
                const fromCard = document.getElementById(conn.from);
                const toCard = document.getElementById(conn.to);
                
                if (fromCard && toCard) {
                    const fromRect = fromCard.getBoundingClientRect();
                    const toRect = toCard.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    
                    const fromCenter = {
                        x: fromRect.left - canvasRect.left + fromRect.width / 2,
                        y: fromRect.top - canvasRect.top + fromRect.height / 2
                    };
                    const toCenter = {
                        x: toRect.left - canvasRect.left + toRect.width / 2,
                        y: toRect.top - canvasRect.top + toRect.height / 2
                    };
                    
                    const fromEdge = getEdgeIntersection(fromCenter, toCenter, {
                        x: fromRect.left - canvasRect.left,
                        y: fromRect.top - canvasRect.top,
                        width: fromRect.width,
                        height: fromRect.height
                    });
                    
                    const toEdge = getEdgeIntersection(toCenter, fromCenter, {
                        x: toRect.left - canvasRect.left,
                        y: toRect.top - canvasRect.top,
                        width: toRect.width,
                        height: toRect.height
                    });
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', fromEdge.x);
                    line.setAttribute('y1', fromEdge.y);
                    line.setAttribute('x2', toEdge.x);
                    line.setAttribute('y2', toEdge.y);
                    line.setAttribute('class', 'arrow-line');
                    line.setAttribute('stroke', '#007AFF');
                    line.setAttribute('marker-end', 'url(#arrowhead-blue)');
                    
                    svg.appendChild(line);
                    
                    const midX = (fromEdge.x + toEdge.x) / 2;
                    const midY = (fromEdge.y + toEdge.y) / 2;
                    
                    const detailsBtn = document.createElement('div');
                    detailsBtn.className = 'arrow-details-btn';
                    detailsBtn.style.left = (midX - 30) + 'px';
                    detailsBtn.style.top = (midY - 12) + 'px';
                    detailsBtn.textContent = 'Flow';
                    detailsBtn.onclick = () => editConnection(conn.id);
                    
                    canvas.appendChild(detailsBtn);
                }
            });
        }

        function getEdgeIntersection(center, target, rect) {
            const dx = target.x - center.x;
            const dy = target.y - center.y;
            const intersections = [];
            
            if (dy < 0) {
                const t = -rect.height / 2 / dy;
                const x = center.x + dx * t;
                if (x >= rect.x && x <= rect.x + rect.width) {
                    intersections.push({ x, y: rect.y });
                }
            }
            
            if (dy > 0) {
                const t = rect.height / 2 / dy;
                const x = center.x + dx * t;
                if (x >= rect.x && x <= rect.x + rect.width) {
                    intersections.push({ x, y: rect.y + rect.height });
                }
            }
            
            if (dx < 0) {
                const t = -rect.width / 2 / dx;
                const y = center.y + dy * t;
                if (y >= rect.y && y <= rect.y + rect.height) {
                    intersections.push({ x: rect.x, y });
                }
            }
            
            if (dx > 0) {
                const t = rect.width / 2 / dx;
                const y = center.y + dy * t;
                if (y >= rect.y && y <= rect.y + rect.height) {
                    intersections.push({ x: rect.x + rect.width, y });
                }
            }
            
            if (intersections.length > 0) {
                return intersections.reduce((closest, current) => {
                    const closestDist = Math.hypot(closest.x - target.x, closest.y - target.y);
                    const currentDist = Math.hypot(current.x - target.x, current.y - target.y);
                    return currentDist < closestDist ? current : closest;
                });
            }
            
            return center;
        }

        function editConnection(connectionId) {
            const connection = connections.find(c => c.id === connectionId);
            if (!connection) return;
            
            currentEditingConnection = connection;
            
            document.getElementById('transportMethod').value = connection.transportMethod || 'manual';
            document.getElementById('transferTime').value = connection.transferTime || '';
            document.getElementById('batchSize').value = connection.batchSize || '';
            document.getElementById('qualityCheck').value = connection.qualityCheck || '';
            document.getElementById('safetyRequirements').value = connection.safetyRequirements || '';
            document.getElementById('specialHandling').value = connection.specialHandling || '';
            
            document.getElementById('connectionModal').style.display = 'flex';
        }

        function saveConnection() {
            if (!currentEditingConnection) return;
            
            currentEditingConnection.transportMethod = document.getElementById('transportMethod').value;
            currentEditingConnection.transferTime = document.getElementById('transferTime').value;
            currentEditingConnection.batchSize = document.getElementById('batchSize').value;
            currentEditingConnection.qualityCheck = document.getElementById('qualityCheck').value;
            currentEditingConnection.safetyRequirements = document.getElementById('safetyRequirements').value;
            currentEditingConnection.specialHandling = document.getElementById('specialHandling').value;
            
            closeConnectionModal();
            drawConnections();
            // saveToStorage();
        }

        function closeConnectionModal() {
            document.getElementById('connectionModal').style.display = 'none';
            currentEditingConnection = null;
        }

        function toggleView() {
            isTimelineMode = !isTimelineMode;
            const canvas = document.getElementById('canvas');
            const toggleBtn = document.getElementById('viewToggle');
            
            if (isTimelineMode) {
                canvas.classList.add('timeline-mode');
                toggleBtn.textContent = 'üè≠ Switch to Layout';
                toggleBtn.style.background = '#FF9500';
                arrangeTimelineView();
            } else {
                canvas.classList.remove('timeline-mode');
                toggleBtn.textContent = 'üìä Switch to Timeline';
                toggleBtn.style.background = '#34C759';
                renderPhysicalLayout();
            }
        }

        function arrangeTimelineView() {
            // Create swimlanes
            const canvas = document.getElementById('canvas');
            
            // Clear existing grid labels and add swimlanes
            canvas.querySelectorAll('.timeline-swimlane, .grid-labels').forEach(el => el.remove());
            
            // Production flow swimlane
            const productionLane = document.createElement('div');
            productionLane.className = 'timeline-swimlane';
            productionLane.style.top = '20px';
            productionLane.innerHTML = '<div class="swimlane-label">Production Flow</div>';
            canvas.appendChild(productionLane);
            
            // Storage swimlane  
            const storageLane = document.createElement('div');
            storageLane.className = 'timeline-swimlane';
            storageLane.style.top = '240px';
            storageLane.innerHTML = '<div class="swimlane-label">Storage & Materials</div>';
            canvas.appendChild(storageLane);
            
            // Arrange production stations by dependency order
            const orderedStations = getStationsInOrder();
            orderedStations.forEach((station, index) => {
                const stationEl = document.getElementById(station.id);
                if (stationEl) {
                    stationEl.classList.add('timeline-card');
                    stationEl.style.left = (200 + index * 220) + 'px';
                    stationEl.style.top = '60px';
                }
            });
            
            // Arrange storage in storage lane
            storageCards.forEach((storage, index) => {
                const storageEl = document.getElementById(storage.id);
                if (storageEl) {
                    storageEl.classList.add('timeline-card');
                    storageEl.style.left = (200 + index * 220) + 'px';
                    storageEl.style.top = '280px';
                    // Hide resize handle in timeline mode
                    storageEl.style.resize = 'none';
                }
            });
            
            setTimeout(drawConnections, 100);
        }

        function getStationsInOrder() {
            // Topological sort of production stations
            const visited = new Set();
            const result = [];
            
            function visit(stationId) {
                if (visited.has(stationId)) return;
                visited.add(stationId);
                
                const dependencies = connections
                    .filter(c => c.to === stationId && productionStations.some(s => s.id === c.from))
                    .map(c => c.from);
                    
                dependencies.forEach(depId => visit(depId));
                
                const station = productionStations.find(s => s.id === stationId);
                if (station) result.push(station);
            }
            
            productionStations.forEach(station => visit(station.id));
            return result;
        }

        function renderPhysicalLayout() {
            // Remove timeline-specific elements
            const canvas = document.getElementById('canvas');
            canvas.querySelectorAll('.timeline-swimlane').forEach(el => el.remove());
            
            // Add grid labels for physical layout
            addGridLabels();
            
            // Restore original positions
            [...productionStations, ...storageCards].forEach(card => {
                const cardEl = document.getElementById(card.id);
                if (cardEl) {
                    cardEl.classList.remove('timeline-card');
                    cardEl.style.left = card.x + 'px';
                    cardEl.style.top = card.y + 'px';
                    // Restore resize functionality for storage cards
                    if (card.type === 'storage') {
                        cardEl.style.resize = 'both';
                    }
                }
            });
            
            // Delay connection drawing to ensure layout is fully applied
            setTimeout(drawConnections, 100);
        }

        function addGridLabels() {
            const canvas = document.getElementById('canvas');
            canvas.querySelectorAll('.grid-labels').forEach(el => el.remove());
            
            // Add meter labels every 5 meters (120px)
            for (let i = 0; i <= 30; i += 5) {
                const xLabel = document.createElement('div');
                xLabel.className = 'grid-labels grid-label-x';
                xLabel.style.left = (i * 24) + 'px';
                xLabel.textContent = i + 'm';
                canvas.appendChild(xLabel);
                
                const yLabel = document.createElement('div');
                yLabel.className = 'grid-labels grid-label-y';
                yLabel.style.top = (i * 24) + 'px';
                yLabel.textContent = i + 'm';
                canvas.appendChild(yLabel);
            }
        }

        function toggleDrawingMode() {
            isDrawingMode = !isDrawingMode;
            const btn = document.getElementById('drawBufferBtn');
            const canvas = document.getElementById('canvas');
            
            if (isDrawingMode) {
                btn.classList.add('active');
                btn.textContent = 'Exit Drawing';
                canvas.classList.add('drawing-mode');
                document.getElementById('modeIndicator').textContent = 'Click and drag to draw buffer zones';
                
                canvas.addEventListener('mousedown', startBufferDrawing);
                canvas.addEventListener('mousemove', updateBufferDrawing);
                canvas.addEventListener('mouseup', finishBufferDrawing);
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Draw Buffer';
                canvas.classList.remove('drawing-mode');
                document.getElementById('modeIndicator').textContent = '';
                
                canvas.removeEventListener('mousedown', startBufferDrawing);
                canvas.removeEventListener('mousemove', updateBufferDrawing);
                canvas.removeEventListener('mouseup', finishBufferDrawing);
            }
        }

        function startBufferDrawing(e) {
            if (e.target.closest('.production-card, .storage-card, .arrow-details-btn')) return;
            
            e.preventDefault();
            isDrawingBuffer = true;
            
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            
            bufferStartPoint = {
                x: Math.round((e.clientX - rect.left) / 24) * 24,
                y: Math.round((e.clientY - rect.top) / 24) * 24
            };
            
            currentBufferDrawing = document.createElement('div');
            currentBufferDrawing.className = 'buffer-drawing';
            currentBufferDrawing.style.left = bufferStartPoint.x + 'px';
            currentBufferDrawing.style.top = bufferStartPoint.y + 'px';
            currentBufferDrawing.style.width = '0px';
            currentBufferDrawing.style.height = '0px';
            
            canvas.appendChild(currentBufferDrawing);
        }

        function updateBufferDrawing(e) {
            if (!isDrawingBuffer || !currentBufferDrawing) return;
            
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            
            const currentPoint = {
                x: Math.round((e.clientX - rect.left) / 24) * 24,
                y: Math.round((e.clientY - rect.top) / 24) * 24
            };
            
            const width = Math.abs(currentPoint.x - bufferStartPoint.x);
            const height = Math.abs(currentPoint.y - bufferStartPoint.y);
            const left = Math.min(currentPoint.x, bufferStartPoint.x);
            const top = Math.min(currentPoint.y, bufferStartPoint.y);
            
            currentBufferDrawing.style.left = left + 'px';
            currentBufferDrawing.style.top = top + 'px';
            currentBufferDrawing.style.width = width + 'px';
            currentBufferDrawing.style.height = height + 'px';
        }

        function finishBufferDrawing(e) {
            if (!isDrawingBuffer || !currentBufferDrawing) return;
            
            isDrawingBuffer = false;
            
            const rect = currentBufferDrawing.getBoundingClientRect();
            const canvasRect = document.getElementById('canvas').getBoundingClientRect();
            
            if (rect.width > 20 && rect.height > 20) {
                const bufferId = `buffer-${Date.now()}`;
                const buffer = {
                    id: bufferId,
                    x: parseInt(currentBufferDrawing.style.left),
                    y: parseInt(currentBufferDrawing.style.top),
                    width: parseInt(currentBufferDrawing.style.width),
                    height: parseInt(currentBufferDrawing.style.height),
                    type: 'wall',
                    description: '',
                    height: 2.5
                };
                
                bufferZones.push(buffer);
                currentBufferDrawing.remove();
                renderBuffer(buffer);
                editBuffer(bufferId);
                // saveToStorage();
            } else {
                currentBufferDrawing.remove();
            }
            
            currentBufferDrawing = null;
            bufferStartPoint = null;
        }

        function renderBuffer(buffer) {
            const bufferEl = document.createElement('div');
            bufferEl.className = 'buffer-zone';
            bufferEl.id = buffer.id;
            bufferEl.style.left = buffer.x + 'px';
            bufferEl.style.top = buffer.y + 'px';
            bufferEl.style.width = buffer.width + 'px';
            bufferEl.style.height = buffer.height + 'px';
            
            const label = document.createElement('div');
            label.className = 'buffer-label';
            label.textContent = buffer.type.replace('-', ' ').toUpperCase();
            bufferEl.appendChild(label);
            
            // Add edit button for buffer zones
            const editBtn = document.createElement('button');
            editBtn.className = 'card-btn';
            editBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: #34C759;
                color: white;
                border: none;
                width: 24px;
                height: 24px;
                border-radius: 50%;
                cursor: pointer;
                font-size: 0.8rem;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            `;
            editBtn.textContent = '‚úé';
            editBtn.onclick = (e) => {
                e.stopPropagation();
                editBuffer(buffer.id);
            };
            bufferEl.appendChild(editBtn);
            
            bufferEl.addEventListener('click', () => editBuffer(buffer.id));
            
            document.getElementById('canvas').appendChild(bufferEl);
        }

        function editBuffer(bufferId) {
            const buffer = bufferZones.find(b => b.id === bufferId);
            if (!buffer) return;
            
            currentEditingBuffer = buffer;
            document.getElementById('bufferType').value = buffer.type || 'wall';
            document.getElementById('bufferDescription').value = buffer.description || '';
            document.getElementById('bufferHeight').value = buffer.height || 2.5;
            
            document.getElementById('bufferModal').style.display = 'flex';
        }

        function saveBuffer() {
            if (!currentEditingBuffer) return;
            
            currentEditingBuffer.type = document.getElementById('bufferType').value;
            currentEditingBuffer.description = document.getElementById('bufferDescription').value;
            currentEditingBuffer.height = document.getElementById('bufferHeight').value;
            
            // Update the label
            const bufferEl = document.getElementById(currentEditingBuffer.id);
            if (bufferEl) {
                const label = bufferEl.querySelector('.buffer-label');
                if (label) {
                    label.textContent = currentEditingBuffer.type.replace('-', ' ').toUpperCase();
                }
            }
            
            closeBufferModal();
            // saveToStorage();
        }

        function deleteBuffer() {
            if (!currentEditingBuffer) return;
            
            bufferZones = bufferZones.filter(b => b.id !== currentEditingBuffer.id);
            
            const bufferEl = document.getElementById(currentEditingBuffer.id);
            if (bufferEl) bufferEl.remove();
            
            closeBufferModal();
            // saveToStorage();
        }

        function closeBufferModal() {
            document.getElementById('bufferModal').style.display = 'none';
            currentEditingBuffer = null;
        }

        function exportProject() {
            const data = {
                productionStations,
                storageCards,
                connections,
                bufferZones,
                cardCounter,
                version: '1.0'
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'production-line.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importProject(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        productionStations = data.productionStations || [];
                        storageCards = data.storageCards || [];
                        connections = data.connections || [];
                        bufferZones = data.bufferZones || [];
                        cardCounter = data.cardCounter || 0;
                        renderAll();
                        // saveToStorage();
                    } catch (error) {
                        alert('Error importing file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        }

        function renderAll() {
            // Clear canvas
            const canvas = document.getElementById('canvas');
            const svgContent = canvas.querySelector('svg').outerHTML;
            canvas.innerHTML = svgContent;
            
            // Render everything
            productionStations.forEach(renderProductionStation);
            storageCards.forEach(renderStorageCard);
            bufferZones.forEach(renderBuffer);
            calculateNumbers();
            
            if (!isTimelineMode) {
                addGridLabels();
            }
            
            drawConnections();
        }

        // Close modals when clicking outside or pressing Escape
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                if (e.target.id === 'stationModal') closeStationModal();
                if (e.target.id === 'storageModal') closeStorageModal();
                if (e.target.id === 'connectionModal') closeConnectionModal();
                if (e.target.id === 'bufferModal') closeBufferModal();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeStationModal();
                closeStorageModal();
                closeConnectionModal();
                closeBufferModal();
                if (isDrawingMode) {
                    toggleDrawingMode();
                }
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            setTimeout(drawConnections, 100);
        });

        // Initialize
        // loadFromStorage();
        
        // Add sample data to get started
        if (productionStations.length === 0 && storageCards.length === 0) {
            addProductionStation();
            addStorageCard();
        }
        
        // Add grid labels for initial physical view
        addGridLabels();
    </script>
</body>
</html>
