<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TommyPop</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #87CEEB, #98FB98, #FFB6C1);
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: pointer;
        }

        /* â”€â”€ Celebration emoji â”€â”€ */
        .celebration {
            position: absolute;
            pointer-events: none;
            font-size: 30px;
            animation: celebrate 1s ease-out forwards;
            z-index: 100;
        }

        @keyframes celebrate {
            0%   { transform: scale(0) rotate(0deg);   opacity: 1; }
            50%  { transform: scale(1.2) rotate(180deg); opacity: 1; }
            100% { transform: scale(0.8) rotate(360deg); opacity: 0; }
        }

        /* â”€â”€ Intro overlay â”€â”€ */
        #introOverlay {
            position: absolute;
            inset: 0;
            background: linear-gradient(160deg, #e0f4ff 0%, #f0fff4 50%, #fff0f5 100%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            overflow-y: auto;
            padding: 32px 24px 40px;
            gap: 0;
        }

        #introOverlay .logo {
            font-size: 52px;
            margin-bottom: 4px;
            line-height: 1;
        }

        #introOverlay h1 {
            font-size: 34px;
            font-weight: 900;
            color: #2a4a6b;
            letter-spacing: -0.5px;
            margin-bottom: 2px;
        }

        #introOverlay .tagline {
            font-size: 14px;
            color: #7a9ab5;
            margin-bottom: 22px;
            font-style: italic;
        }

        .intro-card {
            background: rgba(255,255,255,0.75);
            border-radius: 18px;
            padding: 18px 20px;
            width: 100%;
            max-width: 440px;
            margin-bottom: 14px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.07);
        }

        .intro-card h2 {
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: #a0b4c8;
            margin-bottom: 12px;
        }

        .philosophy-item {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .philosophy-item:last-child { margin-bottom: 0; }

        .philosophy-icon {
            font-size: 20px;
            flex-shrink: 0;
            margin-top: 1px;
        }

        .philosophy-item p {
            font-size: 14px;
            color: #3a5a7a;
            line-height: 1.5;
        }

        .philosophy-item strong {
            display: block;
            font-size: 14px;
            color: #2a4060;
            margin-bottom: 1px;
        }

        /* Expandable intervention section */
        .expand-toggle {
            width: 100%;
            background: none;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0;
            touch-action: manipulation;
        }

        .expand-toggle h2 {
            margin-bottom: 0;
            color: #7a9ab5;
        }

        .expand-arrow {
            font-size: 18px;
            color: #a0b4c8;
            transition: transform 0.25s ease;
            line-height: 1;
        }

        .expand-arrow.open { transform: rotate(180deg); }

        .expand-body {
            display: none;
            margin-top: 14px;
        }

        .expand-body.open { display: block; }

        .step {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .step:last-child { margin-bottom: 0; }

        .step-num {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: linear-gradient(135deg, #87CEEB, #98D8C8);
            color: #2a4a6b;
            font-size: 13px;
            font-weight: 800;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            margin-top: 1px;
        }

        .step p {
            font-size: 13.5px;
            color: #3a5a7a;
            line-height: 1.5;
        }

        .step strong {
            display: block;
            color: #2a4060;
            margin-bottom: 1px;
        }

        /* Round selector */
        .round-selector {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }

        .round-selector p {
            font-size: 14px;
            color: #3a5a7a;
            line-height: 1.4;
            flex: 1;
        }

        .round-controls {
            display: flex;
            align-items: center;
            gap: 0;
            background: rgba(135,206,235,0.2);
            border-radius: 40px;
            padding: 4px;
            flex-shrink: 0;
        }

        .round-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: white;
            font-size: 20px;
            font-weight: 700;
            color: #2a6a9a;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            line-height: 1;
        }

        .round-btn:active { transform: scale(0.92); }

        #roundDisplay {
            font-size: 22px;
            font-weight: 900;
            color: #2a4a6b;
            min-width: 32px;
            text-align: center;
        }

        /* Start button */
        #startBtn {
            width: 100%;
            max-width: 440px;
            padding: 16px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(135deg, #87CEEB, #4ECDC4);
            color: white;
            font-size: 18px;
            font-weight: 800;
            cursor: pointer;
            touch-action: manipulation;
            box-shadow: 0 4px 20px rgba(78,205,196,0.35);
            letter-spacing: 0.3px;
            transition: transform 0.15s, box-shadow 0.15s;
        }

        #startBtn:active {
            transform: scale(0.97);
            box-shadow: 0 2px 10px rgba(78,205,196,0.25);
        }

        .hint {
            font-size: 11.5px;
            color: #a0b4c8;
            text-align: center;
            max-width: 300px;
            margin-top: 10px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Intro overlay -->
    <div id="introOverlay">
        <div class="logo">ðŸ«§</div>
        <h1>TommyPop</h1>
        <p class="tagline">A non-addictive game for toddlers</p>

        <!-- Philosophy -->
        <div class="intro-card">
            <h2>Design Philosophy</h2>

            <div class="philosophy-item">
                <div class="philosophy-icon">ðŸ”‡</div>
                <p><strong>No High-Dopamine Rewards</strong>No flashing lights, "level up" sounds, or loot boxes.</p>
            </div>
            <div class="philosophy-item">
                <div class="philosophy-icon">ðŸš«</div>
                <p><strong>No Hidden Agendas</strong>Zero ads, zero in-app purchases, no age-inappropriate content.</p>
            </div>
            <div class="philosophy-item">
                <div class="philosophy-icon">ðŸ˜´</div>
                <p><strong>A Natural Exit</strong>Engaging enough to hold attention, predictable enough that children choose to put it down.</p>
            </div>
        </div>

        <!-- Round selector -->
        <div class="intro-card">
            <h2>Session Length</h2>
            <div class="round-selector">
                <p>Number of rounds before the game goes quiet. The final round is always calm.</p>
                <div class="round-controls">
                    <button class="round-btn" id="roundMinus">âˆ’</button>
                    <span id="roundDisplay">3</span>
                    <button class="round-btn" id="roundPlus">+</button>
                </div>
            </div>
        </div>

        <!-- Expandable intervention guide -->
        <div class="intro-card">
            <button class="expand-toggle" id="expandToggle">
                <h2>Parent Intervention Guide</h2>
                <span class="expand-arrow" id="expandArrow">â–¾</span>
            </button>
            <div class="expand-body" id="expandBody">
                <div class="step">
                    <div class="step-num">1</div>
                    <p><strong>The Low-Friction Swap</strong>While the child is on the addictive device, load TommyPop on a separate phone and offer it as a swap.</p>
                </div>
                <div class="step">
                    <div class="step-num">2</div>
                    <p><strong>The Attention Shift</strong>The repetitive nature of the game lowers neurological intensity. Watch for signs of boredom or looking around the room.</p>
                </div>
                <div class="step">
                    <div class="step-num">3</div>
                    <p><strong>The Montessori Catch</strong>Before frustration sets in, "catch" their broadening attention with a prepared physical activity.</p>
                </div>
                <div class="step">
                    <div class="step-num">4</div>
                    <p><strong>Hide the Tech</strong>Once the child engages with the physical toy, quietly remove and hide all phone devices.</p>
                </div>
                <div class="step">
                    <div class="step-num">5</div>
                    <p><strong>Anchor with Routine</strong>Time the end of the physical activity with a meal. This provides a natural biological transition.</p>
                </div>
            </div>
        </div>

        <button id="startBtn">Start Game â†’</button>
        <p class="hint">Hold the cannon to toggle full screen</p>
    </div>

    <script>
        // â”€â”€ Intro UI logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let selectedRounds = 3;
        const MIN_ROUNDS = 1;
        const MAX_ROUNDS = 6;

        const roundDisplay = document.getElementById('roundDisplay');
        const roundMinus   = document.getElementById('roundMinus');
        const roundPlus    = document.getElementById('roundPlus');
        const expandToggle = document.getElementById('expandToggle');
        const expandArrow  = document.getElementById('expandArrow');
        const expandBody   = document.getElementById('expandBody');
        const startBtn     = document.getElementById('startBtn');
        const introOverlay = document.getElementById('introOverlay');

        roundMinus.addEventListener('click', () => {
            if (selectedRounds > MIN_ROUNDS) {
                selectedRounds--;
                roundDisplay.textContent = selectedRounds;
            }
        });

        roundPlus.addEventListener('click', () => {
            if (selectedRounds < MAX_ROUNDS) {
                selectedRounds++;
                roundDisplay.textContent = selectedRounds;
            }
        });

        expandToggle.addEventListener('click', () => {
            const isOpen = expandBody.classList.toggle('open');
            expandArrow.classList.toggle('open', isOpen);
        });

        startBtn.addEventListener('click', () => {
            introOverlay.style.display = 'none';
            new SimpleBubbleGame(selectedRounds);
        });

        // â”€â”€ Game â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        class SimpleBubbleGame {
            constructor(maxRounds) {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx    = this.canvas.getContext('2d');

                this.resizeCanvas();

                // Settings
                this.bubbleRadius  = Math.min(this.canvas.width, this.canvas.height) * 0.04;
                this.bubbleColors  = ['#FF6B6B','#4ECDC4','#45B7D1','#96CEB4','#FFEAA7','#DDA0DD','#FF7F50','#98D8C8'];

                // Audio
                this.audioCtx = null;

                // Rounds
                this.roundsPlayed = 0;
                this.maxRounds    = maxRounds;

                // Game objects
                this.bubbles      = [];
                this.cannonBubbles = [];
                this.particles    = [];

                // Cannon
                this.cannonX           = this.canvas.width / 2;
                this.cannonY           = this.canvas.height - this.canvas.height * 0.15;
                this.cannonAngle       = -Math.PI / 2;
                this.currentBubbleColor = this.getRandomColor();

                // Cannon hold-for-fullscreen state
                this.cannonHoldTimer    = null;
                this.cannonHoldInterval = null;
                this.cannonHoldProgress = 0; // 0..1
                this.isHoldingCannon    = false;
                this.HOLD_DURATION      = 1500; // ms

                this.generateBubbles();
                this.setupEventListeners();
                this.gameLoop();
            }

            // â”€â”€ Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            initAudio() {
                if (!this.audioCtx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    this.audioCtx = new AC();
                }
                if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
            }

            playPopSound() {
                if (!this.audioCtx) return;
                const osc  = this.audioCtx.createOscillator();
                const gain = this.audioCtx.createGain();
                osc.connect(gain); gain.connect(this.audioCtx.destination);
                osc.type = 'sine';
                const t = this.audioCtx.currentTime;
                osc.frequency.setValueAtTime(400, t);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.15);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc.start(t); osc.stop(t + 0.15);
            }

            playShootSound() {
                if (!this.audioCtx) return;
                const osc  = this.audioCtx.createOscillator();
                const gain = this.audioCtx.createGain();
                osc.connect(gain); gain.connect(this.audioCtx.destination);
                osc.type = 'triangle';
                const t = this.audioCtx.currentTime;
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.linearRampToValueAtTime(300, t + 0.1);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.start(t); osc.stop(t + 0.1);
            }

            // â”€â”€ Canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            resizeCanvas() {
                this.canvas.width  = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.cannonX = this.canvas.width / 2;
                this.cannonY = this.canvas.height - this.canvas.height * 0.15;
            }

            getRandomColor() {
                return this.bubbleColors[Math.floor(Math.random() * this.bubbleColors.length)];
            }

            // â”€â”€ Bubbles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            generateBubbles() {
                this.bubbles = [];
                this.roundsPlayed++;

                const cols = Math.floor(this.canvas.width / (this.bubbleRadius * 2.2));
                const rows = Math.floor(this.canvas.height * 0.6 / (this.bubbleRadius * 2));

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        if (Math.random() > 0.3) {
                            const isEvenRow = row % 2 === 0;
                            const offsetX   = isEvenRow ? 0 : this.bubbleRadius;
                            const x = (this.canvas.width - (cols * this.bubbleRadius * 2.2)) / 2
                                    + col * this.bubbleRadius * 2.2 + this.bubbleRadius + offsetX;
                            const y = 50 + row * this.bubbleRadius * 1.8;
                            this.bubbles.push({
                                x, y,
                                color: this.getRandomColor(),
                                radius: this.bubbleRadius,
                                wobble: Math.random() * Math.PI * 2,
                                wobbleSpeed: 0.02 + Math.random() * 0.02
                            });
                        }
                    }
                }
            }

            // â”€â”€ Cannon hold detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            isOnCannon(x, y) {
                const hitRadius = this.bubbleRadius * 2.5;
                return Math.hypot(x - this.cannonX, y - this.cannonY) < hitRadius;
            }

            startCannonHold() {
                if (this.isHoldingCannon) return;
                this.isHoldingCannon    = true;
                this.cannonHoldProgress = 0;
                const startTime = Date.now();

                this.cannonHoldInterval = setInterval(() => {
                    this.cannonHoldProgress = Math.min((Date.now() - startTime) / this.HOLD_DURATION, 1);
                    if (this.cannonHoldProgress >= 1) this.completeCannonHold();
                }, 16);

                this.cannonHoldTimer = setTimeout(() => this.completeCannonHold(), this.HOLD_DURATION);
            }

            cancelCannonHold() {
                if (!this.isHoldingCannon) return;
                clearTimeout(this.cannonHoldTimer);
                clearInterval(this.cannonHoldInterval);
                this.isHoldingCannon    = false;
                this.cannonHoldProgress = 0;
            }

            completeCannonHold() {
                this.cancelCannonHold();
                this.toggleFullscreen();
            }

            toggleFullscreen() {
                const elem = document.documentElement;
                if (!document.fullscreenElement) {
                    if (elem.requestFullscreen)       elem.requestFullscreen();
                    else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
                } else {
                    if (document.exitFullscreen)       document.exitFullscreen();
                    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                }
            }

            // â”€â”€ Event listeners â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            setupEventListeners() {
                document.body.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

                // Touch
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.initAudio();
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.touches[0].clientX - rect.left;
                    const y = e.touches[0].clientY - rect.top;

                    if (this.isOnCannon(x, y)) {
                        this.startCannonHold();
                    } else {
                        this.aimAndShoot(x, y);
                    }
                }, { passive: false });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.cancelCannonHold();
                }, { passive: false });

                this.canvas.addEventListener('touchcancel', (e) => {
                    this.cancelCannonHold();
                }, { passive: false });

                // Mouse
                this.canvas.addEventListener('mousedown', (e) => {
                    this.initAudio();
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (this.isOnCannon(x, y)) {
                        this.startCannonHold();
                    } else {
                        this.aimAndShoot(x, y);
                    }
                });

                this.canvas.addEventListener('mouseup',    () => this.cancelCannonHold());
                this.canvas.addEventListener('mouseleave', () => this.cancelCannonHold());

                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    if (this.bubbles.length > 0) {
                        this.generateBubbles();
                        this.roundsPlayed--;
                    }
                });
            }

            // â”€â”€ Shooting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            aimAndShoot(targetX, targetY) {
                const dx = targetX - this.cannonX;
                const dy = targetY - this.cannonY;
                this.cannonAngle = Math.atan2(dy, dx);
                this.cannonAngle = Math.max(-Math.PI + 0.1, Math.min(-0.1, this.cannonAngle));
                this.shootBubble();
            }

            shootBubble() {
                this.playShootSound();
                const speed = Math.min(this.canvas.width, this.canvas.height) * 0.015;
                this.cannonBubbles.push({
                    x: this.cannonX,
                    y: this.cannonY,
                    vx: Math.cos(this.cannonAngle) * speed,
                    vy: Math.sin(this.cannonAngle) * speed,
                    color: this.currentBubbleColor,
                    radius: this.bubbleRadius
                });
                this.currentBubbleColor = this.getRandomColor();
            }

            // â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            update() {
                // Cannon bubbles
                for (let i = this.cannonBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.cannonBubbles[i];
                    bubble.x += bubble.vx;
                    bubble.y += bubble.vy;

                    if (bubble.x - bubble.radius <= 0 || bubble.x + bubble.radius >= this.canvas.width) {
                        bubble.vx = -bubble.vx;
                        bubble.x  = Math.max(bubble.radius, Math.min(this.canvas.width - bubble.radius, bubble.x));
                    }
                    if (bubble.y - bubble.radius <= 0) bubble.vy = -bubble.vy;

                    let collision = false;
                    for (let j = this.bubbles.length - 1; j >= 0; j--) {
                        const target = this.bubbles[j];
                        const dist   = Math.hypot(bubble.x - target.x, bubble.y - target.y);

                        if (dist < bubble.radius + target.radius) {
                            this.playPopSound();
                            this.bubbles.splice(j, 1);
                            this.cannonBubbles.splice(i, 1);

                            // Celebrate on all rounds EXCEPT the final one
                            if (this.roundsPlayed < this.maxRounds) {
                                this.createCelebration(target.x, target.y);
                            }

                            collision = true;
                            break;
                        }
                    }

                    if (!collision && bubble.y > this.canvas.height + 50) {
                        this.cannonBubbles.splice(i, 1);
                    }
                }

                // Particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life--;
                    if (p.life <= 0) this.particles.splice(i, 1);
                }

                // Wobble
                this.bubbles.forEach(b => b.wobble += b.wobbleSpeed);

                // Regenerate if board cleared and rounds remain
                if (this.bubbles.length === 0 && this.roundsPlayed < this.maxRounds) {
                    this.generateBubbles();
                }
                // If final round is cleared: board stays empty, game goes quiet â€” no message
            }

            createCelebration(x, y) {
                const container = document.querySelector('.game-container');
                const el = document.createElement('div');
                el.className  = 'celebration';
                el.textContent = ['ðŸŽ‰','â­','âœ¨','ðŸŒŸ','ðŸ’«'][Math.floor(Math.random() * 5)];
                el.style.left = (x - 15) + 'px';
                el.style.top  = (y - 15) + 'px';
                container.appendChild(el);
                setTimeout(() => el.remove(), 1000);

                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6 - 2,
                        color: this.getRandomColor(),
                        life: 30 + Math.random() * 20
                    });
                }
            }

            // â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            render() {
                // Background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0,   '#87CEEB');
                gradient.addColorStop(0.5, '#98FB98');
                gradient.addColorStop(1,   '#FFB6C1');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Target bubbles
                for (const b of this.bubbles) {
                    this.drawBubble(
                        b.x + Math.sin(b.wobble) * 2,
                        b.y + Math.cos(b.wobble * 0.7),
                        b.radius, b.color
                    );
                }

                // Cannon bubbles in flight
                for (const b of this.cannonBubbles) {
                    this.drawBubble(b.x, b.y, b.radius, b.color);
                }

                // Particles
                for (const p of this.particles) {
                    this.ctx.save();
                    this.ctx.globalAlpha = p.life / 50;
                    this.ctx.fillStyle   = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                }

                this.drawCannon();
            }

            drawBubble(x, y, radius, color) {
                this.ctx.save();
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.fill();

                const g = this.ctx.createRadialGradient(x - radius*0.3, y - radius*0.3, 0, x, y, radius);
                g.addColorStop(0,   'rgba(255,255,255,0.8)');
                g.addColorStop(0.3, 'rgba(255,255,255,0.3)');
                g.addColorStop(1,   'rgba(255,255,255,0)');
                this.ctx.fillStyle = g;
                this.ctx.fill();

                this.ctx.strokeStyle = color;
                this.ctx.lineWidth   = 1;
                this.ctx.stroke();
                this.ctx.restore();
            }

            drawCannon() {
                const cx = this.cannonX;
                const cy = this.cannonY;
                const r  = this.bubbleRadius;

                this.ctx.save();

                // Hold ring â€” fills clockwise as parent holds
                if (this.isHoldingCannon && this.cannonHoldProgress > 0) {
                    const ringRadius = r * 2.2;
                    const startAngle = -Math.PI / 2;
                    const endAngle   = startAngle + (Math.PI * 2 * this.cannonHoldProgress);

                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, ringRadius, startAngle, endAngle);
                    this.ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                    this.ctx.lineWidth   = 3;
                    this.ctx.lineCap     = 'round';
                    this.ctx.stroke();
                }

                // Cannon base
                this.ctx.fillStyle = '#8B4513';
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, r * 1.5, 0, Math.PI * 2);
                this.ctx.fill();

                // Cannon barrel
                this.ctx.translate(cx, cy);
                this.ctx.rotate(this.cannonAngle);
                this.ctx.fillStyle = '#654321';
                this.ctx.fillRect(0, -r * 0.6, r * 2, r * 1.2);
                this.ctx.restore();

                // Next bubble preview
                this.drawBubble(cx, cy, r * 0.8, this.currentBubbleColor);
            }

            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
    </script>
</body>
</html>
