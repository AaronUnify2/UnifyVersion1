<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unify v2.0</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.12.0/toastify.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.12.0/toastify.min.js"></script>
    <style>
    :root {
    /* Dark Theme Variables (Default) */
    --bg-color: #0e1621;
    --section-bg: #142334;
    --form-bg: #1d2d44;
    --border-color: #4a5d73;
    --input-bg: #1d2d44;
    --input-border: #4a5d73;
    --text-color: #e8f0f7;
    --text-secondary: #a3b8cc;
    --btn-primary: #27ae60;
    --btn-danger: #e74c3c;
    --btn-secondary: #3498db;
    --btn-help: #3498db;
    --header-bg: #142334;
    --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    --achievement-locked: #545b6b;
    --achievement-bronze: #cd7f32;
    --achievement-silver: #7ac9ff;
    --achievement-gold: #ffd700;
}

/* Light Theme Variables - Greek-Inspired */
.light-theme {
    --bg-color: #F5F1E3;          /* Parchment/Stone color for background */
    --section-bg: #E4DBC0;         /* Lighter stone color for sections */
    --form-bg: #F0E9D2;            /* Warm beige for form backgrounds */
    --border-color: #8E7F56;       /* Olive brown for borders */
    --input-bg: #FFF9E6;           /* Very light cream for input fields */
    --input-border: #A69769;       /* Golden olive for input borders */
    --text-color: #3D3522;         /* Dark olive for main text */
    --text-secondary: #5E5338;     /* Medium olive for secondary text */
    --btn-primary: #4E6E58;        /* Olive green for primary buttons */
    --btn-danger: #A3320B;         /* Terracotta/Greek pottery red */
    --btn-secondary: #3E7A9C;      /* Aegean Sea blue */
    --btn-help: #3E7A9C;           /* Aegean Sea blue for help buttons */
    --header-bg: #D1C7A3;          /* Limestone color for header */
    --box-shadow: 0 4px 8px rgba(71, 45, 15, 0.15); /* Subtle shadow */
    --achievement-locked: #A39E93;  /* Muted stone for locked achievements */
    --achievement-bronze: #B05C36;  /* Bronze metal color */
    --achievement-silver: #94A1B2;  /* Ancient silver color */
    --achievement-gold: #D4AC2B;    /* Antique gold */
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    transition: background-color 0.3s, color 0.3s;
}

body {
    font-family: 'Segoe UI', Arial, sans-serif;
    line-height: 1.6;
    margin: 0;
    padding: 0;
    background-color: var(--bg-color);
    color: var(--text-color);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

.fixed-header {
    position: fixed;
    top: 0;
    width: 100%;
    z-index: 1000;
    background-color: var(--header-bg);
    padding: 15px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: var(--box-shadow);
}

.app-title {
    font-size: 1.8rem;
    margin: 0;
    font-weight: 600;
}

.header-controls {
    display: flex;
    gap: 15px;
}

.main-container {
    max-width: 800px;
    margin: 80px auto 30px;
    padding: 0 20px;
    width: 100%;
    position: relative;
    z-index: 10;
}

#background-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

.section {
    background-color: rgba(20, 35, 52, 0.75);
    border-radius: 8px;
    margin-bottom: 20px;
    overflow: hidden;
    transition: transform 0.3s, box-shadow 0.3s;
    box-shadow: var(--box-shadow);
    backdrop-filter: blur(5px);
    border: 1px solid var(--border-color);
}

.light-theme .section {
    background-color: rgba(228, 219, 192, 0.75);
}

.section:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.3);
}

.section-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    background-color: rgba(20, 35, 52, 0.95);
    cursor: pointer;
    font-weight: 600;
    border-bottom: 1px solid var(--border-color);
}

.light-theme .section-title {
    background-color: #34495E;
    color: #F5F1E3;
}

.section-title-left {
    display: flex;
    align-items: center;
    gap: 10px;
}

.section-content {
    display: none;
    padding: 20px;
}

.section-content.active {
    display: block;
}

.light-theme .section-content.active {
    background-color: #EFE8CF;
    border-radius: 0 0 8px 8px;
}

.form-container, .list-container {
    background-color: var(--form-bg);
    color: var(--text-color);
    border-radius: 6px;
    padding: 15px;
    margin-bottom: 15px;
    border: 1px solid var(--border-color);
}

label {
    display: block;
    margin-bottom: 15px;
    font-weight: 500;
}

input[type="text"], select, textarea {
    width: 100%;
    padding: 10px;
    margin-top: 5px;
    border: 1px solid var(--input-border);
    border-radius: 4px;
    background-color: var(--input-bg);
    color: var(--text-color);
    font-size: 14px;
}

input[type="text"]:focus, select:focus, textarea:focus {
    border-color: var(--btn-secondary);
    outline: none;
    box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
}

textarea {
    min-height: 100px;
    resize: vertical;
}

/* Star Rating Styles */
.star-rating {
  margin-top: 10px;
}

.stars {
  display: flex;
  flex-direction: row;
  gap: 5px;
}

.star {
  font-size: 24px;
  cursor: pointer;
  color: #ccc; /* Unselected star color */
  transition: color 0.2s ease;
  user-select: none; /* Prevent text selection */
}

.light-theme .star {
  color: #D1C7A3; /* Muted gold for unselected stars */
}

/* Base selected state */
.star.selected {
  color: var(--btn-primary); /* Selected star color */
}

.light-theme .star.selected {
  color: #D4AC2B; /* Ancient gold for selected */
}

/* Handle the hover fill effect properly */
.stars:hover .star {
  color: #ccc; /* Reset all stars on hover */
}

.light-theme .stars:hover .star {
  color: #D1C7A3;
}

.stars .star:hover, 
.stars .star:hover ~ .star {
  color: #ccc; /* Reset stars to the right when hovering */
}

.light-theme .stars .star:hover, 
.light-theme .stars .star:hover ~ .star {
  color: #D1C7A3;
}

.star:hover, 
.star:hover ~ .star {
  color: #ccc; /* Reset to the right */
}

.light-theme .star:hover, 
.light-theme .star:hover ~ .star {
  color: #D1C7A3;
}

/* This is the key - select stars from the first up to the hovered one */
.stars:hover .star:nth-child(1):hover,
.stars:hover .star:nth-child(2):hover,
.stars:hover .star:nth-child(2):hover ~ .star:nth-child(1),
.stars:hover .star:nth-child(3):hover,
.stars:hover .star:nth-child(3):hover ~ .star:nth-child(-n+2),
.stars:hover .star:nth-child(4):hover,
.stars:hover .star:nth-child(4):hover ~ .star:nth-child(-n+3),
.stars:hover .star:nth-child(5):hover,
.stars:hover .star:nth-child(5):hover ~ .star:nth-child(-n+4) {
  color: var(--btn-primary); /* Fill stars to the left of and including hovered star */
}

.light-theme .stars:hover .star:nth-child(1):hover,
.light-theme .stars:hover .star:nth-child(2):hover,
.light-theme .stars:hover .star:nth-child(2):hover ~ .star:nth-child(1),
.light-theme .stars:hover .star:nth-child(3):hover,
.light-theme .stars:hover .star:nth-child(3):hover ~ .star:nth-child(-n+2),
.light-theme .stars:hover .star:nth-child(4):hover,
.light-theme .stars:hover .star:nth-child(4):hover ~ .star:nth-child(-n+3),
.light-theme .stars:hover .star:nth-child(5):hover,
.light-theme .stars:hover .star:nth-child(5):hover ~ .star:nth-child(-n+4) {
  color: #D4AC2B;
}

/* Keep selected stars colored when not hovering */
.stars .star:nth-child(1).selected,
.stars .star:nth-child(2).selected,
.stars .star:nth-child(2).selected ~ .star:nth-child(1),
.stars .star:nth-child(3).selected,
.stars .star:nth-child(3).selected ~ .star:nth-child(-n+2),
.stars .star:nth-child(4).selected,
.stars .star:nth-child(4).selected ~ .star:nth-child(-n+3),
.stars .star:nth-child(5).selected,
.stars .star:nth-child(5).selected ~ .star:nth-child(-n+4) {
  color: var(--btn-primary); /* Selected star color */
}

.light-theme .stars .star:nth-child(1).selected,
.light-theme .stars .star:nth-child(2).selected,
.light-theme .stars .star:nth-child(2).selected ~ .star:nth-child(1),
.light-theme .stars .star:nth-child(3).selected,
.light-theme .stars .star:nth-child(3).selected ~ .star:nth-child(-n+2),
.light-theme .stars .star:nth-child(4).selected,
.light-theme .stars .star:nth-child(4).selected ~ .star:nth-child(-n+3),
.light-theme .stars .star:nth-child(5).selected,
.light-theme .stars .star:nth-child(5).selected ~ .star:nth-child(-n+4) {
  color: #D4AC2B;
}

.rating-description {
  margin-top: 8px;
  color: var(--text-secondary);
  font-style: italic;
}

@media (max-width: 480px) {
  .star {
    font-size: 20px;
  }
}

button {
    padding: 10px 15px;
    border-radius: 4px;
    border: none;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.3s ease;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.btn-add {
    background-color: var(--btn-primary);
    color: white;
    margin-top: 15px;
}

.light-theme .btn-add {
    background-color: #5D8A82;
}

.btn-delete {
    background-color: var(--btn-danger);
    color: white;
}

.btn-secondary {
    background-color: var(--btn-secondary);
    color: white;
}

.btn-help {
    background-color: var(--btn-help);
    color: white;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    padding: 0;
    font-size: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.btn-toggle {
    background-color: rgba(42, 47, 69, 0.7);
    border: 1px solid var(--border-color);
    color: var(--text-color);
    display: flex;
    align-items: center;
    gap: 5px;
}

.light-theme .btn-toggle {
    background-color: #D1C7A3;
    border: 1px solid #8E7F56;
    color: #3D3522;
}

.btn-quick-nav {
    background-color: var(--btn-primary);
    color: white;
}

.btn-calendar {
    background-color: var(--btn-secondary);
    color: white;
    display: flex;
    align-items: center;
    gap: 5px;
}

.description {
    margin-top: 10px;
    color: var(--text-secondary);
    font-style: italic;
    display: none; /* Hide descriptions by default */
}

.description.active {
    display: block; /* Show only when active */
}

.help-content {
    display: none;
    padding: 20px;
    background-color: var(--section-bg);
    border-radius: 8px;
    margin-bottom: 20px;
    box-shadow: var(--box-shadow);
    border: 1px solid var(--border-color);
}

.help-content.active {
    display: block;
}

.list-item {
    background-color: var(--form-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    transition: transform 0.3s, box-shadow 0.3s;
    position: relative;
}

.light-theme .list-item {
    background-color: #EFE8CF;
    border: 1px solid var(--border-color);
    border-left: 5px solid #5D8A82;
}

.list-item:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
}

.light-theme .list-item:hover {
    background-color: #F5F1E3;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.list-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 5px;
    height: 100%;
    background: linear-gradient(to bottom, var(--btn-secondary), var(--btn-primary));
    border-radius: 8px 0 0 8px;
}

.light-theme .list-item::before {
    /* Hide default gradient since we're using a solid border in light theme */
    background: transparent;
}

.list-item-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    font-weight: 600;
}

.list-item-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin: 10px 0;
    font-size: 0.9rem;
}

.meta-item {
    display: flex;
    align-items: center;
    gap: 5px;
}

.meta-item i {
    width: 20px;
    text-align: center;
}

.list-item-content {
    display: none;
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px solid var(--border-color);
}

.list-item-content.active {
    display: block;
}

.sort-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap;
}

.sort-controls button {
    background-color: rgba(52, 73, 94, 0.2);
    color: var(--text-color);
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 13px;
}

.sort-controls button.active {
    background-color: var(--btn-secondary);
    color: white;
}

.light-theme .sort-controls button.active {
    background-color: #3E7A9C;
}

.stats-container {
    display: flex;
    justify-content: space-around;
    margin: 20px 0;
    flex-wrap: wrap;
}

.stat-box {
    background-color: var(--form-bg);
    border-radius: 8px;
    padding: 15px;
    min-width: 150px;
    text-align: center;
    box-shadow: var(--box-shadow);
    margin: 10px;
    border: 1px solid var(--border-color);
    transition: transform 0.3s, box-shadow 0.3s;
}

.stat-box:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
}

.stat-value {
    font-size: 28px;
    font-weight: bold;
    margin: 10px 0;
    color: var(--btn-secondary);
}

.stat-label {
    color: var(--text-secondary);
    font-size: 14px;
}

.progress-container {
    width: 100%;
    height: 6px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    margin: 30px 0;
    overflow: hidden;
}

.light-theme .progress-container {
    background-color: rgba(0, 0, 0, 0.1);
}

.progress-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(to right, var(--btn-secondary), var(--btn-primary));
    border-radius: 3px;
    transition: width 0.5s ease;
}

.light-theme .progress-bar {
    background: linear-gradient(to right, #3E7A9C, #5D8A82);
}

.chart-container {
    height: 250px;
    margin-bottom: 20px;
}

.stats-row {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-bottom: 20px;
}

.task-complete-text {
    text-decoration: line-through;
    opacity: 0.7;
}

.custom-checkbox {
    display: inline-block;
    width: 20px;
    height: 20px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    margin-right: 10px;
    cursor: pointer;
    position: relative;
    vertical-align: middle;
    transition: all 0.2s ease;
    z-index: 10; /* Higher z-index to ensure clickability */
}

.light-theme .custom-checkbox {
    background-color: #FFF9E6;
    border: 1px solid #8E7F56;
}

.custom-checkbox.checked {
    background-color: var(--btn-primary);
}

.light-theme .custom-checkbox.checked {
    background-color: #5D8A82;
}

.custom-checkbox.checked::after {
    content: 'âœ“';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 14px;
}

.item-actions {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

.action-btn {
    flex: 1;
}

.count-badge {
    background-color: var(--btn-primary);
    color: white;
    border-radius: 12px;
    padding: 2px 8px;
    font-size: 0.75rem;
    margin-left: 10px;
}

.toggle-arrow {
    transition: transform 0.3s;
}

.toggle-arrow.open {
    transform: rotate(180deg);
}

.dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.9);
    background-color: var(--section-bg);
    border-radius: 12px;
    padding: 25px;
    z-index: 1000;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
    display: none;
    border: 1px solid var(--border-color);
    opacity: 0;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
}

.light-theme .dialog {
    background-color: #F0E9D2;
    border: 1px solid #8E7F56;
}

.dialog.active {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
    display: block;
}

.dialog-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 15px;
}

.light-theme .dialog-header {
    border-bottom: 1px solid #8E7F56;
}

.dialog-title {
    font-size: 20px;
    font-weight: 600;
    color: var(--text-color);
}

.dialog-close {
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 22px;
    cursor: pointer;
    padding: 0;
}

.dialog-close:hover {
    color: var(--text-color);
    transform: none;
    box-shadow: none;
}

.overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 999;
    display: none;
}

.overlay.active {
    display: block;
}

/* Loading animation */
.cosmic-loader {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--bg-color);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    opacity: 1;
    transition: opacity 1s ease-out;
}

.cosmic-loader.hidden {
    opacity: 0;
    pointer-events: none;
}

.loader-planet {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: linear-gradient(45deg, var(--btn-secondary), var(--btn-primary));
    position: relative;
    animation: pulse 2s infinite;
}

.light-theme .loader-planet {
    background: linear-gradient(45deg, #3E7A9C, #5D8A82);
}

.loader-orbit {
    position: absolute;
    top: -25px;
    left: -25px;
    width: 100px;
    height: 100px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    animation: rotate 4s linear infinite;
}

.light-theme .loader-orbit {
    border: 1px solid rgba(0, 0, 0, 0.2);
}

.loader-moon {
    position: absolute;
    top: -5px;
    left: 45px;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: #e0e0e0;
}

@keyframes pulse {
    0% { transform: scale(1); box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }
    50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(52, 152, 219, 0.8); }
    100% { transform: scale(1); box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }
}

@keyframes rotate {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Achievement Badges System Styles */
.achievements-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 20px;
    margin-bottom: 30px;
}

.achievements-grid.tier3 {
    grid-template-columns: 1fr;
    max-width: 150px;
    margin: 0 auto 30px;
}

.achievement-badge {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    cursor: pointer;
    transition: transform 0.3s ease;
}

.achievement-badge:hover {
    transform: translateY(-5px);
}

.badge-icon {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: var(--form-bg);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 10px;
    position: relative;
    overflow: hidden;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    border: 2px solid var(--border-color);
}

.light-theme .badge-icon {
    background-color: #E4DBC0;
    border: 2px solid #8E7F56;
}

.badge-icon i {
    font-size: 36px;
    color: var(--achievement-locked);
    transition: color 0.3s ease;
    z-index: 2;
}

.badge-icon.unlocked i {
    color: var(--text-color);
}

.badge-icon.bronze i {
    color: var(--achievement-bronze);
}

.light-theme .badge-icon.bronze i {
    color: #B05C36;
}

.badge-icon.silver i {
    color: var(--achievement-silver);
}

.light-theme .badge-icon.silver i {
    color: #94A1B2;
}

.badge-icon.gold i {
    color: var(--achievement-gold);
}

.light-theme .badge-icon.gold i {
    color: #D4AC2B;
}

.badge-title {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 5px;
}

.badge-icon::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, rgba(0, 0, 0, 0) 70%);
    opacity: 0.5;
    z-index: 1;
}

.badge-icon.unlocked::before {
    background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, rgba(0, 0, 0, 0) 70%);
    opacity: 1;
}

.badge-tier-title {
    font-size: 18px;
    font-weight: 600;
    margin: 30px 0 15px;
    text-align: center;
    color: var(--text-color);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
}

/* Badge unlock animation */
@keyframes unlockBadge {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
    100% { transform: scale(1); }
}

@keyframes sunRays {
    0% { opacity: 0; transform: scale(0.5); }
    50% { opacity: 1; transform: scale(1.5); }
    100% { opacity: 0; transform: scale(2); }
}

.badge-icon.animate-unlock {
    animation: unlockBadge 1s ease-out;
}

.sun-rays {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle, rgba(255, 215, 0, 0.8) 0%, rgba(255, 215, 0, 0) 70%);
    opacity: 0;
    z-index: 0;
}

.badge-icon.animate-unlock .sun-rays {
    animation: sunRays 1s ease-out;
}

/* Achievement Dialog */
.achievement-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.9);
    background-color: var(--section-bg);
    border-radius: 12px;
    padding: 25px;
    z-index: 1001;
    max-width: 400px;
    width: 90%;
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
    display: none;
    border: 1px solid var(--border-color);
    opacity: 0;
    transition: all 0.3s ease;
    text-align: center;
}

.light-theme .achievement-dialog {
    background-color: #F0E9D2;
    border: 1px solid #8E7F56;
}

.achievement-dialog.active {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
    display: block;
}

.achievement-dialog-icon {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    margin: 0 auto 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--form-bg);
    position: relative;
    overflow: hidden;
    border: 3px solid var(--border-color);
}

.light-theme .achievement-dialog-icon {
    background-color: #E4DBC0;
    border: 3px solid #8E7F56;
}

.achievement-dialog-icon i {
    font-size: 60px;
    z-index: 2;
}

.achievement-dialog-icon.bronze i {
    color: var(--achievement-bronze);
}

.light-theme .achievement-dialog-icon.bronze i {
    color: #B05C36;
}

.achievement-dialog-icon.silver i {
    color: var(--achievement-silver);
}

.light-theme .achievement-dialog-icon.silver i {
    color: #94A1B2;
}

.achievement-dialog-icon.gold i {
    color: var(--achievement-gold);
}

.light-theme .achievement-dialog-icon.gold i {
    color: #D4AC2B;
}

.achievement-dialog-title {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 15px;
}

.achievement-dialog-description {
    font-size: 16px;
    margin-bottom: 25px;
    color: var(--text-secondary);
}

.achievement-dialog-close {
    background-color: var(--btn-secondary);
    color: white;
    padding: 10px 20px;
    border-radius: 4px;
    cursor: pointer;
    display: inline-block;
    font-weight: 500;
    transition: all 0.3s ease;
}

.light-theme .achievement-dialog-close {
    background-color: #3E7A9C;
}

.achievement-dialog-close:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

/* Responsive styles */
@media (max-width: 768px) {
    .achievements-grid {
        grid-template-columns: repeat(2, 1fr);
    }

    .stats-row {
        flex-direction: column;
    }
    
    .stat-box {
        width: 100%;
    }
    
    .sort-controls {
        justify-content: center;
    }
}

@media (max-width: 480px) {
    .achievements-grid {
        grid-template-columns: repeat(1, 1fr);
        max-width: 200px;
        margin: 0 auto 30px;
    }
}

/* Toast overrides */
.toastify {
    padding: 12px 20px;
    color: #ffffff;
    display: inline-block;
    box-shadow: 0 3px 6px -1px rgba(0, 0, 0, 0.12), 0 10px 36px -4px rgba(0, 0, 0, 0.3);
    background: var(--section-bg);
    position: fixed;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);
    border-radius: 8px;
    cursor: default;
    text-decoration: none;
    max-width: 350px;
    z-index: 10000;
    border-left: 4px solid var(--btn-primary);
    display: flex;
    align-items: center;
    gap: 10px;
}

.light-theme .toastify {
    background: #F0E9D2;
    border-left: 4px solid #5D8A82;
    color: #3D3522;
}

.toastify.error {
    border-left-color: var(--btn-danger);
}

.light-theme .toastify.error {
    border-left-color: #A3320B;
}

.toastify.info {
    border-left-color: var(--btn-secondary);
}

.light-theme .toastify.info {
    border-left-color: #3E7A9C;
}

.toast-icon {
    font-size: 20px;
    margin-right: 5px;
}

.toast-content {
    flex: 1;
}

.toast-title {
    font-weight: 600;
    margin-bottom: 2px;
}

.toast-message {
    font-size: 0.9rem;
    opacity: 0.9;
}
</style>

<body>
    <!-- Loading animation -->
    <div class="cosmic-loader" id="cosmic-loader">
        <div class="loader-container">
            <div class="loader-planet"></div>
            <div class="loader-orbit">
                <div class="loader-moon"></div>
            </div>
        </div>
    </div>

    <!-- Background Canvas for Animations -->
    <canvas id="background-canvas"></canvas>

    <!-- Fixed Header -->
    <div class="fixed-header">
        <h1 class="app-title">Unify</h1>
        <div class="header-controls">
            <button id="theme-toggle" class="btn-toggle">
                <i id="theme-toggle-icon" class="fas fa-moon"></i>
                <span id="theme-toggle-text">Dark Mode</span>
            </button>
            <button id="help-button" class="btn-help">?</button>
        </div>
    </div>

    <!-- Help Content -->
    <div id="help-content" class="help-content">
        <h2 style="text-align: center;">Unify: Your Path to Targeted Self-Improvement</h2>
        <p>How Unify Works:</p>
        <ol>
            <li><strong>Input Problems:</strong> Identify and rate problems causing negative emotions in different life areas.</li>
            <li><strong>Problems List:</strong> Review your problems and set achievable goals to address them.</li>
            <li><strong>Goals List:</strong> Create goals and identify tasks needed to accomplish them.</li>
            <li><strong>Tasks List:</strong> Break down goals into specific actionable tasks with required resources.</li>
            <li><strong>Dashboard:</strong> Track your progress and gain insights on your journey to self-improvement.</li>
        </ol>
        <hr>
        <p>The core concept of Unify is transforming negative emotions associated with problems into motivation and positive change. The process naturally guides you to solutions that actually work, to solve your self-defined problems, in a way you are motivated to implement.</p>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- SECTION 1: Input Problem -->
        <div class="section" id="section-input">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-plus-circle"></i>
                    <span>Input Problem</span>
                </div>
                <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <div class="form-container">
                    <form id="problem-form">
                        <label>
                            Area:
                            <select id="problem-area">
                                <option value="Diet">Diet</option>
                                <option value="Family">Family</option>
                                <option value="Fitness">Fitness</option>
                                <option value="Health">Health</option>
                                <option value="Home">Home</option>
                                <option value="Parenting">Parenting</option>
                                <option value="Personal">Personal</option>
                                <option value="Relationship">Relationship</option>
                                <option value="Sleep">Sleep</option>
                                <option value="Social Life">Social Life</option>
                                <option value="Study">Study</option>
                                <option value="Work">Work</option>
                            </select>
                        </label>
                        <label>
                            Emotion:
                            <select id="problem-emotion">
                                <option value="Annoyed">Annoyed</option>
                                <option value="Anxious">Anxious</option>
                                <option value="Bored">Bored</option>
                                <option value="Depressed">Depressed</option>
                                <option value="Distracted">Distracted</option>
                                <option value="Disapproving">Disapproving</option>
                                <option value="Disassociated">Disassociated</option>
                                <option value="Embarrassed">Embarrassed</option>
                                <option value="Envy">Envy</option>
                                <option value="Guilty">Guilty</option>
                                <option value="Impatient">Impatient</option>
                                <option value="Insecure">Insecure</option>
                                <option value="Let Down">Let Down</option>
                                <option value="Lonely">Lonely</option>
                                <option value="Offended">Offended</option>
                                <option value="Physical Pain">Physical Pain</option>
                                <option value="Stressed">Stressed</option>
                                <option value="Tired">Tired</option>
                                <option value="Vulnerable">Vulnerable</option>
                            </select>
                        </label>
                        <label>
                            Problem:
                            <input type="text" id="problem-input" placeholder="Describe your problem">
                        </label>
                        <label>
                            Difficulty:
                            <div class="star-rating" id="problem-difficulty-rating">
                              <div class="stars">
                                <span class="star" data-value="1"><i class="fas fa-star"></i></span>
                                <span class="star" data-value="2"><i class="fas fa-star"></i></span>
                                <span class="star" data-value="3"><i class="fas fa-star"></i></span>
                                <span class="star" data-value="4"><i class="fas fa-star"></i></span>
                                <span class="star" data-value="5"><i class="fas fa-star"></i></span>
                              </div>
                              <input type="hidden" name="problem-difficulty" id="problem-difficulty" value="">
                              <div class="rating-description" id="problem-description"></div>
                            </div>
                        </label>
                        <button type="button" id="add-problem-btn" class="btn-add">Add Problem</button>
                    </form>
                </div>
            </div>
        </div>

        <!-- SECTION 2: Problems List -->
        <div class="section" id="section-problems">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-exclamation-circle"></i>
                    <span>Problems</span>
                    <span class="count-badge" id="problems-count">0</span>
                </div>
                <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <div class="sort-controls">
                <button class="active" onclick="sortProblems('recent')">Recent</button>
                    <button onclick="sortProblems('area')">Area</button>
                    <button onclick="sortProblems('emotion')">Emotion</button>
                    <button onclick="sortProblems('difficulty')">Difficulty</button>
                    <button onclick="toggleFinishedProblems()" id="toggle-finished-problems">Show Finished</button>
                </div>
                <div id="problems-list" class="list-container">
                    <!-- Problems will be loaded here dynamically -->
                </div>
            </div>
        </div>

        <!-- SECTION 3: Goals List -->
        <div class="section" id="section-goals">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-bullseye"></i>
                    <span>Goals</span>
                    <span class="count-badge" id="goals-count">0</span>
                </div>
             <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <div class="sort-controls">
                    <button class="active" onclick="sortGoals('recent')">Recent</button>
                    <button onclick="sortGoals('area')">Area</button>
                    <button onclick="sortGoals('emotion')">Emotion</button>
                    <button onclick="sortGoals('difficulty')">Difficulty</button>
                    <button onclick="toggleFinishedGoals()" id="toggle-finished-goals">Show Finished</button>
                </div>
                <div id="goals-list" class="list-container">
                    <!-- Goals will be loaded here dynamically -->
                </div>
            </div>
        </div>

        <!-- SECTION 4: Tasks List -->
        <div class="section" id="section-tasks">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-tasks"></i>
                    <span>Tasks</span>
                    <span class="count-badge" id="tasks-count">0</span>
                </div>
                <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <div class="sort-controls">
                    <button class="active" onclick="sortTasks('recent')">Recent</button>
                    <button onclick="sortTasks('area')">Area</button>
                    <button onclick="toggleFinishedTasks()" id="toggle-finished-tasks">Show Finished</button>
                </div>
                <div id="tasks-list" class="list-container">
                    <!-- Tasks will be loaded here dynamically -->
                </div>
            </div>
        </div>
        
        <!-- SECTION 5: Dashboard & Insights -->
        <div class="section" id="section-dashboard">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-chart-line"></i>
                    <span>Dashboard & Insights</span>
                </div>
                <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <!-- Progress bar (keeping this) -->
                <div class="progress-container">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>

                <!-- Problem Analysis -->
                <h3>Problem Analysis</h3>
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-label">Problems by Area</div>
                        <div class="chart-container">
                            <canvas id="chart-problems-area"></canvas>
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Problems by Emotion</div>
                        <div class="chart-container">
                            <canvas id="chart-problems-emotion"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Goal Analysis -->
                <h3>Goal Analysis</h3>
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-label">Goals by Area</div>
                        <div class="chart-container">
                            <canvas id="chart-goals-area"></canvas>
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Goals by Emotion</div>
                        <div class="chart-container">
                            <canvas id="chart-goals-emotion"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SECTION 6: Achievements -->
        <div class="section" id="section-achievements">
            <div class="section-title">
                <div class="section-title-left">
                    <i class="fas fa-trophy"></i>
                    <span>Achievements</span>
                    <span class="count-badge" id="achievements-count">0</span>
                </div>
                <i class="fas fa-chevron-down toggle-arrow"></i>
            </div>
            <div class="section-content">
                <!-- Tier 1 Badges -->
                <div class="badge-tier-title">Discovery Achievements</div>
                <div class="achievements-grid tier1">
                    <!-- Pandora's Box -->
                    <div class="achievement-badge" id="badge-pandoras-box">
                        <div class="badge-icon">
                            <div class="sun-rays"></div>
                            <i class="fas fa-box-open"></i>
                        </div>
                        <div class="badge-title">Pandora's Box</div>
                    </div>
                    
                    <!-- Sword of Damocles -->
                    <div class="achievement-badge" id="badge-sword-of-damocles">
                        <div class="badge-icon">
                            <div class="sun-rays"></div>
                   <i class="fa-regular fa-hourglass-half"></i>
                        </div>
                        <div class="badge-title">Sword of Damocles</div>
                    </div>
                    
                    <!-- Midas Touch -->
                    <div class="achievement-badge" id="badge-midas-touch">
                        <div class="badge-icon">
                            <div class="sun-rays"></div>
                            <i class="fas fa-hand-sparkles"></i>
                        </div>
                        <div class="badge-title">Midas Touch</div>
                    </div>
                    
                    <!-- Sisyphus -->
                    <div class="achievement-badge" id="badge-sisyphus">
                        <div class="badge-icon">
                            <div class="sun-rays"></div>
                            <i class="fas fa-mountain"></i>
                        </div>
                        <div class="badge-title">Sisyphus</div>
                    </div>
                    
                    <!-- The Labyrinth of Daedalus -->
                    <div class="achievement-badge" id="badge-labyrinth">
                        <div class="badge-icon">
                            <div class="sun-rays"></div>
                            <i class="fas fa-route"></i>
                        </div>
                        <div class="badge-title">Labyrinth of Daedalus</div>
                    </div>
                </div>
                
                <!-- Tier 2 Badges -->
                <div class="badge-tier-title">Mastery Achievements</div>
                <div class="achievements-grid tier2">
                    <!-- The Hydra -->
                    <div class="achievement-badge" id="badge-hydra">
                        <div class="badge-icon">
                            <div class="sun-rays"></div>
                            <i class="fas fa-dragon"></i>
                        </div>
                        <div class="badge-title">The Hydra</div>
                    </div>
                    
                    <!-- The Phoenix -->
                    <div class="achievement-badge" id="badge-phoenix">
                        <div class="badge-icon">
                            <div class="sun-rays"></div>
                            <i class="fas fa-fire"></i>
                        </div>
                        <div class="badge-title">The Phoenix</div>
                    </div>
                    
                    <!-- The Oracle of Delphi -->
                    <div class="achievement-badge" id="badge-oracle">
                        <div class="badge-icon">
                            <div class="sun-rays"></div>
                            <i class="fas fa-eye"></i>
                        </div>
                        <div class="badge-title">Oracle of Delphi</div>
                    </div>
                    
                    <!-- Atlas -->
                    <div class="achievement-badge" id="badge-atlas">
                        <div class="badge-icon">
                            <div class="sun-rays"></div>
                            <i class="fas fa-globe-americas"></i>
                        </div>
                        <div class="badge-title">Atlas</div>
                    </div>
                    
                    <!-- Hercules -->
                    <div class="achievement-badge" id="badge-hercules">
                        <div class="badge-icon">
                            <div class="sun-rays"></div>
                            <i class="fas fa-dumbbell"></i>
                        </div>
                        <div class="badge-title">Hercules</div>
                    </div>
                </div>
                
                <!-- Tier 3 Badge -->
                <div class="badge-tier-title">Legendary Achievement</div>
                <div class="achievements-grid tier3">
                    <!-- Theseus -->
                    <div class="achievement-badge" id="badge-theseus">
                        <div class="badge-icon">
                            <div class="sun-rays"></div>
                            <i class="fas fa-crown"></i>
                        </div>
                        <div class="badge-title">Theseus</div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Achievement Dialog -->
    <div class="achievement-dialog" id="achievement-dialog">
        <div class="achievement-dialog-icon" id="achievement-dialog-icon">
            <i class="fas fa-trophy" id="achievement-dialog-icon-inner"></i>
        </div>
        <div class="achievement-dialog-title" id="achievement-dialog-title">Achievement Name</div>
        <div class="achievement-dialog-description" id="achievement-dialog-description">
            Achievement description goes here.
        </div>
        <div class="achievement-dialog-close" onclick="closeAchievementDialog()">Close</div>
    </div>

    <!-- Overlay and Dialog for Task completion -->
    <div class="overlay" id="overlay"></div>
    <div class="dialog" id="completion-dialog">
        <div class="dialog-header">
            <div class="dialog-title">Task Completed!</div>
            <button class="dialog-close" onclick="closeDialog()">&times;</button>
        </div>
        <div class="dialog-content">
            <p>Congratulations on completing your task! How do you feel about this accomplishment?</p>
            <div style="margin: 20px 0;">
                <select id="completion-feedback" style="width: 100%;">
                    <option value="proud">I feel proud of this achievement</option>
                    <option value="relieved">I'm relieved to have this done</option>
                    <option value="motivated">This motivates me to do more</option>
                    <option value="neutral">I feel neutral about it</option>
                </select>
            </div>
            <button class="btn-add" style="width: 100%;" onclick="saveCompletion()">Save & Continue</button>
        </div>
    </div>

    <!-- Standalone Task Dialog -->
    <div class="dialog" id="standalone-task-dialog">
        <div class="dialog-header">
            <div class="dialog-title">Create New Task</div>
            <button class="dialog-close" onclick="closeTaskDialog()">&times;</button>
        </div>
        <div class="dialog-content">
            <form id="standalone-task-form">
                <label>
                    Area:
                    <select id="standalone-task-area">
                        <option value="Diet">Diet</option>
                        <option value="Family">Family</option>
                        <option value="Fitness">Fitness</option>
                        <option value="Health">Health</option>
                        <option value="Home">Home</option>
                        <option value="Parenting">Parenting</option>
                        <option value="Personal">Personal</option>
                        <option value="Relationship">Relationship</option>
                        <option value="Sleep">Sleep</option>
                        <option value="Social Life">Social Life</option>
                        <option value="Study">Study</option>
                        <option value="Work">Work</option>
                    </select>
                </label>
                <label>
                    Task:
                    <input type="text" id="standalone-task-input" placeholder="Describe your task">
                </label>
                <button type="button" class="btn-add" style="width: 100%; margin-top: 20px;" onclick="addStandaloneTask()">Create Task</button>
            </form>
        </div>
    </div>
</body>

<script>
        // Global variables
        let isDarkTheme = true;
        let renderer, scene, camera;
        let particles, goalObjects, problemObjects, taskObjects;
        let animationId;
        let stars = [];
        let nebulas = [];
        let shootingStars = [];
        let galaxyCenter;
        let clock = new THREE.Clock();
        let showFinishedProblems = false;
        let showFinishedGoals = false;
        let showFinishedTasks = false;

        // Achievement system variables
        let achievements = {};
        let newlyUnlockedAchievements = [];

        // Emotion colors mapping for visualization
        const emotionColors = {
            'Annoyed': 0xffa500,     // Orange
            'Anxious': 0x9370db,      // Purple
            'Bored': 0xa9a9a9,        // Gray
            'Depressed': 0x4b0082,    // Indigo
            'Distracted': 0xadd8e6,   // Light Blue
            'Disapproving': 0x8b0000, // Dark Red
            'Disassociated': 0xf5f5f5, // White
            'Embarrassed': 0xff69b4,  // Pink
            'Envy': 0x32cd32,         // Lime Green
            'Guilty': 0x8b4513,       // Brown
            'Impatient': 0xffa07a,    // Light Salmon
            'Insecure': 0xff6347,     // Tomato
            'Let Down': 0x6a5acd,     // Slate Blue
            'Lonely': 0x87ceeb,       // Sky Blue
            'Offended': 0xcd5c5c,     // Indian Red
            'Physical Pain': 0xff0000, // Red
            'Stressed': 0xffd700,     // Gold
            'Tired': 0x2f4f4f,        // Dark Slate Gray
            'Vulnerable': 0x98fb98    // Pale Green
        };

        // Goal emotion colors
        const goalEmotionColors = {
            'Meaningful': 0x4CAF50, // Green
            'Neutral': 0x2196F3,    // Blue
            'Difficult': 0xF44336   // Red
        };

        const problemDescriptions = {
            1: "Fixable now",
            2: "Fixable soon",
            3: "Fixable with the right resources",
            4: "Fixable with the right resources and skills",
            5: "Fixable with the right resources, skills, and cooperation from other people"
        };

        const goalDescriptions = {
            1: "Achievable now",
            2: "Achievable soon",
            3: "Achievable with the right resources",
            4: "Achievable with the right resources and skills",
            5: "Achievable with the right resources, skills, and cooperation from other people"
        };

        // Achievement system definitions
        const achievementDefinitions = {
            "pandoras-box": {
                id: "pandoras-box",
                title: "Pandora's Box",
                icon: "box-open",
                tier: 1,
                condition: (data) => data.problems.length >= 9,
                unlockedHint: "Like Pandora, you've opened the box and recognized the challenges of life. But remember, even in the darkest moments, you've also discovered hope.",
                lockedHint: "Like Pandora, you must first uncover what troubles you before you can truly find hope."
            },
            "sword-of-damocles": {
                id: "sword-of-damocles",
                title: "Sword of Damocles",
                icon: "sword",
                tier: 1,
                condition: (data) => data.problems.some(p => p.problemDifficulty === "5"),
                unlockedHint: "You've acknowledged the great challenge that hangs above you, understanding that greatness comes with great responsibility.",
                lockedHint: "The sword hangs by a single thread, awaiting one who will recognize the weight of their most difficult challenge."
            },
            "midas-touch": {
                id: "midas-touch",
                title: "Midas Touch",
                icon: "hand-sparkles",
                tier: 1,
                condition: (data) => data.goals.length >= 9,
                unlockedHint: "Everything you touch turns to gold! Your vision creates possibilities where others see obstacles.",
                lockedHint: "King Midas could transform anything to gold with his touch. Set your goals, and transform your future."
            },
            "sisyphus": {
                id: "sisyphus",
                title: "Sisyphus",
                icon: "mountain",
                tier: 1,
                condition: (data) => data.goals.some(g => g.goalDifficulty === "5"),
                unlockedHint: "Like Sisyphus, you face a momentous challenge. Yet in the struggle itself, there is meaning to be found.",
                lockedHint: "Sisyphus was condemned to roll a boulder uphill for eternity. What great task awaits you?"
            },
            "labyrinth": {
                id: "labyrinth",
                title: "Labyrinth of Daedalus",
                icon: "route",
                tier: 1,
                condition: (data) => data.tasks.length >= 12,
                unlockedHint: "You've mapped out the complex pathways of your journey, creating order from chaos like the great inventor Daedalus.",
                lockedHint: "The maze built by Daedalus was complex, with many paths. Create your own paths to navigate your challenges."
            },
            "hydra": {
                id: "hydra",
                title: "The Hydra",
                icon: "dragon",
                tier: 2,
                condition: (data) => data.problems.filter(p => p.finished).length >= 9,
                unlockedHint: "When faced with many challenges, you've overcome them all, cutting down each head of the Hydra with determination.",
                lockedHint: "The Hydra grew two heads for each one cut off. Overcome your many challenges to tame this beast."
            },
            "phoenix": {
                id: "phoenix",
                title: "The Phoenix",
                icon: "fire",
                tier: 2,
                condition: (data) => data.problems.some(p => p.problemDifficulty === "5" && p.finished),
                unlockedHint: "From the ashes of your greatest challenge, you have risen anew, transformed by the fire of adversity.",
                lockedHint: "The Phoenix rises from its own ashes. Overcome your greatest challenge to experience this rebirth."
            },
            "oracle": {
                id: "oracle",
                title: "Oracle of Delphi",
                icon: "eye",
                tier: 2,
                condition: (data) => data.goals.filter(g => g.finished).length >= 3,
                unlockedHint: "With wisdom and foresight, you've guided your destiny to meaningful achievements, as the Oracle guides seekers of truth.",
                lockedHint: "The Oracle at Delphi saw what others could not. Achieve your goals to gain such foresight."
            },
            "atlas": {
                id: "atlas",
                title: "Atlas",
                icon: "globe-americas",
                tier: 2,
                condition: (data) => data.goals.some(g => g.goalDifficulty === "5" && g.finished),
                unlockedHint: "You've shouldered the weight of your greatest ambition and stood firm, showing strength that would impress Atlas himself.",
                lockedHint: "Atlas bore the weight of the heavens on his shoulders. What great weight will you bear to reach your most difficult goal?"
            },
            "hercules": {
                id: "hercules",
                title: "Hercules",
                icon: "dumbbell",
                tier: 2,
                condition: (data) => data.tasks.filter(t => t.completed).length >= 12,
                unlockedHint: "Your twelve labors are complete! Like Hercules, your persistence through many tasks has proven your heroic nature.",
                lockedHint: "Hercules completed twelve great labors to prove himself. What tasks will define your legendary status?"
            },
            "theseus": {
                id: "theseus",
                title: "Theseus",
                icon: "crown",
                tier: 3,
                condition: (data) => {
                    return data.problems.filter(p => p.finished).length >= 10 &&
                           data.goals.filter(g => g.finished).length >= 10 &&
                           data.tasks.filter(t => t.completed).length >= 20;
                },
                unlockedHint: "Like Theseus, you've navigated the labyrinth of self-improvement, defeated your inner Minotaur, and emerged as a true hero of your own story.",
                lockedHint: "Theseus conquered the Minotaur and found his way through the labyrinth. Complete your journey to claim your crown."
            }
        };

        // Replace the initApp function to reorder menu sections
        function initApp() {
            // Hide loader after 1.5 seconds
            setTimeout(() => {
                document.getElementById('cosmic-loader').classList.add('hidden');
            }, 1500);
            
            // Initialize UI event listeners
            initEventListeners();
            
            // Initialize Three.js visualization
            initThreeJS();
            
            // Add sample items if empty
            addSampleItems();
            
            // Load data from localStorage
            loadData();

            // Initialize achievements system
            initAchievements();

            // Add UI for standalone items
            addStandaloneItemButtons();
            
            // Update stats and counters
            updateStats();
            updateCounts();
            
            // Open Input Problem section by default instead of Dashboard
            const inputProblemSection = document.querySelector('#section-input .section-content');
            const inputProblemArrow = document.querySelector('#section-input .toggle-arrow');
            inputProblemSection.classList.add('active');
            inputProblemArrow.classList.add('open');
            
            // Focus problem input
            document.getElementById('problem-input').focus();

            // Show welcome toast
            showToast("Welcome to Unify!", "Your personal self-improvement journey begins now.", "info");
        }

        // Initialize event listeners
        function initEventListeners() {
            // Initialize the problem difficulty star rating
            setTimeout(() => {
                const problemRatingElement = document.getElementById('problem-difficulty-rating');
                if (problemRatingElement) {
                    initStarRating(
                        problemRatingElement,
                        problemDescriptions,
                        null
                    );
                }
            }, 100);

            // Toggle sections
            document.querySelectorAll('.section-title').forEach(title => {
                title.addEventListener('click', toggleSection);
            });
            
            // Help button
            document.getElementById('help-button').addEventListener('click', toggleHelp);
            
            // Theme toggle
            document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
            
            // Add problem button
            document.getElementById('add-problem-btn').addEventListener('click', addProblem);

            // Initialize achievement badges click events
            document.querySelectorAll('.achievement-badge').forEach(badge => {
                badge.addEventListener('click', function() {
                    const badgeId = this.id.replace('badge-', '');
                    showAchievementDialog(badgeId);
                });
            });
        }

        // Star rating initialization function
        function initStarRating(container, descriptions, onSelectCallback) {
            if (!container) return null;
            
            const stars = container.querySelectorAll('.star');
            const ratingInput = container.querySelector('input[type="hidden"]');
            const descriptionElement = container.querySelector('.rating-description');

            
            // Function to update stars
            function updateStars(value) {
                stars.forEach(star => {
                    const starValue = parseInt(star.dataset.value);
                    if (starValue <= value) {
                        star.classList.add('selected');
                    } else {
                        star.classList.remove('selected');
                    }
                });
                
                // Update hidden input value
                if (ratingInput) {
                    ratingInput.value = value;
                }
          
                // Update description
                if (descriptionElement && descriptions && descriptions[value]) {
                    descriptionElement.textContent = descriptions[value];
                    descriptionElement.classList.add('active');
                }
                
                // Call callback if provided
                if (onSelectCallback) {
                    onSelectCallback(value);
                }
            }
            
            // Add click event listeners to stars
            stars.forEach(star => {
                star.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const value = parseInt(this.dataset.value);
                    updateStars(value);
                });
            });
            
            // Method to set a value programmatically
            return {
                setValue: function(value) {
                    if (value) {
                        updateStars(parseInt(value));
                    }
                }
            };
        }

        // Toggle section visibility
        function toggleSection(e) {
            if (e.target.classList.contains('btn-secondary')) return;
            
            const section = this.closest('.section');
            const content = section.querySelector('.section-content');
            const arrow = this.querySelector('.toggle-arrow');
            
            content.classList.toggle('active');
            arrow.classList.toggle('open');
 
updateCounts();
checkAchievements();
       }

        // Toggle help content
        function toggleHelp() {
            const helpContent = document.getElementById('help-content');
            helpContent.classList.toggle('active');
        }

        // Toggle theme (Dark/Light)
        function toggleTheme() {
    isDarkTheme = !isDarkTheme;
    
    if (isDarkTheme) {
        document.body.classList.remove('light-theme');
        document.getElementById('theme-toggle-icon').className = 'fas fa-moon';
        document.getElementById('theme-toggle-text').textContent = 'Dark Mode';
    } else {
        document.body.classList.add('light-theme');
        document.getElementById('theme-toggle-icon').className = 'fas fa-sun';
        document.getElementById('theme-toggle-text').textContent = 'Light Mode';
    }
    
    // Reinitialize Three.js scene based on new theme
    resetThreeJS();
    
    // Regenerate all charts with the new theme colors
    updateStats();

    // Show theme change toast
    showToast("Theme Changed", isDarkTheme ? "Dark theme activated." : "Light theme activated.", "info");
}

        // Add a new problem
        // Add a new problem
function addProblem() {
    const problemInput = document.getElementById('problem-input').value.trim();
    const problemArea = document.getElementById('problem-area').value;
    const problemEmotion = document.getElementById('problem-emotion').value;
    const problemDifficulty = document.getElementById('problem-difficulty').value;
    
    if (!problemInput) {
        showToast("Validation Error", "Please enter a problem description.", "error");
        return;
    }
    
    if (!problemDifficulty) {
        showToast("Validation Error", "Please select a difficulty level.", "error");
        return;
    }
    
    // Show toast notification immediately after validation passes
    showToast("Problem Added", "Identifying problems is the first step to solving them.", "success");
    
    const problem = {
        id: Date.now().toString(),
        problemInput,
        problemArea,
        problemEmotion,
        problemDifficulty,
        timestamp: Date.now(),
        finished: false
    };
    
    // Save to localStorage
    let problems = JSON.parse(localStorage.getItem('problems')) || [];
    problems.push(problem);
    localStorage.setItem('problems', JSON.stringify(problems));
    
    // Reset form
    document.getElementById('problem-form').reset();
    
    // Reset star rating properly
    const starRating = document.getElementById('problem-difficulty-rating');
    if (starRating) {
        const stars = starRating.querySelectorAll('.star');
        stars.forEach(star => star.classList.remove('selected'));
        document.getElementById('problem-difficulty').value = '';
        const descriptionElement = document.getElementById('problem-description');
        if (descriptionElement) {
            descriptionElement.textContent = '';
            descriptionElement.classList.remove('active');
        }
    }
    
    // Update UI
    renderProblems();
    updateStats();
    updateCounts();
    
    // Add object to 3D scene
    addProblemObject(problem);
    
    // Open the problems section
    const problemsSection = document.querySelector('#section-problems .section-content');
    const problemsArrow = document.querySelector('#section-problems .toggle-arrow');
    if (!problemsSection.classList.contains('active')) {
        problemsSection.classList.add('active');
        problemsArrow.classList.add('open');
    }

    // Check achievements
    checkAchievements();
}

        // Toggle finished problems visibility
        function toggleFinishedProblems() {
            showFinishedProblems = !showFinishedProblems;
            const toggleButton = document.getElementById('toggle-finished-problems');
            toggleButton.textContent = showFinishedProblems ? 'Hide Finished' : 'Show Finished';
            renderProblems();
        }

        // Toggle finished goals visibility
        function toggleFinishedGoals() {
            showFinishedGoals = !showFinishedGoals;
            const toggleButton = document.getElementById('toggle-finished-goals');
            toggleButton.textContent = showFinishedGoals ? 'Hide Finished' : 'Show Finished';
            renderGoals();
        }

        // Toggle finished tasks visibility
        function toggleFinishedTasks() {
            showFinishedTasks = !showFinishedTasks;
            const toggleButton = document.getElementById('toggle-finished-tasks');
            toggleButton.textContent = showFinishedTasks ? 'Hide Finished' : 'Show Finished';
            renderTasks();
        }

        // Mark problem as finished/unfinished
        // Mark problem as finished/unfinished
function toggleProblemStatus(problemId) {
    let problems = JSON.parse(localStorage.getItem('problems')) || [];
    const problemIndex = problems.findIndex(p => p.id === problemId);
    
    if (problemIndex !== -1) {
        const wasFinished = problems[problemIndex].finished;
        problems[problemIndex].finished = !wasFinished;
        
        // Show toast notification before updating localStorage
        if (!wasFinished) {
            showToast("Problem Resolved", "You've successfully addressed this challenge.", "success");
        } else {
            showToast("Problem Reopened", "Sometimes we need to revisit challenges.", "info");
        }
        
        // Update localStorage
        localStorage.setItem('problems', JSON.stringify(problems));
        
        // Update UI
        renderProblems();
        updateStats();
        updateCounts();

        // Check achievements
        checkAchievements();
    }
}

        // Mark goal as finished/unfinished
        // Mark goal as finished/unfinished
function toggleGoalStatus(goalId) {
    let goals = JSON.parse(localStorage.getItem('goals')) || [];
    const goalIndex = goals.findIndex(g => g.id === goalId);
    
    if (goalIndex !== -1) {
        const wasFinished = goals[goalIndex].finished;
        goals[goalIndex].finished = !wasFinished;
        
        // Show toast notification before updating localStorage
        if (!wasFinished) {
            showToast("Goal Achieved", "Celebrate this milestone in your journey.", "success");
        } else {
            showToast("Goal Reopened", "It's okay to reassess and continue working.", "info");
        }
        
        // Update localStorage
        localStorage.setItem('goals', JSON.stringify(goals));
        
        // Update UI
        renderGoals();
        updateStats();
        updateCounts();

        // Check achievements
        checkAchievements();
    }
}

   // Render problems list with updated UI
        function renderProblems() {
            const problems = JSON.parse(localStorage.getItem('problems')) || [];
            const problemsList = document.getElementById('problems-list');
            
            problemsList.innerHTML = '';
            
            if (problems.length === 0) {
                problemsList.innerHTML = '<p style="padding: 10px;">No problems added yet. Use the Input Problem section to add problems.</p>';
                return;
            }
            
            // Filter problems based on finished status
            const filteredProblems = showFinishedProblems 
                ? problems 
                : problems.filter(p => !p.finished);
            
            if (filteredProblems.length === 0) {
                problemsList.innerHTML = '<p style="padding: 10px;">No ' + (showFinishedProblems ? 'finished' : 'active') + ' problems found.</p>';
                return;
            }
            
            filteredProblems.forEach(problem => {
                const listItem = document.createElement('div');
                listItem.className = 'list-item';
                
                listItem.innerHTML = `
                    <div class="list-item-title">
                  
                    <span>
<span>
    <span class="custom-checkbox ${problem.finished ? 'checked' : ''}" data-problem-id="${problem.id}"></span>
    <span class="${problem.finished ? 'task-complete-text' : ''}">${problem.problemInput}</span>
</span>

                        
                        </span>
                        <div>
                            ${problem.finished ? `<i class="fas fa-trash" onclick="deleteProblem('${problem.id}');" style="cursor: pointer; margin-right: 10px;"></i>` : ''}
                            <i class="fas fa-chevron-down toggle-arrow"></i>
                        </div>
                    </div>
                    <div class="list-item-meta">
                        <div class="meta-item"><i class="fas fa-folder"></i> ${problem.problemArea}</div>
                        <div class="meta-item"><i class="fas fa-heart-broken"></i> ${problem.problemEmotion}</div>
                        <div class="meta-item"><i class="fas fa-star"></i> Difficulty: ${problem.problemDifficulty}</div>
                        ${problem.finished ? '<div class="meta-item"><i class="fas fa-check-circle"></i> Finished</div>' : ''}
                    </div>
                    <div class="list-item-content">
                        ${!problem.finished ? `
                        <form id="goal-form-${problem.id}">
                            <label>
                                Area:
                                <select id="goal-area-${problem.id}">
                                    <option value="Diet">Diet</option>
                                    <option value="Family">Family</option>
                                    <option value="Fitness">Fitness</option>
                                    <option value="Health">Health</option>
                                    <option value="Home">Home</option>
                                    <option value="Parenting">Parenting</option>
                                    <option value="Personal">Personal</option>
                                    <option value="Relationship">Relationship</option>
                                    <option value="Sleep">Sleep</option>
                                    <option value="Social Life">Social Life</option>
                                    <option value="Study">Study</option>
                                    <option value="Work">Work</option>
                                </select>
                            </label>
                            <label>
                                Goal:
                                <input type="text" id="goal-input-${problem.id}" placeholder="Create a goal to address this problem">
                            </label>
                            <label>
                                Emotion:
                                <select id="goal-emotion-${problem.id}">
                                    <option value="Meaningful">Meaningful</option>
                                    <option value="Neutral">Neutral</option>
                                    <option value="Difficult">Difficult</option>
                                </select>
                            </label>
                            <label>
                                Difficulty:
                                <div class="star-rating" id="goal-difficulty-rating-${problem.id}">
                                    <div class="stars">
                                        <span class="star" data-value="1"><i class="fas fa-star"></i></span>
                                        <span class="star" data-value="2"><i class="fas fa-star"></i></span>
                                        <span class="star" data-value="3"><i class="fas fa-star"></i></span>
                                        <span class="star" data-value="4"><i class="fas fa-star"></i></span>
                                        <span class="star" data-value="5"><i class="fas fa-star"></i></span>
                                    </div>
                                    <input type="hidden" name="goal-difficulty-${problem.id}" id="goal-difficulty-${problem.id}" value="">
                                    <div class="rating-description" id="goal-description-${problem.id}"></div>
                                </div>
                            </label>
                            <div class="item-actions">
                                <button type="button" class="btn-add action-btn" onclick="addGoal('${problem.id}')">Add Goal</button>
                            </div>
                        </form>
                        ` : ''}
                    </div>
                `;
                
                // Set selected area to match problem area
                setTimeout(() => {
                    if (!problem.finished) {
                        const areaSelect = listItem.querySelector(`#goal-area-${problem.id}`);
                        if (areaSelect) areaSelect.value = problem.problemArea;
                        
                        // Initialize goal star rating for this problem
                        const goalRatingElement = document.getElementById(`goal-difficulty-rating-${problem.id}`);
                        if (goalRatingElement) {
                            initStarRating(
                                goalRatingElement,
                                goalDescriptions,
                                (value) => {
                                    // Handle emotion warning if needed
                                    const emotion = document.getElementById(`goal-emotion-${problem.id}`).value;
                                    const descriptionElement = document.getElementById(`goal-description-${problem.id}`);
                                    if (emotion === 'Difficult' && descriptionElement) {
                                        descriptionElement.innerHTML = goalDescriptions[value];
                                        descriptionElement.innerHTML += '<br><em>Self-defined difficult goals are sources of fatigue. Sometimes it\'s wise to choose easier goals in order to build momentum and motivation.</em>';
                                        descriptionElement.classList.add('active');
                                    }
                                }
                            );
                        }
                        
                        // Add event listener for emotion change
                        const emotionSelect = listItem.querySelector(`#goal-emotion-${problem.id}`);
                        if (emotionSelect) {
                            emotionSelect.addEventListener('change', function() {
                                const difficultyValue = document.getElementById(`goal-difficulty-${problem.id}`).value;
                                if (difficultyValue && this.value === 'Difficult') {
                                    const descriptionElement = document.getElementById(`goal-description-${problem.id}`);
                                    if (descriptionElement) {
                                        descriptionElement.innerHTML = goalDescriptions[difficultyValue];
                                        descriptionElement.innerHTML += '<br><em>Self-defined difficult goals are sources of fatigue. Sometimes it\'s wise to choose easier goals in order to build momentum and motivation.</em>';
                                        descriptionElement.classList.add('active');
                                    }
                                }
                            });
                        }
                    }
                }, 0);
                
                // Add checkbox event listener
                const checkbox = listItem.querySelector(`.custom-checkbox[data-problem-id="${problem.id}"]`);
                if (checkbox) {
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        toggleProblemStatus(problem.id);
                    });
                }
                
                // Toggle content visibility
                const title = listItem.querySelector('.list-item-title');
                title.addEventListener('click', function(e) {
                    // Don't toggle if clicking on the checkbox or trash icon
                    if (e.target.classList.contains('custom-checkbox') || 
                        e.target.closest('.custom-checkbox') ||
                        e.target.classList.contains('fa-trash')) return;
                    
                    const content = this.parentElement.querySelector('.list-item-content');
                    const arrow = this.querySelector('.toggle-arrow');
                    content.classList.toggle('active');
                    
                    if (content.classList.contains('active')) {
                        arrow.classList.remove('fa-chevron-down');
                        arrow.classList.add('fa-chevron-up');
                    } else {
                        arrow.classList.remove('fa-chevron-up');
                        arrow.classList.add('fa-chevron-down');
                    }
                });
                
                problemsList.appendChild(listItem);
            });
        }

        // Add a new goal
     // Add a new goal
function addGoal(problemId) {
    const goalInput = document.getElementById(`goal-input-${problemId}`).value.trim();
    const goalArea = document.getElementById(`goal-area-${problemId}`).value;
    const goalEmotion = document.getElementById(`goal-emotion-${problemId}`).value;
    const goalDifficulty = document.getElementById(`goal-difficulty-${problemId}`).value;
    
    if (!goalInput) {
        showToast("Validation Error", "Please enter a goal description.", "error");
        return;
    }
    
    if (!goalDifficulty) {
        showToast("Validation Error", "Please select a difficulty level.", "error");
        return;
    }
    
    // Get the problem details
    const problems = JSON.parse(localStorage.getItem('problems')) || [];
    const problem = problems.find(p => p.id === problemId);
    
    if (!problem) {
        showToast("Error", "Problem not found. Please try again.", "error");
        return;
    }
    
    // Show toast notification immediately after validation passes
    showToast("Goal Created", "Your path forward is becoming clearer.", "success");
    
    const goal = {
        id: Date.now().toString(),
        goalInput,
        goalArea,
        goalEmotion,
        goalDifficulty,
        relatedProblemId: problemId,
        relatedProblem: problem.problemInput,
        timestamp: Date.now(),
        finished: false
    };
    
    // Save to localStorage
    let goals = JSON.parse(localStorage.getItem('goals')) || [];
    goals.push(goal);
    localStorage.setItem('goals', JSON.stringify(goals));
    
    // Reset form
    document.getElementById(`goal-form-${problemId}`).reset();
    
    // Reset star rating
    const starRating = document.getElementById(`goal-difficulty-rating-${problemId}`);
    if (starRating) {
        const stars = starRating.querySelectorAll('.star');
        stars.forEach(star => star.classList.remove('selected'));
        document.getElementById(`goal-difficulty-${problemId}`).value = '';
        const descriptionElement = document.getElementById(`goal-description-${problemId}`);
        if (descriptionElement) {
            descriptionElement.textContent = '';
            descriptionElement.classList.remove('active');
        }
    }
    
    // Update UI
    renderGoals();
    updateStats();
    updateCounts();
    
    // Add object to 3D scene
    addGoalObject(goal);
    
    // Open the goals section
    const goalsSection = document.querySelector('#section-goals .section-content');
    const goalsArrow = document.querySelector('#section-goals .toggle-arrow');
    if (!goalsSection.classList.contains('active')) {
        goalsSection.classList.add('active');
        goalsArrow.classList.add('open');
    }

    // Check achievements
    checkAchievements();
}

        // Render goals list with updated UI
        function renderGoals() {
            const goals = JSON.parse(localStorage.getItem('goals')) || [];
            const goalsList = document.getElementById('goals-list');
            
            goalsList.innerHTML = '';
            
            if (goals.length === 0) {
                goalsList.innerHTML = '<p style="padding: 10px;">No goals added yet. Create goals from your problems list.</p>';
                return;
            }
            
            // Filter goals based on finished status
            const filteredGoals = showFinishedGoals 
                ? goals 
                : goals.filter(g => !g.finished);
            
            if (filteredGoals.length === 0) {
                goalsList.innerHTML = '<p style="padding: 10px;">No ' + (showFinishedGoals ? 'finished' : 'active') + ' goals found.</p>';
                return;
            }
            
            filteredGoals.forEach(goal => {
                const listItem = document.createElement('div');
                listItem.className = 'list-item';
       
                
                listItem.innerHTML = `
                    <div class="list-item-title">
          <span>
    <span class="custom-checkbox ${goal.finished ? 'checked' : ''}" data-goal-id="${goal.id}"></span>
    <span class="${goal.finished ? 'task-complete-text' : ''}">${goal.goalInput}</span>
</span>
                        <div>
                            ${goal.finished ? `<i class="fas fa-trash" onclick="deleteGoal('${goal.id}');" style="cursor: pointer; margin-right: 10px;"></i>` : ''}
                            <i class="fas fa-chevron-down toggle-arrow"></i>
                        </div>
                    </div>
                    <div class="list-item-meta">
                        <div class="meta-item"><i class="fas fa-folder"></i> ${goal.goalArea}</div>
                        <div class="meta-item"><i class="fas fa-heart"></i> ${goal.goalEmotion}</div>
                        <div class="meta-item"><i class="fas fa-star"></i> Difficulty: ${goal.goalDifficulty}</div>
                        ${goal.finished ? '<div class="meta-item"><i class="fas fa-check-circle"></i> Finished</div>' : ''}
                    </div>
                    <div class="list-item-content">
                        ${!goal.finished ? `
                        <form id="task-form-${goal.id}">
                            <label>
                                Task:
                                <input type="text" id="task-input-${goal.id}" placeholder="Create a task to achieve this goal">
                            </label>
                            <div class="item-actions">
                                <button type="button" class="btn-add action-btn" onclick="addTask('${goal.id}')">Add Task</button>
                            </div>
                        </form>
                        ` : ''}
                    </div>
                `;
                
                // Add checkbox event listener
                const checkbox = listItem.querySelector(`.custom-checkbox[data-goal-id="${goal.id}"]`);
                if (checkbox) {
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        toggleGoalStatus(goal.id);
                    });
                }
                
                // Toggle content visibility
                const title = listItem.querySelector('.list-item-title');
                title.addEventListener('click', function(e) {
                    // Don't toggle if clicking on the checkbox or trash icon
                    if (e.target.classList.contains('custom-checkbox') || 
                        e.target.closest('.custom-checkbox') ||
                        e.target.classList.contains('fa-trash')) return;
                    
                    const content = this.parentElement.querySelector('.list-item-content');
                    const arrow = this.querySelector('.toggle-arrow');
                    content.classList.toggle('active');
                    
                    if (content.classList.contains('active')) {
                        arrow.classList.remove('fa-chevron-down');
                        arrow.classList.add('fa-chevron-up');
                    } else {
                        arrow.classList.remove('fa-chevron-up');
                        arrow.classList.add('fa-chevron-down');
                    }
                });
                
                goalsList.appendChild(listItem);
            });
        }

        // Add a new task
        // Add a new task
function addTask(goalId) {
    const taskInput = document.getElementById(`task-input-${goalId}`).value.trim();
    
    if (!taskInput) {
        showToast("Validation Error", "Please enter a task description.", "error");
        return;
    }
    
    // Get the goal details
    const goals = JSON.parse(localStorage.getItem('goals')) || [];
    const goal = goals.find(g => g.id === goalId);
    
    if (!goal) {
        showToast("Error", "Goal not found. Please try again.", "error");
        return;
    }
    
    // Show toast notification immediately after validation passes
    showToast("Task Added", "Breaking goals into manageable steps leads to success.", "success");
    
    const task = {
        id: Date.now().toString(),
        taskInput,
        relatedGoalId: goalId,
        relatedGoal: goal.goalInput,
        goalArea: goal.goalArea,
        materialsInput: '',
        cooperationInput: '',
        knowledgeInput: '',
        timestamp: Date.now(),
        completed: false
    };
    
    // Save to localStorage
    let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    tasks.push(task);
    localStorage.setItem('tasks', JSON.stringify(tasks));
    
    // Reset form
    document.getElementById(`task-input-${goalId}`).value = '';
    
    // Update UI
    renderTasks();
    updateStats();
    updateCounts();
    
    // Add object to 3D scene
    addTaskObject(task, goal);
    
    // Open the tasks section
    const tasksSection = document.querySelector('#section-tasks .section-content');
    const tasksArrow = document.querySelector('#section-tasks .toggle-arrow');
    if (!tasksSection.classList.contains('active')) {
        tasksSection.classList.add('active');
        tasksArrow.classList.add('open');
    }

    // Check achievements
    checkAchievements();
}

        // Render tasks list
        function renderTasks() {
            const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            
            // Filter tasks based on completion status and toggle setting
            const filteredTasks = showFinishedTasks 
                ? tasks 
                : tasks.filter(task => !task.completed);
            
            renderTasksList(filteredTasks);
        }

        // Render tasks list with sorting and fixed checkbox functionality
        function renderTasksList(tasks) {
            const tasksList = document.getElementById('tasks-list');
            
            tasksList.innerHTML = '';
            
            if (tasks.length === 0) {
                tasksList.innerHTML = '<p style="padding: 10px;">No ' + (showFinishedTasks ? 'finished' : 'active') + ' tasks found.</p>';
                return;
            }
            
            // Add button for creating standalone tasks
            const buttonsDiv = document.createElement('div');
            buttonsDiv.style.display = 'flex';
            buttonsDiv.style.justifyContent = 'space-between';
            buttonsDiv.style.alignItems = 'center';
            buttonsDiv.style.marginBottom = '15px';
            
            const addTaskButton = document.createElement('button');
            addTaskButton.id = 'add-standalone-task-btn';
            addTaskButton.className = 'btn-add';
            addTaskButton.textContent = 'Create New Task';
            addTaskButton.onclick = openTaskDialog;
            
            buttonsDiv.appendChild(addTaskButton);
            tasksList.appendChild(buttonsDiv);
            
            // Create list container
            const listContainer = document.createElement('div');
            listContainer.className = 'list-container';
            tasksList.appendChild(listContainer);
            
            // Get all goals for reference
            const goals = JSON.parse(localStorage.getItem('goals')) || [];
            const goalMap = new Map(goals.map(g => [g.id, g]));
            
            tasks.forEach(task => {
                // Get the related goal if it exists
                const relatedGoal = goalMap.get(task.relatedGoalId);
                const goalInfo = relatedGoal 
                    ? `<div class="meta-item"><i class="fas fa-bullseye"></i> Goal: ${task.relatedGoal}</div>`
                    : `<div class="meta-item"><i class="fas fa-info-circle"></i> Standalone task</div>`;
                
                const listItem = document.createElement('div');
                listItem.className = 'list-item';
                
                
                listItem.innerHTML = `
                    <div class="list-item-title">
                        <span>
    <span class="custom-checkbox ${task.completed ? 'checked' : ''}" data-task-id="${task.id}"></span>
    <span class="${task.completed ? 'task-complete-text' : ''}">${task.taskInput}</span>
</span>
                        <div>
                            ${task.completed ? `<i class="fas fa-trash" onclick="deleteTask('${task.id}');" style="cursor: pointer; margin-right: 10px;"></i>` : ''}
                            <i class="fas fa-chevron-down toggle-arrow"></i>
                        </div>
                    </div>
                    <div class="list-item-meta">
                        <div class="meta-item"><i class="fas fa-folder"></i> ${task.goalArea || 'Uncategorized'}</div>
                        ${goalInfo}
                        ${task.completed ? '<div class="meta-item"><i class="fas fa-check-circle"></i> Completed</div>' : ''}
                    </div>
                    <div class="list-item-content">
                        <form id="task-details-form-${task.id}">
                            <label>
                                Materials Needed:
                                <textarea id="materials-input-${task.id}" placeholder="List materials needed for this task">${task.materialsInput || ''}</textarea>
                            </label>
                            <label>
                                Cooperation Needed:
                                <textarea id="cooperation-input-${task.id}" placeholder="List people or organizations whose cooperation you need">${task.cooperationInput || ''}</textarea>
                            </label>
                            <label>
                                Knowledge Required:
                                <textarea id="knowledge-input-${task.id}" placeholder="List skills or knowledge you need to acquire">${task.knowledgeInput || ''}</textarea>
                            </label>
                            <div class="item-actions">
                                <button type="button" class="btn-add action-btn" onclick="saveTask('${task.id}')">Save Details</button>
                                <button type="button" class="btn-calendar action-btn" onclick="addToCalendar('${task.id}')">
                                    <i class="fas fa-calendar"></i> Add to Calendar
                                </button>
                            </div>
                        </form>
                    </div>
                `;
                
                listContainer.appendChild(listItem);
                
                // Add specific event listener for the checkbox
                const checkbox = listItem.querySelector(`.custom-checkbox[data-task-id="${task.id}"]`);
                if (checkbox) {
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        toggleTaskComplete(task.id);
                    });
                }
                
                // Toggle content visibility
                const title = listItem.querySelector('.list-item-title');
                title.addEventListener('click', function(e) {
                    // Don't toggle if clicking on the checkbox or trash icon
                    if (e.target.classList.contains('custom-checkbox') || 
                        e.target.closest('.custom-checkbox') ||
                        e.target.classList.contains('fa-trash')) return;
                    
                    const content = this.parentElement.querySelector('.list-item-content');
                    const arrow = this.querySelector('.toggle-arrow');
                    content.classList.toggle('active');
                    
                    if (content.classList.contains('active')) {
                        arrow.classList.remove('fa-chevron-down');
                        arrow.classList.add('fa-chevron-up');
                    } else {
                        arrow.classList.remove('fa-chevron-up');
                        arrow.classList.add('fa-chevron-down');
                    }
                });
            });
        }

       // Toggle task completion
function toggleTaskComplete(taskId) {
    // Update task in localStorage
    let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    const taskIndex = tasks.findIndex(t => t.id === taskId);
    
    if (taskIndex !== -1) {
        const wasCompleted = tasks[taskIndex].completed;
        tasks[taskIndex].completed = !wasCompleted;
        
        // Show toast notification before updating localStorage
        if (!wasCompleted) {
            showToast("Task Completed", "Small victories build great achievements.", "success");
        } else {
            showToast("Task Reopened", "Progress isn't always linear.", "info");
        }
        
        // Update localStorage
        localStorage.setItem('tasks', JSON.stringify(tasks));
        
        // Update UI
        renderTasks();
        updateStats();
        updateCounts();
        
        // Update 3D visualization
        updateTaskObject(tasks[taskIndex]);
        
        // If marking as complete, show dialog
        if (!wasCompleted) {
            openDialog();
        }

        // Check achievements
        checkAchievements();
    }
}

    // Save task details
function saveTask(taskId) {
    const materialsInput = document.getElementById(`materials-input-${taskId}`).value;
    const cooperationInput = document.getElementById(`cooperation-input-${taskId}`).value;
    const knowledgeInput = document.getElementById(`knowledge-input-${taskId}`).value;
    
    // Show toast notification first
    showToast("Task Saved", "Your task details have been saved successfully.", "success");
    
    // Update task in localStorage
    let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    const taskIndex = tasks.findIndex(t => t.id === taskId);
    
    if (taskIndex !== -1) {
        tasks[taskIndex].materialsInput = materialsInput;
        tasks[taskIndex].cooperationInput = cooperationInput;
        tasks[taskIndex].knowledgeInput = knowledgeInput;
        
        localStorage.setItem('tasks', JSON.stringify(tasks));
    }
}

   // Delete task
function deleteTask(taskId) {
    // Remove task from localStorage
    let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    const taskToDelete = tasks.find(t => t.id === taskId);
    tasks = tasks.filter(t => t.id !== taskId);
    
    // Show toast notification before updating localStorage
    showToast("Task Removed", "Focus on what matters most right now.", "info");
    
    // Update localStorage
    localStorage.setItem('tasks', JSON.stringify(tasks));
    
    // Update UI
    renderTasks();
    updateStats();
    updateCounts();
    
    // Remove object from 3D scene
    if (taskToDelete) {
        removeTaskObject(taskToDelete);
    }

    // Check achievements
    checkAchievements();
}

 // Delete goal
function deleteGoal(goalId) {
    // Remove goal from localStorage
    let goals = JSON.parse(localStorage.getItem('goals')) || [];
    const goalToDelete = goals.find(g => g.id === goalId);
    goals = goals.filter(g => g.id !== goalId);
    
    // Show toast notification before updating localStorage
    showToast("Goal Removed", "Adjusting priorities is part of the process.", "info");
    
    // Update localStorage
    localStorage.setItem('goals', JSON.stringify(goals));
    
    // Update UI
    renderGoals();
    renderTasks(); // Re-render tasks to update any related goal references
    updateStats();
    updateCounts();
    
    // Remove object from 3D scene
    if (goalToDelete) {
        removeGoalObject(goalToDelete);
    }

    // Check achievements
    checkAchievements();
}

        // Delete problem
        // Delete problem
function deleteProblem(problemId) {
    // Remove problem from localStorage
    let problems = JSON.parse(localStorage.getItem('problems')) || [];
    const problemToDelete = problems.find(p => p.id === problemId);
    problems = problems.filter(p => p.id !== problemId);
    
    // Show toast notification before updating localStorage
    showToast("Problem Removed", "Simplifying your focus can help progress.", "info");
    
    // Update localStorage
    localStorage.setItem('problems', JSON.stringify(problems));
    
    // Update UI
    renderProblems();
    updateStats();
    updateCounts();
    
    // Remove object from 3D scene
    if (problemToDelete) {
        removeProblemObject(problemToDelete);
    }

    // Check achievements
    checkAchievements();
}

        // Add to Google Calendar
        function addToCalendar(taskId) {
            // Get the task details
            const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            const task = tasks.find(t => t.id === taskId);
            
            if (!task) {
                showToast("Error", "Task not found. Please try again.", "error");
                return;
            }
            
            const taskName = encodeURIComponent(task.taskInput);
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(today.getDate() + 1);
            
            // Format dates for Google Calendar
            const startDate = formatDateForCalendar(tomorrow);
            const endDate = formatDateForCalendar(tomorrow, 1); // 1 hour later
            
            // Build Google Calendar URL
            const calendarUrl = `https://www.google.com/calendar/render?action=TEMPLATE&text=${taskName}&dates=${startDate}/${endDate}`;
            
            // Open calendar in new tab
            window.open(calendarUrl, '_blank');
            
            // Show message
            showToast("Calendar Event", "Task has been added to your calendar.", "success");
        }

        // Format date for Google Calendar (YYYYMMDDTHHMMSSZ)
        function formatDateForCalendar(date, hoursToAdd = 0) {
            const d = new Date(date);
            if (hoursToAdd) d.setHours(d.getHours() + hoursToAdd);
            
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            const hours = String(d.getHours()).padStart(2, '0');
            const minutes = String(d.getMinutes()).padStart(2, '0');
            
            return `${year}${month}${day}T${hours}${minutes}00`;
        }

        // Sort tasks with toggle for ascending/descending
        function sortTasks(criteria) {
            let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            const sortDirection = localStorage.getItem(`sort-tasks-${criteria}`) === 'desc' ? 'asc' : 'desc';
            localStorage.setItem(`sort-tasks-${criteria}`, sortDirection);
            
 switch(criteria) {
                case 'recent':
                    tasks.sort((a, b) => sortDirection === 'desc' ? b.timestamp - a.timestamp : a.timestamp - b.timestamp);
                    break;
                case 'area':
                    tasks.sort((a, b) => {
                        const areaA = a.goalArea || '';
                        const areaB = b.goalArea || '';
                        return sortDirection === 'desc' ? areaB.localeCompare(areaA) : areaA.localeCompare(areaB);
                    });
                    break;
            }
            
            localStorage.setItem('tasks', JSON.stringify(tasks));
            renderTasks();
            
            // Update active button
            document.querySelectorAll('#tasks-list .sort-controls button').forEach(button => {
                if (button.id !== 'toggle-finished-tasks') {
                    button.classList.remove('active');
                }
            });
            document.querySelector(`#tasks-list .sort-controls button[onclick="sortTasks('${criteria}')"]`).classList.add('active');
        }

        // Sort problems with toggle for ascending/descending
        function sortProblems(criteria) {
            let problems = JSON.parse(localStorage.getItem('problems')) || [];
            const sortDirection = localStorage.getItem(`sort-problems-${criteria}`) === 'desc' ? 'asc' : 'desc';
            localStorage.setItem(`sort-problems-${criteria}`, sortDirection);
            
            switch(criteria) {
                case 'recent':
                    problems.sort((a, b) => sortDirection === 'desc' ? b.timestamp - a.timestamp : a.timestamp - b.timestamp);
                    break;
                case 'area':
                    problems.sort((a, b) => sortDirection === 'desc' ? b.problemArea.localeCompare(a.problemArea) : a.problemArea.localeCompare(b.problemArea));
                    break;
                case 'emotion':
                    problems.sort((a, b) => sortDirection === 'desc' ? b.problemEmotion.localeCompare(a.problemEmotion) : a.problemEmotion.localeCompare(b.problemEmotion));
                    break;
                case 'difficulty':
                    problems.sort((a, b) => sortDirection === 'desc' ? Number(b.problemDifficulty) - Number(a.problemDifficulty) : Number(a.problemDifficulty) - Number(b.problemDifficulty));
                    break;
            }
            
            localStorage.setItem('problems', JSON.stringify(problems));
            renderProblems();
            
            // Update active button
            document.querySelectorAll('#section-problems .sort-controls button').forEach(button => {
                if (button.id !== 'toggle-finished-problems') {
                    button.classList.remove('active');
                }
            });
            document.querySelector(`#section-problems .sort-controls button[onclick="sortProblems('${criteria}')"]`).classList.add('active');
        }

        // Sort goals with toggle for ascending/descending
        function sortGoals(criteria) {
            let goals = JSON.parse(localStorage.getItem('goals')) || [];
            const sortDirection = localStorage.getItem(`sort-goals-${criteria}`) === 'desc' ? 'asc' : 'desc';
            localStorage.setItem(`sort-goals-${criteria}`, sortDirection);
            
            switch(criteria) {
                case 'recent':
                    goals.sort((a, b) => sortDirection === 'desc' ? b.timestamp - a.timestamp : a.timestamp - b.timestamp);
                    break;
                case 'area':
                    goals.sort((a, b) => sortDirection === 'desc' ? b.goalArea.localeCompare(a.goalArea) : a.goalArea.localeCompare(b.goalArea));
                    break;
                case 'emotion':
                    goals.sort((a, b) => sortDirection === 'desc' ? b.goalEmotion.localeCompare(a.goalEmotion) : a.goalEmotion.localeCompare(b.goalEmotion));
                    break;
                case 'difficulty':
                    goals.sort((a, b) => sortDirection === 'desc' ? Number(b.goalDifficulty) - Number(a.goalDifficulty) : Number(a.goalDifficulty) - Number(b.goalDifficulty));
                    break;
            }
            
            localStorage.setItem('goals', JSON.stringify(goals));
            renderGoals();
            
            // Update active button
            document.querySelectorAll('#section-goals .sort-controls button').forEach(button => {
                if (button.id !== 'toggle-finished-goals') {
                    button.classList.remove('active');
                }
            });
            document.querySelector(`#section-goals .sort-controls button[onclick="sortGoals('${criteria}')"]`).classList.add('active');
        }

        // Update statistics and charts
        function updateStats() {
            const problems = JSON.parse(localStorage.getItem('problems')) || [];
            const goals = JSON.parse(localStorage.getItem('goals')) || [];
            const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            const completedTasks = tasks.filter(task => task.completed);

            // Update progress bar
            let progress = 0;
            if (tasks.length > 0) {
                progress = (completedTasks.length / tasks.length) * 100;
            }
            document.getElementById('progress-bar').style.width = `${progress}%`;

            // Update only the necessary charts
            updateProblemAreaChart(problems);
            updateProblemEmotionChart(problems);
            updateGoalAreaChart(goals);
            updateGoalEmotionChart(goals);
        }

        // Update count badges
        function updateCounts() {
            const problems = JSON.parse(localStorage.getItem('problems')) || [];
            const goals = JSON.parse(localStorage.getItem('goals')) || [];
            const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
            
            const activeProblems = problems.filter(p => !p.finished);
            const activeGoals = goals.filter(g => !g.finished);
            const activeTasks = tasks.filter(t => !t.completed);

            document.getElementById('problems-count').textContent = activeProblems.length;
            document.getElementById('goals-count').textContent = activeGoals.length;
            document.getElementById('tasks-count').textContent = activeTasks.length;

            // Count unlocked achievements
            const unlockedCount = Object.values(achievements).filter(a => a.unlocked).length;
            document.getElementById('achievements-count').textContent = unlockedCount;
        }

        // Chart update functions
function updateProblemAreaChart(problems) {
    const canvas = document.getElementById('chart-problems-area');
    const ctx = canvas?.getContext('2d');
    if (!ctx) return;

    // Destroy existing chart if it exists
    if (window.problemAreaChart) {
        window.problemAreaChart.destroy();
    }

    const areaData = countByProperty(problems, 'problemArea');

    window.problemAreaChart = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: Object.keys(areaData),
            datasets: [{
                data: Object.values(areaData),
                backgroundColor: getRandomColors(Object.keys(areaData).length)
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        color: isDarkTheme ? '#e8f0f7' : '#472d0f'
                    }
                }
            }
        }
    });
}

function updateProblemEmotionChart(problems) {
    const canvas = document.getElementById('chart-problems-emotion');
    const ctx = canvas?.getContext('2d');
    if (!ctx) return;

    // Destroy existing chart if it exists
    if (window.problemEmotionChart) {
        window.problemEmotionChart.destroy();
    }

    const emotionData = countByProperty(problems, 'problemEmotion');

    window.problemEmotionChart = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: Object.keys(emotionData),
            datasets: [{
                data: Object.values(emotionData),
                backgroundColor: Object.keys(emotionData).map(emotion => {
                    const color = emotionColors[emotion] || getRandomColor();
                    return colorToRgba(color, 0.8);
                })
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        color: isDarkTheme ? '#e8f0f7' : '#472d0f'
                    }
                }
            }
        }
    });
}

function updateGoalAreaChart(goals) {
    const canvas = document.getElementById('chart-goals-area');
    const ctx = canvas?.getContext('2d');
    if (!ctx) return;

    // Destroy existing chart if it exists
    if (window.goalAreaChart) {
        window.goalAreaChart.destroy();
    }

    const areaData = countByProperty(goals, 'goalArea');

    window.goalAreaChart = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: Object.keys(areaData),
            datasets: [{
                data: Object.values(areaData),
                backgroundColor: getRandomColors(Object.keys(areaData).length)
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        color: isDarkTheme ? '#e8f0f7' : '#472d0f'
                    }
                }
            }
        }
    });
}

function updateGoalEmotionChart(goals) {
    const canvas = document.getElementById('chart-goals-emotion');
    const ctx = canvas?.getContext('2d');
    if (!ctx) return;

    // Destroy existing chart if it exists
    if (window.goalEmotionChart) {
        window.goalEmotionChart.destroy();
    }

    const emotionData = countByProperty(goals, 'goalEmotion');

    window.goalEmotionChart = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: Object.keys(emotionData),
            datasets: [{
                data: Object.values(emotionData),
                backgroundColor: Object.keys(emotionData).map(emotion => {
                    const color = goalEmotionColors[emotion] || getRandomColor();
                    return colorToRgba(color, 0.8);
                })
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        color: isDarkTheme ? '#e8f0f7' : '#472d0f'
                    }
                }
            }
        }
    });
}

        // Helper function to count items by property
        function countByProperty(array, property) {
            return array.reduce((acc, item) => {
                const key = item[property];
                if (!acc[key]) {
                    acc[key] = 0;
                }
                acc[key]++;
                return acc;
            }, {});
        }

        // Helper functions for colors
        function getRandomColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                colors.push(getRandomColor(0.8));
            }
            return colors;
        }

        function getRandomColor(alpha = 0.8) {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getColorWithOpacity(index, alpha = 0.8) {
            const colors = [
                `rgba(92, 198, 97, ${alpha})`,   // Green
                `rgba(79, 129, 189, ${alpha})`,  // Blue
                `rgba(192, 80, 77, ${alpha})`,   // Red
                `rgba(155, 87, 188, ${alpha})`,  // Purple
                `rgba(247, 150, 70, ${alpha})`   // Orange
            ];
            return colors[(index - 1) % colors.length];
        }

        function colorToRgba(hex, alpha = 1) {
            // Convert hex color to rgb
            let r, g, b;
            if (typeof hex === 'number') {
                r = (hex >> 16) & 255;
                g = (hex >> 8) & 255;
                b = hex & 255;
            } else {
                // If hex is a string like "#ff0000"
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                if (result) {
                    r = parseInt(result[1], 16);
                    g = parseInt(result[2], 16);
                    b = parseInt(result[3], 16);
                } else {
                    // Default to white if invalid hex
                    r = g = b = 255;
                }
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Enhanced Three.js visualization
        function initThreeJS() {
            const canvas = document.getElementById('background-canvas');

            // Create renderer with antialias
            renderer = new THREE.WebGLRenderer({
                canvas,
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance

            // Create scene
            scene = new THREE.Scene();

            // Create camera with better positioning
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 20;
            camera.position.y = 5;

            // Initialize object containers
            goalObjects = {};
            problemObjects = {};
            taskObjects = {};

            // Add visualization elements based on theme
            if (isDarkTheme) {
                initEnhancedDarkTheme();
            } else {
                initLightTheme();
            }

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Start animation loop
            animate();

            // Load all visualization objects from localStorage
            loadVisualizationObjects();
        }

        function resetThreeJS() {
            // Cancel animation frame
            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            // Clear scene
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }

            // Reset object containers
            goalObjects = {};
            problemObjects = {};
            taskObjects = {};

            // Add visualization elements based on theme
            if (isDarkTheme) {
                initEnhancedDarkTheme();
            } else {
                initLightTheme();
            }

            // Load all objects from localStorage
            loadVisualizationObjects();

            // Restart animation loop
            animate();
        }

        // Enhanced dark theme with space visualization
        function initEnhancedDarkTheme() {
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x111133, 0.3);
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xccddff, 0.8);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            // Add point light (sun effect)
            const sunLight = new THREE.PointLight(0xe0c8a0, 1, 100);
            sunLight.position.set(-10, 5, -10);
            scene.add(sunLight);

            // Add galaxy center with glow
            createGalaxyCenter();

            // Add star field
            createStarField();

            // Add nebula clouds
            createNebulaClouds();

            // Add distant stars
            addDistantStars();
        }

        // Create galaxy center with glow effect
        function createGalaxyCenter() {
            // Central bright core
            const coreGeometry = new THREE.SphereGeometry(2, 32, 32);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffeecc,
                transparent: true,
                opacity: 0.7
            });
            galaxyCenter = new THREE.Mesh(coreGeometry, coreMaterial);
            galaxyCenter.position.set(-30, 5, -50);
            scene.add(galaxyCenter);

            // Add surrounding dust
            const particleCount = 2000;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            const galaxyRadius = 10;
            const galaxyThickness = 3;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Position in polar coordinates for galaxy disc
                const radius = Math.random() * galaxyRadius;
                const theta = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * galaxyThickness * (1 - radius / galaxyRadius);
                
                // Convert to cartesian
                positions[i3] = galaxyCenter.position.x + radius * Math.cos(theta);
                positions[i3 + 1] = galaxyCenter.position.y + height;
                positions[i3 + 2] = galaxyCenter.position.z + radius * Math.sin(theta);
                
                // Color based on distance from center (yellowish near center, bluish far away)
                const distanceRatio = radius / galaxyRadius;
                colors[i3] = 0.9 - (distanceRatio * 0.5);      // R: more near center
                colors[i3 + 1] = 0.6 - (distanceRatio * 0.3);  // G: more near center
                colors[i3 + 2] = 0.3 + (distanceRatio * 0.7);  // B: more at edges
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const galaxyParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(galaxyParticles);
        }

        // Create star field of tiny bright points
        function createStarField() {
            const starCount = 3000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            const colors = new Float32Array(starCount * 3);

            // Star positions in a spherical volume around camera
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                
                // Random position in a sphere
                const radius = 100 + Math.random() * 900; // Stars between 100 and 1000 units away
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
                
                // Random size
                sizes[i] = 0.5 + Math.random() * 1.5;
                
                // Slightly random color (white with tint)
                colors[i3] = 0.8 + Math.random() * 0.2;           // R
                colors[i3 + 1] = 0.8 + Math.random() * 0.2;       // G
                colors[i3 + 2] = 0.8 + Math.random() * 0.2;       // B
                
                // Some stars with color tint
                if (Math.random() < 0.1) {
                    // Blue tint
                    colors[i3] *= 0.5;
                    colors[i3 + 1] *= 0.7;
                } else if (Math.random() < 0.1) {
                    // Red/orange tint
                    colors[i3 + 1] *= 0.7;
                    colors[i3 + 2] *= 0.5;
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const starTexture = createStarTexture();

            const material = new THREE.PointsMaterial({
                size: 0.1,
                map: starTexture,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const starField = new THREE.Points(geometry, material);
            scene.add(starField);

            // Save info for animation
            stars = Array(starCount).fill().map((_, i) => ({
                index: i,
                twinkleSpeed: 0.001 + Math.random() * 0.02,
                twinkleAmount: Math.random() * 0.3
            }));
        }

        // Create a texture for star points
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 32;
            canvas.height = 32;

            // Draw a simple radial gradient for the star
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            return texture;
        }

        // Create colorful nebula clouds
        function createNebulaClouds() {
            // Create 3-5 nebula clouds
            const nebulaCount = 3 + Math.floor(Math.random() * 3);

            for (let i = 0; i < nebulaCount; i++) {
                createNebula(i);
            }
        }

        // Create a single nebula cloud
        function createNebula(index) {
            // Nebula colors
            const nebulaColors = [
                [0xff9999, 0x9999ff], // Red-Blue
                [0x99ffcc, 0x9999ff], // Teal-Blue
                [0xffcc99, 0xff99cc], // Orange-Pink
                [0xff99ff, 0x9999ff], // Pink-Purple
                [0x99ccff, 0x99ffff]  // Blue-Cyan
            ];

            // Select a color pair for this nebula
            const colorPair = nebulaColors[index % nebulaColors.length];

            // Create particle geometry
            const particleCount = 300 + Math.floor(Math.random() * 200);
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            // Position this nebula randomly in space
            const nebulaCenter = new THREE.Vector3(
                -50 + Math.random() * 100,
                -30 + Math.random() * 60,
                -100 - Math.random() * 100
            );

            // Make sure the nebula isn't too close to the galaxy center
            if (galaxyCenter && nebulaCenter.distanceTo(galaxyCenter.position) < 40) {
                nebulaCenter.x += 60 * (Math.random() < 0.5 ? -1 : 1);
                nebulaCenter.z -= 50;
            }

            const nebulaSize = 20 + Math.random() * 30;

            // Generate particles in a cloud shape
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Use a spherical distribution with random variations
                const radius = (0.2 + Math.random() * 0.8) * nebulaSize;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                // Basic spherical position
                let x = radius * Math.sin(phi) * Math.cos(theta);
                let y = radius * Math.sin(phi) * Math.sin(theta);
                let z = radius * Math.cos(phi);
                
                // Add some distortion for a cloud-like appearance
                x += (Math.random() - 0.5) * nebulaSize * 0.3;
                y += (Math.random() - 0.5) * nebulaSize * 0.3;
                z += (Math.random() - 0.5) * nebulaSize * 0.3;
                
                // Set position relative to nebula center
                positions[i3] = nebulaCenter.x + x;
                positions[i3 + 1] = nebulaCenter.y + y;
                positions[i3 + 2] = nebulaCenter.z + z;
                
                // Interpolate between the two colors based on position
                const distanceRatio = Math.sqrt(x*x + y*y + z*z) / nebulaSize;
                const color1 = new THREE.Color(colorPair[0]);
                const color2 = new THREE.Color(colorPair[1]);
                const finalColor = new THREE.Color().lerpColors(color1, color2, distanceRatio);
                
                colors[i3] = finalColor.r;
                colors[i3 + 1] = finalColor.g;
                colors[i3 + 2] = finalColor.b;
                
                // Random size for each particle
                sizes[i] = 2 + Math.random() * 3;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // Create a soft, glowing particle texture
            const particleTexture = createNebulaParticleTexture();

            const material = new THREE.PointsMaterial({
                size: 1.5,
                map: particleTexture,
                transparent: true,
                vertexColors: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            const nebula = new THREE.Points(geometry, material);
            scene.add(nebula);

            // Store for animation
            nebulas.push({
                mesh: nebula,
                center: nebulaCenter,
                rotationSpeed: (Math.random() - 0.5) * 0.0005,
                pulseSpeed: 0.0005 + Math.random() * 0.001,
                originalPositions: positions.slice()
            });
        }

        // Create a texture for nebula particles
        function createNebulaParticleTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;

            // Draw a soft circular gradient for each particle
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            return texture;
        }

        // Add distant stars as a backdrop
        function addDistantStars() {
            // Create a large sphere with stars on the inside
            const geometry = new THREE.SphereGeometry(1500, 64, 64);
            const material = new THREE.MeshBasicMaterial({
                map: createDistantStarTexture(),
                side: THREE.BackSide,
                transparent: true,
                opacity: 0.7
            });

            const starSphere = new THREE.Mesh(geometry, material);
            scene.add(starSphere);
        }

        // Create a texture with tiny stars for the background
        function createDistantStarTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 2048;
            canvas.height = 2048;

            // Fill with dark blue-black
            ctx.fillStyle = '#020209';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add tiny white dots for stars
            const starCount = 10000;
            for (let i = 0; i < starCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() < 0.9 ? 1 : 1 + Math.random() * 2; // Most stars are dim
                
                const brightness = 0.5 + Math.random() * 0.5;
                const r = Math.floor(255 * brightness);
                const g = Math.floor(255 * brightness);
                const b = Math.floor(255 * brightness);
                
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.2 + Math.random() * 0.8})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            return texture;
        }

        // Create a shooting star effect
        function createShootingStar() {
            // Choose a random direction in the hemisphere facing the camera
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI / 2; // Keep in the upper hemisphere

            const startPoint = new THREE.Vector3(
                Math.sin(phi) * Math.cos(theta),
                Math.sin(phi) * Math.sin(theta),
                Math.cos(phi)
            ).multiplyScalar(100); // Start far away

            // End point is in same direction but closer
            const endPoint = startPoint.clone().multiplyScalar(0.5);

            // Create a line between these points
            const points = [startPoint, endPoint];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            // White line with glow
            const material = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                linewidth: 3 // Note: linewidth not supported on WebGL renderer
            });

            const shootingStar = new THREE.Line(geometry, material);
            scene.add(shootingStar);

            // Add a point light that travels with the shooting star
            const light = new THREE.PointLight(0xffffff, 2, 50);
            light.position.copy(startPoint);
            scene.add(light);

            // Add to array for animation
            shootingStars.push({
                line: shootingStar,
                light: light,
                start: startPoint.clone(),
                end: endPoint.clone(),
                startTime: Date.now(),
                duration: 1000 + Math.random() * 1000,
                spawnsParticles: Math.random() < 0.5 // Sometimes spawn particles
            });
        }

        // Initialize light theme with stained glass window design
        function initLightTheme() {
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x777777);
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Add stained glass background
            addStainedGlassBackground();
        }

        function addStainedGlassBackground() {
            // Create a simple colored background
            const geometry = new THREE.PlaneGeometry(50, 50);
            const material = new THREE.MeshBasicMaterial({
                color: 0xf0e6d2,
                transparent: true,
                opacity: 0.8
            });

            const background = new THREE.Mesh(geometry, material);
            background.position.z = -10;
            scene.add(background);

            // Add simple stained glass patterns
            for (let i = 0; i < 20; i++) {
                const size = 1 + Math.random() * 3;
                const patternGeometry = new THREE.PlaneGeometry(size, size);
                
                // Random color for each panel
                const hue = Math.random();
                const saturation = 0.5 + Math.random() * 0.5;
                const lightness = 0.4 + Math.random() * 0.4;
                
                const color = new THREE.Color();
                color.setHSL(hue, saturation, lightness);
                
                const patternMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.5 + Math.random() * 0.3
                });
                
                const pattern = new THREE.Mesh(patternGeometry, patternMaterial);
                
                // Random position
                pattern.position.x = -15 + Math.random() * 30;
                pattern.position.y = -15 + Math.random() * 30;
                pattern.position.z = -9.9 + Math.random() * 0.2;
                
                // Random rotation
                pattern.rotation.z = Math.random() * Math.PI * 2;
                
                scene.add(pattern);
            }

            // Add ivy vine trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.05, 0.1, 20, 8);
            const trunkMaterial = new THREE.MeshBasicMaterial({ color: 0x2d4a00 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);

            trunk.position.x = -5;
            trunk.position.y = 0;
            trunk.position.z = -9;
            trunk.rotation.z = Math.PI * 0.05;

            scene.add(trunk);

            // Add vine branches
            addVineBranch(trunk.position, 5, 8, 3);
            addVineBranch(trunk.position, -3, 5, 2);
            addVineBranch(trunk.position, 2, -4, 4);
        }

        function addVineBranch(startPos, offsetX, offsetY, segments) {
            const points = [];
            points.push(new THREE.Vector3(startPos.x, startPos.y, startPos.z));

            // Create curve points
            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                const x = startPos.x + offsetX * t + (Math.random() - 0.5) * 2 * t;
                const y = startPos.y + offsetY * t + (Math.random() - 0.5) * 2 * t;
                const z = startPos.z + (Math.random() - 0.5) * 0.5;
                
                points.push(new THREE.Vector3(x, y, z));
            }

            // Create a curve path
            const curve = new THREE.CatmullRomCurve3(points);

            // Create geometry from curve
            const branchGeometry = new THREE.TubeGeometry(curve, segments * 4, 0.05 - (segments * 0.01), 8, false);
            const branchMaterial = new THREE.MeshBasicMaterial({ color: 0x3a6100 });
            const branch = new THREE.Mesh(branchGeometry, branchMaterial);

            scene.add(branch);
        }

        function onWindowResize() {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Modify the animate function to reduce camera movement speed by 90%
   function animate() {
    animationId = requestAnimationFrame(animate);

    const elapsedTime = clock.getElapsedTime();

    if (isDarkTheme) {
        // Celestial motion - smooth orbital movement (reduced by 90%)
        camera.position.x = 20 * Math.sin(elapsedTime * 0.01); // Reduced from 0.1
        camera.position.y = 5 + 2 * Math.sin(elapsedTime * 0.005); // Reduced from 0.05
        camera.position.z = 20 * Math.cos(elapsedTime * 0.01); // Reduced from 0.1
        camera.lookAt(0, 0, 0);
        
        // Update nebula clouds - subtle pulsing and rotation
        nebulas.forEach(nebula => {
            nebula.mesh.rotation.y += nebula.rotationSpeed;
            
            // Subtle pulsing effect
            const scale = 1 + 0.05 * Math.sin(elapsedTime * nebula.pulseSpeed * 2);
            nebula.mesh.scale.set(scale, scale, scale);
        });
        
        // Update shooting stars
        shootingStars.forEach((star, index) => {
            const elapsed = Date.now() - star.startTime;
            const progress = Math.min(elapsed / star.duration, 1);
            
            if (progress < 1) {
                const pos = new THREE.Vector3().lerpVectors(star.start, star.end, progress);
                
                // Update the line
                const positions = star.line.geometry.attributes.position.array;
                positions[0] = pos.x;
                positions[1] = pos.y;
                positions[2] = pos.z;
                
                star.line.geometry.attributes.position.needsUpdate = true;
                
                // Update light position
                star.light.position.copy(pos);
            } else {
                // Remove the shooting star when done
                scene.remove(star.line);
                scene.remove(star.light);
                shootingStars.splice(index, 1);
            }
        });
        
        // Occasionally create a new shooting star
        if (Math.random() < 0.003) {
            createShootingStar();
        }
        
        // Animate problems (Saturn-like rings)
        Object.values(problemObjects).forEach(obj => {
            if (obj && obj.group) {
                obj.group.rotation.x += 0.002;
                obj.group.rotation.y += 0.001;
                
                // Add rotation to the planet if it exists
                if (obj.planet) {
                    obj.planet.rotation.y += 0.01;
                }
            }
        });
        
        // Animate goals (planets)
        Object.values(goalObjects).forEach(obj => {
            if (obj && obj.mesh) {
                // Rotate around its axis
                obj.mesh.rotation.y += 0.01;
                
                // Orbit around center
                if (obj.orbit) {
                    obj.orbit.rotation.y += 0.003;
                }
            }
        });
        
        // Animate tasks (moons)
        Object.values(taskObjects).forEach(obj => {
            if (obj && obj.mesh) {
                // Self-rotation
                obj.mesh.rotation.y += 0.02;
                
                // Orbit around its parent goal
                if (obj.orbit) {
                    obj.orbit.rotation.y += 0.01;
                    obj.orbit.rotation.x += 0.005;
                }
            }
        });
    } else {
        // Light theme animations
        // Use same camera movement pattern as dark theme for consistency
        camera.position.x = 20 * Math.sin(elapsedTime * 0.01);
        camera.position.y = 5 + 2 * Math.sin(elapsedTime * 0.005);
        camera.position.z = 20 * Math.cos(elapsedTime * 0.01);
        camera.lookAt(0, 0, 0);
        
        // Simulate gentle wind movement on leaves and flowers
        Object.values(goalObjects).forEach(obj => {
            if (obj && obj.mesh) {
                // Gentle swaying
                obj.mesh.rotation.z = Math.sin(Date.now() * 0.001 + obj.offset) * 0.05;
            }
        });
        
        Object.values(taskObjects).forEach(obj => {
            if (obj && obj.mesh) {
                // Gentle swaying
                obj.mesh.rotation.z = Math.sin(Date.now() * 0.002 + obj.offset) * 0.1;
            }
        });
        
        Object.values(problemObjects).forEach(obj => {
            if (obj && obj.mesh) {
                // Subtle movement
                obj.mesh.rotation.z = Math.sin(Date.now() * 0.0005 + obj.offset) * 0.03;
            }
        });
    }

    // Render scene
    renderer.render(scene, camera);
}

        // Load all visualization objects from localStorage
        function loadVisualizationObjects() {
            const problems = JSON.parse(localStorage.getItem('problems')) || [];
            const goals = JSON.parse(localStorage.getItem('goals')) || [];
            const tasks = JSON.parse(localStorage.getItem('tasks')) || [];

            // Add problems
            problems.forEach(problem => {
                addProblemObject(problem);
            });

            // Add goals
            goals.forEach(goal => {
                addGoalObject(goal);
            });

            // Add tasks (after goals are added)
            tasks.forEach(task => {
                const relatedGoal = goals.find(g => g.id === task.relatedGoalId);
                addTaskObject(task, relatedGoal);
            });
        }

        // Updated addProblemRing function to include a planet at the center
        function addProblemRing(problem) {
            // Create a group to hold rings and the central planet
            const group = new THREE.Group();

            // Determine ring color based on emotion
            const color = emotionColors[problem.problemEmotion] || 0xffffff;

            // Create a small planet at the center of the rings
            const planetRadius = 0.5 + Math.random() * 0.5; // Random size between 0.5 and 1.0
            const planetGeometry = new THREE.SphereGeometry(planetRadius, 32, 32);

            // Create a material for the planet with a color related to but different from the rings
            // Shift the color slightly to create a nice contrast
            const planetColor = new THREE.Color(color);
            planetColor.offsetHSL(0.1, 0, 0); // Slight color shift

            const planetMaterial = new THREE.MeshPhongMaterial({
                color: planetColor,
                shininess: 30,
                specular: 0x333333
            });

            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            group.add(planet);

            // Create multiple rings with different sizes
            const difficulty = parseInt(problem.problemDifficulty);
            const ringCount = difficulty;

            for (let i = 0; i < ringCount; i++) {
                const innerRadius = 1 + (i * 0.2);
                const outerRadius = innerRadius + 0.15;
                
                const ringGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7 - (i * 0.1)
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                
                // Tilt rings
                ring.rotation.x = Math.PI / 2;
                
                group.add(ring);
            }

            // Random position in the scene (avoiding the center)
            const distance = 10 + Math.random() * 15;
            const angle = Math.random() * Math.PI * 2;

            group.position.x = Math.cos(angle) * distance;
            group.position.y = (Math.random() - 0.5) * 10;
            group.position.z = Math.sin(angle) * distance;

            // Random rotation
            group.rotation.x = Math.random() * Math.PI;
            group.rotation.y = Math.random() * Math.PI;

            scene.add(group);

            // Store reference to the object
            problemObjects[problem.id] = { group, planet };
        }

        function addProblemLeaf(problem) {
            // Create a brown leaf shape
            const shape = new THREE.Shape();

            // Define a leaf shape
            shape.moveTo(0, 0);
            shape.bezierCurveTo(0.5, 0.5, 1, -0.5, 2, 0);
            shape.bezierCurveTo(1, 0.2, 0.5, 0.5, 0, 0);

            const geometry = new THREE.ShapeGeometry(shape);

            // Brown color with variation based on difficulty
            const difficulty = parseInt(problem.problemDifficulty);
            const color = new THREE.Color(0.4 - difficulty * 0.05, 0.2 - difficulty * 0.02, 0);

            const material = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide
            });

            const leaf = new THREE.Mesh(geometry, material);

            // Size based on difficulty
            const scale = 0.3 + (difficulty * 0.1);
            leaf.scale.set(scale, scale, scale);

            // Random position on the vine
            const x = -5 + (Math.random() - 0.5) * 6;
            const y = (Math.random() - 0.5) * 15;
            const z = -9 + (Math.random() - 0.5) * 0.5;

            leaf.position.set(x, y, z);

            // Random rotation
            leaf.rotation.z = Math.random() * Math.PI * 2;

            // Store random offset for animation
            const offset = Math.random() * Math.PI * 2;

            scene.add(leaf);

            // Store reference to the object
            problemObjects[problem.id] = { mesh: leaf, offset };
        }

        // Add problem object to 3D scene
        function addProblemObject(problem) {
            if (isDarkTheme) {
                // Create Saturn-like ring for dark theme
                addProblemRing(problem);
            } else {
                // Create brown leaf for light theme
                addProblemLeaf(problem);
            }
        }

        // Add goal object to 3D scene
        function addGoalObject(goal) {
            if (isDarkTheme) {
                // Create planet for dark theme
                addGoalPlanet(goal);
            } else {
                // Create flower for light theme
                addGoalFlower(goal);
            }
        }

        function addGoalPlanet(goal) {
            // Determine planet color based on emotion
            let color = goalEmotionColors[goal.goalEmotion] || 0x2196F3;

            // Create an orbit container
            const orbitGroup = new THREE.Group();
            scene.add(orbitGroup);

            // Planet size based on difficulty
            const difficulty = parseInt(goal.goalDifficulty);
            const radius = 0.3 + (difficulty * 0.1);

            // Create planet geometry
            const geometry = new THREE.SphereGeometry(radius, 32, 32);

            // Create planet material
            const material = new THREE.MeshPhongMaterial({
                color: color,
                shininess: 30,
                specular: 0x666666
            });

            const planet = new THREE.Mesh(geometry, material);

            // Position the planet in orbit
            const orbitRadius = 5 + (Math.random() * 3);
            const orbitAngle = Math.random() * Math.PI * 2;
            const orbitHeight = (Math.random() - 0.5) * 2;

            planet.position.x = Math.cos(orbitAngle) * orbitRadius;
            planet.position.y = orbitHeight;
            planet.position.z = Math.sin(orbitAngle) * orbitRadius;

            orbitGroup.add(planet);

            // Store reference to objects
            goalObjects[goal.id] = {
                mesh: planet,
                orbit: orbitGroup
            };
        }

        function addGoalFlower(goal) {
            // Determine flower color based on emotion
            let color;
            switch (goal.goalEmotion) {
                case 'Meaningful':
                    color = 0x4CAF50; // Green
                    break;
                case 'Neutral':
                    color = 0x2196F3; // Blue
                    break;
                case 'Difficult':
                    color = 0xF44336; // Red
                    break;
                default:
                    color = 0xE91E63; // Pink
            }

            // Create flower group
            const flowerGroup = new THREE.Group();

            // Create stem
            const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
            const stemMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = -0.25;
            flowerGroup.add(stem);

            // Create petals
            const difficulty = parseInt(goal.goalDifficulty);
            const petalCount = 5 + difficulty;
            const petalSize = 0.1 + (difficulty * 0.02);

            for (let i = 0; i < petalCount; i++) {
                const angle = (i / petalCount) * Math.PI * 2;
                
                const petalGeometry = new THREE.CircleGeometry(petalSize, 8);
                const petalMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide
                });
                
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                
                petal.position.x = Math.cos(angle) * petalSize;
                petal.position.z = Math.sin(angle) * petalSize;
                
                // Tilt petals outward
                petal.lookAt(petal.position.clone().multiplyScalar(2));
                
                flowerGroup.add(petal);
            }

            // Create center of flower
            const centerGeometry = new THREE.CircleGeometry(petalSize * 0.6, 16);
            const centerMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00, // Yellow center
                side: THREE.DoubleSide
            });

            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.rotation.x = -Math.PI / 2;
            flowerGroup.add(center);

            // Random position on the vine
            const x = -5 + (Math.random() - 0.5) * 6;
            const y = (Math.random() - 0.5) * 15;
            const z = -9 + (Math.random() - 0.5) * 0.5;

            flowerGroup.position.set(x, y, z);

            // Random rotation
            flowerGroup.rotation.z = Math.random() * Math.PI * 0.2;

            // Store random offset for animation
            const offset = Math.random() * Math.PI * 2;

            scene.add(flowerGroup);

            // Store reference to the object
            goalObjects[goal.id] = { mesh: flowerGroup, offset };
        }

        // Modified addTaskObject function to handle tasks with missing goals
        function addTaskObject(task, goal) {
            if (isDarkTheme) {
                if (goal) {
                    // If goal exists, create moon for dark theme
                    addTaskMoon(task, goal);
                } else {
                    // Create standalone task object
                    addTaskMoonStandalone(task);
                }
            } else {
                if (goal) {
                    // If goal exists, create leaf for light theme
                    addTaskLeaf(task, goal);
                } else {
                    // Create standalone task object
                    addTaskLeafStandalone(task);
                }
            }
        }

        function addTaskMoon(task, goal) {
            // Get parent goal object
            const goalObject = goalObjects[goal.id];

            if (!goalObject || !goalObject.mesh) return;

            // Create an orbit container for the moon
            const moonOrbit = new THREE.Group();

            // Position the orbit at the same position as the planet
            moonOrbit.position.copy(goalObject.mesh.position);

            // Add the orbit to the goal's orbit group
            if (goalObject.orbit) {
                goalObject.orbit.add(moonOrbit);
            } else {
                scene.add(moonOrbit);
            }

            // Create moon geometry (smaller than planets)
            const radius = 0.1 + Math.random() * 0.1;
            const geometry = new THREE.SphereGeometry(radius, 16, 16);

            // Color based on completion status
            const material = new THREE.MeshPhongMaterial({
                color: task.completed ? 0x00FF00 : 0xCCCCCC,
                shininess: 30
            });

            const moon = new THREE.Mesh(geometry, material);

            // Position the moon in orbit around the planet
            const orbitRadius = 0.8 + Math.random() * 0.5;
            const orbitAngle = Math.random() * Math.PI * 2;
            const orbitTilt = Math.random() * Math.PI * 0.1;

            moon.position.x = Math.cos(orbitAngle) * orbitRadius;
            moon.position.y = Math.sin(orbitTilt) * orbitRadius;
            moon.position.z = Math.sin(orbitAngle) * orbitRadius;

            moonOrbit.add(moon);

            // Store reference to objects
            taskObjects[task.id] = {
                mesh: moon,
                orbit: moonOrbit,
                parentGoalId: goal.id
            };
        }

        // Create standalone moon for tasks without goals
        function addTaskMoonStandalone(task) {
            // Create moon geometry (similar size to regular moons)
            const radius = 0.1 + Math.random() * 0.1;
            const geometry = new THREE.SphereGeometry(radius, 16, 16);

            // Color based on completion status
            const material = new THREE.MeshPhongMaterial({
                color: task.completed ? 0x00FF00 : 0xDDDDDD, // Slightly different color for standalone
                shininess: 30
            });

            const moon = new THREE.Mesh(geometry, material);

            // Position the moon in a separate area
            const angle = Math.random() * Math.PI * 2;
            const distance = 15 + Math.random() * 5; // Further out than regular planets
            const height = (Math.random() - 0.5) * 5;

            moon.position.x = Math.cos(angle) * distance;
            moon.position.y = height;
            moon.position.z = Math.sin(angle) * distance;

            scene.add(moon);

            // Store reference to object
            taskObjects[task.id] = {
                mesh: moon,
                isStandalone: true
            };
        }

        function addTaskLeaf(task, goal) {
            // Get parent goal object
            const goalObject = goalObjects[goal.id];

            if (!goalObject || !goalObject.mesh) return;

            // Create a leaf shape
            const shape = new THREE.Shape();

            // Define a leaf shape
            shape.moveTo(0, 0);
            shape.bezierCurveTo(0.25, 0.25, 0.5, -0.25, 1, 0);
            shape.bezierCurveTo(0.5, 0.1, 0.25, 0.25, 0, 0);

            const geometry = new THREE.ShapeGeometry(shape);

            // Green color, brighter if completed
            const color = task.completed ? 0x00FF00 : 0x228B22;

            const material = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide
            });

            const leaf = new THREE.Mesh(geometry, material);

            // Size for leaf
            const scale = 0.2;
            leaf.scale.set(scale, scale, scale);

            // Position near the parent flower/goal
            const parentPos = goalObject.mesh.position.clone();
            const offsetX = (Math.random() - 0.5) * 0.5;
            const offsetY = -0.3 + (Math.random() - 0.5) * 0.2;
            const offsetZ = (Math.random() - 0.5) * 0.5;

            leaf.position.set(
                parentPos.x + offsetX,
                parentPos.y + offsetY,
                parentPos.z + offsetZ
            );

            // Random rotation
            leaf.rotation.z = Math.random() * Math.PI * 2;

            // Store random offset for animation
            const offset = Math.random() * Math.PI * 2;

            scene.add(leaf);

            // Store reference to the object
            taskObjects[task.id] = {
                mesh: leaf,
                parentGoalId: goal.id,
                offset
            };
        }

        // Create standalone leaf for tasks without goals
        function addTaskLeafStandalone(task) {
            // Create a leaf shape
            const shape = new THREE.Shape();

            // Define a leaf shape
            shape.moveTo(0, 0);
            shape.bezierCurveTo(0.25, 0.25, 0.5, -0.25, 1, 0);
            shape.bezierCurveTo(0.5, 0.1, 0.25, 0.25, 0, 0);

            const geometry = new THREE.ShapeGeometry(shape);

            // Green color, brighter if completed
            const color = task.completed ? 0x00FF00 : 0x33AA33; // Slightly different color for standalone

            const material = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide
            });

            const leaf = new THREE.Mesh(geometry, material);

            // Size for leaf
            const scale = 0.2;
            leaf.scale.set(scale, scale, scale);

            // Position in a separate area from goal-related leaves
            const x = 5 + (Math.random() - 0.5) * 6; // Different position than regular leaves
            const y = (Math.random() - 0.5) * 15;
            const z = -9 + (Math.random() - 0.5) * 0.5;

            leaf.position.set(x, y, z);

            // Random rotation
            leaf.rotation.z = Math.random() * Math.PI * 2;

            // Store random offset for animation
            const offset = Math.random() * Math.PI * 2;

            scene.add(leaf);

            // Store reference to the object
            taskObjects[task.id] = {
                mesh: leaf,
                isStandalone: true,
                offset
            };
        }

        // Update task object when completion status changes
        function updateTaskObject(task) {
            const taskObject = taskObjects[task.id];

            if (!taskObject || !taskObject.mesh) return;

            if (isDarkTheme) {
                // Update moon color
                taskObject.mesh.material.color.set(task.completed ? 0x00FF00 : 0xCCCCCC);
                
                // Create a shooting star effect on completion
                if (task.completed) {
                    createShootingStar();
                }
            } else {
                // Update leaf color
                taskObject.mesh.material.color.set(task.completed ? 0x00FF00 : 0x228B22);
            }
        }

 // Remove problem object from scene
        function removeProblemObject(problem) {
            const problemObject = problemObjects[problem.id];

            if (!problemObject) return;

            if (isDarkTheme && problemObject.group) {
                scene.remove(problemObject.group);
            } else if (!isDarkTheme && problemObject.mesh) {
                scene.remove(problemObject.mesh);
            }

            delete problemObjects[problem.id];
        }

        // Remove goal object from scene
        function removeGoalObject(goal) {
            const goalObject = goalObjects[goal.id];

            if (!goalObject) return;

            if (isDarkTheme && goalObject.orbit) {
                scene.remove(goalObject.orbit);
            } else if (!isDarkTheme && goalObject.mesh) {
                scene.remove(goalObject.mesh);
            }

            delete goalObjects[goal.id];
        }

        // Remove task object from scene
        function removeTaskObject(task) {
            const taskObject = taskObjects[task.id];

            if (!taskObject) return;

            if (isDarkTheme && taskObject.orbit) {
                const goalObject = goalObjects[taskObject.parentGoalId];
                if (goalObject && goalObject.orbit) {
                    goalObject.orbit.remove(taskObject.orbit);
                }
            } else if (!isDarkTheme && taskObject.mesh) {
                scene.remove(taskObject.mesh);
            }

            delete taskObjects[task.id];
        }

        // Dialog functions for standalone tasks
        function openTaskDialog() {
            document.getElementById('overlay').classList.add('active');
            document.getElementById('standalone-task-dialog').classList.add('active');
        }

        function closeTaskDialog() {
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('standalone-task-dialog').classList.remove('active');
        }

        // Dialog functions
        function openDialog() {
            document.getElementById('overlay').classList.add('active');
            document.getElementById('completion-dialog').classList.add('active');
        }

        function closeDialog() {
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('completion-dialog').classList.remove('active');
        }

        // Save task completion feedback
        function saveCompletion() {
            const feedback = document.getElementById('completion-feedback').value;
            
            // Could save this feedback for later analysis
            localStorage.setItem('lastCompletionFeedback', feedback);
            
            // Close dialog
            closeDialog();
            
            // Create a shooting star celebration if in dark theme
            if (isDarkTheme) {
                createShootingStar();
            }
        }

      // Add standalone task
function addStandaloneTask() {
    const taskInput = document.getElementById('standalone-task-input').value.trim();
    const taskArea = document.getElementById('standalone-task-area').value;
    
    if (!taskInput) {
        showToast("Validation Error", "Please enter a task description.", "error");
        return;
    }
    
    // Show toast notification immediately after validation passes
    showToast("Task Created", "Breaking down your goals into manageable tasks is key to success.", "success");
    
    const task = {
        id: Date.now().toString(),
        taskInput,
        goalArea: taskArea,
        materialsInput: '',
        cooperationInput: '',
        knowledgeInput: '',
        timestamp: Date.now(),
        completed: false
    };
    
    // Save to localStorage
    let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    tasks.push(task);
    localStorage.setItem('tasks', JSON.stringify(tasks));
    
    // Close the dialog and reset form
    closeTaskDialog();
    document.getElementById('standalone-task-form').reset();
    
    // Update UI
    renderTasks();
    updateStats();
    updateCounts();
    
    // Add object to 3D scene
    addTaskObject(task, null);

    // Check achievements
    checkAchievements();
}

        // Add UI for standalone items
        function addStandaloneItemButtons() {
            // This function is for future expansion if needed
        }

        // Add sample items if data is empty
        function addSampleItems() {
            const problems = JSON.parse(localStorage.getItem('problems')) || [];
            const goals = JSON.parse(localStorage.getItem('goals')) || [];
            const tasks = JSON.parse(localStorage.getItem('tasks')) || [];

            // Only add sample items if all lists are empty
            if (problems.length === 0 && goals.length === 0 && tasks.length === 0) {
                // Add sample problem
                const sampleProblem = {
                    id: 'sample-problem-1',
                    problemInput: 'Getting started with Unify - Use the Input Problem section below to add your own problems',
                    problemArea: 'Personal',
                    problemEmotion: 'Anxious',
                    problemDifficulty: '2',
                    timestamp: Date.now(),
                    finished: false
                };
                
                problems.push(sampleProblem);
                localStorage.setItem('problems', JSON.stringify(problems));
                
                // Add sample goal
                const sampleGoal = {
                    id: 'sample-goal-1',
                    goalInput: 'Identify motivating goals rather than sacrifices - Choose goals that feel meaningful to increase your chances of success',
                    goalArea: 'Personal',
                    goalEmotion: 'Meaningful',
                    goalDifficulty: '2',
                    relatedProblemId: 'sample-problem-1',
                    relatedProblem: sampleProblem.problemInput,
                    timestamp: Date.now(),
                    finished: false
                };
                
                goals.push(sampleGoal);
                localStorage.setItem('goals', JSON.stringify(goals));
                
                // Add sample task
                const sampleTask = {
                    id: 'sample-task-1',
                    taskInput: 'Fill in task details - Include required knowledge, cooperation, and materials to help you accomplish tasks',
                    relatedGoalId: 'sample-goal-1',
                    relatedGoal: sampleGoal.goalInput,
                    goalArea: sampleGoal.goalArea,
                    materialsInput: 'Example: List any physical materials needed for this task',
                    cooperationInput: 'Example: List any people whose help you will need',
                    knowledgeInput: 'Example: List any skills or information you need to learn',
                    timestamp: Date.now(),
                    completed: false
                };
                
                tasks.push(sampleTask);
                localStorage.setItem('tasks', JSON.stringify(tasks));
            }
        }

        // Show toast notification
        function showToast(title, message, type = "success") {
            Toastify({
                node: createToastNode(title, message, type),
                duration: 5000,
                gravity: "bottom",
                position: "right",
                stopOnFocus: true,
                className: type,
                offset: {
                    x: 0,
                    y: 20
                }
            }).showToast();
        }

        // Create toast notification node
        function createToastNode(title, message, type) {
            const toastNode = document.createElement("div");
            toastNode.style.display = "flex";
            toastNode.style.alignItems = "center";

            // Icon based on type
            let iconClass = "fa-check-circle";
            if (type === "error") {
                iconClass = "fa-exclamation-triangle";
            } else if (type === "info") {
                iconClass = "fa-info-circle";
            }

            toastNode.innerHTML = `
                <div class="toast-icon">
                    <i class="fas ${iconClass}"></i>
                </div>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
            `;

            return toastNode;
        }

        // Initialize the achievements system
        function initAchievements() {
            // Load saved achievements state
            achievements = JSON.parse(localStorage.getItem('achievements')) || {};

            // Initialize any undefined achievements
            Object.keys(achievementDefinitions).forEach(id => {
                if (!achievements[id]) {
                    achievements[id] = {
                        id,
                        unlocked: false,
                        timestamp: null
                    };
                }
            });

            // Update UI to reflect current achievement state
            updateAchievementBadges();

            // Do an initial check for newly unlocked achievements
            checkAchievements();
        }

        // Check if any new achievements have been unlocked
        function checkAchievements() {
            newlyUnlockedAchievements = [];

            // Get current data
            const data = {
                problems: JSON.parse(localStorage.getItem('problems')) || [],
                goals: JSON.parse(localStorage.getItem('goals')) || [],
                tasks: JSON.parse(localStorage.getItem('tasks')) || []
            };

            // Check each achievement
            Object.keys(achievementDefinitions).forEach(id => {
                const achievement = achievements[id];
                const definition = achievementDefinitions[id];

                // Skip already unlocked achievements
                if (achievement.unlocked) return;

                // Check if condition is met
                if (definition.condition(data)) {
                    // Unlock the achievement
                    achievement.unlocked = true;
                    achievement.timestamp = Date.now();
                    newlyUnlockedAchievements.push(id);
                }
            });

            // Save updated achievements
            localStorage.setItem('achievements', JSON.stringify(achievements));

            // Update UI
            updateAchievementBadges();

            // Display notifications for newly unlocked achievements
            if (newlyUnlockedAchievements.length > 0) {
                // Process one achievement at a time
                const achievementId = newlyUnlockedAchievements.shift();
                const definition = achievementDefinitions[achievementId];
                
                // Show toast notification
                showToast("Achievement Unlocked!", definition.title, "info");

                // Animate badge
                animateAchievementUnlock(achievementId);
            }

            // Update achievement count
            updateCounts();
        }

        // Update achievement badges UI
        function updateAchievementBadges() {
            Object.keys(achievementDefinitions).forEach(id => {
                const badge = document.getElementById(`badge-${id}`);
                if (!badge) return;

                const badgeIcon = badge.querySelector('.badge-icon');
                const achievement = achievements[id];
                const definition = achievementDefinitions[id];

                if (achievement && achievement.unlocked) {
                    badgeIcon.classList.add('unlocked');
                    
                    // Add tier-based color
                    if (definition.tier === 1) {
                        badgeIcon.classList.add('bronze');
                    } else if (definition.tier === 2) {
                        badgeIcon.classList.add('silver');
                    } else if (definition.tier === 3) {
                        badgeIcon.classList.add('gold');
                    }
                } else {
                    badgeIcon.classList.remove('unlocked', 'bronze', 'silver', 'gold');
                }
            });
        }

        // Animate achievement unlock
        function animateAchievementUnlock(achievementId) {
            const badge = document.getElementById(`badge-${achievementId}`);
            if (!badge) return;

            const badgeIcon = badge.querySelector('.badge-icon');
            badgeIcon.classList.add('animate-unlock');

            // Open the achievements section
            const achievementsSection = document.querySelector('#section-achievements .section-content');
            const achievementsArrow = document.querySelector('#section-achievements .toggle-arrow');
            if (!achievementsSection.classList.contains('active')) {
                achievementsSection.classList.add('active');
                achievementsArrow.classList.add('open');
            }

            // Remove animation class after it completes
            setTimeout(() => {
                badgeIcon.classList.remove('animate-unlock');
            }, 1000);
        }

        // Show achievement dialog
        function showAchievementDialog(achievementId) {
            const definition = achievementDefinitions[achievementId];
            const achievement = achievements[achievementId];

            if (!definition) return;

            const dialogIcon = document.getElementById('achievement-dialog-icon');
            const dialogIconInner = document.getElementById('achievement-dialog-icon-inner');
            const dialogTitle = document.getElementById('achievement-dialog-title');
            const dialogDescription = document.getElementById('achievement-dialog-description');

            // Set dialog content
            dialogTitle.textContent = definition.title;
            
            // Use correct icon
            dialogIconInner.className = `fas fa-${definition.icon}`;
            
            // Set description based on unlocked status
            dialogDescription.textContent = achievement && achievement.unlocked 
                ? definition.unlockedHint 
                : definition.lockedHint;
            
            // Set appropriate styling
            dialogIcon.className = 'achievement-dialog-icon';
            if (achievement && achievement.unlocked) {
                if (definition.tier === 1) {
                    dialogIcon.classList.add('bronze');
                } else if (definition.tier === 2) {
                    dialogIcon.classList.add('silver');
                } else if (definition.tier === 3) {
                    dialogIcon.classList.add('gold');
                }
            }
            
            // Show dialog
            document.getElementById('overlay').classList.add('active');
            document.getElementById('achievement-dialog').classList.add('active');
        }

        // Close achievement dialog
        function closeAchievementDialog() {
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('achievement-dialog').classList.remove('active');
        }

        // General app functions
        function loadData() {
            // Load data from localStorage and render all lists
            renderProblems();
            renderGoals();
            renderTasks();
            
            // Update UI elements
            updateStats();
            updateCounts();
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>